"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@antv+g-web-animations-api@2.1.21";
exports.ids = ["vendor-chunks/@antv+g-web-animations-api@2.1.21"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@antv+g-web-animations-api@2.1.21/node_modules/@antv/g-web-animations-api/dist/index.esm.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@antv+g-web-animations-api@2.1.21/node_modules/@antv/g-web-animations-api/dist/index.esm.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   AnimationEvent: () => (/* binding */ AnimationEvent),\n/* harmony export */   AnimationTimeline: () => (/* binding */ AnimationTimeline),\n/* harmony export */   EasingFunctions: () => (/* binding */ EasingFunctions),\n/* harmony export */   KeyframeEffect: () => (/* binding */ KeyframeEffect),\n/* harmony export */   compareAnimations: () => (/* binding */ compareAnimations),\n/* harmony export */   makeTiming: () => (/* binding */ makeTiming),\n/* harmony export */   normalizeKeyframes: () => (/* binding */ normalizeKeyframes),\n/* harmony export */   normalizeTimingInput: () => (/* binding */ normalizeTimingInput),\n/* harmony export */   numericTimingToObject: () => (/* binding */ numericTimingToObject)\n/* harmony export */ });\n/* harmony import */ var _antv_g_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/g-lite */ \"(ssr)/../node_modules/.pnpm/@antv+g-lite@2.2.16/node_modules/@antv/g-lite/dist/index.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/callSuper */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/callSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/clamp.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-number.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-nil.js\");\n/*!\n * @antv/g-web-animations-api\n * @description A simple implementation of Web Animations API.\n * @version 2.1.21\n * @date 1/23/2025, 8:33:55 AM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */ \n\n\n\n\n\n\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationPlaybackEvent\n */ // @ts-ignore\nvar AnimationEvent = /*#__PURE__*/ function(_FederatedEvent) {\n    function AnimationEvent(manager, target, currentTime, timelineTime) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AnimationEvent);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_3___default()(this, AnimationEvent, [\n            manager\n        ]);\n        // @ts-ignore\n        _this.currentTime = currentTime;\n        _this.timelineTime = timelineTime;\n        _this.target = target;\n        _this.type = \"finish\";\n        _this.bubbles = false;\n        // @ts-ignore\n        _this.currentTarget = target;\n        _this.defaultPrevented = false;\n        _this.eventPhase = _this.AT_TARGET;\n        _this.timeStamp = Date.now();\n        _this.currentTime = currentTime;\n        _this.timelineTime = timelineTime;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(AnimationEvent, _FederatedEvent);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AnimationEvent);\n}(_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.FederatedEvent);\nvar sequenceNumber = 0;\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/Animation\n */ var Animation = /*#__PURE__*/ function() {\n    function Animation(effect, timeline) {\n        var _this$effect;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Animation);\n        this.currentTimePending = false;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/playState\n     */ // playState: AnimationPlayState;\n        this._idle = true;\n        this._paused = false;\n        this._finishedFlag = true;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/currentTime\n     */ this._currentTime = 0;\n        this._playbackRate = 1;\n        this._inTimeline = true;\n        this.effect = effect;\n        effect.animation = this;\n        this.timeline = timeline;\n        this.id = \"\".concat(sequenceNumber++);\n        this._inEffect = !!this.effect.update(0);\n        this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);\n        this._holdTime = 0;\n        this._paused = false;\n        this.oldPlayState = \"idle\";\n        this.updatePromises();\n    }\n    /**\n   * state machine,\n   * resolve/reject ready/finished Promise according to current state\n   */ return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Animation, [\n        {\n            key: \"pending\",\n            get: /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect\n     */ /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline\n     */ /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id\n     */ // animation: InternalAnimation | null;\n            /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending\n     */ function get() {\n                return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;\n            }\n        },\n        {\n            key: \"playState\",\n            get: function get() {\n                if (this._idle) return \"idle\";\n                if (this._isFinished) return \"finished\";\n                if (this._paused) return \"paused\";\n                return \"running\";\n            }\n        },\n        {\n            key: \"ready\",\n            get: /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready\n     * @example\n      animation.pause();\n      animation.ready.then(function() {\n        // Displays 'running'\n        alert(animation.playState);\n      });\n      animation.play();\n     */ function get() {\n                var _this = this;\n                if (!this.readyPromise) {\n                    if (this.timeline.animationsWithPromises.indexOf(this) === -1) {\n                        this.timeline.animationsWithPromises.push(this);\n                    }\n                    this.readyPromise = new Promise(function(resolve, reject) {\n                        _this.resolveReadyPromise = function() {\n                            resolve(_this);\n                        };\n                        _this.rejectReadyPromise = function() {\n                            reject(new Error());\n                        };\n                    });\n                    if (!this.pending) {\n                        this.resolveReadyPromise();\n                    }\n                }\n                return this.readyPromise;\n            }\n        },\n        {\n            key: \"finished\",\n            get: function get() {\n                var _this2 = this;\n                if (!this.finishedPromise) {\n                    if (this.timeline.animationsWithPromises.indexOf(this) === -1) {\n                        this.timeline.animationsWithPromises.push(this);\n                    }\n                    this.finishedPromise = new Promise(function(resolve, reject) {\n                        _this2.resolveFinishedPromise = function() {\n                            resolve(_this2);\n                        };\n                        _this2.rejectFinishedPromise = function() {\n                            reject(new Error());\n                        };\n                    });\n                    if (this.playState === \"finished\") {\n                        this.resolveFinishedPromise();\n                    }\n                }\n                return this.finishedPromise;\n            }\n        },\n        {\n            key: \"currentTime\",\n            get: function get() {\n                this.updatePromises();\n                return this._idle || this.currentTimePending ? null : this._currentTime;\n            },\n            set: function set(newTime) {\n                newTime = Number(newTime);\n                if (isNaN(newTime)) return;\n                this.timeline.restart();\n                if (!this._paused && this._startTime !== null) {\n                    var _this$timeline;\n                    this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;\n                }\n                this.currentTimePending = false;\n                if (this._currentTime === newTime) {\n                    return;\n                }\n                if (this._idle) {\n                    this._idle = false;\n                    this._paused = true;\n                }\n                this.tickCurrentTime(newTime, true);\n                this.timeline.applyDirtiedAnimation(this);\n            }\n        },\n        {\n            key: \"startTime\",\n            get: function get() {\n                return this._startTime;\n            },\n            set: function set(newTime) {\n                if (newTime !== null) {\n                    this.updatePromises();\n                    newTime = Number(newTime);\n                    if (isNaN(newTime)) return;\n                    if (this._paused || this._idle) return;\n                    this._startTime = newTime;\n                    this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);\n                    this.timeline.applyDirtiedAnimation(this);\n                    this.updatePromises();\n                }\n            }\n        },\n        {\n            key: \"playbackRate\",\n            get: function get() {\n                return this._playbackRate;\n            },\n            set: function set(value) {\n                if (value === this._playbackRate) {\n                    return;\n                }\n                this.updatePromises();\n                var oldCurrentTime = this.currentTime;\n                this._playbackRate = value;\n                this.startTime = null;\n                if (this.playState !== \"paused\" && this.playState !== \"idle\") {\n                    this._finishedFlag = false;\n                    this._idle = false;\n                    this.ensureAlive();\n                    this.timeline.applyDirtiedAnimation(this);\n                }\n                if (oldCurrentTime !== null) {\n                    this.currentTime = oldCurrentTime;\n                }\n                this.updatePromises();\n            }\n        },\n        {\n            key: \"_isFinished\",\n            get: function get() {\n                return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);\n            }\n        },\n        {\n            key: \"totalDuration\",\n            get: function get() {\n                return this._totalDuration;\n            }\n        },\n        {\n            key: \"_needsTick\",\n            get: function get() {\n                return this.pending || this.playState === \"running\" || !this._finishedFlag;\n            }\n        },\n        {\n            key: \"updatePromises\",\n            value: function updatePromises() {\n                var oldPlayState = this.oldPlayState;\n                var newPlayState = this.pending ? \"pending\" : this.playState;\n                if (this.readyPromise && newPlayState !== oldPlayState) {\n                    if (newPlayState === \"idle\") {\n                        this.rejectReadyPromise();\n                        this.readyPromise = undefined;\n                    } else if (oldPlayState === \"pending\") {\n                        this.resolveReadyPromise();\n                    } else if (newPlayState === \"pending\") {\n                        this.readyPromise = undefined;\n                    }\n                }\n                if (this.finishedPromise && newPlayState !== oldPlayState) {\n                    if (newPlayState === \"idle\") {\n                        this.rejectFinishedPromise();\n                        this.finishedPromise = undefined;\n                    } else if (newPlayState === \"finished\") {\n                        this.resolveFinishedPromise();\n                    } else if (oldPlayState === \"finished\") {\n                        this.finishedPromise = undefined;\n                    }\n                }\n                this.oldPlayState = newPlayState;\n                return this.readyPromise || this.finishedPromise;\n            }\n        },\n        {\n            key: \"play\",\n            value: function play() {\n                this.updatePromises();\n                this._paused = false;\n                if (this._isFinished || this._idle) {\n                    this.rewind();\n                    this._startTime = null;\n                }\n                this._finishedFlag = false;\n                this._idle = false;\n                this.ensureAlive();\n                this.timeline.applyDirtiedAnimation(this);\n                if (this.timeline.animations.indexOf(this) === -1) {\n                    this.timeline.animations.push(this);\n                }\n                this.updatePromises();\n            }\n        },\n        {\n            key: \"pause\",\n            value: function pause() {\n                this.updatePromises();\n                if (this.currentTime) {\n                    this._holdTime = this.currentTime;\n                }\n                if (!this._isFinished && !this._paused && !this._idle) {\n                    this.currentTimePending = true;\n                } else if (this._idle) {\n                    this.rewind();\n                    this._idle = false;\n                }\n                this._startTime = null;\n                this._paused = true;\n                this.updatePromises();\n            }\n        },\n        {\n            key: \"finish\",\n            value: function finish() {\n                this.updatePromises();\n                if (this._idle) return;\n                this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;\n                this._startTime = this._totalDuration - this.currentTime;\n                this.currentTimePending = false;\n                this.timeline.applyDirtiedAnimation(this);\n                this.updatePromises();\n            }\n        },\n        {\n            key: \"cancel\",\n            value: function cancel() {\n                var _this3 = this;\n                this.updatePromises();\n                if (!this._inEffect) return;\n                this._inEffect = false;\n                this._idle = true;\n                this._paused = false;\n                this._finishedFlag = true;\n                this._currentTime = 0;\n                this._startTime = null;\n                this.effect.update(null);\n                // effects are invalid after cancellation as the animation state\n                // needs to un-apply.\n                this.timeline.applyDirtiedAnimation(this);\n                this.updatePromises();\n                /**\n       * 1. Reject the current finished promise with a DOMException named \"AbortError\".\n       * 2. Let current finished promise be a new promise\n       * @see https://w3c.github.io/csswg-drafts/web-animations-1/#canceling-an-animation-section\n       */ // if (this.finishedPromise) {\n                //   this.rejectFinishedPromise();\n                //   this.finishedPromise = undefined;\n                // }\n                if (this.oncancel) {\n                    var event = new AnimationEvent(null, this, this.currentTime, null);\n                    setTimeout(function() {\n                        _this3.oncancel(event);\n                    });\n                }\n            }\n        },\n        {\n            key: \"reverse\",\n            value: function reverse() {\n                this.updatePromises();\n                var oldCurrentTime = this.currentTime;\n                this.playbackRate *= -1;\n                this.play();\n                if (oldCurrentTime !== null) {\n                    this.currentTime = oldCurrentTime;\n                }\n                this.updatePromises();\n            }\n        },\n        {\n            key: \"updatePlaybackRate\",\n            value: function updatePlaybackRate(playbackRate) {\n                this.playbackRate = playbackRate;\n            }\n        },\n        {\n            key: \"targetAnimations\",\n            value: function targetAnimations() {\n                var _this$effect2;\n                var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;\n                return target.getAnimations();\n            }\n        },\n        {\n            key: \"markTarget\",\n            value: function markTarget() {\n                var animations = this.targetAnimations();\n                if (animations.indexOf(this) === -1) {\n                    animations.push(this);\n                }\n            }\n        },\n        {\n            key: \"unmarkTarget\",\n            value: function unmarkTarget() {\n                var animations = this.targetAnimations();\n                var index = animations.indexOf(this);\n                if (index !== -1) {\n                    animations.splice(index, 1);\n                }\n            }\n        },\n        {\n            key: \"tick\",\n            value: function tick(timelineTime, isAnimationFrame) {\n                if (!this._idle && !this._paused) {\n                    if (this._startTime === null) {\n                        if (isAnimationFrame) {\n                            this.startTime = timelineTime - this._currentTime / this.playbackRate;\n                        }\n                    } else if (!this._isFinished) {\n                        this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);\n                    }\n                }\n                if (isAnimationFrame) {\n                    this.currentTimePending = false;\n                    this.fireEvents(timelineTime);\n                }\n            }\n        },\n        {\n            key: \"rewind\",\n            value: function rewind() {\n                if (this.playbackRate >= 0) {\n                    this.currentTime = 0;\n                } else if (this._totalDuration < Infinity) {\n                    this.currentTime = this._totalDuration;\n                } else {\n                    throw new Error(\"Unable to rewind negative playback rate animation with infinite duration\");\n                }\n            }\n        },\n        {\n            key: \"persist\",\n            value: function persist() {\n                throw new Error(_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"addEventListener\",\n            value: function addEventListener(type, listener, options) {\n                throw new Error(_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"removeEventListener\",\n            value: function removeEventListener(type, listener, options) {\n                throw new Error(_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"dispatchEvent\",\n            value: function dispatchEvent(event) {\n                throw new Error(_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"commitStyles\",\n            value: // replaceState: AnimationReplaceState;\n            function commitStyles() {\n                throw new Error(_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"ensureAlive\",\n            value: function ensureAlive() {\n                // If an animation is playing backwards and is not fill backwards/both\n                // then it should go out of effect when it reaches the start of its\n                // active interval (currentTime === 0).\n                if (this.playbackRate < 0 && this.currentTime === 0) {\n                    var _this$effect3;\n                    this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));\n                } else {\n                    var _this$effect4;\n                    this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));\n                }\n                if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {\n                    this._inTimeline = true;\n                    this.timeline.animations.push(this);\n                }\n            }\n        },\n        {\n            key: \"tickCurrentTime\",\n            value: function tickCurrentTime(newTime, ignoreLimit) {\n                if (newTime !== this._currentTime) {\n                    this._currentTime = newTime;\n                    if (this._isFinished && !ignoreLimit) {\n                        this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;\n                    }\n                    this.ensureAlive();\n                }\n            }\n        },\n        {\n            key: \"fireEvents\",\n            value: function fireEvents(baseTime) {\n                var _this4 = this;\n                if (this._isFinished) {\n                    if (!this._finishedFlag) {\n                        if (this.onfinish) {\n                            var event = new AnimationEvent(null, this, this.currentTime, baseTime);\n                            setTimeout(function() {\n                                if (_this4.onfinish) {\n                                    _this4.onfinish(event);\n                                }\n                            });\n                        }\n                        this._finishedFlag = true;\n                    }\n                } else {\n                    if (this.onframe && this.playState === \"running\") {\n                        var _event = new AnimationEvent(null, this, this.currentTime, baseTime);\n                        this.onframe(_event);\n                    }\n                    this._finishedFlag = false;\n                }\n            }\n        }\n    ]);\n}();\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */ // These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nvar A = function A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n};\nvar B = function B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n};\nvar C = function C(aA1) {\n    return 3.0 * aA1;\n};\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nvar calcBezier = function calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n};\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nvar getSlope = function getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n};\nvar binarySubdivide = function binarySubdivide(aX, aA, aB, mX1, mX2) {\n    var currentX;\n    var currentT;\n    var i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) aB = currentT;\n        else aA = currentT;\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n};\nvar newtonRaphsonIterate = function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for(var i = 0; i < NEWTON_ITERATIONS; ++i){\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) return aGuessT;\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n};\nvar bezier = function bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error(\"bezier x values must be in [0, 1] range\");\n    if (mX1 === mY1 && mX2 === mY2) return function(t) {\n        return t;\n    };\n    // Precompute samples table\n    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    for(var i = 0; i < kSplineTableSize; ++i){\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    var getTForX = function getTForX(aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)intervalStart += kSampleStepSize;\n        --currentSample;\n        // Interpolate to provide an initial guess for t\n        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        if (initialSlope === 0.0) return guessForT;\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    };\n    return function(t) {\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n        if (t === 0 || t === 1) return t;\n        return calcBezier(getTForX(t), mY1, mY2);\n    };\n};\nvar convertToDash = function convertToDash(str) {\n    str = str.replace(/([A-Z])/g, function(letter) {\n        return \"-\".concat(letter.toLowerCase());\n    });\n    // Remove first dash\n    return str.charAt(0) === \"-\" ? str.substring(1) : str;\n};\n/**\n  Easing Functions from anime.js, they are tried and true, so, its better to use them instead of other alternatives\n*/ var Quad = function Quad(t) {\n    return Math.pow(t, 2);\n};\nvar Cubic = function Cubic(t) {\n    return Math.pow(t, 3);\n};\nvar Quart = function Quart(t) {\n    return Math.pow(t, 4);\n};\nvar Quint = function Quint(t) {\n    return Math.pow(t, 5);\n};\nvar Expo = function Expo(t) {\n    return Math.pow(t, 6);\n};\nvar Sine = function Sine(t) {\n    return 1 - Math.cos(t * Math.PI / 2);\n};\nvar Circ = function Circ(t) {\n    return 1 - Math.sqrt(1 - t * t);\n};\nvar Back = function Back(t) {\n    return t * t * (3 * t - 2);\n};\nvar Bounce = function Bounce(t) {\n    var pow2;\n    var b = 4;\n    while(t < ((pow2 = Math.pow(2, --b)) - 1) / 11){}\n    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);\n};\nvar Elastic = function Elastic(t) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var _params = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;\n    var a = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Number(amplitude), 1, 10);\n    var p = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Number(period), 0.1, 2);\n    if (t === 0 || t === 1) return t;\n    return -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);\n};\nvar Spring = function Spring(t) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var duration = arguments.length > 2 ? arguments[2] : undefined;\n    var _params2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;\n    mass = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(mass, 0.1, 1000);\n    stiffness = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(stiffness, 0.1, 1000);\n    damping = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(damping, 0.1, 1000);\n    velocity = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(velocity, 0.1, 1000);\n    var w0 = Math.sqrt(stiffness / mass);\n    var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n    var a = 1;\n    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n    var progress = duration ? duration * t / 1000 : t;\n    if (zeta < 1) {\n        progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n    } else {\n        progress = (a + b * progress) * Math.exp(-progress * w0);\n    }\n    if (t === 0 || t === 1) return t;\n    return 1 - progress;\n};\n/**\n * Cache the durations at set easing parameters\n */ // export const EasingDurationCache: Map<string | TypeEasingFunction, number> = new Map();\n/**\n * The threshold for an infinite loop\n */ // const INTINITE_LOOP_LIMIT = 10000;\n/** Convert easing parameters to Array of numbers, e.g. \"spring(2, 500)\" to [2, 500] */ // export const parseEasingParameters = (str: string) => {\n//   const match = /(\\(|\\s)([^)]+)\\)?/.exec(str);\n//   return match\n//     ? match[2].split(',').map((value) => {\n//         const num = parseFloat(value);\n//         return !Number.isNaN(num) ? num : value.trim();\n//       })\n//     : [];\n// };\n/**\n * The spring easing function will only look smooth at certain durations, with certain parameters.\n * This functions returns the optimal duration to create a smooth springy animation based on physics\n *\n * Note: it can also be used to determine the optimal duration of other types of easing function, but be careful of 'in-'\n * easing functions, because of the nature of the function it can sometimes create an infinite loop, I suggest only using\n * `getEasingDuration` for `spring`, specifically 'out-spring' and 'spring'\n */ // export const getEasingDuration = (easing: string | TypeEasingFunction = 'spring') => {\n//   if (EasingDurationCache.has(easing)) return EasingDurationCache.get(easing);\n//   // eslint-disable-next-line @typescript-eslint/no-use-before-define\n//   const easingFunction = typeof easing == 'function' ? easing : getEasingFunction(easing as string);\n//   const params = typeof easing == 'function' ? [] : parseEasingParameters(easing);\n//   const frame = 1 / 6;\n//   let elapsed = 0;\n//   let rest = 0;\n//   let count = 0;\n//   while (++count < INTINITE_LOOP_LIMIT) {\n//     elapsed += frame;\n//     if (easingFunction(elapsed, params, undefined) === 1) {\n//       rest++;\n//       if (rest >= 16) break;\n//     } else {\n//       rest = 0;\n//     }\n//   }\n//   const duration = elapsed * frame * 1000;\n//   EasingDurationCache.set(easing, duration);\n//   return duration;\n// };\n/**\n  These Easing Functions are based off of the Sozi Project's easing functions\n  https://github.com/sozi-projects/Sozi/blob/d72e44ebd580dc7579d1e177406ad41e632f961d/src/js/player/Timing.js\n*/ var Steps = function Steps(t) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var _ref = params, _ref2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];\n    var trunc = type === \"start\" ? Math.ceil : Math.floor;\n    return trunc((0,_antv_util__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(t, 0, 1) * steps) / steps;\n};\n// @ts-ignore\nvar Bezier = function Bezier(t) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var _params3 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];\n    return bezier(mX1, mY1, mX2, mY2)(t);\n};\n/** The default `ease-in` easing function */ var easein = bezier(0.42, 0.0, 1.0, 1.0);\n/** Converts easing functions to their `out`counter parts */ var EaseOut = function EaseOut(ease) {\n    return function(t) {\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var duration = arguments.length > 2 ? arguments[2] : undefined;\n        return 1 - ease(1 - t, params, duration);\n    };\n};\n/** Converts easing functions to their `in-out` counter parts */ var EaseInOut = function EaseInOut(ease) {\n    return function(t) {\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var duration = arguments.length > 2 ? arguments[2] : undefined;\n        return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;\n    };\n};\n/** Converts easing functions to their `out-in` counter parts */ var EaseOutIn = function EaseOutIn(ease) {\n    return function(t) {\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var duration = arguments.length > 2 ? arguments[2] : undefined;\n        return t < 0.5 ? (1 - ease(1 - t * 2, params, duration)) / 2 : (ease(t * 2 - 1, params, duration) + 1) / 2;\n    };\n};\n/**\n * The default list of easing functions, do note this is different from {@link EASING}\n */ var EasingFunctions = {\n    steps: Steps,\n    \"step-start\": function stepStart(t) {\n        return Steps(t, [\n            1,\n            \"start\"\n        ]);\n    },\n    \"step-end\": function stepEnd(t) {\n        return Steps(t, [\n            1,\n            \"end\"\n        ]);\n    },\n    linear: function linear(t) {\n        return t;\n    },\n    \"cubic-bezier\": Bezier,\n    ease: function ease(t) {\n        return Bezier(t, [\n            0.25,\n            0.1,\n            0.25,\n            1.0\n        ]);\n    },\n    \"in\": easein,\n    out: EaseOut(easein),\n    \"in-out\": EaseInOut(easein),\n    \"out-in\": EaseOutIn(easein),\n    \"in-quad\": Quad,\n    \"out-quad\": EaseOut(Quad),\n    \"in-out-quad\": EaseInOut(Quad),\n    \"out-in-quad\": EaseOutIn(Quad),\n    \"in-cubic\": Cubic,\n    \"out-cubic\": EaseOut(Cubic),\n    \"in-out-cubic\": EaseInOut(Cubic),\n    \"out-in-cubic\": EaseOutIn(Cubic),\n    \"in-quart\": Quart,\n    \"out-quart\": EaseOut(Quart),\n    \"in-out-quart\": EaseInOut(Quart),\n    \"out-in-quart\": EaseOutIn(Quart),\n    \"in-quint\": Quint,\n    \"out-quint\": EaseOut(Quint),\n    \"in-out-quint\": EaseInOut(Quint),\n    \"out-in-quint\": EaseOutIn(Quint),\n    \"in-expo\": Expo,\n    \"out-expo\": EaseOut(Expo),\n    \"in-out-expo\": EaseInOut(Expo),\n    \"out-in-expo\": EaseOutIn(Expo),\n    \"in-sine\": Sine,\n    \"out-sine\": EaseOut(Sine),\n    \"in-out-sine\": EaseInOut(Sine),\n    \"out-in-sine\": EaseOutIn(Sine),\n    \"in-circ\": Circ,\n    \"out-circ\": EaseOut(Circ),\n    \"in-out-circ\": EaseInOut(Circ),\n    \"out-in-circ\": EaseOutIn(Circ),\n    \"in-back\": Back,\n    \"out-back\": EaseOut(Back),\n    \"in-out-back\": EaseInOut(Back),\n    \"out-in-back\": EaseOutIn(Back),\n    \"in-bounce\": Bounce,\n    \"out-bounce\": EaseOut(Bounce),\n    \"in-out-bounce\": EaseInOut(Bounce),\n    \"out-in-bounce\": EaseOutIn(Bounce),\n    \"in-elastic\": Elastic,\n    \"out-elastic\": EaseOut(Elastic),\n    \"in-out-elastic\": EaseInOut(Elastic),\n    \"out-in-elastic\": EaseOutIn(Elastic),\n    spring: Spring,\n    \"spring-in\": Spring,\n    \"spring-out\": EaseOut(Spring),\n    \"spring-in-out\": EaseInOut(Spring),\n    \"spring-out-in\": EaseOutIn(Spring)\n};\n/**\n * Convert string easing to their proper form\n */ var complexEasingSyntax = function complexEasingSyntax(ease) {\n    return convertToDash(ease).replace(/^ease-/, \"\") // Remove the \"ease-\" keyword\n    .replace(/(\\(|\\s).+/, \"\") // Remove the function brackets and parameters\n    .toLowerCase().trim();\n};\n/** Re-maps a number from one range to another. Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. */ var getEasingFunction = function getEasingFunction(ease) {\n    return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;\n};\n// /**\n//  * Allows you to register new easing functions\n//  */\n// export const registerEasingFunction = (key: string, fn: TypeEasingFunction) => {\n//   Object.assign(EasingFunctions, {\n//     [key]: fn,\n//   });\n// };\n// /**\n//  * Allows you to register multiple new easing functions\n//  */\n// export const registerEasingFunctions = (...obj: typeof EasingFunctions[]) => {\n//   Object.assign(EasingFunctions, ...obj);\n// };\nvar linear = function linear(x) {\n    return x;\n};\nvar Start = 1;\nvar Middle = 0.5;\nvar End = 0;\nfunction step(count, pos) {\n    return function(x) {\n        if (x >= 1) {\n            return 1;\n        }\n        var stepSize = 1 / count;\n        x += pos * stepSize;\n        return x - x % stepSize;\n    };\n}\nvar numberString = \"\\\\s*(-?\\\\d+\\\\.?\\\\d*|-?\\\\.\\\\d+)\\\\s*\";\nvar cubicBezierRe = new RegExp(\"cubic-bezier\\\\(\".concat(numberString, \",\").concat(numberString, \",\").concat(numberString, \",\").concat(numberString, \"\\\\)\"));\nvar step1Re = /steps\\(\\s*(\\d+)\\s*\\)/;\nvar step2Re = /steps\\(\\s*(\\d+)\\s*,\\s*(start|middle|end)\\s*\\)/;\nfunction parseEasingFunction(normalizedEasing) {\n    var cubicData = cubicBezierRe.exec(normalizedEasing);\n    if (cubicData) {\n        // @ts-ignore\n        return bezier.apply(void 0, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5___default()(cubicData.slice(1).map(Number)));\n    }\n    var step1Data = step1Re.exec(normalizedEasing);\n    if (step1Data) {\n        return step(Number(step1Data[1]), End);\n    }\n    var step2Data = step2Re.exec(normalizedEasing);\n    if (step2Data) {\n        // @ts-ignore\n        return step(Number(step2Data[1]), {\n            start: Start,\n            middle: Middle,\n            end: End\n        }[step2Data[2]]);\n    }\n    return getEasingFunction(normalizedEasing);\n}\nfunction calculateActiveDuration(timing) {\n    // @ts-ignore\n    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));\n}\nfunction repeatedDuration(timing) {\n    var _timing$iterations;\n    // https://drafts.csswg.org/web-animations/#calculating-the-active-duration\n    if (timing.duration === 0 || timing.iterations === 0) {\n        return 0;\n    }\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration#value\n    // if (timing.duration === 'auto') {\n    //   timing.duration = 0;\n    // }\n    return (timing.duration === \"auto\" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);\n}\nvar PhaseNone = 0;\nvar PhaseBefore = 1;\nvar PhaseAfter = 2;\nvar PhaseActive = 3;\nfunction calculatePhase(activeDuration, localTime, timing) {\n    // https://drafts.csswg.org/web-animations/#animation-effect-phases-and-states\n    if (localTime === null) {\n        return PhaseNone;\n    }\n    var endTime = timing.endTime;\n    if (localTime < Math.min(timing.delay, endTime)) {\n        return PhaseBefore;\n    }\n    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {\n        return PhaseAfter;\n    }\n    return PhaseActive;\n}\nfunction calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-active-time\n    switch(phase){\n        case PhaseBefore:\n            if (fillMode === \"backwards\" || fillMode === \"both\") return 0;\n            return null;\n        case PhaseActive:\n            return localTime - delay;\n        case PhaseAfter:\n            if (fillMode === \"forwards\" || fillMode === \"both\") return activeDuration;\n            return null;\n        case PhaseNone:\n            return null;\n    }\n}\nfunction calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-overall-progress\n    var overallProgress = iterationStart;\n    if (iterationDuration === 0) {\n        if (phase !== PhaseBefore) {\n            overallProgress += iterations;\n        }\n    } else {\n        overallProgress += activeTime / iterationDuration;\n    }\n    return overallProgress;\n}\nfunction calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-simple-iteration-progress\n    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;\n    if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {\n        simpleIterationProgress = 1;\n    }\n    return simpleIterationProgress;\n}\nfunction calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-current-iteration\n    if (phase === PhaseAfter && iterations === Infinity) {\n        return Infinity;\n    }\n    if (simpleIterationProgress === 1) {\n        return Math.floor(overallProgress) - 1;\n    }\n    return Math.floor(overallProgress);\n}\nfunction calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-directed-progress\n    var currentDirection = playbackDirection;\n    if (playbackDirection !== \"normal\" && playbackDirection !== \"reverse\") {\n        var d = currentIteration;\n        if (playbackDirection === \"alternate-reverse\") {\n            d += 1;\n        }\n        currentDirection = \"normal\";\n        if (d !== Infinity && d % 2 !== 0) {\n            currentDirection = \"reverse\";\n        }\n    }\n    if (currentDirection === \"normal\") {\n        return simpleIterationProgress;\n    }\n    return 1 - simpleIterationProgress;\n}\nfunction calculateIterationProgress(activeDuration, localTime, timing) {\n    var phase = calculatePhase(activeDuration, localTime, timing);\n    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);\n    if (activeTime === null) return null;\n    var duration = timing.duration === \"auto\" ? 0 : timing.duration;\n    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);\n    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);\n    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);\n    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);\n    timing.currentIteration = currentIteration;\n    timing.progress = directedProgress;\n    // https://drafts.csswg.org/web-animations/#calculating-the-transformed-progress\n    // https://drafts.csswg.org/web-animations/#calculating-the-iteration-progress\n    return timing.easingFunction(directedProgress);\n}\nfunction convertEffectInput(keyframes, timing, target) {\n    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);\n    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);\n    return function(target, fraction) {\n        if (fraction !== null) {\n            interpolations.filter(function(interpolation) {\n                return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;\n            }).forEach(function(interpolation) {\n                var offsetFraction = fraction - interpolation.startOffset;\n                var localDuration = interpolation.endOffset - interpolation.startOffset;\n                var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;\n                // apply updated attribute\n                target.setAttribute(interpolation.property, interpolation.interpolation(scaledLocalTime), false, false // disable memoize\n                );\n            // if (interpolation.property === 'visibility') {\n            //   console.log(\n            //     scaledLocalTime,\n            //     interpolation.interpolation(scaledLocalTime),\n            //   );\n            // }\n            });\n        } else {\n            for(var property in propertySpecificKeyframeGroups)if (isNotReservedWord(property)) {\n                // clear attribute\n                target.setAttribute(property, null);\n            }\n        }\n    };\n}\nfunction isNotReservedWord(member) {\n    return member !== \"offset\" && member !== \"easing\" && member !== \"composite\" && member !== \"computedOffset\";\n}\nfunction makePropertySpecificKeyframeGroups(keyframes, timing) {\n    var propertySpecificKeyframeGroups = {};\n    for(var i = 0; i < keyframes.length; i++){\n        for(var member in keyframes[i]){\n            if (isNotReservedWord(member)) {\n                var propertySpecificKeyframe = {\n                    offset: keyframes[i].offset,\n                    computedOffset: keyframes[i].computedOffset,\n                    easing: keyframes[i].easing,\n                    easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,\n                    value: keyframes[i][member]\n                };\n                propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];\n                propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);\n            }\n        }\n    }\n    return propertySpecificKeyframeGroups;\n}\nfunction makeInterpolations(propertySpecificKeyframeGroups, target) {\n    var interpolations = [];\n    for(var groupName in propertySpecificKeyframeGroups){\n        var keyframes = propertySpecificKeyframeGroups[groupName];\n        for(var i = 0; i < keyframes.length - 1; i++){\n            var startIndex = i;\n            var endIndex = i + 1;\n            var startOffset = keyframes[startIndex].computedOffset;\n            var endOffset = keyframes[endIndex].computedOffset;\n            var applyFrom = startOffset;\n            var applyTo = endOffset;\n            if (i === 0) {\n                applyFrom = -Infinity;\n                if (endOffset === 0) {\n                    endIndex = startIndex;\n                }\n            }\n            if (i === keyframes.length - 2) {\n                applyTo = Infinity;\n                if (startOffset === 1) {\n                    startIndex = endIndex;\n                }\n            }\n            interpolations.push({\n                applyFrom: applyFrom,\n                applyTo: applyTo,\n                startOffset: keyframes[startIndex].computedOffset,\n                endOffset: keyframes[endIndex].computedOffset,\n                easingFunction: keyframes[startIndex].easingFunction,\n                property: groupName,\n                interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)\n            });\n        }\n    }\n    interpolations.sort(function(leftInterpolation, rightInterpolation) {\n        return leftInterpolation.startOffset - rightInterpolation.startOffset;\n    });\n    return interpolations;\n}\nvar InterpolationFactory = function InterpolationFactory(from, to, convertToString) {\n    return function(f) {\n        var interpolated = interpolate(from, to, f);\n        return (0,_antv_util__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(interpolated) ? interpolated : convertToString(interpolated);\n    };\n};\nfunction propertyInterpolation(property, left, right, target) {\n    var metadata = _antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.propertyMetadataCache[property];\n    if (metadata && metadata.syntax && metadata[\"int\"]) {\n        var propertyHandler = _antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);\n        if (propertyHandler) {\n            var parser = propertyHandler.parser;\n            var usedLeft = parser ? parser(left, target) : left;\n            var usedRight = parser ? parser(right, target) : right;\n            // merger [left, right, n2string()]\n            var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);\n            if (interpolationArgs) {\n                var interp = InterpolationFactory.apply(void 0, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5___default()(interpolationArgs));\n                return function(t) {\n                    if (t === 0) return left;\n                    if (t === 1) return right;\n                    return interp(t);\n                };\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return InterpolationFactory(false, true, function(bool) {\n        return bool ? right : left;\n    });\n}\n/**\n * interpolate with number, boolean, number[], boolean[]\n */ function interpolate(from, to, f) {\n    if (typeof from === \"number\" && typeof to === \"number\") {\n        return from * (1 - f) + to * f;\n    }\n    if (typeof from === \"boolean\" && typeof to === \"boolean\" || typeof from === \"string\" && typeof to === \"string\" // skip string, eg. path ['M', 10, 10]\n    ) {\n        return f < 0.5 ? from : to;\n    }\n    if (Array.isArray(from) && Array.isArray(to)) {\n        // interpolate arrays/matrix\n        var fromLength = from.length;\n        var toLength = to.length;\n        var length = Math.max(fromLength, toLength);\n        var r = [];\n        for(var i = 0; i < length; i++){\n            r.push(interpolate(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));\n        }\n        return r;\n    }\n    throw new Error(\"Mismatched interpolation arguments \".concat(from, \":\").concat(to));\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming\n */ var AnimationEffectTiming = /*#__PURE__*/ function() {\n    function AnimationEffectTiming() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AnimationEffectTiming);\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/delay\n     */ this.delay = 0;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/direction\n     */ this.direction = \"normal\";\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration\n     */ this.duration = \"auto\";\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing\n     */ this._easing = \"linear\";\n        this.easingFunction = linear;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay\n     */ this.endDelay = 0;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill\n     */ this.fill = \"auto\";\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterationStart\n     */ this.iterationStart = 0;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterations\n     */ this.iterations = 1;\n        this.currentIteration = null;\n        this.progress = null;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AnimationEffectTiming, [\n        {\n            key: \"easing\",\n            get: function get() {\n                return this._easing;\n            },\n            set: function set(value) {\n                this.easingFunction = parseEasingFunction(value);\n                this._easing = value;\n            }\n        }\n    ]);\n}();\n/**\n * @example\n  {\n    translateY: [200, 300],\n    scale: [1, 10],\n  }\n\n * groups' length can be different, the following config should generate 3 frames:\n  @example\n  {\n    translateY: [200, 300, 400],\n    scale: [1, 10],\n  }\n */ function convertToArrayForm(effectInput) {\n    var normalizedEffectInput = [];\n    for(var property in effectInput){\n        // skip reserved props\n        if (property in [\n            \"easing\",\n            \"offset\",\n            \"composite\"\n        ]) {\n            continue;\n        }\n        // @ts-ignore\n        var values = effectInput[property];\n        if (!Array.isArray(values)) {\n            values = [\n                values\n            ];\n        }\n        var numKeyframes = values.length;\n        for(var i = 0; i < numKeyframes; i++){\n            if (!normalizedEffectInput[i]) {\n                var keyframe = {};\n                if (\"offset\" in effectInput) {\n                    keyframe.offset = Number(effectInput.offset);\n                }\n                if (\"easing\" in effectInput) {\n                    // @ts-ignore\n                    keyframe.easing = effectInput.easing;\n                }\n                if (\"composite\" in effectInput) {\n                    // @ts-ignore\n                    keyframe.composite = effectInput.composite;\n                }\n                normalizedEffectInput[i] = keyframe;\n            }\n            if (values[i] !== undefined && values[i] !== null) {\n                normalizedEffectInput[i][property] = values[i];\n            }\n        }\n    }\n    normalizedEffectInput.sort(function(a, b) {\n        return (a.computedOffset || 0) - (b.computedOffset || 0);\n    });\n    return normalizedEffectInput;\n}\nfunction normalizeKeyframes(effectInput, timing) {\n    if (effectInput === null) {\n        return [];\n    }\n    if (!Array.isArray(effectInput)) {\n        effectInput = convertToArrayForm(effectInput);\n    }\n    var keyframes = effectInput.map(function(originalKeyframe) {\n        var keyframe = {};\n        if (timing !== null && timing !== void 0 && timing.composite) {\n            // This will be auto if the composite operation specified on the effect is being used.\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats\n            keyframe.composite = \"auto\";\n        }\n        for(var member in originalKeyframe){\n            var memberValue = originalKeyframe[member];\n            if (member === \"offset\") {\n                if (memberValue !== null) {\n                    memberValue = Number(memberValue);\n                    if (!isFinite(memberValue)) throw new Error(\"Keyframe offsets must be numbers.\");\n                    if (memberValue < 0 || memberValue > 1) throw new Error(\"Keyframe offsets must be between 0 and 1.\");\n                    keyframe.computedOffset = memberValue;\n                }\n            } else if (member === \"composite\") {\n                // TODO: Support add & accumulate in KeyframeEffect.composite\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/composite\n                if ([\n                    \"replace\",\n                    \"add\",\n                    \"accumulate\",\n                    \"auto\"\n                ].indexOf(memberValue) === -1) {\n                    throw new Error(\"\".concat(memberValue, \" compositing is not supported\"));\n                }\n            } else ;\n            // assign to keyframe, no need to parse shorthand value\n            keyframe[member] = memberValue;\n        }\n        if (keyframe.offset === undefined) {\n            keyframe.offset = null;\n        }\n        if (keyframe.easing === undefined) {\n            // override with timing.easing\n            keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || \"linear\";\n        }\n        if (keyframe.composite === undefined) {\n            keyframe.composite = \"auto\";\n        }\n        return keyframe;\n    });\n    var everyFrameHasOffset = true;\n    var previousOffset = -Infinity;\n    for(var i = 0; i < keyframes.length; i++){\n        var offset = keyframes[i].offset;\n        if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(offset)) {\n            if (offset < previousOffset) {\n                throw new TypeError(\"Keyframes are not loosely sorted by offset. Sort or specify offsets.\");\n            }\n            previousOffset = offset;\n        } else {\n            everyFrameHasOffset = false;\n        }\n    }\n    keyframes = keyframes.filter(function(keyframe) {\n        return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;\n    });\n    function spaceKeyframes() {\n        var _keyframes$offset;\n        var _keyframes = keyframes, length = _keyframes.length;\n        keyframes[length - 1].computedOffset = Number((_keyframes$offset = keyframes[length - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);\n        if (length > 1) {\n            var _keyframes$0$offset;\n            keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);\n        }\n        var previousIndex = 0;\n        var previousOffset = Number(keyframes[0].computedOffset);\n        for(var _i = 1; _i < length; _i++){\n            var _offset = keyframes[_i].computedOffset;\n            if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(_offset) && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(previousOffset)) {\n                for(var j = 1; j < _i - previousIndex; j++)keyframes[previousIndex + j].computedOffset = previousOffset + (Number(_offset) - previousOffset) * j / (_i - previousIndex);\n                previousIndex = _i;\n                previousOffset = Number(_offset);\n            }\n        }\n    }\n    if (!everyFrameHasOffset) spaceKeyframes();\n    return keyframes;\n}\nvar fills = \"backwards|forwards|both|none\".split(\"|\");\nvar directions = \"reverse|alternate|alternate-reverse\".split(\"|\");\nfunction makeTiming(timingInput, forGroup) {\n    var timing = new AnimationEffectTiming();\n    if (forGroup) {\n        timing.fill = \"both\";\n        timing.duration = \"auto\";\n    }\n    if (typeof timingInput === \"number\" && !isNaN(timingInput)) {\n        timing.duration = timingInput;\n    } else if (timingInput !== undefined) {\n        Object.keys(timingInput).forEach(function(property) {\n            if (timingInput[property] !== undefined && timingInput[property] !== null && timingInput[property] !== \"auto\") {\n                if (typeof timing[property] === \"number\" || property === \"duration\") {\n                    if (typeof timingInput[property] !== \"number\" || isNaN(timingInput[property])) {\n                        return;\n                    }\n                }\n                if (property === \"fill\" && fills.indexOf(timingInput[property]) === -1) {\n                    return;\n                }\n                if (property === \"direction\" && directions.indexOf(timingInput[property]) === -1) {\n                    return;\n                }\n                // @ts-ignore\n                timing[property] = timingInput[property];\n            }\n        });\n    }\n    return timing;\n}\nfunction normalizeTimingInput(timingInput, forGroup) {\n    timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : {\n        duration: \"auto\"\n    });\n    return makeTiming(timingInput, forGroup);\n}\nfunction numericTimingToObject(timingInput) {\n    if (typeof timingInput === \"number\") {\n        if (isNaN(timingInput)) {\n            timingInput = {\n                duration: \"auto\"\n            };\n        } else {\n            timingInput = {\n                duration: timingInput\n            };\n        }\n    }\n    return timingInput;\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect\n * @example\n  const circleDownKeyframes = new KeyframeEffect(\n    circle, // element to animate\n    [\n      { transform: 'translateY(0)' }, // keyframe\n      { transform: 'translateY(100)' } // keyframe\n    ],\n    { duration: 3000, fill: 'forwards' } // keyframe options\n  );\n *\n */ var KeyframeEffect = /*#__PURE__*/ function() {\n    // pseudoElement: string | null;\n    function KeyframeEffect(target, effectInput, timingInput) {\n        var _this = this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, KeyframeEffect);\n        this.composite = \"replace\";\n        this.iterationComposite = \"replace\";\n        this.target = target;\n        this.timing = normalizeTimingInput(timingInput, false);\n        this.timing.effect = this;\n        this.timing.activeDuration = calculateActiveDuration(this.timing);\n        this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);\n        this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);\n        this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);\n        // 不支持 proxy 时降级成 this.timing\n        var Proxy = _antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.runtime.globalThis.Proxy;\n        this.computedTiming = Proxy ? new Proxy(this.timing, {\n            get: function get(target, prop) {\n                if (prop === \"duration\") {\n                    return target.duration === \"auto\" ? 0 : target.duration;\n                }\n                if (prop === \"fill\") {\n                    return target.fill === \"auto\" ? \"none\" : target.fill;\n                }\n                if (prop === \"localTime\") {\n                    return _this.animation && _this.animation.currentTime || null;\n                }\n                if (prop === \"currentIteration\") {\n                    if (!_this.animation || _this.animation.playState !== \"running\") {\n                        return null;\n                    }\n                    return target.currentIteration || 0;\n                }\n                if (prop === \"progress\") {\n                    if (!_this.animation || _this.animation.playState !== \"running\") {\n                        return null;\n                    }\n                    return target.progress || 0;\n                }\n                return target[prop];\n            },\n            set: function set() {\n                return true;\n            }\n        }) : this.timing;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(KeyframeEffect, [\n        {\n            key: \"applyInterpolations\",\n            value: function applyInterpolations() {\n                this.interpolations(this.target, Number(this.timeFraction));\n            }\n        },\n        {\n            key: \"update\",\n            value: function update(localTime) {\n                if (localTime === null) {\n                    return false;\n                }\n                this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);\n                return this.timeFraction !== null;\n            }\n        },\n        {\n            key: \"getKeyframes\",\n            value: function getKeyframes() {\n                return this.normalizedKeyframes;\n            }\n        },\n        {\n            key: \"setKeyframes\",\n            value: function setKeyframes(keyframes) {\n                this.normalizedKeyframes = normalizeKeyframes(keyframes);\n            }\n        },\n        {\n            key: \"getComputedTiming\",\n            value: function getComputedTiming() {\n                return this.computedTiming;\n            }\n        },\n        {\n            key: \"getTiming\",\n            value: function getTiming() {\n                return this.timing;\n            }\n        },\n        {\n            key: \"updateTiming\",\n            value: function updateTiming(timing) {\n                var _this2 = this;\n                Object.keys(timing || {}).forEach(function(name) {\n                    _this2.timing[name] = timing[name];\n                });\n            }\n        }\n    ]);\n}();\nfunction compareAnimations(leftAnimation, rightAnimation) {\n    return Number(leftAnimation.id) - Number(rightAnimation.id);\n}\n/**\n * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/web-animations-js/index.d.ts\n */ var AnimationTimeline = /*#__PURE__*/ function() {\n    function AnimationTimeline(document) {\n        var _this = this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AnimationTimeline);\n        /**\n     * all active animations\n     */ this.animations = [];\n        this.ticking = false;\n        this.timelineTicking = false;\n        this.hasRestartedThisFrame = false;\n        this.animationsWithPromises = [];\n        this.inTick = false;\n        this.pendingEffects = [];\n        this.currentTime = null;\n        this.rafId = 0;\n        this.rafCallbacks = [];\n        this.webAnimationsNextTick = function(t) {\n            _this.currentTime = t;\n            _this.discardAnimations();\n            if (_this.animations.length === 0) {\n                _this.timelineTicking = false;\n            } else {\n                _this.requestAnimationFrame(_this.webAnimationsNextTick);\n            }\n        };\n        this.processRafCallbacks = function(t) {\n            var processing = _this.rafCallbacks;\n            _this.rafCallbacks = [];\n            if (t < Number(_this.currentTime)) t = Number(_this.currentTime);\n            _this.animations.sort(compareAnimations);\n            _this.animations = _this.tick(t, true, _this.animations)[0];\n            processing.forEach(function(entry) {\n                entry[1](t);\n            });\n            _this.applyPendingEffects();\n        };\n        this.document = document;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AnimationTimeline, [\n        {\n            key: \"getAnimations\",\n            value: function getAnimations() {\n                this.discardAnimations();\n                return this.animations.slice();\n            }\n        },\n        {\n            key: \"isTicking\",\n            value: function isTicking() {\n                return this.inTick;\n            }\n        },\n        {\n            key: \"play\",\n            value: function play(target, keyframes, options) {\n                var effect = new KeyframeEffect(target, keyframes, options);\n                var animation = new Animation(effect, this);\n                this.animations.push(animation);\n                this.restartWebAnimationsNextTick();\n                animation.updatePromises();\n                animation.play();\n                animation.updatePromises();\n                return animation;\n            }\n        },\n        {\n            key: \"applyDirtiedAnimation\",\n            value: function applyDirtiedAnimation(animation) {\n                var _this2 = this;\n                if (this.inTick) {\n                    return;\n                }\n                // update active animations in displayobject\n                animation.markTarget();\n                var animations = animation.targetAnimations();\n                animations.sort(compareAnimations);\n                // clear inactive animations\n                var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];\n                inactiveAnimations.forEach(function(animation) {\n                    var index = _this2.animations.indexOf(animation);\n                    if (index !== -1) {\n                        _this2.animations.splice(index, 1);\n                    }\n                });\n                this.applyPendingEffects();\n            }\n        },\n        {\n            key: \"restart\",\n            value: function restart() {\n                if (!this.ticking) {\n                    this.ticking = true;\n                    this.requestAnimationFrame(function() {});\n                    this.hasRestartedThisFrame = true;\n                }\n                return this.hasRestartedThisFrame;\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                this.document.defaultView.cancelAnimationFrame(this.frameId);\n            }\n        },\n        {\n            key: \"applyPendingEffects\",\n            value: function applyPendingEffects() {\n                this.pendingEffects.forEach(function(effect) {\n                    effect === null || effect === void 0 || effect.applyInterpolations();\n                });\n                this.pendingEffects = [];\n            }\n        },\n        {\n            key: \"updateAnimationsPromises\",\n            value: function updateAnimationsPromises() {\n                this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {\n                    return animation.updatePromises();\n                });\n            }\n        },\n        {\n            key: \"discardAnimations\",\n            value: function discardAnimations() {\n                this.updateAnimationsPromises();\n                this.animations = this.animations.filter(function(animation) {\n                    return animation.playState !== \"finished\" && animation.playState !== \"idle\";\n                });\n            }\n        },\n        {\n            key: \"restartWebAnimationsNextTick\",\n            value: function restartWebAnimationsNextTick() {\n                if (!this.timelineTicking) {\n                    this.timelineTicking = true;\n                    this.requestAnimationFrame(this.webAnimationsNextTick);\n                }\n            }\n        },\n        {\n            key: \"rAF\",\n            value: function rAF(f) {\n                var id = this.rafId++;\n                if (this.rafCallbacks.length === 0) {\n                    this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);\n                }\n                this.rafCallbacks.push([\n                    id,\n                    f\n                ]);\n                return id;\n            }\n        },\n        {\n            key: \"requestAnimationFrame\",\n            value: function requestAnimationFrame(f) {\n                var _this3 = this;\n                return this.rAF(function(x) {\n                    _this3.updateAnimationsPromises();\n                    f(x);\n                    _this3.updateAnimationsPromises();\n                });\n            }\n        },\n        {\n            key: \"tick\",\n            value: function tick(t, isAnimationFrame, updatingAnimations) {\n                var _this4 = this, _this$pendingEffects, _this$pendingEffects2;\n                this.inTick = true;\n                this.hasRestartedThisFrame = false;\n                this.currentTime = t;\n                this.ticking = false;\n                var newPendingClears = [];\n                var newPendingEffects = [];\n                var activeAnimations = [];\n                var inactiveAnimations = [];\n                updatingAnimations.forEach(function(animation) {\n                    animation.tick(t, isAnimationFrame);\n                    if (!animation._inEffect) {\n                        newPendingClears.push(animation.effect);\n                        animation.unmarkTarget();\n                    } else {\n                        newPendingEffects.push(animation.effect);\n                        animation.markTarget();\n                    }\n                    if (animation._needsTick) _this4.ticking = true;\n                    var alive = animation._inEffect || animation._needsTick;\n                    animation._inTimeline = alive;\n                    if (alive) {\n                        activeAnimations.push(animation);\n                    } else {\n                        inactiveAnimations.push(animation);\n                    }\n                });\n                (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);\n                (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);\n                if (this.ticking) this.requestAnimationFrame(function() {});\n                this.inTick = false;\n                return [\n                    activeAnimations,\n                    inactiveAnimations\n                ];\n            }\n        }\n    ]);\n}();\n_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.runtime.EasingFunction = parseEasingFunction;\n_antv_g_lite__WEBPACK_IMPORTED_MODULE_0__.runtime.AnimationTimeline = AnimationTimeline;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhbnR2K2ctd2ViLWFuaW1hdGlvbnMtYXBpQDIuMS4yMS9ub2RlX21vZHVsZXMvQGFudHYvZy13ZWItYW5pbWF0aW9ucy1hcGkvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQytHO0FBQzVDO0FBQ047QUFDSjtBQUNGO0FBQ2tCO0FBQ1I7QUFDZDtBQUVwRDs7Q0FFQyxHQUNELGFBQWE7QUFDYixJQUFJYSxpQkFBaUIsV0FBVyxHQUFFLFNBQVVDLGVBQWU7SUFDekQsU0FBU0QsZUFBZUUsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsWUFBWTtRQUNoRSxJQUFJQztRQUNKZiw0RUFBZUEsQ0FBQyxJQUFJLEVBQUVTO1FBQ3RCTSxRQUFRYix1RUFBVUEsQ0FBQyxJQUFJLEVBQUVPLGdCQUFnQjtZQUFDRTtTQUFRO1FBRWxELGFBQWE7UUFDYkksTUFBTUYsV0FBVyxHQUFHQTtRQUNwQkUsTUFBTUQsWUFBWSxHQUFHQTtRQUNyQkMsTUFBTUgsTUFBTSxHQUFHQTtRQUNmRyxNQUFNQyxJQUFJLEdBQUc7UUFDYkQsTUFBTUUsT0FBTyxHQUFHO1FBQ2hCLGFBQWE7UUFDYkYsTUFBTUcsYUFBYSxHQUFHTjtRQUN0QkcsTUFBTUksZ0JBQWdCLEdBQUc7UUFDekJKLE1BQU1LLFVBQVUsR0FBR0wsTUFBTU0sU0FBUztRQUNsQ04sTUFBTU8sU0FBUyxHQUFHQyxLQUFLQyxHQUFHO1FBQzFCVCxNQUFNRixXQUFXLEdBQUdBO1FBQ3BCRSxNQUFNRCxZQUFZLEdBQUdBO1FBQ3JCLE9BQU9DO0lBQ1Q7SUFDQVosc0VBQVNBLENBQUNNLGdCQUFnQkM7SUFDMUIsT0FBT1QseUVBQVlBLENBQUNRO0FBQ3RCLEVBQUViLHdEQUFjQTtBQUVoQixJQUFJNkIsaUJBQWlCO0FBRXJCOztDQUVDLEdBQ0QsSUFBSUMsWUFBWSxXQUFXLEdB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Q29MLHVCQUF1QkU7Z0JBQ2hGLElBQUksSUFBSSxDQUFDM0IsT0FBTyxFQUFFLElBQUksQ0FBQ1MscUJBQXFCLENBQUMsWUFBYTtnQkFDMUQsSUFBSSxDQUFDTixNQUFNLEdBQUc7Z0JBQ2QsT0FBTztvQkFBQ3lCO29CQUFrQlo7aUJBQW1CO1lBQy9DO1FBQ0Y7S0FBRTtBQUNKO0FBRUE1YSxpREFBT0EsQ0FBQzJiLGNBQWMsR0FBRzlMO0FBQ3pCN1AsaURBQU9BLENBQUMwWixpQkFBaUIsR0FBR0E7QUFFNkosQ0FDekwscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvY2Vzcy1hbmFseXNpcy1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGFudHYrZy13ZWItYW5pbWF0aW9ucy1hcGlAMi4xLjIxL25vZGVfbW9kdWxlcy9AYW50di9nLXdlYi1hbmltYXRpb25zLWFwaS9kaXN0L2luZGV4LmVzbS5qcz9mMWIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGFudHYvZy13ZWItYW5pbWF0aW9ucy1hcGlcbiAqIEBkZXNjcmlwdGlvbiBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBXZWIgQW5pbWF0aW9ucyBBUEkuXG4gKiBAdmVyc2lvbiAyLjEuMjFcbiAqIEBkYXRlIDEvMjMvMjAyNSwgODozMzo1NSBBTVxuICogQGF1dGhvciBBbnRWaXNcbiAqIEBkb2NzIGh0dHBzOi8vZy5hbnR2LmFudGdyb3VwLmNvbS9cbiAqL1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQsIEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVELCBwcm9wZXJ0eU1ldGFkYXRhQ2FjaGUsIHJ1bnRpbWUgfSBmcm9tICdAYW50di9nLWxpdGUnO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJztcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyc7XG5pbXBvcnQgX2NhbGxTdXBlciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NhbGxTdXBlcic7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5JztcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXknO1xuaW1wb3J0IHsgY2xhbXAsIGlzTnVtYmVyLCBpc05pbCB9IGZyb20gJ0BhbnR2L3V0aWwnO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvblBsYXliYWNrRXZlbnRcbiAqL1xuLy8gQHRzLWlnbm9yZVxudmFyIEFuaW1hdGlvbkV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRmVkZXJhdGVkRXZlbnQpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uRXZlbnQobWFuYWdlciwgdGFyZ2V0LCBjdXJyZW50VGltZSwgdGltZWxpbmVUaW1lKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmltYXRpb25FdmVudCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEFuaW1hdGlvbkV2ZW50LCBbbWFuYWdlcl0pO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF90aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgX3RoaXMudGltZWxpbmVUaW1lID0gdGltZWxpbmVUaW1lO1xuICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICBfdGhpcy50eXBlID0gJ2ZpbmlzaCc7XG4gICAgX3RoaXMuYnViYmxlcyA9IGZhbHNlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIF90aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5ldmVudFBoYXNlID0gX3RoaXMuQVRfVEFSR0VUO1xuICAgIF90aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgX3RoaXMuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBfdGhpcy50aW1lbGluZVRpbWUgPSB0aW1lbGluZVRpbWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhBbmltYXRpb25FdmVudCwgX0ZlZGVyYXRlZEV2ZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBbmltYXRpb25FdmVudCk7XG59KEZlZGVyYXRlZEV2ZW50KTtcblxudmFyIHNlcXVlbmNlTnVtYmVyID0gMDtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vQW5pbWF0aW9uXG4gKi9cbnZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24oZWZmZWN0LCB0aW1lbGluZSkge1xuICAgIHZhciBfdGhpcyRlZmZlY3Q7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuaW1hdGlvbik7XG4gICAgdGhpcy5jdXJyZW50VGltZVBlbmRpbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vcGxheVN0YXRlXG4gICAgICovXG4gICAgLy8gcGxheVN0YXRlOiBBbmltYXRpb25QbGF5U3RhdGU7XG4gICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluaXNoZWRGbGFnID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vY3VycmVudFRpbWVcbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5fcGxheWJhY2tSYXRlID0gMTtcbiAgICB0aGlzLl9pblRpbWVsaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDtcbiAgICBlZmZlY3QuYW5pbWF0aW9uID0gdGhpcztcbiAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgdGhpcy5pZCA9IFwiXCIuY29uY2F0KHNlcXVlbmNlTnVtYmVyKyspO1xuICAgIHRoaXMuX2luRWZmZWN0ID0gISF0aGlzLmVmZmVjdC51cGRhdGUoMCk7XG4gICAgdGhpcy5fdG90YWxEdXJhdGlvbiA9IE51bWJlcigoX3RoaXMkZWZmZWN0ID0gdGhpcy5lZmZlY3QpID09PSBudWxsIHx8IF90aGlzJGVmZmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZWZmZWN0LmdldENvbXB1dGVkVGltaW5nKCkuZW5kVGltZSk7XG4gICAgdGhpcy5faG9sZFRpbWUgPSAwO1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMub2xkUGxheVN0YXRlID0gJ2lkbGUnO1xuICAgIHRoaXMudXBkYXRlUHJvbWlzZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdGF0ZSBtYWNoaW5lLFxuICAgKiByZXNvbHZlL3JlamVjdCByZWFkeS9maW5pc2hlZCBQcm9taXNlIGFjY29yZGluZyB0byBjdXJyZW50IHN0YXRlXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFuaW1hdGlvbiwgW3tcbiAgICBrZXk6IFwicGVuZGluZ1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vZWZmZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vdGltZWxpbmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbi9pZFxuICAgICAqL1xuXG4gICAgLy8gYW5pbWF0aW9uOiBJbnRlcm5hbEFuaW1hdGlvbiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vcGVuZGluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuX3BhdXNlZCAmJiB0aGlzLnBsYXliYWNrUmF0ZSAhPT0gMCB8fCB0aGlzLmN1cnJlbnRUaW1lUGVuZGluZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5faWRsZSkgcmV0dXJuICdpZGxlJztcbiAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSByZXR1cm4gJ2ZpbmlzaGVkJztcbiAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHJldHVybiAncGF1c2VkJztcbiAgICAgIHJldHVybiAncnVubmluZyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVjb3JkIHByZXZpb3Mgc3RhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWFkeVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vcmVhZHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICBhbmltYXRpb24ucmVhZHkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRGlzcGxheXMgJ3J1bm5pbmcnXG4gICAgICAgIGFsZXJ0KGFuaW1hdGlvbi5wbGF5U3RhdGUpO1xuICAgICAgfSk7XG4gICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMucmVhZHlQcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lLmFuaW1hdGlvbnNXaXRoUHJvbWlzZXMuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLnRpbWVsaW5lLmFuaW1hdGlvbnNXaXRoUHJvbWlzZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBfdGhpcy5yZXNvbHZlUmVhZHlQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpcy5yZWplY3RSZWFkeVByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZykge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZVJlYWR5UHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uL2ZpbmlzaGVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICBlbGVtLmdldEFuaW1hdGlvbnMoKS5tYXAoXG4gICAgICAgICAgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLmZpbmlzaGVkXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmlzaGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5maW5pc2hlZFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUuYW5pbWF0aW9uc1dpdGhQcm9taXNlcy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgICAgIHRoaXMudGltZWxpbmUuYW5pbWF0aW9uc1dpdGhQcm9taXNlcy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluaXNoZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIF90aGlzMi5yZXNvbHZlRmluaXNoZWRQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfdGhpczIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3RoaXMyLnJlamVjdEZpbmlzaGVkUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnBsYXlTdGF0ZSA9PT0gJ2ZpbmlzaGVkJykge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hlZFByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uL29uZmluaXNoXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb24vb25jYW5jZWxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGdldCBjYWxsZWQgYWZ0ZXIgZWFjaCBmcmFtZSB3aGVuIHJ1bm5pbmdcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50VGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhpcy51cGRhdGVQcm9taXNlcygpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lkbGUgfHwgdGhpcy5jdXJyZW50VGltZVBlbmRpbmcgPyBudWxsIDogdGhpcy5fY3VycmVudFRpbWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdUaW1lKSB7XG4gICAgICBuZXdUaW1lID0gTnVtYmVyKG5ld1RpbWUpO1xuICAgICAgaWYgKGlzTmFOKG5ld1RpbWUpKSByZXR1cm47XG4gICAgICB0aGlzLnRpbWVsaW5lLnJlc3RhcnQoKTtcbiAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3N0YXJ0VGltZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3RoaXMkdGltZWxpbmU7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IE51bWJlcigoX3RoaXMkdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKSA9PT0gbnVsbCB8fCBfdGhpcyR0aW1lbGluZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkdGltZWxpbmUuY3VycmVudFRpbWUpIC0gbmV3VGltZSAvIHRoaXMucGxheWJhY2tSYXRlO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50VGltZVBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSA9PT0gbmV3VGltZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faWRsZSkge1xuICAgICAgICB0aGlzLl9pZGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tDdXJyZW50VGltZShuZXdUaW1lLCB0cnVlKTtcbiAgICAgIHRoaXMudGltZWxpbmUuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbi9zdGFydFRpbWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdUaW1lKSB7XG4gICAgICBpZiAobmV3VGltZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgICAgIG5ld1RpbWUgPSBOdW1iZXIobmV3VGltZSk7XG4gICAgICAgIGlmIChpc05hTihuZXdUaW1lKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fcGF1c2VkIHx8IHRoaXMuX2lkbGUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbmV3VGltZTtcbiAgICAgICAgdGhpcy50aWNrQ3VycmVudFRpbWUoKE51bWJlcih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLnBsYXliYWNrUmF0ZSk7XG4gICAgICAgIHRoaXMudGltZWxpbmUuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsYXliYWNrUmF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRoaXMuX3BsYXliYWNrUmF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgICB2YXIgb2xkQ3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5wbGF5U3RhdGUgIT09ICdwYXVzZWQnICYmIHRoaXMucGxheVN0YXRlICE9PSAnaWRsZScpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoZWRGbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbnN1cmVBbGl2ZSgpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbGRDdXJyZW50VGltZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gb2xkQ3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc0ZpbmlzaGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2lkbGUgJiYgKHRoaXMuX3BsYXliYWNrUmF0ZSA+IDAgJiYgTnVtYmVyKHRoaXMuX2N1cnJlbnRUaW1lKSA+PSB0aGlzLl90b3RhbER1cmF0aW9uIHx8IHRoaXMuX3BsYXliYWNrUmF0ZSA8IDAgJiYgTnVtYmVyKHRoaXMuX2N1cnJlbnRUaW1lKSA8PSAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG90YWxEdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9uZWVkc1RpY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgdGhpcy5wbGF5U3RhdGUgPT09ICdydW5uaW5nJyB8fCAhdGhpcy5fZmluaXNoZWRGbGFnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcm9taXNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQcm9taXNlcygpIHtcbiAgICAgIHZhciBvbGRQbGF5U3RhdGUgPSB0aGlzLm9sZFBsYXlTdGF0ZTtcbiAgICAgIHZhciBuZXdQbGF5U3RhdGUgPSB0aGlzLnBlbmRpbmcgPyAncGVuZGluZycgOiB0aGlzLnBsYXlTdGF0ZTtcbiAgICAgIGlmICh0aGlzLnJlYWR5UHJvbWlzZSAmJiBuZXdQbGF5U3RhdGUgIT09IG9sZFBsYXlTdGF0ZSkge1xuICAgICAgICBpZiAobmV3UGxheVN0YXRlID09PSAnaWRsZScpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdFJlYWR5UHJvbWlzZSgpO1xuICAgICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFBsYXlTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlUmVhZHlQcm9taXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmV3UGxheVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmluaXNoZWRQcm9taXNlICYmIG5ld1BsYXlTdGF0ZSAhPT0gb2xkUGxheVN0YXRlKSB7XG4gICAgICAgIGlmIChuZXdQbGF5U3RhdGUgPT09ICdpZGxlJykge1xuICAgICAgICAgIHRoaXMucmVqZWN0RmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgICAgdGhpcy5maW5pc2hlZFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAobmV3UGxheVN0YXRlID09PSAnZmluaXNoZWQnKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkUGxheVN0YXRlID09PSAnZmluaXNoZWQnKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hlZFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub2xkUGxheVN0YXRlID0gbmV3UGxheVN0YXRlO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlIHx8IHRoaXMuZmluaXNoZWRQcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkIHx8IHRoaXMuX2lkbGUpIHtcbiAgICAgICAgdGhpcy5yZXdpbmQoKTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpbmlzaGVkRmxhZyA9IGZhbHNlO1xuICAgICAgdGhpcy5faWRsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lbnN1cmVBbGl2ZSgpO1xuICAgICAgdGhpcy50aW1lbGluZS5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcyk7XG4gICAgICBpZiAodGhpcy50aW1lbGluZS5hbmltYXRpb25zLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gICAgICAgIHRoaXMudGltZWxpbmUuYW5pbWF0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVQcm9taXNlcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvbWlzZXMoKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMuX2hvbGRUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5faXNGaW5pc2hlZCAmJiAhdGhpcy5fcGF1c2VkICYmICF0aGlzLl9pZGxlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVQZW5kaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faWRsZSkge1xuICAgICAgICB0aGlzLnJld2luZCgpO1xuICAgICAgICB0aGlzLl9pZGxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlUHJvbWlzZXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluaXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvbWlzZXMoKTtcbiAgICAgIGlmICh0aGlzLl9pZGxlKSByZXR1cm47XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5fcGxheWJhY2tSYXRlID4gMCA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiAwO1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5fdG90YWxEdXJhdGlvbiAtIHRoaXMuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lUGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy50aW1lbGluZS5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcyk7XG4gICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHRoaXMudXBkYXRlUHJvbWlzZXMoKTtcbiAgICAgIGlmICghdGhpcy5faW5FZmZlY3QpIHJldHVybjtcbiAgICAgIHRoaXMuX2luRWZmZWN0ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmluaXNoZWRGbGFnID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gICAgICB0aGlzLmVmZmVjdC51cGRhdGUobnVsbCk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBpbnZhbGlkIGFmdGVyIGNhbmNlbGxhdGlvbiBhcyB0aGUgYW5pbWF0aW9uIHN0YXRlXG4gICAgICAvLyBuZWVkcyB0byB1bi1hcHBseS5cbiAgICAgIHRoaXMudGltZWxpbmUuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgdGhpcy51cGRhdGVQcm9taXNlcygpO1xuXG4gICAgICAvKipcbiAgICAgICAqIDEuIFJlamVjdCB0aGUgY3VycmVudCBmaW5pc2hlZCBwcm9taXNlIHdpdGggYSBET01FeGNlcHRpb24gbmFtZWQgXCJBYm9ydEVycm9yXCIuXG4gICAgICAgKiAyLiBMZXQgY3VycmVudCBmaW5pc2hlZCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2Nzc3dnLWRyYWZ0cy93ZWItYW5pbWF0aW9ucy0xLyNjYW5jZWxpbmctYW4tYW5pbWF0aW9uLXNlY3Rpb25cbiAgICAgICAqL1xuICAgICAgLy8gaWYgKHRoaXMuZmluaXNoZWRQcm9taXNlKSB7XG4gICAgICAvLyAgIHRoaXMucmVqZWN0RmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAvLyAgIHRoaXMuZmluaXNoZWRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgLy8gfVxuXG4gICAgICBpZiAodGhpcy5vbmNhbmNlbCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQW5pbWF0aW9uRXZlbnQobnVsbCwgdGhpcywgdGhpcy5jdXJyZW50VGltZSwgbnVsbCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5vbmNhbmNlbChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgICB2YXIgb2xkQ3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5wbGF5YmFja1JhdGUgKj0gLTE7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIGlmIChvbGRDdXJyZW50VGltZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gb2xkQ3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVByb21pc2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uL3VwZGF0ZVBsYXliYWNrUmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQbGF5YmFja1JhdGUocGxheWJhY2tSYXRlKSB7XG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFyZ2V0QW5pbWF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YXJnZXRBbmltYXRpb25zKCkge1xuICAgICAgdmFyIF90aGlzJGVmZmVjdDI7XG4gICAgICB2YXIgdGFyZ2V0ID0gKF90aGlzJGVmZmVjdDIgPSB0aGlzLmVmZmVjdCkgPT09IG51bGwgfHwgX3RoaXMkZWZmZWN0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZWZmZWN0Mi50YXJnZXQ7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya1RhcmdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrVGFyZ2V0KCkge1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLnRhcmdldEFuaW1hdGlvbnMoKTtcbiAgICAgIGlmIChhbmltYXRpb25zLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXJrVGFyZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVubWFya1RhcmdldCgpIHtcbiAgICAgIHZhciBhbmltYXRpb25zID0gdGhpcy50YXJnZXRBbmltYXRpb25zKCk7XG4gICAgICB2YXIgaW5kZXggPSBhbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrKHRpbWVsaW5lVGltZSwgaXNBbmltYXRpb25GcmFtZSkge1xuICAgICAgaWYgKCF0aGlzLl9pZGxlICYmICF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpc0FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRpbWVsaW5lVGltZSAtIHRoaXMuX2N1cnJlbnRUaW1lIC8gdGhpcy5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgdGhpcy50aWNrQ3VycmVudFRpbWUoKHRpbWVsaW5lVGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLnBsYXliYWNrUmF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50cyh0aW1lbGluZVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXdpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgICAgaWYgKHRoaXMucGxheWJhY2tSYXRlID49IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RvdGFsRHVyYXRpb24gPCBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5fdG90YWxEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJld2luZCBuZWdhdGl2ZSBwbGF5YmFjayByYXRlIGFuaW1hdGlvbiB3aXRoIGluZmluaXRlIGR1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBlcnNpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVyc2lzdCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFN0eWxlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8vIHJlcGxhY2VTdGF0ZTogQW5pbWF0aW9uUmVwbGFjZVN0YXRlO1xuICAgIGZ1bmN0aW9uIGNvbW1pdFN0eWxlcygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuc3VyZUFsaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZUFsaXZlKCkge1xuICAgICAgLy8gSWYgYW4gYW5pbWF0aW9uIGlzIHBsYXlpbmcgYmFja3dhcmRzIGFuZCBpcyBub3QgZmlsbCBiYWNrd2FyZHMvYm90aFxuICAgICAgLy8gdGhlbiBpdCBzaG91bGQgZ28gb3V0IG9mIGVmZmVjdCB3aGVuIGl0IHJlYWNoZXMgdGhlIHN0YXJ0IG9mIGl0c1xuICAgICAgLy8gYWN0aXZlIGludGVydmFsIChjdXJyZW50VGltZSA9PT0gMCkuXG4gICAgICBpZiAodGhpcy5wbGF5YmFja1JhdGUgPCAwICYmIHRoaXMuY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgdmFyIF90aGlzJGVmZmVjdDM7XG4gICAgICAgIHRoaXMuX2luRWZmZWN0ID0gISEoKF90aGlzJGVmZmVjdDMgPSB0aGlzLmVmZmVjdCkgIT09IG51bGwgJiYgX3RoaXMkZWZmZWN0MyAhPT0gdm9pZCAwICYmIF90aGlzJGVmZmVjdDMudXBkYXRlKC0xKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkZWZmZWN0NDtcbiAgICAgICAgdGhpcy5faW5FZmZlY3QgPSAhISgoX3RoaXMkZWZmZWN0NCA9IHRoaXMuZWZmZWN0KSAhPT0gbnVsbCAmJiBfdGhpcyRlZmZlY3Q0ICE9PSB2b2lkIDAgJiYgX3RoaXMkZWZmZWN0NC51cGRhdGUodGhpcy5jdXJyZW50VGltZSkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9pblRpbWVsaW5lICYmICh0aGlzLl9pbkVmZmVjdCB8fCAhdGhpcy5fZmluaXNoZWRGbGFnKSkge1xuICAgICAgICB0aGlzLl9pblRpbWVsaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5hbmltYXRpb25zLnB1c2godGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpY2tDdXJyZW50VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrQ3VycmVudFRpbWUobmV3VGltZSwgaWdub3JlTGltaXQpIHtcbiAgICAgIGlmIChuZXdUaW1lICE9PSB0aGlzLl9jdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IG5ld1RpbWU7XG4gICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkICYmICFpZ25vcmVMaW1pdCkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGhpcy5fcGxheWJhY2tSYXRlID4gMCA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlQWxpdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlRXZlbnRzKGJhc2VUaW1lKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWRGbGFnKSB7XG4gICAgICAgICAgaWYgKHRoaXMub25maW5pc2gpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBBbmltYXRpb25FdmVudChudWxsLCB0aGlzLCB0aGlzLmN1cnJlbnRUaW1lLCBiYXNlVGltZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzNC5vbmZpbmlzaCkge1xuICAgICAgICAgICAgICAgIF90aGlzNC5vbmZpbmlzaChldmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9maW5pc2hlZEZsYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vbmZyYW1lICYmIHRoaXMucGxheVN0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50ID0gbmV3IEFuaW1hdGlvbkV2ZW50KG51bGwsIHRoaXMsIHRoaXMuY3VycmVudFRpbWUsIGJhc2VUaW1lKTtcbiAgICAgICAgICB0aGlzLm9uZnJhbWUoX2V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5pc2hlZEZsYWcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcbiAqIEJlemllckVhc2luZyAtIHVzZSBiZXppZXIgY3VydmUgZm9yIHRyYW5zaXRpb24gZWFzaW5nIGZ1bmN0aW9uXG4gKiBieSBHYcOrdGFuIFJlbmF1ZGVhdSAyMDE0IC0gMjAxNSDigJMgTUlUIExpY2Vuc2VcbiAqL1xuXG4vLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG52YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBBID0gZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xufTtcbnZhciBCID0gZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xufTtcbnZhciBDID0gZnVuY3Rpb24gQyhhQTEpIHtcbiAgcmV0dXJuIDMuMCAqIGFBMTtcbn07XG5cbi8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG52YXIgY2FsY0JlemllciA9IGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcbn07XG5cbi8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbnZhciBnZXRTbG9wZSA9IGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcbn07XG52YXIgYmluYXJ5U3ViZGl2aWRlID0gZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gIHZhciBjdXJyZW50WDtcbiAgdmFyIGN1cnJlbnRUO1xuICB2YXIgaSA9IDA7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMC4wKSBhQiA9IGN1cnJlbnRUO2Vsc2UgYUEgPSBjdXJyZW50VDtcbiAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcbiAgcmV0dXJuIGN1cnJlbnRUO1xufTtcbnZhciBuZXd0b25SYXBoc29uSXRlcmF0ZSA9IGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgcmV0dXJuIGFHdWVzc1Q7XG4gICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICB9XG4gIHJldHVybiBhR3Vlc3NUO1xufTtcbnZhciBiZXppZXIgPSBmdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmICghKG1YMSA+PSAwICYmIG1YMSA8PSAxICYmIG1YMiA+PSAwICYmIG1YMiA8PSAxKSkgdGhyb3cgbmV3IEVycm9yKCdiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UnKTtcbiAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBQcmVjb21wdXRlIHNhbXBsZXMgdGFibGVcbiAgdmFyIHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gIH1cbiAgdmFyIGdldFRGb3JYID0gZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMDtcbiAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuXG4gICAgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XG4gICAgdmFyIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIC8vIEJlY2F1c2UgSmF2YVNjcmlwdCBudW1iZXIgYXJlIGltcHJlY2lzZSwgd2Ugc2hvdWxkIGd1YXJhbnRlZSB0aGUgZXh0cmVtZXMgYXJlIHJpZ2h0LlxuICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHJldHVybiB0O1xuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG4gIH07XG59O1xuXG52YXIgY29udmVydFRvRGFzaCA9IGZ1bmN0aW9uIGNvbnZlcnRUb0Rhc2goc3RyKSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICByZXR1cm4gXCItXCIuY29uY2F0KGxldHRlci50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG5cbiAgLy8gUmVtb3ZlIGZpcnN0IGRhc2hcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgPT09ICctJyA/IHN0ci5zdWJzdHJpbmcoMSkgOiBzdHI7XG59O1xuLyoqXG4gIEVhc2luZyBGdW5jdGlvbnMgZnJvbSBhbmltZS5qcywgdGhleSBhcmUgdHJpZWQgYW5kIHRydWUsIHNvLCBpdHMgYmV0dGVyIHRvIHVzZSB0aGVtIGluc3RlYWQgb2Ygb3RoZXIgYWx0ZXJuYXRpdmVzXG4qL1xudmFyIFF1YWQgPSBmdW5jdGlvbiBRdWFkKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDIpO1xufTtcbnZhciBDdWJpYyA9IGZ1bmN0aW9uIEN1YmljKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDMpO1xufTtcbnZhciBRdWFydCA9IGZ1bmN0aW9uIFF1YXJ0KHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDQpO1xufTtcbnZhciBRdWludCA9IGZ1bmN0aW9uIFF1aW50KHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDUpO1xufTtcbnZhciBFeHBvID0gZnVuY3Rpb24gRXhwbyh0KSB7XG4gIHJldHVybiBNYXRoLnBvdyh0LCA2KTtcbn07XG52YXIgU2luZSA9IGZ1bmN0aW9uIFNpbmUodCkge1xuICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7XG59O1xudmFyIENpcmMgPSBmdW5jdGlvbiBDaXJjKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbn07XG52YXIgQmFjayA9IGZ1bmN0aW9uIEJhY2sodCkge1xuICByZXR1cm4gdCAqIHQgKiAoMyAqIHQgLSAyKTtcbn07XG52YXIgQm91bmNlID0gZnVuY3Rpb24gQm91bmNlKHQpIHtcbiAgdmFyIHBvdzI7XG4gIHZhciBiID0gNDtcbiAgd2hpbGUgKHQgPCAoKHBvdzIgPSBNYXRoLnBvdygyLCAtLWIpKSAtIDEpIC8gMTEpIHt9XG4gIHJldHVybiAxIC8gTWF0aC5wb3coNCwgMyAtIGIpIC0gNy41NjI1ICogTWF0aC5wb3coKHBvdzIgKiAzIC0gMikgLyAyMiAtIHQsIDIpO1xufTtcbnZhciBFbGFzdGljID0gZnVuY3Rpb24gRWxhc3RpYyh0KSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgX3BhcmFtcyA9IF9zbGljZWRUb0FycmF5KHBhcmFtcywgMiksXG4gICAgX3BhcmFtcyQgPSBfcGFyYW1zWzBdLFxuICAgIGFtcGxpdHVkZSA9IF9wYXJhbXMkID09PSB2b2lkIDAgPyAxIDogX3BhcmFtcyQsXG4gICAgX3BhcmFtcyQyID0gX3BhcmFtc1sxXSxcbiAgICBwZXJpb2QgPSBfcGFyYW1zJDIgPT09IHZvaWQgMCA/IDAuNSA6IF9wYXJhbXMkMjtcbiAgdmFyIGEgPSBjbGFtcChOdW1iZXIoYW1wbGl0dWRlKSwgMSwgMTApO1xuICB2YXIgcCA9IGNsYW1wKE51bWJlcihwZXJpb2QpLCAwLjEsIDIpO1xuICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSByZXR1cm4gdDtcbiAgcmV0dXJuIC1hICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSAqIE1hdGguc2luKCh0IC0gMSAtIHAgLyAoTWF0aC5QSSAqIDIpICogTWF0aC5hc2luKDEgLyBhKSkgKiAoTWF0aC5QSSAqIDIpIC8gcCk7XG59O1xudmFyIFNwcmluZyA9IGZ1bmN0aW9uIFNwcmluZyh0KSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIF9wYXJhbXMyID0gX3NsaWNlZFRvQXJyYXkocGFyYW1zLCA0KSxcbiAgICBfcGFyYW1zMiQgPSBfcGFyYW1zMlswXSxcbiAgICBtYXNzID0gX3BhcmFtczIkID09PSB2b2lkIDAgPyAxIDogX3BhcmFtczIkLFxuICAgIF9wYXJhbXMyJDIgPSBfcGFyYW1zMlsxXSxcbiAgICBzdGlmZm5lc3MgPSBfcGFyYW1zMiQyID09PSB2b2lkIDAgPyAxMDAgOiBfcGFyYW1zMiQyLFxuICAgIF9wYXJhbXMyJDMgPSBfcGFyYW1zMlsyXSxcbiAgICBkYW1waW5nID0gX3BhcmFtczIkMyA9PT0gdm9pZCAwID8gMTAgOiBfcGFyYW1zMiQzLFxuICAgIF9wYXJhbXMyJDQgPSBfcGFyYW1zMlszXSxcbiAgICB2ZWxvY2l0eSA9IF9wYXJhbXMyJDQgPT09IHZvaWQgMCA/IDAgOiBfcGFyYW1zMiQ0O1xuICBtYXNzID0gY2xhbXAobWFzcywgMC4xLCAxMDAwKTtcbiAgc3RpZmZuZXNzID0gY2xhbXAoc3RpZmZuZXNzLCAwLjEsIDEwMDApO1xuICBkYW1waW5nID0gY2xhbXAoZGFtcGluZywgMC4xLCAxMDAwKTtcbiAgdmVsb2NpdHkgPSBjbGFtcCh2ZWxvY2l0eSwgMC4xLCAxMDAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcbiAgdmFyIHByb2dyZXNzID0gZHVyYXRpb24gPyBkdXJhdGlvbiAqIHQgLyAxMDAwIDogdDtcbiAgaWYgKHpldGEgPCAxKSB7XG4gICAgcHJvZ3Jlc3MgPSBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB6ZXRhICogdzApICogKGEgKiBNYXRoLmNvcyh3ZCAqIHByb2dyZXNzKSArIGIgKiBNYXRoLnNpbih3ZCAqIHByb2dyZXNzKSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvZ3Jlc3MgPSAoYSArIGIgKiBwcm9ncmVzcykgKiBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB3MCk7XG4gIH1cbiAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgcmV0dXJuIHQ7XG4gIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSBkdXJhdGlvbnMgYXQgc2V0IGVhc2luZyBwYXJhbWV0ZXJzXG4gKi9cbi8vIGV4cG9ydCBjb25zdCBFYXNpbmdEdXJhdGlvbkNhY2hlOiBNYXA8c3RyaW5nIHwgVHlwZUVhc2luZ0Z1bmN0aW9uLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIFRoZSB0aHJlc2hvbGQgZm9yIGFuIGluZmluaXRlIGxvb3BcbiAqL1xuLy8gY29uc3QgSU5USU5JVEVfTE9PUF9MSU1JVCA9IDEwMDAwO1xuXG4vKiogQ29udmVydCBlYXNpbmcgcGFyYW1ldGVycyB0byBBcnJheSBvZiBudW1iZXJzLCBlLmcuIFwic3ByaW5nKDIsIDUwMClcIiB0byBbMiwgNTAwXSAqL1xuLy8gZXhwb3J0IGNvbnN0IHBhcnNlRWFzaW5nUGFyYW1ldGVycyA9IChzdHI6IHN0cmluZykgPT4ge1xuLy8gICBjb25zdCBtYXRjaCA9IC8oXFwofFxccykoW14pXSspXFwpPy8uZXhlYyhzdHIpO1xuLy8gICByZXR1cm4gbWF0Y2hcbi8vICAgICA/IG1hdGNoWzJdLnNwbGl0KCcsJykubWFwKCh2YWx1ZSkgPT4ge1xuLy8gICAgICAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbi8vICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4obnVtKSA/IG51bSA6IHZhbHVlLnRyaW0oKTtcbi8vICAgICAgIH0pXG4vLyAgICAgOiBbXTtcbi8vIH07XG5cbi8qKlxuICogVGhlIHNwcmluZyBlYXNpbmcgZnVuY3Rpb24gd2lsbCBvbmx5IGxvb2sgc21vb3RoIGF0IGNlcnRhaW4gZHVyYXRpb25zLCB3aXRoIGNlcnRhaW4gcGFyYW1ldGVycy5cbiAqIFRoaXMgZnVuY3Rpb25zIHJldHVybnMgdGhlIG9wdGltYWwgZHVyYXRpb24gdG8gY3JlYXRlIGEgc21vb3RoIHNwcmluZ3kgYW5pbWF0aW9uIGJhc2VkIG9uIHBoeXNpY3NcbiAqXG4gKiBOb3RlOiBpdCBjYW4gYWxzbyBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgb3B0aW1hbCBkdXJhdGlvbiBvZiBvdGhlciB0eXBlcyBvZiBlYXNpbmcgZnVuY3Rpb24sIGJ1dCBiZSBjYXJlZnVsIG9mICdpbi0nXG4gKiBlYXNpbmcgZnVuY3Rpb25zLCBiZWNhdXNlIG9mIHRoZSBuYXR1cmUgb2YgdGhlIGZ1bmN0aW9uIGl0IGNhbiBzb21ldGltZXMgY3JlYXRlIGFuIGluZmluaXRlIGxvb3AsIEkgc3VnZ2VzdCBvbmx5IHVzaW5nXG4gKiBgZ2V0RWFzaW5nRHVyYXRpb25gIGZvciBgc3ByaW5nYCwgc3BlY2lmaWNhbGx5ICdvdXQtc3ByaW5nJyBhbmQgJ3NwcmluZydcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGdldEVhc2luZ0R1cmF0aW9uID0gKGVhc2luZzogc3RyaW5nIHwgVHlwZUVhc2luZ0Z1bmN0aW9uID0gJ3NwcmluZycpID0+IHtcbi8vICAgaWYgKEVhc2luZ0R1cmF0aW9uQ2FjaGUuaGFzKGVhc2luZykpIHJldHVybiBFYXNpbmdEdXJhdGlvbkNhY2hlLmdldChlYXNpbmcpO1xuXG4vLyAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbi8vICAgY29uc3QgZWFzaW5nRnVuY3Rpb24gPSB0eXBlb2YgZWFzaW5nID09ICdmdW5jdGlvbicgPyBlYXNpbmcgOiBnZXRFYXNpbmdGdW5jdGlvbihlYXNpbmcgYXMgc3RyaW5nKTtcbi8vICAgY29uc3QgcGFyYW1zID0gdHlwZW9mIGVhc2luZyA9PSAnZnVuY3Rpb24nID8gW10gOiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbi8vICAgY29uc3QgZnJhbWUgPSAxIC8gNjtcblxuLy8gICBsZXQgZWxhcHNlZCA9IDA7XG4vLyAgIGxldCByZXN0ID0gMDtcbi8vICAgbGV0IGNvdW50ID0gMDtcblxuLy8gICB3aGlsZSAoKytjb3VudCA8IElOVElOSVRFX0xPT1BfTElNSVQpIHtcbi8vICAgICBlbGFwc2VkICs9IGZyYW1lO1xuLy8gICAgIGlmIChlYXNpbmdGdW5jdGlvbihlbGFwc2VkLCBwYXJhbXMsIHVuZGVmaW5lZCkgPT09IDEpIHtcbi8vICAgICAgIHJlc3QrKztcbi8vICAgICAgIGlmIChyZXN0ID49IDE2KSBicmVhaztcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgcmVzdCA9IDA7XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgY29uc3QgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuLy8gICBFYXNpbmdEdXJhdGlvbkNhY2hlLnNldChlYXNpbmcsIGR1cmF0aW9uKTtcbi8vICAgcmV0dXJuIGR1cmF0aW9uO1xuLy8gfTtcblxuLyoqXG4gIFRoZXNlIEVhc2luZyBGdW5jdGlvbnMgYXJlIGJhc2VkIG9mZiBvZiB0aGUgU296aSBQcm9qZWN0J3MgZWFzaW5nIGZ1bmN0aW9uc1xuICBodHRwczovL2dpdGh1Yi5jb20vc296aS1wcm9qZWN0cy9Tb3ppL2Jsb2IvZDcyZTQ0ZWJkNTgwZGM3NTc5ZDFlMTc3NDA2YWQ0MWU2MzJmOTYxZC9zcmMvanMvcGxheWVyL1RpbWluZy5qc1xuKi9cbnZhciBTdGVwcyA9IGZ1bmN0aW9uIFN0ZXBzKHQpIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHZhciBfcmVmID0gcGFyYW1zLFxuICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgX3JlZjIkID0gX3JlZjJbMF0sXG4gICAgc3RlcHMgPSBfcmVmMiQgPT09IHZvaWQgMCA/IDEwIDogX3JlZjIkLFxuICAgIHR5cGUgPSBfcmVmMlsxXTtcbiAgdmFyIHRydW5jID0gdHlwZSA9PT0gJ3N0YXJ0JyA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gIHJldHVybiB0cnVuYyhjbGFtcCh0LCAwLCAxKSAqIHN0ZXBzKSAvIHN0ZXBzO1xufTtcblxuLy8gQHRzLWlnbm9yZVxudmFyIEJlemllciA9IGZ1bmN0aW9uIEJlemllcih0KSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgX3BhcmFtczMgPSBfc2xpY2VkVG9BcnJheShwYXJhbXMsIDQpLFxuICAgIG1YMSA9IF9wYXJhbXMzWzBdLFxuICAgIG1ZMSA9IF9wYXJhbXMzWzFdLFxuICAgIG1YMiA9IF9wYXJhbXMzWzJdLFxuICAgIG1ZMiA9IF9wYXJhbXMzWzNdO1xuICByZXR1cm4gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikodCk7XG59O1xuXG4vKiogVGhlIGRlZmF1bHQgYGVhc2UtaW5gIGVhc2luZyBmdW5jdGlvbiAqL1xudmFyIGVhc2VpbiA9IGJlemllcigwLjQyLCAwLjAsIDEuMCwgMS4wKTtcblxuLyoqIENvbnZlcnRzIGVhc2luZyBmdW5jdGlvbnMgdG8gdGhlaXIgYG91dGBjb3VudGVyIHBhcnRzICovXG52YXIgRWFzZU91dCA9IGZ1bmN0aW9uIEVhc2VPdXQoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHQsIHBhcmFtcywgZHVyYXRpb24pO1xuICB9O1xufTtcblxuLyoqIENvbnZlcnRzIGVhc2luZyBmdW5jdGlvbnMgdG8gdGhlaXIgYGluLW91dGAgY291bnRlciBwYXJ0cyAqL1xudmFyIEVhc2VJbk91dCA9IGZ1bmN0aW9uIEVhc2VJbk91dChlYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0IDwgMC41ID8gZWFzZSh0ICogMiwgcGFyYW1zLCBkdXJhdGlvbikgLyAyIDogMSAtIGVhc2UodCAqIC0yICsgMiwgcGFyYW1zLCBkdXJhdGlvbikgLyAyO1xuICB9O1xufTtcblxuLyoqIENvbnZlcnRzIGVhc2luZyBmdW5jdGlvbnMgdG8gdGhlaXIgYG91dC1pbmAgY291bnRlciBwYXJ0cyAqL1xudmFyIEVhc2VPdXRJbiA9IGZ1bmN0aW9uIEVhc2VPdXRJbihlYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0IDwgMC41ID8gKDEgLSBlYXNlKDEgLSB0ICogMiwgcGFyYW1zLCBkdXJhdGlvbikpIC8gMiA6IChlYXNlKHQgKiAyIC0gMSwgcGFyYW1zLCBkdXJhdGlvbikgKyAxKSAvIDI7XG4gIH07XG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxpc3Qgb2YgZWFzaW5nIGZ1bmN0aW9ucywgZG8gbm90ZSB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHtAbGluayBFQVNJTkd9XG4gKi9cblxudmFyIEVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgc3RlcHM6IFN0ZXBzLFxuICAnc3RlcC1zdGFydCc6IGZ1bmN0aW9uIHN0ZXBTdGFydCh0KSB7XG4gICAgcmV0dXJuIFN0ZXBzKHQsIFsxLCAnc3RhcnQnXSk7XG4gIH0sXG4gICdzdGVwLWVuZCc6IGZ1bmN0aW9uIHN0ZXBFbmQodCkge1xuICAgIHJldHVybiBTdGVwcyh0LCBbMSwgJ2VuZCddKTtcbiAgfSxcbiAgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9LFxuICAnY3ViaWMtYmV6aWVyJzogQmV6aWVyLFxuICBlYXNlOiBmdW5jdGlvbiBlYXNlKHQpIHtcbiAgICByZXR1cm4gQmV6aWVyKHQsIFswLjI1LCAwLjEsIDAuMjUsIDEuMF0pO1xuICB9LFxuICBcImluXCI6IGVhc2VpbixcbiAgb3V0OiBFYXNlT3V0KGVhc2VpbiksXG4gICdpbi1vdXQnOiBFYXNlSW5PdXQoZWFzZWluKSxcbiAgJ291dC1pbic6IEVhc2VPdXRJbihlYXNlaW4pLFxuICAnaW4tcXVhZCc6IFF1YWQsXG4gICdvdXQtcXVhZCc6IEVhc2VPdXQoUXVhZCksXG4gICdpbi1vdXQtcXVhZCc6IEVhc2VJbk91dChRdWFkKSxcbiAgJ291dC1pbi1xdWFkJzogRWFzZU91dEluKFF1YWQpLFxuICAnaW4tY3ViaWMnOiBDdWJpYyxcbiAgJ291dC1jdWJpYyc6IEVhc2VPdXQoQ3ViaWMpLFxuICAnaW4tb3V0LWN1YmljJzogRWFzZUluT3V0KEN1YmljKSxcbiAgJ291dC1pbi1jdWJpYyc6IEVhc2VPdXRJbihDdWJpYyksXG4gICdpbi1xdWFydCc6IFF1YXJ0LFxuICAnb3V0LXF1YXJ0JzogRWFzZU91dChRdWFydCksXG4gICdpbi1vdXQtcXVhcnQnOiBFYXNlSW5PdXQoUXVhcnQpLFxuICAnb3V0LWluLXF1YXJ0JzogRWFzZU91dEluKFF1YXJ0KSxcbiAgJ2luLXF1aW50JzogUXVpbnQsXG4gICdvdXQtcXVpbnQnOiBFYXNlT3V0KFF1aW50KSxcbiAgJ2luLW91dC1xdWludCc6IEVhc2VJbk91dChRdWludCksXG4gICdvdXQtaW4tcXVpbnQnOiBFYXNlT3V0SW4oUXVpbnQpLFxuICAnaW4tZXhwbyc6IEV4cG8sXG4gICdvdXQtZXhwbyc6IEVhc2VPdXQoRXhwbyksXG4gICdpbi1vdXQtZXhwbyc6IEVhc2VJbk91dChFeHBvKSxcbiAgJ291dC1pbi1leHBvJzogRWFzZU91dEluKEV4cG8pLFxuICAnaW4tc2luZSc6IFNpbmUsXG4gICdvdXQtc2luZSc6IEVhc2VPdXQoU2luZSksXG4gICdpbi1vdXQtc2luZSc6IEVhc2VJbk91dChTaW5lKSxcbiAgJ291dC1pbi1zaW5lJzogRWFzZU91dEluKFNpbmUpLFxuICAnaW4tY2lyYyc6IENpcmMsXG4gICdvdXQtY2lyYyc6IEVhc2VPdXQoQ2lyYyksXG4gICdpbi1vdXQtY2lyYyc6IEVhc2VJbk91dChDaXJjKSxcbiAgJ291dC1pbi1jaXJjJzogRWFzZU91dEluKENpcmMpLFxuICAnaW4tYmFjayc6IEJhY2ssXG4gICdvdXQtYmFjayc6IEVhc2VPdXQoQmFjayksXG4gICdpbi1vdXQtYmFjayc6IEVhc2VJbk91dChCYWNrKSxcbiAgJ291dC1pbi1iYWNrJzogRWFzZU91dEluKEJhY2spLFxuICAnaW4tYm91bmNlJzogQm91bmNlLFxuICAnb3V0LWJvdW5jZSc6IEVhc2VPdXQoQm91bmNlKSxcbiAgJ2luLW91dC1ib3VuY2UnOiBFYXNlSW5PdXQoQm91bmNlKSxcbiAgJ291dC1pbi1ib3VuY2UnOiBFYXNlT3V0SW4oQm91bmNlKSxcbiAgJ2luLWVsYXN0aWMnOiBFbGFzdGljLFxuICAnb3V0LWVsYXN0aWMnOiBFYXNlT3V0KEVsYXN0aWMpLFxuICAnaW4tb3V0LWVsYXN0aWMnOiBFYXNlSW5PdXQoRWxhc3RpYyksXG4gICdvdXQtaW4tZWxhc3RpYyc6IEVhc2VPdXRJbihFbGFzdGljKSxcbiAgc3ByaW5nOiBTcHJpbmcsXG4gICdzcHJpbmctaW4nOiBTcHJpbmcsXG4gICdzcHJpbmctb3V0JzogRWFzZU91dChTcHJpbmcpLFxuICAnc3ByaW5nLWluLW91dCc6IEVhc2VJbk91dChTcHJpbmcpLFxuICAnc3ByaW5nLW91dC1pbic6IEVhc2VPdXRJbihTcHJpbmcpXG59O1xuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIGVhc2luZyB0byB0aGVpciBwcm9wZXIgZm9ybVxuICovXG52YXIgY29tcGxleEVhc2luZ1N5bnRheCA9IGZ1bmN0aW9uIGNvbXBsZXhFYXNpbmdTeW50YXgoZWFzZSkge1xuICByZXR1cm4gY29udmVydFRvRGFzaChlYXNlKS5yZXBsYWNlKC9eZWFzZS0vLCAnJykgLy8gUmVtb3ZlIHRoZSBcImVhc2UtXCIga2V5d29yZFxuICAucmVwbGFjZSgvKFxcKHxcXHMpLisvLCAnJykgLy8gUmVtb3ZlIHRoZSBmdW5jdGlvbiBicmFja2V0cyBhbmQgcGFyYW1ldGVyc1xuICAudG9Mb3dlckNhc2UoKS50cmltKCk7XG59O1xuXG4vKiogUmUtbWFwcyBhIG51bWJlciBmcm9tIG9uZSByYW5nZSB0byBhbm90aGVyLiBOdW1iZXJzIG91dHNpZGUgdGhlIHJhbmdlIGFyZSBub3QgY2xhbXBlZCB0byAwIGFuZCAxLCBiZWNhdXNlIG91dC1vZi1yYW5nZSB2YWx1ZXMgYXJlIG9mdGVuIGludGVudGlvbmFsIGFuZCB1c2VmdWwuICovXG52YXIgZ2V0RWFzaW5nRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRFYXNpbmdGdW5jdGlvbihlYXNlKSB7XG4gIHJldHVybiBFYXNpbmdGdW5jdGlvbnNbY29tcGxleEVhc2luZ1N5bnRheChlYXNlKV0gfHwgRWFzaW5nRnVuY3Rpb25zLmxpbmVhcjtcbn07XG5cbi8vIC8qKlxuLy8gICogQWxsb3dzIHlvdSB0byByZWdpc3RlciBuZXcgZWFzaW5nIGZ1bmN0aW9uc1xuLy8gICovXG4vLyBleHBvcnQgY29uc3QgcmVnaXN0ZXJFYXNpbmdGdW5jdGlvbiA9IChrZXk6IHN0cmluZywgZm46IFR5cGVFYXNpbmdGdW5jdGlvbikgPT4ge1xuLy8gICBPYmplY3QuYXNzaWduKEVhc2luZ0Z1bmN0aW9ucywge1xuLy8gICAgIFtrZXldOiBmbixcbi8vICAgfSk7XG4vLyB9O1xuXG4vLyAvKipcbi8vICAqIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgbmV3IGVhc2luZyBmdW5jdGlvbnNcbi8vICAqL1xuLy8gZXhwb3J0IGNvbnN0IHJlZ2lzdGVyRWFzaW5nRnVuY3Rpb25zID0gKC4uLm9iajogdHlwZW9mIEVhc2luZ0Z1bmN0aW9uc1tdKSA9PiB7XG4vLyAgIE9iamVjdC5hc3NpZ24oRWFzaW5nRnVuY3Rpb25zLCAuLi5vYmopO1xuLy8gfTtcblxudmFyIGxpbmVhciA9IGZ1bmN0aW9uIGxpbmVhcih4KSB7XG4gIHJldHVybiB4O1xufTtcbnZhciBTdGFydCA9IDE7XG52YXIgTWlkZGxlID0gMC41O1xudmFyIEVuZCA9IDA7XG5mdW5jdGlvbiBzdGVwKGNvdW50LCBwb3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHggPj0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBzdGVwU2l6ZSA9IDEgLyBjb3VudDtcbiAgICB4ICs9IHBvcyAqIHN0ZXBTaXplO1xuICAgIHJldHVybiB4IC0geCAlIHN0ZXBTaXplO1xuICB9O1xufVxudmFyIG51bWJlclN0cmluZyA9ICdcXFxccyooLT9cXFxcZCtcXFxcLj9cXFxcZCp8LT9cXFxcLlxcXFxkKylcXFxccyonO1xudmFyIGN1YmljQmV6aWVyUmUgPSBuZXcgUmVnRXhwKFwiY3ViaWMtYmV6aWVyXFxcXChcIi5jb25jYXQobnVtYmVyU3RyaW5nLCBcIixcIikuY29uY2F0KG51bWJlclN0cmluZywgXCIsXCIpLmNvbmNhdChudW1iZXJTdHJpbmcsIFwiLFwiKS5jb25jYXQobnVtYmVyU3RyaW5nLCBcIlxcXFwpXCIpKTtcbnZhciBzdGVwMVJlID0gL3N0ZXBzXFwoXFxzKihcXGQrKVxccypcXCkvO1xudmFyIHN0ZXAyUmUgPSAvc3RlcHNcXChcXHMqKFxcZCspXFxzKixcXHMqKHN0YXJ0fG1pZGRsZXxlbmQpXFxzKlxcKS87XG5mdW5jdGlvbiBwYXJzZUVhc2luZ0Z1bmN0aW9uKG5vcm1hbGl6ZWRFYXNpbmcpIHtcbiAgdmFyIGN1YmljRGF0YSA9IGN1YmljQmV6aWVyUmUuZXhlYyhub3JtYWxpemVkRWFzaW5nKTtcbiAgaWYgKGN1YmljRGF0YSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gYmV6aWVyLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGN1YmljRGF0YS5zbGljZSgxKS5tYXAoTnVtYmVyKSkpO1xuICB9XG4gIHZhciBzdGVwMURhdGEgPSBzdGVwMVJlLmV4ZWMobm9ybWFsaXplZEVhc2luZyk7XG4gIGlmIChzdGVwMURhdGEpIHtcbiAgICByZXR1cm4gc3RlcChOdW1iZXIoc3RlcDFEYXRhWzFdKSwgRW5kKTtcbiAgfVxuICB2YXIgc3RlcDJEYXRhID0gc3RlcDJSZS5leGVjKG5vcm1hbGl6ZWRFYXNpbmcpO1xuICBpZiAoc3RlcDJEYXRhKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBzdGVwKE51bWJlcihzdGVwMkRhdGFbMV0pLCB7XG4gICAgICBzdGFydDogU3RhcnQsXG4gICAgICBtaWRkbGU6IE1pZGRsZSxcbiAgICAgIGVuZDogRW5kXG4gICAgfVtzdGVwMkRhdGFbMl1dKTtcbiAgfVxuICByZXR1cm4gZ2V0RWFzaW5nRnVuY3Rpb24obm9ybWFsaXplZEVhc2luZyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVBY3RpdmVEdXJhdGlvbih0aW1pbmcpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gTWF0aC5hYnMocmVwZWF0ZWREdXJhdGlvbih0aW1pbmcpIC8gKHRpbWluZy5wbGF5YmFja1JhdGUgfHwgMSkpO1xufVxuZnVuY3Rpb24gcmVwZWF0ZWREdXJhdGlvbih0aW1pbmcpIHtcbiAgdmFyIF90aW1pbmckaXRlcmF0aW9ucztcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3dlYi1hbmltYXRpb25zLyNjYWxjdWxhdGluZy10aGUtYWN0aXZlLWR1cmF0aW9uXG4gIGlmICh0aW1pbmcuZHVyYXRpb24gPT09IDAgfHwgdGltaW5nLml0ZXJhdGlvbnMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VmZmVjdFRpbWluZy9kdXJhdGlvbiN2YWx1ZVxuICAvLyBpZiAodGltaW5nLmR1cmF0aW9uID09PSAnYXV0bycpIHtcbiAgLy8gICB0aW1pbmcuZHVyYXRpb24gPSAwO1xuICAvLyB9XG5cbiAgcmV0dXJuICh0aW1pbmcuZHVyYXRpb24gPT09ICdhdXRvJyA/IDAgOiBOdW1iZXIodGltaW5nLmR1cmF0aW9uKSkgKiAoKF90aW1pbmckaXRlcmF0aW9ucyA9IHRpbWluZy5pdGVyYXRpb25zKSAhPT0gbnVsbCAmJiBfdGltaW5nJGl0ZXJhdGlvbnMgIT09IHZvaWQgMCA/IF90aW1pbmckaXRlcmF0aW9ucyA6IDEpO1xufVxudmFyIFBoYXNlTm9uZSA9IDA7XG52YXIgUGhhc2VCZWZvcmUgPSAxO1xudmFyIFBoYXNlQWZ0ZXIgPSAyO1xudmFyIFBoYXNlQWN0aXZlID0gMztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBoYXNlKGFjdGl2ZUR1cmF0aW9uLCBsb2NhbFRpbWUsIHRpbWluZykge1xuICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvd2ViLWFuaW1hdGlvbnMvI2FuaW1hdGlvbi1lZmZlY3QtcGhhc2VzLWFuZC1zdGF0ZXNcbiAgaWYgKGxvY2FsVGltZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBQaGFzZU5vbmU7XG4gIH1cbiAgdmFyIGVuZFRpbWUgPSB0aW1pbmcuZW5kVGltZTtcbiAgaWYgKGxvY2FsVGltZSA8IE1hdGgubWluKHRpbWluZy5kZWxheSwgZW5kVGltZSkpIHtcbiAgICByZXR1cm4gUGhhc2VCZWZvcmU7XG4gIH1cbiAgaWYgKGxvY2FsVGltZSA+PSBNYXRoLm1pbih0aW1pbmcuZGVsYXkgKyBhY3RpdmVEdXJhdGlvbiArIHRpbWluZy5lbmREZWxheSwgZW5kVGltZSkpIHtcbiAgICByZXR1cm4gUGhhc2VBZnRlcjtcbiAgfVxuICByZXR1cm4gUGhhc2VBY3RpdmU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVBY3RpdmVUaW1lKGFjdGl2ZUR1cmF0aW9uLCBmaWxsTW9kZSwgbG9jYWxUaW1lLCBwaGFzZSwgZGVsYXkpIHtcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3dlYi1hbmltYXRpb25zLyNjYWxjdWxhdGluZy10aGUtYWN0aXZlLXRpbWVcbiAgc3dpdGNoIChwaGFzZSkge1xuICAgIGNhc2UgUGhhc2VCZWZvcmU6XG4gICAgICBpZiAoZmlsbE1vZGUgPT09ICdiYWNrd2FyZHMnIHx8IGZpbGxNb2RlID09PSAnYm90aCcpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBQaGFzZUFjdGl2ZTpcbiAgICAgIHJldHVybiBsb2NhbFRpbWUgLSBkZWxheTtcbiAgICBjYXNlIFBoYXNlQWZ0ZXI6XG4gICAgICBpZiAoZmlsbE1vZGUgPT09ICdmb3J3YXJkcycgfHwgZmlsbE1vZGUgPT09ICdib3RoJykgcmV0dXJuIGFjdGl2ZUR1cmF0aW9uO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBQaGFzZU5vbmU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlT3ZlcmFsbFByb2dyZXNzKGl0ZXJhdGlvbkR1cmF0aW9uLCBwaGFzZSwgaXRlcmF0aW9ucywgYWN0aXZlVGltZSwgaXRlcmF0aW9uU3RhcnQpIHtcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3dlYi1hbmltYXRpb25zLyNjYWxjdWxhdGluZy10aGUtb3ZlcmFsbC1wcm9ncmVzc1xuICB2YXIgb3ZlcmFsbFByb2dyZXNzID0gaXRlcmF0aW9uU3RhcnQ7XG4gIGlmIChpdGVyYXRpb25EdXJhdGlvbiA9PT0gMCkge1xuICAgIGlmIChwaGFzZSAhPT0gUGhhc2VCZWZvcmUpIHtcbiAgICAgIG92ZXJhbGxQcm9ncmVzcyArPSBpdGVyYXRpb25zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdmVyYWxsUHJvZ3Jlc3MgKz0gYWN0aXZlVGltZSAvIGl0ZXJhdGlvbkR1cmF0aW9uO1xuICB9XG4gIHJldHVybiBvdmVyYWxsUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTaW1wbGVJdGVyYXRpb25Qcm9ncmVzcyhvdmVyYWxsUHJvZ3Jlc3MsIGl0ZXJhdGlvblN0YXJ0LCBwaGFzZSwgaXRlcmF0aW9ucywgYWN0aXZlVGltZSwgaXRlcmF0aW9uRHVyYXRpb24pIHtcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3dlYi1hbmltYXRpb25zLyNjYWxjdWxhdGluZy10aGUtc2ltcGxlLWl0ZXJhdGlvbi1wcm9ncmVzc1xuXG4gIHZhciBzaW1wbGVJdGVyYXRpb25Qcm9ncmVzcyA9IG92ZXJhbGxQcm9ncmVzcyA9PT0gSW5maW5pdHkgPyBpdGVyYXRpb25TdGFydCAlIDEgOiBvdmVyYWxsUHJvZ3Jlc3MgJSAxO1xuICBpZiAoc2ltcGxlSXRlcmF0aW9uUHJvZ3Jlc3MgPT09IDAgJiYgcGhhc2UgPT09IFBoYXNlQWZ0ZXIgJiYgaXRlcmF0aW9ucyAhPT0gMCAmJiAoYWN0aXZlVGltZSAhPT0gMCB8fCBpdGVyYXRpb25EdXJhdGlvbiA9PT0gMCkpIHtcbiAgICBzaW1wbGVJdGVyYXRpb25Qcm9ncmVzcyA9IDE7XG4gIH1cbiAgcmV0dXJuIHNpbXBsZUl0ZXJhdGlvblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ3VycmVudEl0ZXJhdGlvbihwaGFzZSwgaXRlcmF0aW9ucywgc2ltcGxlSXRlcmF0aW9uUHJvZ3Jlc3MsIG92ZXJhbGxQcm9ncmVzcykge1xuICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvd2ViLWFuaW1hdGlvbnMvI2NhbGN1bGF0aW5nLXRoZS1jdXJyZW50LWl0ZXJhdGlvblxuICBpZiAocGhhc2UgPT09IFBoYXNlQWZ0ZXIgJiYgaXRlcmF0aW9ucyA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgaWYgKHNpbXBsZUl0ZXJhdGlvblByb2dyZXNzID09PSAxKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Iob3ZlcmFsbFByb2dyZXNzKSAtIDE7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3Iob3ZlcmFsbFByb2dyZXNzKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURpcmVjdGVkUHJvZ3Jlc3MocGxheWJhY2tEaXJlY3Rpb24sIGN1cnJlbnRJdGVyYXRpb24sIHNpbXBsZUl0ZXJhdGlvblByb2dyZXNzKSB7XG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy93ZWItYW5pbWF0aW9ucy8jY2FsY3VsYXRpbmctdGhlLWRpcmVjdGVkLXByb2dyZXNzXG4gIHZhciBjdXJyZW50RGlyZWN0aW9uID0gcGxheWJhY2tEaXJlY3Rpb247XG4gIGlmIChwbGF5YmFja0RpcmVjdGlvbiAhPT0gJ25vcm1hbCcgJiYgcGxheWJhY2tEaXJlY3Rpb24gIT09ICdyZXZlcnNlJykge1xuICAgIHZhciBkID0gY3VycmVudEl0ZXJhdGlvbjtcbiAgICBpZiAocGxheWJhY2tEaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUtcmV2ZXJzZScpIHtcbiAgICAgIGQgKz0gMTtcbiAgICB9XG4gICAgY3VycmVudERpcmVjdGlvbiA9ICdub3JtYWwnO1xuICAgIGlmIChkICE9PSBJbmZpbml0eSAmJiBkICUgMiAhPT0gMCkge1xuICAgICAgY3VycmVudERpcmVjdGlvbiA9ICdyZXZlcnNlJztcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnREaXJlY3Rpb24gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpbXBsZUl0ZXJhdGlvblByb2dyZXNzO1xuICB9XG4gIHJldHVybiAxIC0gc2ltcGxlSXRlcmF0aW9uUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVyYXRpb25Qcm9ncmVzcyhhY3RpdmVEdXJhdGlvbiwgbG9jYWxUaW1lLCB0aW1pbmcpIHtcbiAgdmFyIHBoYXNlID0gY2FsY3VsYXRlUGhhc2UoYWN0aXZlRHVyYXRpb24sIGxvY2FsVGltZSwgdGltaW5nKTtcbiAgdmFyIGFjdGl2ZVRpbWUgPSBjYWxjdWxhdGVBY3RpdmVUaW1lKGFjdGl2ZUR1cmF0aW9uLCB0aW1pbmcuZmlsbCwgbG9jYWxUaW1lLCBwaGFzZSwgdGltaW5nLmRlbGF5KTtcbiAgaWYgKGFjdGl2ZVRpbWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgZHVyYXRpb24gPSB0aW1pbmcuZHVyYXRpb24gPT09ICdhdXRvJyA/IDAgOiB0aW1pbmcuZHVyYXRpb247XG4gIHZhciBvdmVyYWxsUHJvZ3Jlc3MgPSBjYWxjdWxhdGVPdmVyYWxsUHJvZ3Jlc3MoZHVyYXRpb24sIHBoYXNlLCB0aW1pbmcuaXRlcmF0aW9ucywgYWN0aXZlVGltZSwgdGltaW5nLml0ZXJhdGlvblN0YXJ0KTtcbiAgdmFyIHNpbXBsZUl0ZXJhdGlvblByb2dyZXNzID0gY2FsY3VsYXRlU2ltcGxlSXRlcmF0aW9uUHJvZ3Jlc3Mob3ZlcmFsbFByb2dyZXNzLCB0aW1pbmcuaXRlcmF0aW9uU3RhcnQsIHBoYXNlLCB0aW1pbmcuaXRlcmF0aW9ucywgYWN0aXZlVGltZSwgZHVyYXRpb24pO1xuICB2YXIgY3VycmVudEl0ZXJhdGlvbiA9IGNhbGN1bGF0ZUN1cnJlbnRJdGVyYXRpb24ocGhhc2UsIHRpbWluZy5pdGVyYXRpb25zLCBzaW1wbGVJdGVyYXRpb25Qcm9ncmVzcywgb3ZlcmFsbFByb2dyZXNzKTtcbiAgdmFyIGRpcmVjdGVkUHJvZ3Jlc3MgPSBjYWxjdWxhdGVEaXJlY3RlZFByb2dyZXNzKHRpbWluZy5kaXJlY3Rpb24sIGN1cnJlbnRJdGVyYXRpb24sIHNpbXBsZUl0ZXJhdGlvblByb2dyZXNzKTtcbiAgdGltaW5nLmN1cnJlbnRJdGVyYXRpb24gPSBjdXJyZW50SXRlcmF0aW9uO1xuICB0aW1pbmcucHJvZ3Jlc3MgPSBkaXJlY3RlZFByb2dyZXNzO1xuXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy93ZWItYW5pbWF0aW9ucy8jY2FsY3VsYXRpbmctdGhlLXRyYW5zZm9ybWVkLXByb2dyZXNzXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy93ZWItYW5pbWF0aW9ucy8jY2FsY3VsYXRpbmctdGhlLWl0ZXJhdGlvbi1wcm9ncmVzc1xuICByZXR1cm4gdGltaW5nLmVhc2luZ0Z1bmN0aW9uKGRpcmVjdGVkUHJvZ3Jlc3MpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RWZmZWN0SW5wdXQoa2V5ZnJhbWVzLCB0aW1pbmcsIHRhcmdldCkge1xuICB2YXIgcHJvcGVydHlTcGVjaWZpY0tleWZyYW1lR3JvdXBzID0gbWFrZVByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3VwcyhrZXlmcmFtZXMsIHRpbWluZyk7XG4gIHZhciBpbnRlcnBvbGF0aW9ucyA9IG1ha2VJbnRlcnBvbGF0aW9ucyhwcm9wZXJ0eVNwZWNpZmljS2V5ZnJhbWVHcm91cHMsIHRhcmdldCk7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBmcmFjdGlvbikge1xuICAgIGlmIChmcmFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgaW50ZXJwb2xhdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBmcmFjdGlvbiA+PSBpbnRlcnBvbGF0aW9uLmFwcGx5RnJvbSAmJiBmcmFjdGlvbiA8IGludGVycG9sYXRpb24uYXBwbHlUbztcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGludGVycG9sYXRpb24pIHtcbiAgICAgICAgdmFyIG9mZnNldEZyYWN0aW9uID0gZnJhY3Rpb24gLSBpbnRlcnBvbGF0aW9uLnN0YXJ0T2Zmc2V0O1xuICAgICAgICB2YXIgbG9jYWxEdXJhdGlvbiA9IGludGVycG9sYXRpb24uZW5kT2Zmc2V0IC0gaW50ZXJwb2xhdGlvbi5zdGFydE9mZnNldDtcbiAgICAgICAgdmFyIHNjYWxlZExvY2FsVGltZSA9IGxvY2FsRHVyYXRpb24gPT09IDAgPyAwIDogb2Zmc2V0RnJhY3Rpb24gLyBsb2NhbER1cmF0aW9uO1xuICAgICAgICAvLyBhcHBseSB1cGRhdGVkIGF0dHJpYnV0ZVxuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKGludGVycG9sYXRpb24ucHJvcGVydHksIGludGVycG9sYXRpb24uaW50ZXJwb2xhdGlvbihzY2FsZWRMb2NhbFRpbWUpLCBmYWxzZSwgZmFsc2UgLy8gZGlzYWJsZSBtZW1vaXplXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gaWYgKGludGVycG9sYXRpb24ucHJvcGVydHkgPT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKFxuICAgICAgICAvLyAgICAgc2NhbGVkTG9jYWxUaW1lLFxuICAgICAgICAvLyAgICAgaW50ZXJwb2xhdGlvbi5pbnRlcnBvbGF0aW9uKHNjYWxlZExvY2FsVGltZSksXG4gICAgICAgIC8vICAgKTtcbiAgICAgICAgLy8gfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3VwcykgaWYgKGlzTm90UmVzZXJ2ZWRXb3JkKHByb3BlcnR5KSkge1xuICAgICAgICAvLyBjbGVhciBhdHRyaWJ1dGVcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNOb3RSZXNlcnZlZFdvcmQobWVtYmVyKSB7XG4gIHJldHVybiBtZW1iZXIgIT09ICdvZmZzZXQnICYmIG1lbWJlciAhPT0gJ2Vhc2luZycgJiYgbWVtYmVyICE9PSAnY29tcG9zaXRlJyAmJiBtZW1iZXIgIT09ICdjb21wdXRlZE9mZnNldCc7XG59XG5mdW5jdGlvbiBtYWtlUHJvcGVydHlTcGVjaWZpY0tleWZyYW1lR3JvdXBzKGtleWZyYW1lcywgdGltaW5nKSB7XG4gIHZhciBwcm9wZXJ0eVNwZWNpZmljS2V5ZnJhbWVHcm91cHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBtZW1iZXIgaW4ga2V5ZnJhbWVzW2ldKSB7XG4gICAgICBpZiAoaXNOb3RSZXNlcnZlZFdvcmQobWVtYmVyKSkge1xuICAgICAgICB2YXIgcHJvcGVydHlTcGVjaWZpY0tleWZyYW1lID0ge1xuICAgICAgICAgIG9mZnNldDoga2V5ZnJhbWVzW2ldLm9mZnNldCxcbiAgICAgICAgICBjb21wdXRlZE9mZnNldDoga2V5ZnJhbWVzW2ldLmNvbXB1dGVkT2Zmc2V0LFxuICAgICAgICAgIGVhc2luZzoga2V5ZnJhbWVzW2ldLmVhc2luZyxcbiAgICAgICAgICBlYXNpbmdGdW5jdGlvbjogcGFyc2VFYXNpbmdGdW5jdGlvbihrZXlmcmFtZXNbaV0uZWFzaW5nKSB8fCB0aW1pbmcuZWFzaW5nRnVuY3Rpb24sXG4gICAgICAgICAgdmFsdWU6IGtleWZyYW1lc1tpXVttZW1iZXJdXG4gICAgICAgIH07XG4gICAgICAgIHByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3Vwc1ttZW1iZXJdID0gcHJvcGVydHlTcGVjaWZpY0tleWZyYW1lR3JvdXBzW21lbWJlcl0gfHwgW107XG4gICAgICAgIHByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3Vwc1ttZW1iZXJdLnB1c2gocHJvcGVydHlTcGVjaWZpY0tleWZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3Vwcztcbn1cbmZ1bmN0aW9uIG1ha2VJbnRlcnBvbGF0aW9ucyhwcm9wZXJ0eVNwZWNpZmljS2V5ZnJhbWVHcm91cHMsIHRhcmdldCkge1xuICB2YXIgaW50ZXJwb2xhdGlvbnMgPSBbXTtcbiAgZm9yICh2YXIgZ3JvdXBOYW1lIGluIHByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3Vwcykge1xuICAgIHZhciBrZXlmcmFtZXMgPSBwcm9wZXJ0eVNwZWNpZmljS2V5ZnJhbWVHcm91cHNbZ3JvdXBOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleWZyYW1lcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gaTtcbiAgICAgIHZhciBlbmRJbmRleCA9IGkgKyAxO1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0ga2V5ZnJhbWVzW3N0YXJ0SW5kZXhdLmNvbXB1dGVkT2Zmc2V0O1xuICAgICAgdmFyIGVuZE9mZnNldCA9IGtleWZyYW1lc1tlbmRJbmRleF0uY29tcHV0ZWRPZmZzZXQ7XG4gICAgICB2YXIgYXBwbHlGcm9tID0gc3RhcnRPZmZzZXQ7XG4gICAgICB2YXIgYXBwbHlUbyA9IGVuZE9mZnNldDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGFwcGx5RnJvbSA9IC1JbmZpbml0eTtcbiAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIGVuZEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IGtleWZyYW1lcy5sZW5ndGggLSAyKSB7XG4gICAgICAgIGFwcGx5VG8gPSBJbmZpbml0eTtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAxKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnRlcnBvbGF0aW9ucy5wdXNoKHtcbiAgICAgICAgYXBwbHlGcm9tOiBhcHBseUZyb20sXG4gICAgICAgIGFwcGx5VG86IGFwcGx5VG8sXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiBrZXlmcmFtZXNbc3RhcnRJbmRleF0uY29tcHV0ZWRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldDoga2V5ZnJhbWVzW2VuZEluZGV4XS5jb21wdXRlZE9mZnNldCxcbiAgICAgICAgZWFzaW5nRnVuY3Rpb246IGtleWZyYW1lc1tzdGFydEluZGV4XS5lYXNpbmdGdW5jdGlvbixcbiAgICAgICAgcHJvcGVydHk6IGdyb3VwTmFtZSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogcHJvcGVydHlJbnRlcnBvbGF0aW9uKGdyb3VwTmFtZSwga2V5ZnJhbWVzW3N0YXJ0SW5kZXhdLnZhbHVlLCBrZXlmcmFtZXNbZW5kSW5kZXhdLnZhbHVlLCB0YXJnZXQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaW50ZXJwb2xhdGlvbnMuc29ydChmdW5jdGlvbiAobGVmdEludGVycG9sYXRpb24sIHJpZ2h0SW50ZXJwb2xhdGlvbikge1xuICAgIHJldHVybiBsZWZ0SW50ZXJwb2xhdGlvbi5zdGFydE9mZnNldCAtIHJpZ2h0SW50ZXJwb2xhdGlvbi5zdGFydE9mZnNldDtcbiAgfSk7XG4gIHJldHVybiBpbnRlcnBvbGF0aW9ucztcbn1cbnZhciBJbnRlcnBvbGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uIEludGVycG9sYXRpb25GYWN0b3J5KGZyb20sIHRvLCBjb252ZXJ0VG9TdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGludGVycG9sYXRlZCA9IGludGVycG9sYXRlKGZyb20sIHRvLCBmKTtcbiAgICByZXR1cm4gaXNOdW1iZXIoaW50ZXJwb2xhdGVkKSA/IGludGVycG9sYXRlZCA6IGNvbnZlcnRUb1N0cmluZyhpbnRlcnBvbGF0ZWQpO1xuICB9O1xufTtcbmZ1bmN0aW9uIHByb3BlcnR5SW50ZXJwb2xhdGlvbihwcm9wZXJ0eSwgbGVmdCwgcmlnaHQsIHRhcmdldCkge1xuICB2YXIgbWV0YWRhdGEgPSBwcm9wZXJ0eU1ldGFkYXRhQ2FjaGVbcHJvcGVydHldO1xuICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuc3ludGF4ICYmIG1ldGFkYXRhW1wiaW50XCJdKSB7XG4gICAgdmFyIHByb3BlcnR5SGFuZGxlciA9IHJ1bnRpbWUuc3R5bGVWYWx1ZVJlZ2lzdHJ5LmdldFByb3BlcnR5U3ludGF4KG1ldGFkYXRhLnN5bnRheCk7XG4gICAgaWYgKHByb3BlcnR5SGFuZGxlcikge1xuICAgICAgdmFyIHBhcnNlciA9IHByb3BlcnR5SGFuZGxlci5wYXJzZXI7XG4gICAgICB2YXIgdXNlZExlZnQgPSBwYXJzZXIgPyBwYXJzZXIobGVmdCwgdGFyZ2V0KSA6IGxlZnQ7XG4gICAgICB2YXIgdXNlZFJpZ2h0ID0gcGFyc2VyID8gcGFyc2VyKHJpZ2h0LCB0YXJnZXQpIDogcmlnaHQ7XG5cbiAgICAgIC8vIG1lcmdlciBbbGVmdCwgcmlnaHQsIG4yc3RyaW5nKCldXG4gICAgICB2YXIgaW50ZXJwb2xhdGlvbkFyZ3MgPSBwcm9wZXJ0eUhhbmRsZXIubWl4ZXIodXNlZExlZnQsIHVzZWRSaWdodCwgdGFyZ2V0KTtcbiAgICAgIGlmIChpbnRlcnBvbGF0aW9uQXJncykge1xuICAgICAgICB2YXIgaW50ZXJwID0gSW50ZXJwb2xhdGlvbkZhY3RvcnkuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoaW50ZXJwb2xhdGlvbkFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHQgPT09IDApIHJldHVybiBsZWZ0O1xuICAgICAgICAgIGlmICh0ID09PSAxKSByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIGludGVycCh0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHJldHVybiBJbnRlcnBvbGF0aW9uRmFjdG9yeShmYWxzZSwgdHJ1ZSwgZnVuY3Rpb24gKGJvb2wpIHtcbiAgICByZXR1cm4gYm9vbCA/IHJpZ2h0IDogbGVmdDtcbiAgfSk7XG59XG5cbi8qKlxuICogaW50ZXJwb2xhdGUgd2l0aCBudW1iZXIsIGJvb2xlYW4sIG51bWJlcltdLCBib29sZWFuW11cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGYpIHtcbiAgaWYgKHR5cGVvZiBmcm9tID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdG8gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb20gKiAoMSAtIGYpICsgdG8gKiBmO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbSA9PT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiB0byA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIC8vIHNraXAgc3RyaW5nLCBlZy4gcGF0aCBbJ00nLCAxMCwgMTBdXG4gICkge1xuICAgIHJldHVybiBmIDwgMC41ID8gZnJvbSA6IHRvO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGZyb20pICYmIEFycmF5LmlzQXJyYXkodG8pKSB7XG4gICAgLy8gaW50ZXJwb2xhdGUgYXJyYXlzL21hdHJpeFxuICAgIHZhciBmcm9tTGVuZ3RoID0gZnJvbS5sZW5ndGg7XG4gICAgdmFyIHRvTGVuZ3RoID0gdG8ubGVuZ3RoO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChmcm9tTGVuZ3RoLCB0b0xlbmd0aCk7XG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByLnB1c2goaW50ZXJwb2xhdGUoZnJvbVtpIDwgZnJvbUxlbmd0aCA/IGkgOiBmcm9tTGVuZ3RoIC0gMV0sIHRvW2kgPCB0b0xlbmd0aCA/IGkgOiB0b0xlbmd0aCAtIDFdLCBmKSk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgaW50ZXJwb2xhdGlvbiBhcmd1bWVudHMgXCIuY29uY2F0KGZyb20sIFwiOlwiKS5jb25jYXQodG8pKTtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FZmZlY3RUaW1pbmdcbiAqL1xudmFyIEFuaW1hdGlvbkVmZmVjdFRpbWluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbkVmZmVjdFRpbWluZygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0aW9uRWZmZWN0VGltaW5nKTtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FZmZlY3RUaW1pbmcvZGVsYXlcbiAgICAgKi9cbiAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FZmZlY3RUaW1pbmcvZGlyZWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAnbm9ybWFsJztcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FZmZlY3RUaW1pbmcvZHVyYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gJ2F1dG8nO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VmZmVjdFRpbWluZy9lYXNpbmdcbiAgICAgKi9cbiAgICB0aGlzLl9lYXNpbmcgPSAnbGluZWFyJztcbiAgICB0aGlzLmVhc2luZ0Z1bmN0aW9uID0gbGluZWFyO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VmZmVjdFRpbWluZy9lbmREZWxheVxuICAgICAqL1xuICAgIHRoaXMuZW5kRGVsYXkgPSAwO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VmZmVjdFRpbWluZy9maWxsXG4gICAgICovXG4gICAgdGhpcy5maWxsID0gJ2F1dG8nO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VmZmVjdFRpbWluZy9pdGVyYXRpb25TdGFydFxuICAgICAqL1xuICAgIHRoaXMuaXRlcmF0aW9uU3RhcnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VmZmVjdFRpbWluZy9pdGVyYXRpb25zXG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gMTtcbiAgICB0aGlzLmN1cnJlbnRJdGVyYXRpb24gPSBudWxsO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQW5pbWF0aW9uRWZmZWN0VGltaW5nLCBbe1xuICAgIGtleTogXCJlYXNpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lYXNpbmc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5lYXNpbmdGdW5jdGlvbiA9IHBhcnNlRWFzaW5nRnVuY3Rpb24odmFsdWUpO1xuICAgICAgdGhpcy5fZWFzaW5nID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKlxuICogQGV4YW1wbGVcbiAge1xuICAgIHRyYW5zbGF0ZVk6IFsyMDAsIDMwMF0sXG4gICAgc2NhbGU6IFsxLCAxMF0sXG4gIH1cblxuICogZ3JvdXBzJyBsZW5ndGggY2FuIGJlIGRpZmZlcmVudCwgdGhlIGZvbGxvd2luZyBjb25maWcgc2hvdWxkIGdlbmVyYXRlIDMgZnJhbWVzOlxuICBAZXhhbXBsZVxuICB7XG4gICAgdHJhbnNsYXRlWTogWzIwMCwgMzAwLCA0MDBdLFxuICAgIHNjYWxlOiBbMSwgMTBdLFxuICB9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0FycmF5Rm9ybShlZmZlY3RJbnB1dCkge1xuICB2YXIgbm9ybWFsaXplZEVmZmVjdElucHV0ID0gW107XG4gIGZvciAodmFyIHByb3BlcnR5IGluIGVmZmVjdElucHV0KSB7XG4gICAgLy8gc2tpcCByZXNlcnZlZCBwcm9wc1xuICAgIGlmIChwcm9wZXJ0eSBpbiBbJ2Vhc2luZycsICdvZmZzZXQnLCAnY29tcG9zaXRlJ10pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgdmFsdWVzID0gZWZmZWN0SW5wdXRbcHJvcGVydHldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG4gICAgdmFyIG51bUtleWZyYW1lcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlmcmFtZXM7IGkrKykge1xuICAgICAgaWYgKCFub3JtYWxpemVkRWZmZWN0SW5wdXRbaV0pIHtcbiAgICAgICAgdmFyIGtleWZyYW1lID0ge307XG4gICAgICAgIGlmICgnb2Zmc2V0JyBpbiBlZmZlY3RJbnB1dCkge1xuICAgICAgICAgIGtleWZyYW1lLm9mZnNldCA9IE51bWJlcihlZmZlY3RJbnB1dC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZWFzaW5nJyBpbiBlZmZlY3RJbnB1dCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBrZXlmcmFtZS5lYXNpbmcgPSBlZmZlY3RJbnB1dC5lYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjb21wb3NpdGUnIGluIGVmZmVjdElucHV0KSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGtleWZyYW1lLmNvbXBvc2l0ZSA9IGVmZmVjdElucHV0LmNvbXBvc2l0ZTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVkRWZmZWN0SW5wdXRbaV0gPSBrZXlmcmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXNbaV0gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZEVmZmVjdElucHV0W2ldW3Byb3BlcnR5XSA9IHZhbHVlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbm9ybWFsaXplZEVmZmVjdElucHV0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuY29tcHV0ZWRPZmZzZXQgfHwgMCkgLSAoYi5jb21wdXRlZE9mZnNldCB8fCAwKTtcbiAgfSk7XG4gIHJldHVybiBub3JtYWxpemVkRWZmZWN0SW5wdXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVLZXlmcmFtZXMoZWZmZWN0SW5wdXQsIHRpbWluZykge1xuICBpZiAoZWZmZWN0SW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGVmZmVjdElucHV0KSkge1xuICAgIGVmZmVjdElucHV0ID0gY29udmVydFRvQXJyYXlGb3JtKGVmZmVjdElucHV0KTtcbiAgfVxuICB2YXIga2V5ZnJhbWVzID0gZWZmZWN0SW5wdXQubWFwKGZ1bmN0aW9uIChvcmlnaW5hbEtleWZyYW1lKSB7XG4gICAgdmFyIGtleWZyYW1lID0ge307XG4gICAgaWYgKHRpbWluZyAhPT0gbnVsbCAmJiB0aW1pbmcgIT09IHZvaWQgMCAmJiB0aW1pbmcuY29tcG9zaXRlKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgYmUgYXV0byBpZiB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBzcGVjaWZpZWQgb24gdGhlIGVmZmVjdCBpcyBiZWluZyB1c2VkLlxuICAgICAgLy8gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0FuaW1hdGlvbnNfQVBJL0tleWZyYW1lX0Zvcm1hdHNcbiAgICAgIGtleWZyYW1lLmNvbXBvc2l0ZSA9ICdhdXRvJztcbiAgICB9XG4gICAgZm9yICh2YXIgbWVtYmVyIGluIG9yaWdpbmFsS2V5ZnJhbWUpIHtcbiAgICAgIHZhciBtZW1iZXJWYWx1ZSA9IG9yaWdpbmFsS2V5ZnJhbWVbbWVtYmVyXTtcbiAgICAgIGlmIChtZW1iZXIgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgIGlmIChtZW1iZXJWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1lbWJlclZhbHVlID0gTnVtYmVyKG1lbWJlclZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKG1lbWJlclZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKCdLZXlmcmFtZSBvZmZzZXRzIG11c3QgYmUgbnVtYmVycy4nKTtcbiAgICAgICAgICBpZiAobWVtYmVyVmFsdWUgPCAwIHx8IG1lbWJlclZhbHVlID4gMSkgdGhyb3cgbmV3IEVycm9yKCdLZXlmcmFtZSBvZmZzZXRzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLicpO1xuICAgICAgICAgIGtleWZyYW1lLmNvbXB1dGVkT2Zmc2V0ID0gbWVtYmVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyID09PSAnY29tcG9zaXRlJykge1xuICAgICAgICAvLyBUT0RPOiBTdXBwb3J0IGFkZCAmIGFjY3VtdWxhdGUgaW4gS2V5ZnJhbWVFZmZlY3QuY29tcG9zaXRlXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWZyYW1lRWZmZWN0L2NvbXBvc2l0ZVxuICAgICAgICBpZiAoWydyZXBsYWNlJywgJ2FkZCcsICdhY2N1bXVsYXRlJywgJ2F1dG8nXS5pbmRleE9mKG1lbWJlclZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQobWVtYmVyVmFsdWUsIFwiIGNvbXBvc2l0aW5nIGlzIG5vdCBzdXBwb3J0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgO1xuXG4gICAgICAvLyBhc3NpZ24gdG8ga2V5ZnJhbWUsIG5vIG5lZWQgdG8gcGFyc2Ugc2hvcnRoYW5kIHZhbHVlXG4gICAgICBrZXlmcmFtZVttZW1iZXJdID0gbWVtYmVyVmFsdWU7XG4gICAgfVxuICAgIGlmIChrZXlmcmFtZS5vZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ZnJhbWUub2Zmc2V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGtleWZyYW1lLmVhc2luZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvdmVycmlkZSB3aXRoIHRpbWluZy5lYXNpbmdcbiAgICAgIGtleWZyYW1lLmVhc2luZyA9ICh0aW1pbmcgPT09IG51bGwgfHwgdGltaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1pbmcuZWFzaW5nKSB8fCAnbGluZWFyJztcbiAgICB9XG4gICAgaWYgKGtleWZyYW1lLmNvbXBvc2l0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlmcmFtZS5jb21wb3NpdGUgPSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBrZXlmcmFtZTtcbiAgfSk7XG4gIHZhciBldmVyeUZyYW1lSGFzT2Zmc2V0ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzT2Zmc2V0ID0gLUluZmluaXR5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvZmZzZXQgPSBrZXlmcmFtZXNbaV0ub2Zmc2V0O1xuICAgIGlmICghaXNOaWwob2Zmc2V0KSkge1xuICAgICAgaWYgKG9mZnNldCA8IHByZXZpb3VzT2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleWZyYW1lcyBhcmUgbm90IGxvb3NlbHkgc29ydGVkIGJ5IG9mZnNldC4gU29ydCBvciBzcGVjaWZ5IG9mZnNldHMuJyk7XG4gICAgICB9XG4gICAgICBwcmV2aW91c09mZnNldCA9IG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlcnlGcmFtZUhhc09mZnNldCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBrZXlmcmFtZXMgPSBrZXlmcmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChrZXlmcmFtZSkge1xuICAgIHJldHVybiBOdW1iZXIoa2V5ZnJhbWUub2Zmc2V0KSA+PSAwICYmIE51bWJlcihrZXlmcmFtZS5vZmZzZXQpIDw9IDE7XG4gIH0pO1xuICBmdW5jdGlvbiBzcGFjZUtleWZyYW1lcygpIHtcbiAgICB2YXIgX2tleWZyYW1lcyRvZmZzZXQ7XG4gICAgdmFyIF9rZXlmcmFtZXMgPSBrZXlmcmFtZXMsXG4gICAgICBsZW5ndGggPSBfa2V5ZnJhbWVzLmxlbmd0aDtcbiAgICBrZXlmcmFtZXNbbGVuZ3RoIC0gMV0uY29tcHV0ZWRPZmZzZXQgPSBOdW1iZXIoKF9rZXlmcmFtZXMkb2Zmc2V0ID0ga2V5ZnJhbWVzW2xlbmd0aCAtIDFdLm9mZnNldCkgIT09IG51bGwgJiYgX2tleWZyYW1lcyRvZmZzZXQgIT09IHZvaWQgMCA/IF9rZXlmcmFtZXMkb2Zmc2V0IDogMSk7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBfa2V5ZnJhbWVzJDAkb2Zmc2V0O1xuICAgICAga2V5ZnJhbWVzWzBdLmNvbXB1dGVkT2Zmc2V0ID0gTnVtYmVyKChfa2V5ZnJhbWVzJDAkb2Zmc2V0ID0ga2V5ZnJhbWVzWzBdLm9mZnNldCkgIT09IG51bGwgJiYgX2tleWZyYW1lcyQwJG9mZnNldCAhPT0gdm9pZCAwID8gX2tleWZyYW1lcyQwJG9mZnNldCA6IDApO1xuICAgIH1cbiAgICB2YXIgcHJldmlvdXNJbmRleCA9IDA7XG4gICAgdmFyIHByZXZpb3VzT2Zmc2V0ID0gTnVtYmVyKGtleWZyYW1lc1swXS5jb21wdXRlZE9mZnNldCk7XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9vZmZzZXQgPSBrZXlmcmFtZXNbX2ldLmNvbXB1dGVkT2Zmc2V0O1xuICAgICAgaWYgKCFpc05pbChfb2Zmc2V0KSAmJiAhaXNOaWwocHJldmlvdXNPZmZzZXQpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgX2kgLSBwcmV2aW91c0luZGV4OyBqKyspIGtleWZyYW1lc1twcmV2aW91c0luZGV4ICsgal0uY29tcHV0ZWRPZmZzZXQgPSBwcmV2aW91c09mZnNldCArIChOdW1iZXIoX29mZnNldCkgLSBwcmV2aW91c09mZnNldCkgKiBqIC8gKF9pIC0gcHJldmlvdXNJbmRleCk7XG4gICAgICAgIHByZXZpb3VzSW5kZXggPSBfaTtcbiAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBOdW1iZXIoX29mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghZXZlcnlGcmFtZUhhc09mZnNldCkgc3BhY2VLZXlmcmFtZXMoKTtcbiAgcmV0dXJuIGtleWZyYW1lcztcbn1cblxudmFyIGZpbGxzID0gJ2JhY2t3YXJkc3xmb3J3YXJkc3xib3RofG5vbmUnLnNwbGl0KCd8Jyk7XG52YXIgZGlyZWN0aW9ucyA9ICdyZXZlcnNlfGFsdGVybmF0ZXxhbHRlcm5hdGUtcmV2ZXJzZScuc3BsaXQoJ3wnKTtcbmZ1bmN0aW9uIG1ha2VUaW1pbmcodGltaW5nSW5wdXQsIGZvckdyb3VwKSB7XG4gIHZhciB0aW1pbmcgPSBuZXcgQW5pbWF0aW9uRWZmZWN0VGltaW5nKCk7XG4gIGlmIChmb3JHcm91cCkge1xuICAgIHRpbWluZy5maWxsID0gJ2JvdGgnO1xuICAgIHRpbWluZy5kdXJhdGlvbiA9ICdhdXRvJztcbiAgfVxuICBpZiAodHlwZW9mIHRpbWluZ0lucHV0ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odGltaW5nSW5wdXQpKSB7XG4gICAgdGltaW5nLmR1cmF0aW9uID0gdGltaW5nSW5wdXQ7XG4gIH0gZWxzZSBpZiAodGltaW5nSW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5rZXlzKHRpbWluZ0lucHV0KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgaWYgKHRpbWluZ0lucHV0W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkICYmIHRpbWluZ0lucHV0W3Byb3BlcnR5XSAhPT0gbnVsbCAmJiB0aW1pbmdJbnB1dFtwcm9wZXJ0eV0gIT09ICdhdXRvJykge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWluZ1twcm9wZXJ0eV0gPT09ICdudW1iZXInIHx8IHByb3BlcnR5ID09PSAnZHVyYXRpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aW1pbmdJbnB1dFtwcm9wZXJ0eV0gIT09ICdudW1iZXInIHx8IGlzTmFOKHRpbWluZ0lucHV0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnZmlsbCcgJiYgZmlsbHMuaW5kZXhPZih0aW1pbmdJbnB1dFtwcm9wZXJ0eV0pID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHkgPT09ICdkaXJlY3Rpb24nICYmIGRpcmVjdGlvbnMuaW5kZXhPZih0aW1pbmdJbnB1dFtwcm9wZXJ0eV0pID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRpbWluZ1twcm9wZXJ0eV0gPSB0aW1pbmdJbnB1dFtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWluZ0lucHV0KHRpbWluZ0lucHV0LCBmb3JHcm91cCkge1xuICB0aW1pbmdJbnB1dCA9IG51bWVyaWNUaW1pbmdUb09iamVjdCh0aW1pbmdJbnB1dCAhPT0gbnVsbCAmJiB0aW1pbmdJbnB1dCAhPT0gdm9pZCAwID8gdGltaW5nSW5wdXQgOiB7XG4gICAgZHVyYXRpb246ICdhdXRvJ1xuICB9KTtcbiAgcmV0dXJuIG1ha2VUaW1pbmcodGltaW5nSW5wdXQsIGZvckdyb3VwKTtcbn1cbmZ1bmN0aW9uIG51bWVyaWNUaW1pbmdUb09iamVjdCh0aW1pbmdJbnB1dCkge1xuICBpZiAodHlwZW9mIHRpbWluZ0lucHV0ID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpc05hTih0aW1pbmdJbnB1dCkpIHtcbiAgICAgIHRpbWluZ0lucHV0ID0ge1xuICAgICAgICBkdXJhdGlvbjogJ2F1dG8nXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1pbmdJbnB1dCA9IHtcbiAgICAgICAgZHVyYXRpb246IHRpbWluZ0lucHV0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nSW5wdXQ7XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5ZnJhbWVFZmZlY3RcbiAqIEBleGFtcGxlXG4gIGNvbnN0IGNpcmNsZURvd25LZXlmcmFtZXMgPSBuZXcgS2V5ZnJhbWVFZmZlY3QoXG4gICAgY2lyY2xlLCAvLyBlbGVtZW50IHRvIGFuaW1hdGVcbiAgICBbXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCknIH0sIC8vIGtleWZyYW1lXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMTAwKScgfSAvLyBrZXlmcmFtZVxuICAgIF0sXG4gICAgeyBkdXJhdGlvbjogMzAwMCwgZmlsbDogJ2ZvcndhcmRzJyB9IC8vIGtleWZyYW1lIG9wdGlvbnNcbiAgKTtcbiAqXG4gKi9cbnZhciBLZXlmcmFtZUVmZmVjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIHBzZXVkb0VsZW1lbnQ6IHN0cmluZyB8IG51bGw7XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVFZmZlY3QodGFyZ2V0LCBlZmZlY3RJbnB1dCwgdGltaW5nSW5wdXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlmcmFtZUVmZmVjdCk7XG4gICAgdGhpcy5jb21wb3NpdGUgPSAncmVwbGFjZSc7XG4gICAgdGhpcy5pdGVyYXRpb25Db21wb3NpdGUgPSAncmVwbGFjZSc7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50aW1pbmcgPSBub3JtYWxpemVUaW1pbmdJbnB1dCh0aW1pbmdJbnB1dCwgZmFsc2UpO1xuICAgIHRoaXMudGltaW5nLmVmZmVjdCA9IHRoaXM7XG4gICAgdGhpcy50aW1pbmcuYWN0aXZlRHVyYXRpb24gPSBjYWxjdWxhdGVBY3RpdmVEdXJhdGlvbih0aGlzLnRpbWluZyk7XG4gICAgdGhpcy50aW1pbmcuZW5kVGltZSA9IE1hdGgubWF4KDAsIHRoaXMudGltaW5nLmRlbGF5ICsgdGhpcy50aW1pbmcuYWN0aXZlRHVyYXRpb24gKyB0aGlzLnRpbWluZy5lbmREZWxheSk7XG4gICAgdGhpcy5ub3JtYWxpemVkS2V5ZnJhbWVzID0gbm9ybWFsaXplS2V5ZnJhbWVzKGVmZmVjdElucHV0LCB0aGlzLnRpbWluZyk7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9ucyA9IGNvbnZlcnRFZmZlY3RJbnB1dCh0aGlzLm5vcm1hbGl6ZWRLZXlmcmFtZXMsIHRoaXMudGltaW5nLCB0aGlzLnRhcmdldCk7XG5cbiAgICAvLyDkuI3mlK/mjIEgcHJveHkg5pe26ZmN57qn5oiQIHRoaXMudGltaW5nXG4gICAgdmFyIFByb3h5ID0gcnVudGltZS5nbG9iYWxUaGlzLlByb3h5O1xuICAgIHRoaXMuY29tcHV0ZWRUaW1pbmcgPSBQcm94eSA/IG5ldyBQcm94eSh0aGlzLnRpbWluZywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnZHVyYXRpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5kdXJhdGlvbiA9PT0gJ2F1dG8nID8gMCA6IHRhcmdldC5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5maWxsID09PSAnYXV0bycgPyAnbm9uZScgOiB0YXJnZXQuZmlsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCA9PT0gJ2xvY2FsVGltZScpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYW5pbWF0aW9uICYmIF90aGlzLmFuaW1hdGlvbi5jdXJyZW50VGltZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wID09PSAnY3VycmVudEl0ZXJhdGlvbicpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmFuaW1hdGlvbiB8fCBfdGhpcy5hbmltYXRpb24ucGxheVN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmN1cnJlbnRJdGVyYXRpb24gfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCA9PT0gJ3Byb2dyZXNzJykge1xuICAgICAgICAgIGlmICghX3RoaXMuYW5pbWF0aW9uIHx8IF90aGlzLmFuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXQucHJvZ3Jlc3MgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSA6IHRoaXMudGltaW5nO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoS2V5ZnJhbWVFZmZlY3QsIFt7XG4gICAga2V5OiBcImFwcGx5SW50ZXJwb2xhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlJbnRlcnBvbGF0aW9ucygpIHtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbnModGhpcy50YXJnZXQsIE51bWJlcih0aGlzLnRpbWVGcmFjdGlvbikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGxvY2FsVGltZSkge1xuICAgICAgaWYgKGxvY2FsVGltZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWVGcmFjdGlvbiA9IGNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzKHRoaXMudGltaW5nLmFjdGl2ZUR1cmF0aW9uLCBsb2NhbFRpbWUsIHRoaXMudGltaW5nKTtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVGcmFjdGlvbiAhPT0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0S2V5ZnJhbWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEtleWZyYW1lcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWRLZXlmcmFtZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEtleWZyYW1lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRLZXlmcmFtZXMoa2V5ZnJhbWVzKSB7XG4gICAgICB0aGlzLm5vcm1hbGl6ZWRLZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXMoa2V5ZnJhbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRWZmZWN0L2dldENvbXB1dGVkVGltaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29tcHV0ZWRUaW1pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tcHV0ZWRUaW1pbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wdXRlZFRpbWluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRWZmZWN0L2dldFRpbWluZ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRpbWluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaW1pbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkVmZmVjdC91cGRhdGVUaW1pbmdcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUaW1pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGltaW5nKHRpbWluZykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBPYmplY3Qua2V5cyh0aW1pbmcgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgX3RoaXMyLnRpbWluZ1tuYW1lXSA9IHRpbWluZ1tuYW1lXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG5mdW5jdGlvbiBjb21wYXJlQW5pbWF0aW9ucyhsZWZ0QW5pbWF0aW9uLCByaWdodEFuaW1hdGlvbikge1xuICByZXR1cm4gTnVtYmVyKGxlZnRBbmltYXRpb24uaWQpIC0gTnVtYmVyKHJpZ2h0QW5pbWF0aW9uLmlkKTtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2Jsb2IvbWFzdGVyL3R5cGVzL3dlYi1hbmltYXRpb25zLWpzL2luZGV4LmQudHNcbiAqL1xudmFyIEFuaW1hdGlvblRpbWVsaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uVGltZWxpbmUoZG9jdW1lbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmltYXRpb25UaW1lbGluZSk7XG4gICAgLyoqXG4gICAgICogYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy50aW1lbGluZVRpY2tpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmhhc1Jlc3RhcnRlZFRoaXNGcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uc1dpdGhQcm9taXNlcyA9IFtdO1xuICAgIHRoaXMuaW5UaWNrID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nRWZmZWN0cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSBudWxsO1xuICAgIHRoaXMucmFmSWQgPSAwO1xuICAgIHRoaXMucmFmQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy53ZWJBbmltYXRpb25zTmV4dFRpY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgX3RoaXMuY3VycmVudFRpbWUgPSB0O1xuICAgICAgX3RoaXMuZGlzY2FyZEFuaW1hdGlvbnMoKTtcbiAgICAgIGlmIChfdGhpcy5hbmltYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBfdGhpcy50aW1lbGluZVRpY2tpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy53ZWJBbmltYXRpb25zTmV4dFRpY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wcm9jZXNzUmFmQ2FsbGJhY2tzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBwcm9jZXNzaW5nID0gX3RoaXMucmFmQ2FsbGJhY2tzO1xuICAgICAgX3RoaXMucmFmQ2FsbGJhY2tzID0gW107XG4gICAgICBpZiAodCA8IE51bWJlcihfdGhpcy5jdXJyZW50VGltZSkpIHQgPSBOdW1iZXIoX3RoaXMuY3VycmVudFRpbWUpO1xuICAgICAgX3RoaXMuYW5pbWF0aW9ucy5zb3J0KGNvbXBhcmVBbmltYXRpb25zKTtcbiAgICAgIF90aGlzLmFuaW1hdGlvbnMgPSBfdGhpcy50aWNrKHQsIHRydWUsIF90aGlzLmFuaW1hdGlvbnMpWzBdO1xuICAgICAgcHJvY2Vzc2luZy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBlbnRyeVsxXSh0KTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuYXBwbHlQZW5kaW5nRWZmZWN0cygpO1xuICAgIH07XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQW5pbWF0aW9uVGltZWxpbmUsIFt7XG4gICAga2V5OiBcImdldEFuaW1hdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QW5pbWF0aW9ucygpIHtcbiAgICAgIHRoaXMuZGlzY2FyZEFuaW1hdGlvbnMoKTtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuc2xpY2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUaWNraW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGlja2luZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmluVGljaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHRhcmdldCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZWZmZWN0ID0gbmV3IEtleWZyYW1lRWZmZWN0KHRhcmdldCwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGVmZmVjdCwgdGhpcyk7XG4gICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgdGhpcy5yZXN0YXJ0V2ViQW5pbWF0aW9uc05leHRUaWNrKCk7XG4gICAgICBhbmltYXRpb24udXBkYXRlUHJvbWlzZXMoKTtcbiAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgICBhbmltYXRpb24udXBkYXRlUHJvbWlzZXMoKTtcbiAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxuXG4gICAgLy8gUkFGIGlzIHN1cHBvc2VkIHRvIGJlIHRoZSBsYXN0IHNjcmlwdCB0byBvY2N1ciBiZWZvcmUgZnJhbWUgcmVuZGVyaW5nIGJ1dCBub3RcbiAgICAvLyBhbGwgYnJvd3NlcnMgYmVoYXZlIGxpa2UgdGhpcy4gVGhpcyBmdW5jdGlvbiBpcyBmb3Igc3luY2hvbm91c2x5IHVwZGF0aW5nIGFuXG4gICAgLy8gYW5pbWF0aW9uJ3MgZWZmZWN0cyB3aGVuZXZlciBpdHMgc3RhdGUgaXMgbXV0YXRlZCBieSBzY3JpcHQgdG8gd29yayBhcm91bmRcbiAgICAvLyBpbmNvcnJlY3Qgc2NyaXB0IGV4ZWN1dGlvbiBvcmRlcmluZyBieSB0aGUgYnJvd3Nlci5cbiAgfSwge1xuICAgIGtleTogXCJhcHBseURpcnRpZWRBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pblRpY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIGFjdGl2ZSBhbmltYXRpb25zIGluIGRpc3BsYXlvYmplY3RcbiAgICAgIGFuaW1hdGlvbi5tYXJrVGFyZ2V0KCk7XG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IGFuaW1hdGlvbi50YXJnZXRBbmltYXRpb25zKCk7XG4gICAgICBhbmltYXRpb25zLnNvcnQoY29tcGFyZUFuaW1hdGlvbnMpO1xuXG4gICAgICAvLyBjbGVhciBpbmFjdGl2ZSBhbmltYXRpb25zXG4gICAgICB2YXIgaW5hY3RpdmVBbmltYXRpb25zID0gdGhpcy50aWNrKE51bWJlcih0aGlzLmN1cnJlbnRUaW1lKSwgZmFsc2UsIGFuaW1hdGlvbnMuc2xpY2UoKSlbMV07XG4gICAgICBpbmFjdGl2ZUFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IF90aGlzMi5hbmltYXRpb25zLmluZGV4T2YoYW5pbWF0aW9uKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIF90aGlzMi5hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBseVBlbmRpbmdFZmZlY3RzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICAgIGlmICghdGhpcy50aWNraW5nKSB7XG4gICAgICAgIHRoaXMudGlja2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgdGhpcy5oYXNSZXN0YXJ0ZWRUaGlzRnJhbWUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFzUmVzdGFydGVkVGhpc0ZyYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVJZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5UGVuZGluZ0VmZmVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlQZW5kaW5nRWZmZWN0cygpIHtcbiAgICAgIHRoaXMucGVuZGluZ0VmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgIGVmZmVjdCA9PT0gbnVsbCB8fCBlZmZlY3QgPT09IHZvaWQgMCB8fCBlZmZlY3QuYXBwbHlJbnRlcnBvbGF0aW9ucygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBlbmRpbmdFZmZlY3RzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUFuaW1hdGlvbnNQcm9taXNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBbmltYXRpb25zUHJvbWlzZXMoKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNXaXRoUHJvbWlzZXMgPSB0aGlzLmFuaW1hdGlvbnNXaXRoUHJvbWlzZXMuZmlsdGVyKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi51cGRhdGVQcm9taXNlcygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2NhcmRBbmltYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2NhcmRBbmltYXRpb25zKCkge1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25zUHJvbWlzZXMoKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ2ZpbmlzaGVkJyAmJiBhbmltYXRpb24ucGxheVN0YXRlICE9PSAnaWRsZSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdGFydFdlYkFuaW1hdGlvbnNOZXh0VGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0YXJ0V2ViQW5pbWF0aW9uc05leHRUaWNrKCkge1xuICAgICAgaWYgKCF0aGlzLnRpbWVsaW5lVGlja2luZykge1xuICAgICAgICB0aGlzLnRpbWVsaW5lVGlja2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMud2ViQW5pbWF0aW9uc05leHRUaWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwickFGXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJBRihmKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLnJhZklkKys7XG4gICAgICBpZiAodGhpcy5yYWZDYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucHJvY2Vzc1JhZkNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJhZkNhbGxiYWNrcy5wdXNoKFtpZCwgZl0pO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGYpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuckFGKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIF90aGlzMy51cGRhdGVBbmltYXRpb25zUHJvbWlzZXMoKTtcbiAgICAgICAgZih4KTtcbiAgICAgICAgX3RoaXMzLnVwZGF0ZUFuaW1hdGlvbnNQcm9taXNlcygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGljayh0LCBpc0FuaW1hdGlvbkZyYW1lLCB1cGRhdGluZ0FuaW1hdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzLFxuICAgICAgICBfdGhpcyRwZW5kaW5nRWZmZWN0cyxcbiAgICAgICAgX3RoaXMkcGVuZGluZ0VmZmVjdHMyO1xuICAgICAgdGhpcy5pblRpY2sgPSB0cnVlO1xuICAgICAgdGhpcy5oYXNSZXN0YXJ0ZWRUaGlzRnJhbWUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0O1xuICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgICB2YXIgbmV3UGVuZGluZ0NsZWFycyA9IFtdO1xuICAgICAgdmFyIG5ld1BlbmRpbmdFZmZlY3RzID0gW107XG4gICAgICB2YXIgYWN0aXZlQW5pbWF0aW9ucyA9IFtdO1xuICAgICAgdmFyIGluYWN0aXZlQW5pbWF0aW9ucyA9IFtdO1xuICAgICAgdXBkYXRpbmdBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24udGljayh0LCBpc0FuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24uX2luRWZmZWN0KSB7XG4gICAgICAgICAgbmV3UGVuZGluZ0NsZWFycy5wdXNoKGFuaW1hdGlvbi5lZmZlY3QpO1xuICAgICAgICAgIGFuaW1hdGlvbi51bm1hcmtUYXJnZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdQZW5kaW5nRWZmZWN0cy5wdXNoKGFuaW1hdGlvbi5lZmZlY3QpO1xuICAgICAgICAgIGFuaW1hdGlvbi5tYXJrVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbi5fbmVlZHNUaWNrKSBfdGhpczQudGlja2luZyA9IHRydWU7XG4gICAgICAgIHZhciBhbGl2ZSA9IGFuaW1hdGlvbi5faW5FZmZlY3QgfHwgYW5pbWF0aW9uLl9uZWVkc1RpY2s7XG4gICAgICAgIGFuaW1hdGlvbi5faW5UaW1lbGluZSA9IGFsaXZlO1xuICAgICAgICBpZiAoYWxpdmUpIHtcbiAgICAgICAgICBhY3RpdmVBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmFjdGl2ZUFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIChfdGhpcyRwZW5kaW5nRWZmZWN0cyA9IHRoaXMucGVuZGluZ0VmZmVjdHMpLnB1c2guYXBwbHkoX3RoaXMkcGVuZGluZ0VmZmVjdHMsIG5ld1BlbmRpbmdDbGVhcnMpO1xuICAgICAgKF90aGlzJHBlbmRpbmdFZmZlY3RzMiA9IHRoaXMucGVuZGluZ0VmZmVjdHMpLnB1c2guYXBwbHkoX3RoaXMkcGVuZGluZ0VmZmVjdHMyLCBuZXdQZW5kaW5nRWZmZWN0cyk7XG4gICAgICBpZiAodGhpcy50aWNraW5nKSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB0aGlzLmluVGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFthY3RpdmVBbmltYXRpb25zLCBpbmFjdGl2ZUFuaW1hdGlvbnNdO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG5ydW50aW1lLkVhc2luZ0Z1bmN0aW9uID0gcGFyc2VFYXNpbmdGdW5jdGlvbjtcbnJ1bnRpbWUuQW5pbWF0aW9uVGltZWxpbmUgPSBBbmltYXRpb25UaW1lbGluZTtcblxuZXhwb3J0IHsgQW5pbWF0aW9uLCBBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uVGltZWxpbmUsIEVhc2luZ0Z1bmN0aW9ucywgS2V5ZnJhbWVFZmZlY3QsIGNvbXBhcmVBbmltYXRpb25zLCBtYWtlVGltaW5nLCBub3JtYWxpemVLZXlmcmFtZXMsIG5vcm1hbGl6ZVRpbWluZ0lucHV0LCBudW1lcmljVGltaW5nVG9PYmplY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJGZWRlcmF0ZWRFdmVudCIsIkVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEIiwicHJvcGVydHlNZXRhZGF0YUNhY2hlIiwicnVudGltZSIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsIl9jYWxsU3VwZXIiLCJfaW5oZXJpdHMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfc2xpY2VkVG9BcnJheSIsImNsYW1wIiwiaXNOdW1iZXIiLCJpc05pbCIsIkFuaW1hdGlvbkV2ZW50IiwiX0ZlZGVyYXRlZEV2ZW50IiwibWFuYWdlciIsInRhcmdldCIsImN1cnJlbnRUaW1lIiwidGltZWxpbmVUaW1lIiwiX3RoaXMiLCJ0eXBlIiwiYnViYmxlcyIsImN1cnJlbnRUYXJnZXQiLCJkZWZhdWx0UHJldmVudGVkIiwiZXZlbnRQaGFzZSIsIkFUX1RBUkdFVCIsInRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJzZXF1ZW5jZU51bWJlciIsIkFuaW1hdGlvbiIsImVmZmVjdCIsInRpbWVsaW5lIiwiX3RoaXMkZWZmZWN0IiwiY3VycmVudFRpbWVQZW5kaW5nIiwiX2lkbGUiLCJfcGF1c2VkIiwiX2ZpbmlzaGVkRmxhZyIsIl9jdXJyZW50VGltZSIsIl9wbGF5YmFja1JhdGUiLCJfaW5UaW1lbGluZSIsImFuaW1hdGlvbiIsImlkIiwiY29uY2F0IiwiX2luRWZmZWN0IiwidXBkYXRlIiwiX3RvdGFsRHVyYXRpb24iLCJOdW1iZXIiLCJnZXRDb21wdXRlZFRpbWluZyIsImVuZFRpbWUiLCJfaG9sZFRpbWUiLCJvbGRQbGF5U3RhdGUiLCJ1cGRhdGVQcm9taXNlcyIsImtleSIsImdldCIsIl9zdGFydFRpbWUiLCJwbGF5YmFja1JhdGUiLCJfaXNGaW5pc2hlZCIsInJlYWR5UHJvbWlzZSIsImFuaW1hdGlvbnNXaXRoUHJvbWlzZXMiLCJpbmRleE9mIiwicHVzaCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzb2x2ZVJlYWR5UHJvbWlzZSIsInJlamVjdFJlYWR5UHJvbWlzZSIsIkVycm9yIiwicGVuZGluZyIsIl90aGlzMiIsImZpbmlzaGVkUHJvbWlzZSIsInJlc29sdmVGaW5pc2hlZFByb21pc2UiLCJyZWplY3RGaW5pc2hlZFByb21pc2UiLCJwbGF5U3RhdGUiLCJzZXQiLCJuZXdUaW1lIiwiaXNOYU4iLCJyZXN0YXJ0IiwiX3RoaXMkdGltZWxpbmUiLCJ0aWNrQ3VycmVudFRpbWUiLCJhcHBseURpcnRpZWRBbmltYXRpb24iLCJ2YWx1ZSIsIm9sZEN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwiZW5zdXJlQWxpdmUiLCJuZXdQbGF5U3RhdGUiLCJ1bmRlZmluZWQiLCJwbGF5IiwicmV3aW5kIiwiYW5pbWF0aW9ucyIsInBhdXNlIiwiZmluaXNoIiwiY2FuY2VsIiwiX3RoaXMzIiwib25jYW5jZWwiLCJldmVudCIsInNldFRpbWVvdXQiLCJyZXZlcnNlIiwidXBkYXRlUGxheWJhY2tSYXRlIiwidGFyZ2V0QW5pbWF0aW9ucyIsIl90aGlzJGVmZmVjdDIiLCJnZXRBbmltYXRpb25zIiwibWFya1RhcmdldCIsInVubWFya1RhcmdldCIsImluZGV4Iiwic3BsaWNlIiwidGljayIsImlzQW5pbWF0aW9uRnJhbWUiLCJmaXJlRXZlbnRzIiwiSW5maW5pdHkiLCJwZXJzaXN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwib3B0aW9ucyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50IiwiY29tbWl0U3R5bGVzIiwiX3RoaXMkZWZmZWN0MyIsIl90aGlzJGVmZmVjdDQiLCJpZ25vcmVMaW1pdCIsImJhc2VUaW1lIiwiX3RoaXM0Iiwib25maW5pc2giLCJvbmZyYW1lIiwiX2V2ZW50IiwiTkVXVE9OX0lURVJBVElPTlMiLCJORVdUT05fTUlOX1NMT1BFIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiZmxvYXQzMkFycmF5U3VwcG9ydGVkIiwiRmxvYXQzMkFycmF5IiwiQSIsImFBMSIsImFBMiIsIkIiLCJDIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiaSIsIk1hdGgiLCJhYnMiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsImFHdWVzc1QiLCJjdXJyZW50U2xvcGUiLCJiZXppZXIiLCJtWTEiLCJtWTIiLCJ0Iiwic2FtcGxlVmFsdWVzIiwiQXJyYXkiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJjb252ZXJ0VG9EYXNoIiwic3RyIiwicmVwbGFjZSIsImxldHRlciIsInRvTG93ZXJDYXNlIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwiUXVhZCIsInBvdyIsIkN1YmljIiwiUXVhcnQiLCJRdWludCIsIkV4cG8iLCJTaW5lIiwiY29zIiwiUEkiLCJDaXJjIiwic3FydCIsIkJhY2siLCJCb3VuY2UiLCJwb3cyIiwiYiIsIkVsYXN0aWMiLCJwYXJhbXMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJfcGFyYW1zIiwiX3BhcmFtcyQiLCJhbXBsaXR1ZGUiLCJfcGFyYW1zJDIiLCJwZXJpb2QiLCJhIiwicCIsInNpbiIsImFzaW4iLCJTcHJpbmciLCJkdXJhdGlvbiIsIl9wYXJhbXMyIiwiX3BhcmFtczIkIiwibWFzcyIsIl9wYXJhbXMyJDIiLCJzdGlmZm5lc3MiLCJfcGFyYW1zMiQzIiwiZGFtcGluZyIsIl9wYXJhbXMyJDQiLCJ2ZWxvY2l0eSIsIncwIiwiemV0YSIsIndkIiwicHJvZ3Jlc3MiLCJleHAiLCJTdGVwcyIsIl9yZWYiLCJfcmVmMiIsIl9yZWYyJCIsInN0ZXBzIiwidHJ1bmMiLCJjZWlsIiwiZmxvb3IiLCJCZXppZXIiLCJfcGFyYW1zMyIsImVhc2VpbiIsIkVhc2VPdXQiLCJlYXNlIiwiRWFzZUluT3V0IiwiRWFzZU91dEluIiwiRWFzaW5nRnVuY3Rpb25zIiwic3RlcFN0YXJ0Iiwic3RlcEVuZCIsImxpbmVhciIsIm91dCIsInNwcmluZyIsImNvbXBsZXhFYXNpbmdTeW50YXgiLCJ0cmltIiwiZ2V0RWFzaW5nRnVuY3Rpb24iLCJ4IiwiU3RhcnQiLCJNaWRkbGUiLCJFbmQiLCJzdGVwIiwiY291bnQiLCJwb3MiLCJzdGVwU2l6ZSIsIm51bWJlclN0cmluZyIsImN1YmljQmV6aWVyUmUiLCJSZWdFeHAiLCJzdGVwMVJlIiwic3RlcDJSZSIsInBhcnNlRWFzaW5nRnVuY3Rpb24iLCJub3JtYWxpemVkRWFzaW5nIiwiY3ViaWNEYXRhIiwiZXhlYyIsImFwcGx5Iiwic2xpY2UiLCJtYXAiLCJzdGVwMURhdGEiLCJzdGVwMkRhdGEiLCJzdGFydCIsIm1pZGRsZSIsImVuZCIsImNhbGN1bGF0ZUFjdGl2ZUR1cmF0aW9uIiwidGltaW5nIiwicmVwZWF0ZWREdXJhdGlvbiIsIl90aW1pbmckaXRlcmF0aW9ucyIsIml0ZXJhdGlvbnMiLCJQaGFzZU5vbmUiLCJQaGFzZUJlZm9yZSIsIlBoYXNlQWZ0ZXIiLCJQaGFzZUFjdGl2ZSIsImNhbGN1bGF0ZVBoYXNlIiwiYWN0aXZlRHVyYXRpb24iLCJsb2NhbFRpbWUiLCJtaW4iLCJkZWxheSIsImVuZERlbGF5IiwiY2FsY3VsYXRlQWN0aXZlVGltZSIsImZpbGxNb2RlIiwicGhhc2UiLCJjYWxjdWxhdGVPdmVyYWxsUHJvZ3Jlc3MiLCJpdGVyYXRpb25EdXJhdGlvbiIsImFjdGl2ZVRpbWUiLCJpdGVyYXRpb25TdGFydCIsIm92ZXJhbGxQcm9ncmVzcyIsImNhbGN1bGF0ZVNpbXBsZUl0ZXJhdGlvblByb2dyZXNzIiwic2ltcGxlSXRlcmF0aW9uUHJvZ3Jlc3MiLCJjYWxjdWxhdGVDdXJyZW50SXRlcmF0aW9uIiwiY2FsY3VsYXRlRGlyZWN0ZWRQcm9ncmVzcyIsInBsYXliYWNrRGlyZWN0aW9uIiwiY3VycmVudEl0ZXJhdGlvbiIsImN1cnJlbnREaXJlY3Rpb24iLCJkIiwiY2FsY3VsYXRlSXRlcmF0aW9uUHJvZ3Jlc3MiLCJmaWxsIiwiZGlyZWN0ZWRQcm9ncmVzcyIsImRpcmVjdGlvbiIsImVhc2luZ0Z1bmN0aW9uIiwiY29udmVydEVmZmVjdElucHV0Iiwia2V5ZnJhbWVzIiwicHJvcGVydHlTcGVjaWZpY0tleWZyYW1lR3JvdXBzIiwibWFrZVByb3BlcnR5U3BlY2lmaWNLZXlmcmFtZUdyb3VwcyIsImludGVycG9sYXRpb25zIiwibWFrZUludGVycG9sYXRpb25zIiwiZnJhY3Rpb24iLCJmaWx0ZXIiLCJpbnRlcnBvbGF0aW9uIiwiYXBwbHlGcm9tIiwiYXBwbHlUbyIsImZvckVhY2giLCJvZmZzZXRGcmFjdGlvbiIsInN0YXJ0T2Zmc2V0IiwibG9jYWxEdXJhdGlvbiIsImVuZE9mZnNldCIsInNjYWxlZExvY2FsVGltZSIsInNldEF0dHJpYnV0ZSIsInByb3BlcnR5IiwiaXNOb3RSZXNlcnZlZFdvcmQiLCJtZW1iZXIiLCJwcm9wZXJ0eVNwZWNpZmljS2V5ZnJhbWUiLCJvZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImVhc2luZyIsImdyb3VwTmFtZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInByb3BlcnR5SW50ZXJwb2xhdGlvbiIsInNvcnQiLCJsZWZ0SW50ZXJwb2xhdGlvbiIsInJpZ2h0SW50ZXJwb2xhdGlvbiIsIkludGVycG9sYXRpb25GYWN0b3J5IiwiZnJvbSIsInRvIiwiY29udmVydFRvU3RyaW5nIiwiZiIsImludGVycG9sYXRlZCIsImludGVycG9sYXRlIiwibGVmdCIsInJpZ2h0IiwibWV0YWRhdGEiLCJzeW50YXgiLCJwcm9wZXJ0eUhhbmRsZXIiLCJzdHlsZVZhbHVlUmVnaXN0cnkiLCJnZXRQcm9wZXJ0eVN5bnRheCIsInBhcnNlciIsInVzZWRMZWZ0IiwidXNlZFJpZ2h0IiwiaW50ZXJwb2xhdGlvbkFyZ3MiLCJtaXhlciIsImludGVycCIsImJvb2wiLCJpc0FycmF5IiwiZnJvbUxlbmd0aCIsInRvTGVuZ3RoIiwibWF4IiwiciIsIkFuaW1hdGlvbkVmZmVjdFRpbWluZyIsIl9lYXNpbmciLCJjb252ZXJ0VG9BcnJheUZvcm0iLCJlZmZlY3RJbnB1dCIsIm5vcm1hbGl6ZWRFZmZlY3RJbnB1dCIsInZhbHVlcyIsIm51bUtleWZyYW1lcyIsImtleWZyYW1lIiwiY29tcG9zaXRlIiwibm9ybWFsaXplS2V5ZnJhbWVzIiwib3JpZ2luYWxLZXlmcmFtZSIsIm1lbWJlclZhbHVlIiwiaXNGaW5pdGUiLCJldmVyeUZyYW1lSGFzT2Zmc2V0IiwicHJldmlvdXNPZmZzZXQiLCJUeXBlRXJyb3IiLCJzcGFjZUtleWZyYW1lcyIsIl9rZXlmcmFtZXMkb2Zmc2V0IiwiX2tleWZyYW1lcyIsIl9rZXlmcmFtZXMkMCRvZmZzZXQiLCJwcmV2aW91c0luZGV4IiwiX2kiLCJfb2Zmc2V0IiwiaiIsImZpbGxzIiwic3BsaXQiLCJkaXJlY3Rpb25zIiwibWFrZVRpbWluZyIsInRpbWluZ0lucHV0IiwiZm9yR3JvdXAiLCJPYmplY3QiLCJrZXlzIiwibm9ybWFsaXplVGltaW5nSW5wdXQiLCJudW1lcmljVGltaW5nVG9PYmplY3QiLCJLZXlmcmFtZUVmZmVjdCIsIml0ZXJhdGlvbkNvbXBvc2l0ZSIsIm5vcm1hbGl6ZWRLZXlmcmFtZXMiLCJQcm94eSIsImdsb2JhbFRoaXMiLCJjb21wdXRlZFRpbWluZyIsInByb3AiLCJhcHBseUludGVycG9sYXRpb25zIiwidGltZUZyYWN0aW9uIiwiZ2V0S2V5ZnJhbWVzIiwic2V0S2V5ZnJhbWVzIiwiZ2V0VGltaW5nIiwidXBkYXRlVGltaW5nIiwibmFtZSIsImNvbXBhcmVBbmltYXRpb25zIiwibGVmdEFuaW1hdGlvbiIsInJpZ2h0QW5pbWF0aW9uIiwiQW5pbWF0aW9uVGltZWxpbmUiLCJkb2N1bWVudCIsInRpY2tpbmciLCJ0aW1lbGluZVRpY2tpbmciLCJoYXNSZXN0YXJ0ZWRUaGlzRnJhbWUiLCJpblRpY2siLCJwZW5kaW5nRWZmZWN0cyIsInJhZklkIiwicmFmQ2FsbGJhY2tzIiwid2ViQW5pbWF0aW9uc05leHRUaWNrIiwiZGlzY2FyZEFuaW1hdGlvbnMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwcm9jZXNzUmFmQ2FsbGJhY2tzIiwicHJvY2Vzc2luZyIsImVudHJ5IiwiYXBwbHlQZW5kaW5nRWZmZWN0cyIsImlzVGlja2luZyIsInJlc3RhcnRXZWJBbmltYXRpb25zTmV4dFRpY2siLCJpbmFjdGl2ZUFuaW1hdGlvbnMiLCJkZXN0cm95IiwiZGVmYXVsdFZpZXciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImZyYW1lSWQiLCJ1cGRhdGVBbmltYXRpb25zUHJvbWlzZXMiLCJyQUYiLCJ1cGRhdGluZ0FuaW1hdGlvbnMiLCJfdGhpcyRwZW5kaW5nRWZmZWN0cyIsIl90aGlzJHBlbmRpbmdFZmZlY3RzMiIsIm5ld1BlbmRpbmdDbGVhcnMiLCJuZXdQZW5kaW5nRWZmZWN0cyIsImFjdGl2ZUFuaW1hdGlvbnMiLCJfbmVlZHNUaWNrIiwiYWxpdmUiLCJFYXNpbmdGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@antv+g-web-animations-api@2.1.21/node_modules/@antv/g-web-animations-api/dist/index.esm.js\n");

/***/ })

};
;