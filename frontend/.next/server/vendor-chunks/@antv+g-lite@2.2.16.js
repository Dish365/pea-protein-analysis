"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@antv+g-lite@2.2.16";
exports.ids = ["vendor-chunks/@antv+g-lite@2.2.16"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@antv+g-lite@2.2.16/node_modules/@antv/g-lite/dist/index.esm.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/.pnpm/@antv+g-lite@2.2.16/node_modules/@antv/g-lite/dist/index.esm.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AABB: () => (/* binding */ AABB),\n/* harmony export */   AbstractRenderer: () => (/* binding */ AbstractRenderer),\n/* harmony export */   AbstractRendererPlugin: () => (/* binding */ AbstractRendererPlugin),\n/* harmony export */   BUILT_IN_PROPERTIES: () => (/* binding */ BUILT_IN_PROPERTIES),\n/* harmony export */   CSS: () => (/* binding */ CSS),\n/* harmony export */   CSSGradientValue: () => (/* binding */ CSSGradientValue),\n/* harmony export */   CSSKeywordValue: () => (/* binding */ CSSKeywordValue),\n/* harmony export */   CSSRGB: () => (/* binding */ CSSRGB),\n/* harmony export */   CSSStyleValue: () => (/* binding */ CSSStyleValue),\n/* harmony export */   CSSUnitValue: () => (/* binding */ CSSUnitValue),\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   CameraEvent: () => (/* binding */ CameraEvent),\n/* harmony export */   CameraProjectionMode: () => (/* binding */ CameraProjectionMode),\n/* harmony export */   CameraTrackingMode: () => (/* binding */ CameraTrackingMode),\n/* harmony export */   CameraType: () => (/* binding */ CameraType),\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   CanvasEvent: () => (/* binding */ CanvasEvent),\n/* harmony export */   Circle: () => (/* binding */ Circle),\n/* harmony export */   CircleUpdater: () => (/* binding */ CircleUpdater),\n/* harmony export */   ClipSpaceNearZ: () => (/* binding */ ClipSpaceNearZ),\n/* harmony export */   CustomElement: () => (/* binding */ CustomElement),\n/* harmony export */   CustomElementRegistry: () => (/* binding */ CustomElementRegistry),\n/* harmony export */   CustomEvent: () => (/* binding */ CustomEvent),\n/* harmony export */   DefaultSceneGraphSelector: () => (/* binding */ DefaultSceneGraphSelector),\n/* harmony export */   DefaultSceneGraphService: () => (/* binding */ DefaultSceneGraphService),\n/* harmony export */   DisplayObject: () => (/* binding */ DisplayObject),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   ERROR_MSG_METHOD_NOT_IMPLEMENTED: () => (/* binding */ ERROR_MSG_METHOD_NOT_IMPLEMENTED),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   ElementEvent: () => (/* binding */ ElementEvent),\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse),\n/* harmony export */   EllipseUpdater: () => (/* binding */ EllipseUpdater),\n/* harmony export */   EventService: () => (/* binding */ EventService),\n/* harmony export */   EventTarget: () => (/* binding */ EventTarget),\n/* harmony export */   FederatedEvent: () => (/* binding */ FederatedEvent),\n/* harmony export */   FederatedMouseEvent: () => (/* binding */ FederatedMouseEvent),\n/* harmony export */   FederatedPointerEvent: () => (/* binding */ FederatedPointerEvent),\n/* harmony export */   FederatedWheelEvent: () => (/* binding */ FederatedWheelEvent),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Frustum: () => (/* binding */ Frustum),\n/* harmony export */   GradientType: () => (/* binding */ GradientType),\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   GroupUpdater: () => (/* binding */ GroupUpdater),\n/* harmony export */   HTML: () => (/* binding */ HTML),\n/* harmony export */   HTMLUpdater: () => (/* binding */ HTMLUpdater),\n/* harmony export */   Image: () => (/* binding */ Image),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   LineUpdater: () => (/* binding */ LineUpdater),\n/* harmony export */   Mask: () => (/* binding */ Mask),\n/* harmony export */   MutationEvent: () => (/* binding */ MutationEvent),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   OffscreenCanvasCreator: () => (/* binding */ OffscreenCanvasCreator),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathUpdater: () => (/* binding */ PathUpdater),\n/* harmony export */   Plane: () => (/* binding */ Plane),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Polygon: () => (/* binding */ Polygon),\n/* harmony export */   Polyline: () => (/* binding */ Polyline),\n/* harmony export */   PolylineUpdater: () => (/* binding */ PolylineUpdater),\n/* harmony export */   PropertySyntax: () => (/* binding */ PropertySyntax),\n/* harmony export */   RBush: () => (/* binding */ RBush),\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   RectUpdater: () => (/* binding */ RectUpdater),\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle),\n/* harmony export */   RenderReason: () => (/* binding */ RenderReason),\n/* harmony export */   RenderingService: () => (/* binding */ RenderingService),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   SortReason: () => (/* binding */ SortReason),\n/* harmony export */   Strategy: () => (/* binding */ Strategy),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   TextService: () => (/* binding */ TextService),\n/* harmony export */   TextUpdater: () => (/* binding */ TextUpdater),\n/* harmony export */   UnitType: () => (/* binding */ UnitType),\n/* harmony export */   attrModifiedEvent: () => (/* binding */ attrModifiedEvent),\n/* harmony export */   computeLinearGradient: () => (/* binding */ computeLinearGradient),\n/* harmony export */   computeRadialGradient: () => (/* binding */ computeRadialGradient),\n/* harmony export */   convertToPath: () => (/* binding */ convertToPath),\n/* harmony export */   createVec3: () => (/* binding */ createVec3),\n/* harmony export */   decompose: () => (/* binding */ decompose),\n/* harmony export */   definedProps: () => (/* binding */ definedProps),\n/* harmony export */   deg2rad: () => (/* binding */ deg2rad),\n/* harmony export */   deg2turn: () => (/* binding */ deg2turn),\n/* harmony export */   destroyEvent: () => (/* binding */ destroyEvent),\n/* harmony export */   findClosestClipPathTarget: () => (/* binding */ findClosestClipPathTarget),\n/* harmony export */   fromRotationTranslationScale: () => (/* binding */ fromRotationTranslationScale),\n/* harmony export */   getAngle: () => (/* binding */ getAngle),\n/* harmony export */   getEuler: () => (/* binding */ getEuler),\n/* harmony export */   getOrCalculatePathTotalLength: () => (/* binding */ getOrCalculatePathTotalLength),\n/* harmony export */   grad2deg: () => (/* binding */ grad2deg),\n/* harmony export */   insertedEvent: () => (/* binding */ insertedEvent),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isCSSGradientValue: () => (/* binding */ isCSSGradientValue),\n/* harmony export */   isCSSRGB: () => (/* binding */ isCSSRGB),\n/* harmony export */   isCanvas: () => (/* binding */ isCanvas),\n/* harmony export */   isDisplayObject: () => (/* binding */ isDisplayObject),\n/* harmony export */   isFederatedEvent: () => (/* binding */ isFederatedEvent),\n/* harmony export */   isFillOrStrokeAffected: () => (/* binding */ isFillOrStrokeAffected),\n/* harmony export */   isPattern: () => (/* binding */ isPattern),\n/* harmony export */   mergeColors: () => (/* binding */ mergeColors),\n/* harmony export */   parseColor: () => (/* binding */ parseColor),\n/* harmony export */   parseLength: () => (/* binding */ parseLength),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   parseTransform: () => (/* binding */ parseTransform),\n/* harmony export */   parsedTransformToMat4: () => (/* binding */ parsedTransformToMat4),\n/* harmony export */   propertyMetadataCache: () => (/* binding */ propertyMetadataCache),\n/* harmony export */   rad2deg: () => (/* binding */ rad2deg),\n/* harmony export */   removedEvent: () => (/* binding */ removedEvent),\n/* harmony export */   resetEntityCounter: () => (/* binding */ resetEntityCounter),\n/* harmony export */   runtime: () => (/* binding */ runtime),\n/* harmony export */   setDOMSize: () => (/* binding */ setDOMSize),\n/* harmony export */   translatePathToString: () => (/* binding */ translatePathToString),\n/* harmony export */   turn2deg: () => (/* binding */ turn2deg)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/callSuper */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/callSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec4.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat3.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/quat.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec2.js\");\n/* harmony import */ var _babel_runtime_helpers_readOnlyError__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/readOnlyError */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/readOnlyError.js\");\n/* harmony import */ var _babel_runtime_helpers_readOnlyError__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_readOnlyError__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-number.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/util/distance-square-root.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-nil.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-string.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/clamp.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/util/get-total-length.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/min.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/max.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-number-equal.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/mod.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/process/normalize-path.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/convert/path-2-curve.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/util/equalize-segments.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/util/get-draw-direction.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/process/reverse-curve.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/process/clone-path.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/util/get-rotated-curve.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-undefined.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-array.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-boolean.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-function.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-object.js\");\n/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! @antv/util */ \"(ssr)/../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/path/util/get-point-at-length.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _babel_runtime_helpers_superPropGet__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime/helpers/superPropGet */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/superPropGet.js\");\n/* harmony import */ var _babel_runtime_helpers_superPropGet__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_superPropGet__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _antv_g_math__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/g-math */ \"(ssr)/../node_modules/.pnpm/@antv+g-math@3.0.0/node_modules/@antv/g-math/dist/index.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @babel/runtime/helpers/regeneratorRuntime */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\");\n/* harmony import */ var _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @babel/runtime/helpers/createForOfIteratorHelper */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\");\n/* harmony import */ var _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"(ssr)/../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\");\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15__);\n/*!\n * @antv/g-lite\n * @description A core module for rendering engine implements DOM API.\n * @version 2.2.16\n * @date 1/23/2025, 8:31:51 AM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar rbush = {\n    exports: {}\n};\n(function(module, exports) {\n    (function(global1, factory) {\n        module.exports = factory();\n    })(commonjsGlobal, function() {\n        function quickselect(arr, k, left, right, compare) {\n            quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n        }\n        function quickselectStep(arr, k, left, right, compare) {\n            while(right > left){\n                if (right - left > 600) {\n                    var n = right - left + 1;\n                    var m = k - left + 1;\n                    var z = Math.log(n);\n                    var s = 0.5 * Math.exp(2 * z / 3);\n                    var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n                    var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n                    var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n                    quickselectStep(arr, k, newLeft, newRight, compare);\n                }\n                var t = arr[k];\n                var i = left;\n                var j = right;\n                swap(arr, left, k);\n                if (compare(arr[right], t) > 0) {\n                    swap(arr, left, right);\n                }\n                while(i < j){\n                    swap(arr, i, j);\n                    i++;\n                    j--;\n                    while(compare(arr[i], t) < 0){\n                        i++;\n                    }\n                    while(compare(arr[j], t) > 0){\n                        j--;\n                    }\n                }\n                if (compare(arr[left], t) === 0) {\n                    swap(arr, left, j);\n                } else {\n                    j++;\n                    swap(arr, j, right);\n                }\n                if (j <= k) {\n                    left = j + 1;\n                }\n                if (k <= j) {\n                    right = j - 1;\n                }\n            }\n        }\n        function swap(arr, i, j) {\n            var tmp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = tmp;\n        }\n        function defaultCompare(a, b) {\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n        var RBush = function RBush(maxEntries) {\n            if (maxEntries === void 0) maxEntries = 9;\n            // max entries in a node is 9 by default; min node fill is 40% for best performance\n            this._maxEntries = Math.max(4, maxEntries);\n            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n            this.clear();\n        };\n        RBush.prototype.all = function all() {\n            return this._all(this.data, []);\n        };\n        RBush.prototype.search = function search(bbox) {\n            var node = this.data;\n            var result = [];\n            if (!intersects(bbox, node)) {\n                return result;\n            }\n            var toBBox = this.toBBox;\n            var nodesToSearch = [];\n            while(node){\n                for(var i = 0; i < node.children.length; i++){\n                    var child = node.children[i];\n                    var childBBox = node.leaf ? toBBox(child) : child;\n                    if (intersects(bbox, childBBox)) {\n                        if (node.leaf) {\n                            result.push(child);\n                        } else if (contains(bbox, childBBox)) {\n                            this._all(child, result);\n                        } else {\n                            nodesToSearch.push(child);\n                        }\n                    }\n                }\n                node = nodesToSearch.pop();\n            }\n            return result;\n        };\n        RBush.prototype.collides = function collides(bbox) {\n            var node = this.data;\n            if (!intersects(bbox, node)) {\n                return false;\n            }\n            var nodesToSearch = [];\n            while(node){\n                for(var i = 0; i < node.children.length; i++){\n                    var child = node.children[i];\n                    var childBBox = node.leaf ? this.toBBox(child) : child;\n                    if (intersects(bbox, childBBox)) {\n                        if (node.leaf || contains(bbox, childBBox)) {\n                            return true;\n                        }\n                        nodesToSearch.push(child);\n                    }\n                }\n                node = nodesToSearch.pop();\n            }\n            return false;\n        };\n        RBush.prototype.load = function load(data) {\n            if (!(data && data.length)) {\n                return this;\n            }\n            if (data.length < this._minEntries) {\n                for(var i = 0; i < data.length; i++){\n                    this.insert(data[i]);\n                }\n                return this;\n            }\n            // recursively build the tree with the given data from scratch using OMT algorithm\n            var node = this._build(data.slice(), 0, data.length - 1, 0);\n            if (!this.data.children.length) {\n                // save as is if tree is empty\n                this.data = node;\n            } else if (this.data.height === node.height) {\n                // split root if trees have the same height\n                this._splitRoot(this.data, node);\n            } else {\n                if (this.data.height < node.height) {\n                    // swap trees if inserted one is bigger\n                    var tmpNode = this.data;\n                    this.data = node;\n                    node = tmpNode;\n                }\n                // insert the small tree into the large tree at appropriate level\n                this._insert(node, this.data.height - node.height - 1, true);\n            }\n            return this;\n        };\n        RBush.prototype.insert = function insert(item) {\n            if (item) {\n                this._insert(item, this.data.height - 1);\n            }\n            return this;\n        };\n        RBush.prototype.clear = function clear() {\n            this.data = createNode([]);\n            return this;\n        };\n        RBush.prototype.remove = function remove(item, equalsFn) {\n            if (!item) {\n                return this;\n            }\n            var node = this.data;\n            var bbox = this.toBBox(item);\n            var path = [];\n            var indexes = [];\n            var i, parent, goingUp;\n            // depth-first iterative tree traversal\n            while(node || path.length){\n                if (!node) {\n                    node = path.pop();\n                    parent = path[path.length - 1];\n                    i = indexes.pop();\n                    goingUp = true;\n                }\n                if (node.leaf) {\n                    var index = findItem(item, node.children, equalsFn);\n                    if (index !== -1) {\n                        // item found, remove the item and condense tree upwards\n                        node.children.splice(index, 1);\n                        path.push(node);\n                        this._condense(path);\n                        return this;\n                    }\n                }\n                if (!goingUp && !node.leaf && contains(node, bbox)) {\n                    path.push(node);\n                    indexes.push(i);\n                    i = 0;\n                    parent = node;\n                    node = node.children[0];\n                } else if (parent) {\n                    i++;\n                    node = parent.children[i];\n                    goingUp = false;\n                } else {\n                    node = null;\n                } // nothing found\n            }\n            return this;\n        };\n        RBush.prototype.toBBox = function toBBox(item) {\n            return item;\n        };\n        RBush.prototype.compareMinX = function compareMinX(a, b) {\n            return a.minX - b.minX;\n        };\n        RBush.prototype.compareMinY = function compareMinY(a, b) {\n            return a.minY - b.minY;\n        };\n        RBush.prototype.toJSON = function toJSON() {\n            return this.data;\n        };\n        RBush.prototype.fromJSON = function fromJSON(data) {\n            this.data = data;\n            return this;\n        };\n        RBush.prototype._all = function _all(node, result) {\n            var nodesToSearch = [];\n            while(node){\n                if (node.leaf) {\n                    result.push.apply(result, node.children);\n                } else {\n                    nodesToSearch.push.apply(nodesToSearch, node.children);\n                }\n                node = nodesToSearch.pop();\n            }\n            return result;\n        };\n        RBush.prototype._build = function _build(items, left, right, height) {\n            var N = right - left + 1;\n            var M = this._maxEntries;\n            var node;\n            if (N <= M) {\n                // reached leaf level; return leaf\n                node = createNode(items.slice(left, right + 1));\n                calcBBox(node, this.toBBox);\n                return node;\n            }\n            if (!height) {\n                // target height of the bulk-loaded tree\n                height = Math.ceil(Math.log(N) / Math.log(M));\n                // target number of root entries to maximize storage utilization\n                M = Math.ceil(N / Math.pow(M, height - 1));\n            }\n            node = createNode([]);\n            node.leaf = false;\n            node.height = height;\n            // split the items into M mostly square tiles\n            var N2 = Math.ceil(N / M);\n            var N1 = N2 * Math.ceil(Math.sqrt(M));\n            multiSelect(items, left, right, N1, this.compareMinX);\n            for(var i = left; i <= right; i += N1){\n                var right2 = Math.min(i + N1 - 1, right);\n                multiSelect(items, i, right2, N2, this.compareMinY);\n                for(var j = i; j <= right2; j += N2){\n                    var right3 = Math.min(j + N2 - 1, right2);\n                    // pack each entry recursively\n                    node.children.push(this._build(items, j, right3, height - 1));\n                }\n            }\n            calcBBox(node, this.toBBox);\n            return node;\n        };\n        RBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {\n            while(true){\n                path.push(node);\n                if (node.leaf || path.length - 1 === level) {\n                    break;\n                }\n                var minArea = Infinity;\n                var minEnlargement = Infinity;\n                var targetNode = void 0;\n                for(var i = 0; i < node.children.length; i++){\n                    var child = node.children[i];\n                    var area = bboxArea(child);\n                    var enlargement = enlargedArea(bbox, child) - area;\n                    // choose entry with the least area enlargement\n                    if (enlargement < minEnlargement) {\n                        minEnlargement = enlargement;\n                        minArea = area < minArea ? area : minArea;\n                        targetNode = child;\n                    } else if (enlargement === minEnlargement) {\n                        // otherwise choose one with the smallest area\n                        if (area < minArea) {\n                            minArea = area;\n                            targetNode = child;\n                        }\n                    }\n                }\n                node = targetNode || node.children[0];\n            }\n            return node;\n        };\n        RBush.prototype._insert = function _insert(item, level, isNode) {\n            var bbox = isNode ? item : this.toBBox(item);\n            var insertPath = [];\n            // find the best node for accommodating the item, saving all nodes along the path too\n            var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n            // put the item into the node\n            node.children.push(item);\n            extend(node, bbox);\n            // split on node overflow; propagate upwards if necessary\n            while(level >= 0){\n                if (insertPath[level].children.length > this._maxEntries) {\n                    this._split(insertPath, level);\n                    level--;\n                } else {\n                    break;\n                }\n            }\n            // adjust bboxes along the insertion path\n            this._adjustParentBBoxes(bbox, insertPath, level);\n        };\n        // split overflowed node into two\n        RBush.prototype._split = function _split(insertPath, level) {\n            var node = insertPath[level];\n            var M = node.children.length;\n            var m = this._minEntries;\n            this._chooseSplitAxis(node, m, M);\n            var splitIndex = this._chooseSplitIndex(node, m, M);\n            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n            newNode.height = node.height;\n            newNode.leaf = node.leaf;\n            calcBBox(node, this.toBBox);\n            calcBBox(newNode, this.toBBox);\n            if (level) {\n                insertPath[level - 1].children.push(newNode);\n            } else {\n                this._splitRoot(node, newNode);\n            }\n        };\n        RBush.prototype._splitRoot = function _splitRoot(node, newNode) {\n            // split root node\n            this.data = createNode([\n                node,\n                newNode\n            ]);\n            this.data.height = node.height + 1;\n            this.data.leaf = false;\n            calcBBox(this.data, this.toBBox);\n        };\n        RBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {\n            var index;\n            var minOverlap = Infinity;\n            var minArea = Infinity;\n            for(var i = m; i <= M - m; i++){\n                var bbox1 = distBBox(node, 0, i, this.toBBox);\n                var bbox2 = distBBox(node, i, M, this.toBBox);\n                var overlap = intersectionArea(bbox1, bbox2);\n                var area = bboxArea(bbox1) + bboxArea(bbox2);\n                // choose distribution with minimum overlap\n                if (overlap < minOverlap) {\n                    minOverlap = overlap;\n                    index = i;\n                    minArea = area < minArea ? area : minArea;\n                } else if (overlap === minOverlap) {\n                    // otherwise choose distribution with minimum area\n                    if (area < minArea) {\n                        minArea = area;\n                        index = i;\n                    }\n                }\n            }\n            return index || M - m;\n        };\n        // sorts node children by the best axis for split\n        RBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {\n            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n            var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n            var xMargin = this._allDistMargin(node, m, M, compareMinX);\n            var yMargin = this._allDistMargin(node, m, M, compareMinY);\n            // if total distributions margin value is minimal for x, sort by minX,\n            // otherwise it's already sorted by minY\n            if (xMargin < yMargin) {\n                node.children.sort(compareMinX);\n            }\n        };\n        // total margin of all possible split distributions where each node is at least m full\n        RBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {\n            node.children.sort(compare);\n            var toBBox = this.toBBox;\n            var leftBBox = distBBox(node, 0, m, toBBox);\n            var rightBBox = distBBox(node, M - m, M, toBBox);\n            var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n            for(var i = m; i < M - m; i++){\n                var child = node.children[i];\n                extend(leftBBox, node.leaf ? toBBox(child) : child);\n                margin += bboxMargin(leftBBox);\n            }\n            for(var i$1 = M - m - 1; i$1 >= m; i$1--){\n                var child$1 = node.children[i$1];\n                extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n                margin += bboxMargin(rightBBox);\n            }\n            return margin;\n        };\n        RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {\n            // adjust bboxes along the given tree path\n            for(var i = level; i >= 0; i--){\n                extend(path[i], bbox);\n            }\n        };\n        RBush.prototype._condense = function _condense(path) {\n            // go through the path, removing empty nodes and updating bboxes\n            for(var i = path.length - 1, siblings = void 0; i >= 0; i--){\n                if (path[i].children.length === 0) {\n                    if (i > 0) {\n                        siblings = path[i - 1].children;\n                        siblings.splice(siblings.indexOf(path[i]), 1);\n                    } else {\n                        this.clear();\n                    }\n                } else {\n                    calcBBox(path[i], this.toBBox);\n                }\n            }\n        };\n        function findItem(item, items, equalsFn) {\n            if (!equalsFn) {\n                return items.indexOf(item);\n            }\n            for(var i = 0; i < items.length; i++){\n                if (equalsFn(item, items[i])) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        // calculate node's bbox from bboxes of its children\n        function calcBBox(node, toBBox) {\n            distBBox(node, 0, node.children.length, toBBox, node);\n        }\n        // min bounding rectangle of node children from k to p-1\n        function distBBox(node, k, p, toBBox, destNode) {\n            if (!destNode) {\n                destNode = createNode(null);\n            }\n            destNode.minX = Infinity;\n            destNode.minY = Infinity;\n            destNode.maxX = -Infinity;\n            destNode.maxY = -Infinity;\n            for(var i = k; i < p; i++){\n                var child = node.children[i];\n                extend(destNode, node.leaf ? toBBox(child) : child);\n            }\n            return destNode;\n        }\n        function extend(a, b) {\n            a.minX = Math.min(a.minX, b.minX);\n            a.minY = Math.min(a.minY, b.minY);\n            a.maxX = Math.max(a.maxX, b.maxX);\n            a.maxY = Math.max(a.maxY, b.maxY);\n            return a;\n        }\n        function compareNodeMinX(a, b) {\n            return a.minX - b.minX;\n        }\n        function compareNodeMinY(a, b) {\n            return a.minY - b.minY;\n        }\n        function bboxArea(a) {\n            return (a.maxX - a.minX) * (a.maxY - a.minY);\n        }\n        function bboxMargin(a) {\n            return a.maxX - a.minX + (a.maxY - a.minY);\n        }\n        function enlargedArea(a, b) {\n            return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n        }\n        function intersectionArea(a, b) {\n            var minX = Math.max(a.minX, b.minX);\n            var minY = Math.max(a.minY, b.minY);\n            var maxX = Math.min(a.maxX, b.maxX);\n            var maxY = Math.min(a.maxY, b.maxY);\n            return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n        }\n        function contains(a, b) {\n            return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n        }\n        function intersects(a, b) {\n            return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n        }\n        function createNode(children) {\n            return {\n                children: children,\n                height: 1,\n                leaf: true,\n                minX: Infinity,\n                minY: Infinity,\n                maxX: -Infinity,\n                maxY: -Infinity\n            };\n        }\n        // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n        // combines selection algorithm with binary divide & conquer approach\n        function multiSelect(arr, left, right, n, compare) {\n            var stack = [\n                left,\n                right\n            ];\n            while(stack.length){\n                right = stack.pop();\n                left = stack.pop();\n                if (right - left <= n) {\n                    continue;\n                }\n                var mid = left + Math.ceil((right - left) / n / 2) * n;\n                quickselect(arr, mid, left, right, compare);\n                stack.push(left, mid, mid, right);\n            }\n        }\n        return RBush;\n    });\n})(rbush);\nvar RBush = rbush.exports;\nvar Shape = /*#__PURE__*/ function(Shape) {\n    Shape[\"GROUP\"] = \"g\";\n    Shape[\"FRAGMENT\"] = \"fragment\";\n    Shape[\"CIRCLE\"] = \"circle\";\n    Shape[\"ELLIPSE\"] = \"ellipse\";\n    Shape[\"IMAGE\"] = \"image\";\n    Shape[\"RECT\"] = \"rect\";\n    Shape[\"LINE\"] = \"line\";\n    Shape[\"POLYLINE\"] = \"polyline\";\n    Shape[\"POLYGON\"] = \"polygon\";\n    Shape[\"TEXT\"] = \"text\";\n    Shape[\"PATH\"] = \"path\";\n    Shape[\"HTML\"] = \"html\";\n    Shape[\"MESH\"] = \"mesh\";\n    return Shape;\n}({});\n// prettier-ignore\n// prettier-ignore\n// Cursor style\n// See: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\nvar ClipSpaceNearZ = /*#__PURE__*/ function(ClipSpaceNearZ) {\n    ClipSpaceNearZ[ClipSpaceNearZ[\"ZERO\"] = 0] = \"ZERO\";\n    ClipSpaceNearZ[ClipSpaceNearZ[\"NEGATIVE_ONE\"] = 1] = \"NEGATIVE_ONE\";\n    return ClipSpaceNearZ;\n}({});\n/**\n * eg. NodeCanvas, OffscreenCanvas, HTMLCanvasElement\n */ /**\n * The format to use when defining custom easing functions\n */ // @see https://github.com/zhanba/pailye/blob/master/packages/flex/src/types.ts\nvar AbstractRendererPlugin = /*#__PURE__*/ function() {\n    function AbstractRendererPlugin() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AbstractRendererPlugin);\n        this.plugins = [];\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AbstractRendererPlugin, [\n        {\n            key: \"addRenderingPlugin\",\n            value: function addRenderingPlugin(plugin) {\n                this.plugins.push(plugin);\n                this.context.renderingPlugins.push(plugin);\n            }\n        },\n        {\n            key: \"removeAllRenderingPlugins\",\n            value: function removeAllRenderingPlugins() {\n                var _this = this;\n                this.plugins.forEach(function(plugin) {\n                    var index = _this.context.renderingPlugins.indexOf(plugin);\n                    if (index >= 0) {\n                        _this.context.renderingPlugins.splice(index, 1);\n                    }\n                });\n            }\n        }\n    ]);\n}();\nvar AbstractRenderer = /*#__PURE__*/ function() {\n    function AbstractRenderer(config) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AbstractRenderer);\n        this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;\n        this.plugins = [];\n        this.config = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n            /**\n       * only dirty object will cause re-render\n       */ enableDirtyCheck: true,\n            enableCulling: false,\n            /**\n       * enable auto rendering by default\n       */ enableAutoRendering: true,\n            /**\n       * enable dirty rectangle rendering by default\n       */ enableDirtyRectangleRendering: true,\n            enableDirtyRectangleRenderingDebug: false,\n            enableSizeAttenuation: true,\n            enableRenderingOptimization: false\n        }, config);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AbstractRenderer, [\n        {\n            key: \"registerPlugin\",\n            value: function registerPlugin(plugin) {\n                var index = this.plugins.findIndex(function(p) {\n                    return p === plugin;\n                });\n                if (index === -1) {\n                    this.plugins.push(plugin);\n                }\n            }\n        },\n        {\n            key: \"unregisterPlugin\",\n            value: function unregisterPlugin(plugin) {\n                var index = this.plugins.findIndex(function(p) {\n                    return p === plugin;\n                });\n                if (index > -1) {\n                    this.plugins.splice(index, 1);\n                }\n            }\n        },\n        {\n            key: \"getPlugins\",\n            value: function getPlugins() {\n                return this.plugins;\n            }\n        },\n        {\n            key: \"getPlugin\",\n            value: function getPlugin(name) {\n                return this.plugins.find(function(plugin) {\n                    return plugin.name === name;\n                });\n            }\n        },\n        {\n            key: \"getConfig\",\n            value: function getConfig() {\n                return this.config;\n            }\n        },\n        {\n            key: \"setConfig\",\n            value: function setConfig(config) {\n                Object.assign(this.config, config);\n            }\n        }\n    ]);\n}();\nvar addVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.add, copyVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy, maxVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.max, minVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.min, scaleVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.scale, subVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.sub;\n/**\n * Axis-Aligned Bounding Box\n * 为了便于后续 Frustum Culling，通过查找表定义 p-vertex 和 n-vertex\n * @see https://github.com/antvis/GWebGPUEngine/issues/3\n */ var AABB = /*#__PURE__*/ function() {\n    function AABB() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AABB);\n        this.center = [\n            0,\n            0,\n            0\n        ];\n        this.halfExtents = [\n            0,\n            0,\n            0\n        ];\n        this.min = [\n            0,\n            0,\n            0\n        ];\n        this.max = [\n            0,\n            0,\n            0\n        ];\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AABB, [\n        {\n            key: \"update\",\n            value: function update(center, halfExtents) {\n                copyVec3(this.center, center);\n                copyVec3(this.halfExtents, halfExtents);\n                subVec3(this.min, this.center, this.halfExtents);\n                addVec3(this.max, this.center, this.halfExtents);\n            }\n        },\n        {\n            key: \"setMinMax\",\n            value: function setMinMax(min, max) {\n                addVec3(this.center, max, min);\n                scaleVec3(this.center, this.center, 0.5);\n                subVec3(this.halfExtents, max, min);\n                scaleVec3(this.halfExtents, this.halfExtents, 0.5);\n                copyVec3(this.min, min);\n                copyVec3(this.max, max);\n            }\n        },\n        {\n            key: \"getMin\",\n            value: function getMin() {\n                return this.min;\n            }\n        },\n        {\n            key: \"getMax\",\n            value: function getMax() {\n                return this.max;\n            }\n        },\n        {\n            key: \"add\",\n            value: function add(aabb) {\n                if (AABB.isEmpty(aabb)) {\n                    return;\n                }\n                if (AABB.isEmpty(this)) {\n                    this.setMinMax(aabb.getMin(), aabb.getMax());\n                    return;\n                }\n                var tc = this.center;\n                var tcx = tc[0];\n                var tcy = tc[1];\n                var tcz = tc[2];\n                var th = this.halfExtents;\n                var thx = th[0];\n                var thy = th[1];\n                var thz = th[2];\n                var tminx = tcx - thx;\n                var tmaxx = tcx + thx;\n                var tminy = tcy - thy;\n                var tmaxy = tcy + thy;\n                var tminz = tcz - thz;\n                var tmaxz = tcz + thz;\n                var oc = aabb.center;\n                var ocx = oc[0];\n                var ocy = oc[1];\n                var ocz = oc[2];\n                var oh = aabb.halfExtents;\n                var ohx = oh[0];\n                var ohy = oh[1];\n                var ohz = oh[2];\n                var ominx = ocx - ohx;\n                var omaxx = ocx + ohx;\n                var ominy = ocy - ohy;\n                var omaxy = ocy + ohy;\n                var ominz = ocz - ohz;\n                var omaxz = ocz + ohz;\n                if (ominx < tminx) {\n                    tminx = ominx;\n                }\n                if (omaxx > tmaxx) {\n                    tmaxx = omaxx;\n                }\n                if (ominy < tminy) {\n                    tminy = ominy;\n                }\n                if (omaxy > tmaxy) {\n                    tmaxy = omaxy;\n                }\n                if (ominz < tminz) {\n                    tminz = ominz;\n                }\n                if (omaxz > tmaxz) {\n                    tmaxz = omaxz;\n                }\n                tc[0] = (tminx + tmaxx) * 0.5;\n                tc[1] = (tminy + tmaxy) * 0.5;\n                tc[2] = (tminz + tmaxz) * 0.5;\n                th[0] = (tmaxx - tminx) * 0.5;\n                th[1] = (tmaxy - tminy) * 0.5;\n                th[2] = (tmaxz - tminz) * 0.5;\n                this.min[0] = tminx;\n                this.min[1] = tminy;\n                this.min[2] = tminz;\n                this.max[0] = tmaxx;\n                this.max[1] = tmaxy;\n                this.max[2] = tmaxz;\n            }\n        },\n        {\n            key: \"setFromTransformedAABB\",\n            value: function setFromTransformedAABB(aabb, m) {\n                var bc = this.center;\n                var br = this.halfExtents;\n                var ac = aabb.center;\n                var ar = aabb.halfExtents;\n                var mx0 = m[0];\n                var mx1 = m[4];\n                var mx2 = m[8];\n                var my0 = m[1];\n                var my1 = m[5];\n                var my2 = m[9];\n                var mz0 = m[2];\n                var mz1 = m[6];\n                var mz2 = m[10];\n                var mx0a = Math.abs(mx0);\n                var mx1a = Math.abs(mx1);\n                var mx2a = Math.abs(mx2);\n                var my0a = Math.abs(my0);\n                var my1a = Math.abs(my1);\n                var my2a = Math.abs(my2);\n                var mz0a = Math.abs(mz0);\n                var mz1a = Math.abs(mz1);\n                var mz2a = Math.abs(mz2);\n                bc[0] = m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];\n                bc[1] = m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];\n                bc[2] = m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];\n                // vec3.set(\n                //   bc,\n                //   m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2],\n                //   m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2],\n                //   m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2],\n                // );\n                br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];\n                br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];\n                br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];\n                // vec3.set(\n                //   br,\n                //   mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2],\n                //   my0a * ar[0] + my1a * ar[1] + my2a * ar[2],\n                //   mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2],\n                // );\n                // this.min = vec3.sub(this.min, bc, br);\n                // this.max = vec3.add(this.max, bc, br);\n                subVec3(this.min, bc, br);\n                addVec3(this.max, bc, br);\n            }\n        },\n        {\n            key: \"intersects\",\n            value: function intersects(aabb) {\n                var aMax = this.getMax();\n                var aMin = this.getMin();\n                var bMax = aabb.getMax();\n                var bMin = aabb.getMin();\n                return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];\n            }\n        },\n        {\n            key: \"intersection\",\n            value: function intersection(aabb) {\n                if (!this.intersects(aabb)) {\n                    return null;\n                }\n                var intersection = new AABB();\n                var min = maxVec3([\n                    0,\n                    0,\n                    0\n                ], this.getMin(), aabb.getMin());\n                var max = minVec3([\n                    0,\n                    0,\n                    0\n                ], this.getMax(), aabb.getMax());\n                intersection.setMinMax(min, max);\n                return intersection;\n            }\n        },\n        {\n            key: \"getNegativeFarPoint\",\n            value: function getNegativeFarPoint(plane) {\n                if (plane.pnVertexFlag === 0x111) {\n                    return copyVec3([\n                        0,\n                        0,\n                        0\n                    ], this.min);\n                // return vec3.copy(vec3.create(), this.min);\n                }\n                if (plane.pnVertexFlag === 0x110) {\n                    return [\n                        this.min[0],\n                        this.min[1],\n                        this.max[2]\n                    ];\n                // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);\n                }\n                if (plane.pnVertexFlag === 0x101) {\n                    return [\n                        this.min[0],\n                        this.max[1],\n                        this.min[2]\n                    ];\n                // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);\n                }\n                if (plane.pnVertexFlag === 0x100) {\n                    return [\n                        this.min[0],\n                        this.max[1],\n                        this.max[2]\n                    ];\n                // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);\n                }\n                if (plane.pnVertexFlag === 0x011) {\n                    return [\n                        this.max[0],\n                        this.min[1],\n                        this.min[2]\n                    ];\n                // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);\n                }\n                if (plane.pnVertexFlag === 0x010) {\n                    return [\n                        this.max[0],\n                        this.min[1],\n                        this.max[2]\n                    ];\n                // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);\n                }\n                if (plane.pnVertexFlag === 0x001) {\n                    return [\n                        this.max[0],\n                        this.max[1],\n                        this.min[2]\n                    ];\n                // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);\n                }\n                return [\n                    this.max[0],\n                    this.max[1],\n                    this.max[2]\n                ];\n            // return vec3.fromValues(this.max[0], this.max[1], this.max[2]);\n            }\n        },\n        {\n            key: \"getPositiveFarPoint\",\n            value: function getPositiveFarPoint(plane) {\n                if (plane.pnVertexFlag === 0x111) {\n                    return copyVec3([\n                        0,\n                        0,\n                        0\n                    ], this.max);\n                // return vec3.copy(vec3.create(), this.max);\n                }\n                if (plane.pnVertexFlag === 0x110) {\n                    return [\n                        this.max[0],\n                        this.max[1],\n                        this.min[2]\n                    ];\n                // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);\n                }\n                if (plane.pnVertexFlag === 0x101) {\n                    return [\n                        this.max[0],\n                        this.min[1],\n                        this.max[2]\n                    ];\n                // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);\n                }\n                if (plane.pnVertexFlag === 0x100) {\n                    return [\n                        this.max[0],\n                        this.min[1],\n                        this.min[2]\n                    ];\n                // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);\n                }\n                if (plane.pnVertexFlag === 0x011) {\n                    return [\n                        this.min[0],\n                        this.max[1],\n                        this.max[2]\n                    ];\n                // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);\n                }\n                if (plane.pnVertexFlag === 0x010) {\n                    return [\n                        this.min[0],\n                        this.max[1],\n                        this.min[2]\n                    ];\n                // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);\n                }\n                if (plane.pnVertexFlag === 0x001) {\n                    return [\n                        this.min[0],\n                        this.min[1],\n                        this.max[2]\n                    ];\n                // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);\n                }\n                return [\n                    this.min[0],\n                    this.min[1],\n                    this.min[2]\n                ];\n            // return vec3.fromValues(this.min[0], this.min[1], this.min[2]);\n            }\n        }\n    ], [\n        {\n            key: \"isEmpty\",\n            value: function isEmpty(aabb) {\n                return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;\n            }\n        }\n    ]);\n}();\nvar Plane = /*#__PURE__*/ function() {\n    /**\n   * lookup table for p-vertex & n-vertex when doing frustum culling\n   */ function Plane(distance, normal) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Plane);\n        this.distance = distance || 0;\n        this.normal = normal || gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 1, 0);\n        this.updatePNVertexFlag();\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Plane, [\n        {\n            key: \"updatePNVertexFlag\",\n            value: function updatePNVertexFlag() {\n                this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);\n            }\n        },\n        {\n            key: \"distanceToPoint\",\n            value: function distanceToPoint(point) {\n                return gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(point, this.normal) - this.distance;\n            }\n        },\n        {\n            key: \"normalize\",\n            value: function normalize() {\n                var invLen = 1 / gl_matrix__WEBPACK_IMPORTED_MODULE_16__.len(this.normal);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.scale(this.normal, this.normal, invLen);\n                this.distance *= invLen;\n            }\n        },\n        {\n            key: \"intersectsLine\",\n            value: function intersectsLine(start, end, point) {\n                var d0 = this.distanceToPoint(start);\n                var d1 = this.distanceToPoint(end);\n                var t = d0 / (d0 - d1);\n                var intersects = t >= 0 && t <= 1;\n                if (intersects && point) {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.lerp(point, start, end, t);\n                }\n                return intersects;\n            }\n        }\n    ]);\n}();\nvar Mask = /*#__PURE__*/ function(Mask) {\n    Mask[Mask[\"OUTSIDE\"] = 4294967295] = \"OUTSIDE\";\n    Mask[Mask[\"INSIDE\"] = 0] = \"INSIDE\";\n    Mask[Mask[\"INDETERMINATE\"] = 2147483647] = \"INDETERMINATE\";\n    return Mask;\n}({});\nvar Frustum = /*#__PURE__*/ function() {\n    function Frustum(planes) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Frustum);\n        this.planes = [];\n        if (planes) {\n            this.planes = planes;\n        } else {\n            for(var i = 0; i < 6; i++){\n                this.planes.push(new Plane());\n            }\n        }\n    }\n    /**\n   * extract 6 planes from projectionMatrix\n   * @see http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf\n   */ return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Frustum, [\n        {\n            key: \"extractFromVPMatrix\",\n            value: function extractFromVPMatrix(projectionMatrix) {\n                // @ts-ignore\n                var _projectionMatrix = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m2 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];\n                // right\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);\n                this.planes[0].distance = m15 - m12;\n                // left\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);\n                this.planes[1].distance = m15 + m12;\n                // bottom\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);\n                this.planes[2].distance = m15 + m13;\n                // top\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);\n                this.planes[3].distance = m15 - m13;\n                // far\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);\n                this.planes[4].distance = m15 - m14;\n                // near\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);\n                this.planes[5].distance = m15 + m14;\n                this.planes.forEach(function(plane) {\n                    plane.normalize();\n                    plane.updatePNVertexFlag();\n                });\n            }\n        }\n    ]);\n}();\nvar Point = /*#__PURE__*/ function() {\n    function Point() {\n        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Point);\n        this.x = 0;\n        this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Point, [\n        {\n            key: \"clone\",\n            value: function clone() {\n                return new Point(this.x, this.y);\n            }\n        },\n        {\n            key: \"copyFrom\",\n            value: function copyFrom(p) {\n                this.x = p.x;\n                this.y = p.y;\n            }\n        }\n    ]);\n}();\nvar Rectangle = /*#__PURE__*/ function() {\n    function Rectangle(x, y, width, height) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Rectangle);\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.left = x;\n        this.right = x + width;\n        this.top = y;\n        this.bottom = y + height;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Rectangle, [\n        {\n            key: \"toJSON\",\n            value: function toJSON() {}\n        }\n    ], [\n        {\n            key: \"fromRect\",\n            value: /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static\n     */ function fromRect(rect) {\n                return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n            }\n        },\n        {\n            key: \"applyTransform\",\n            value: function applyTransform(rect, matrix) {\n                var topLeft = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.fromValues(rect.x, rect.y, 0, 1);\n                var topRight = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.fromValues(rect.x + rect.width, rect.y, 0, 1);\n                var bottomLeft = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.fromValues(rect.x, rect.y + rect.height, 0, 1);\n                var bottomRight = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.fromValues(rect.x + rect.width, rect.y + rect.height, 0, 1);\n                var transformedTopLeft = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create();\n                var transformedTopRight = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create();\n                var transformedBottomLeft = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create();\n                var transformedBottomRight = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create();\n                gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(transformedTopLeft, topLeft, matrix);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(transformedTopRight, topRight, matrix);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(transformedBottomLeft, bottomLeft, matrix);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(transformedBottomRight, bottomRight, matrix);\n                var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);\n                var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);\n                var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);\n                var maxY = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);\n                return Rectangle.fromRect({\n                    x: minX,\n                    y: minY,\n                    width: maxX - minX,\n                    height: maxY - minY\n                });\n            }\n        }\n    ]);\n}();\nvar ERROR_MSG_METHOD_NOT_IMPLEMENTED = \"Method not implemented.\";\nvar ERROR_MSG_USE_DOCUMENT_ELEMENT = \"Use document.documentElement instead.\";\nvar ERROR_MSG_APPEND_DESTROYED_ELEMENT = \"Cannot append a destroyed element.\";\nfunction getAngle(angle) {\n    if (angle === undefined) {\n        return 0;\n    }\n    if (angle > 360 || angle < -360) {\n        return angle % 360;\n    }\n    return angle;\n}\nvar $vec3$2 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nfunction createVec3(x) {\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (Array.isArray(x) && x.length === 3) {\n        return clone ? gl_matrix__WEBPACK_IMPORTED_MODULE_16__.clone(x) : gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy($vec3$2, x);\n    }\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(x)) {\n        return clone ? gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(x, y, z) : gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set($vec3$2, x, y, z);\n    }\n    return clone ? gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(x[0], x[1] || y, x[2] || z) : gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set($vec3$2, x[0], x[1] || y, x[2] || z);\n}\nvar DEG_RAD = Math.PI / 180;\nfunction deg2rad(deg) {\n    return deg * DEG_RAD;\n}\nvar RAD_DEG = 180 / Math.PI;\nfunction rad2deg(rad) {\n    return rad * RAD_DEG;\n}\nvar GRAD_DEG = 0.9; // 360 / 400;\nfunction grad2deg(grads) {\n    grads %= 400;\n    if (grads < 0) {\n        grads += 400;\n    }\n    return grads * GRAD_DEG;\n}\nfunction deg2turn(deg) {\n    return deg / 360;\n}\nfunction turn2deg(turn) {\n    return 360 * turn;\n}\nvar HALF_PI = Math.PI / 2;\nfunction getEulerFromQuat(out, quat) {\n    var x = quat[0];\n    var y = quat[1];\n    var z = quat[2];\n    var w = quat[3];\n    var x2 = x * x;\n    var y2 = y * y;\n    var z2 = z * z;\n    var w2 = w * w;\n    var unit = x2 + y2 + z2 + w2;\n    var test = x * w - y * z;\n    if (test > 0.499995 * unit) {\n        // TODO: Use glmatrix.EPSILON\n        // singularity at the north pole\n        out[0] = HALF_PI;\n        out[1] = 2 * Math.atan2(y, x);\n        out[2] = 0;\n    } else if (test < -0.499995 * unit) {\n        // TODO: Use glmatrix.EPSILON\n        // singularity at the south pole\n        out[0] = -HALF_PI;\n        out[1] = 2 * Math.atan2(y, x);\n        out[2] = 0;\n    } else {\n        out[0] = Math.asin(2 * (x * z - w * y));\n        out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));\n        out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));\n    }\n    // TODO: Return them as degrees and not as radians\n    return out;\n}\nfunction getEulerFromMat4(out, m) {\n    var x;\n    var z;\n    var _mat4$getScaling = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getScaling(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), m), _mat4$getScaling2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];\n    var y = Math.asin(-m[2] / sx);\n    if (y < HALF_PI) {\n        if (y > -HALF_PI) {\n            x = Math.atan2(m[6] / sy, m[10] / sz);\n            z = Math.atan2(m[1] / sx, m[0] / sx);\n        } else {\n            // Not a unique solution\n            z = 0;\n            x = -Math.atan2(m[4] / sy, m[5] / sy);\n        }\n    } else {\n        // Not a unique solution\n        z = 0;\n        x = Math.atan2(m[4] / sy, m[5] / sy);\n    }\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n}\n/**\n * @see https://github.com/toji/gl-matrix/issues/329\n * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\n */ function getEuler(out, quat) {\n    if (quat.length === 16) {\n        return getEulerFromMat4(out, quat);\n    }\n    return getEulerFromQuat(out, quat);\n}\nfunction fromRotationTranslationScale(rotation, x, y, scaleX, scaleY) {\n    var cos = Math.cos(rotation);\n    var sin = Math.sin(rotation);\n    return gl_matrix__WEBPACK_IMPORTED_MODULE_20__.fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);\n}\nfunction makePerspective(out, left, right, top, bottom, near, far) {\n    var zero = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n    var twoNear = 2 * near;\n    var rightMinusLeft = right - left;\n    var topMinusBottom = top - bottom;\n    var x = twoNear / rightMinusLeft;\n    var y = twoNear / topMinusBottom;\n    var a = (right + left) / rightMinusLeft;\n    var b = (top + bottom) / topMinusBottom;\n    var c;\n    var d;\n    var farMinusNear = far - near;\n    var farMulNear = far * near;\n    if (zero) {\n        c = -far / farMinusNear;\n        d = -farMulNear / farMinusNear;\n    } else {\n        c = -(far + near) / farMinusNear;\n        d = -2 * farMulNear / farMinusNear;\n    }\n    out[0] = x;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = y;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = a;\n    out[9] = b;\n    out[10] = c;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = d;\n    out[15] = 0;\n    return out;\n}\nfunction decompose(mat) {\n    var row0x = mat[0];\n    var row0y = mat[1];\n    var row1x = mat[3];\n    var row1y = mat[4];\n    // decompose 3x3 matrix\n    // @see https://www.w3.org/TR/css-transforms-1/#decomposing-a-2d-matrix\n    var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);\n    var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);\n    // If determinant is negative, one axis was flipped.\n    var determinant = row0x * row1y - row0y * row1x;\n    if (determinant < 0) {\n        // Flip axis with minimum unit vector dot product.\n        if (row0x < row1y) {\n            scalingX = -scalingX;\n        } else {\n            scalingY = -scalingY;\n        }\n    }\n    // Renormalize matrix to remove scale.\n    if (scalingX) {\n        var invScalingX = 1 / scalingX;\n        row0x *= invScalingX;\n        row0y *= invScalingX;\n    }\n    if (scalingY) {\n        var invScalingY = 1 / scalingY;\n        row1x *= invScalingY;\n        row1y *= invScalingY;\n    }\n    // Compute rotation and renormalize matrix.\n    var rotation = Math.atan2(row0y, row0x);\n    var angle = rad2deg(rotation);\n    return [\n        mat[6],\n        mat[7],\n        scalingX,\n        scalingY,\n        angle\n    ];\n}\nvar tmp = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\nvar perspectiveMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\nvar tmpVec4 = gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create();\nvar row = [\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(),\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(),\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create()\n];\nvar pdum3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\n/*\nInput:  matrix      ; a 4x4 matrix\nOutput: translation ; a 3 component vector\n        scale       ; a 3 component vector\n        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector\n        perspective ; a 4 component vector\n        quaternion  ; a 4 component vector\nReturns false if the matrix cannot be decomposed, true if it can\n\n\nReferences:\nhttps://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js\nhttps://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc\nhttp://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix\n*/ function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {\n    // normalize, if not possible then bail out early\n    if (!normalize(tmp, matrix)) return false;\n    // perspectiveMatrix is used to solve for perspective, but it also provides\n    // an easy way to test for singularity of the upper 3x3 component.\n    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.copy(perspectiveMatrix, tmp);\n    perspectiveMatrix[3] = 0;\n    perspectiveMatrix[7] = 0;\n    perspectiveMatrix[11] = 0;\n    perspectiveMatrix[15] = 1;\n    // If the perspectiveMatrix is not invertible, we are also unable to\n    // decompose, so we'll bail early. Constant taken from SkMatrix44::invert.\n    if (Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.determinant(perspectiveMatrix)) < 1e-8) return false;\n    var a03 = tmp[3];\n    var a13 = tmp[7];\n    var a23 = tmp[11];\n    var a30 = tmp[12];\n    var a31 = tmp[13];\n    var a32 = tmp[14];\n    var a33 = tmp[15];\n    // First, isolate perspective.\n    if (a03 !== 0 || a13 !== 0 || a23 !== 0) {\n        tmpVec4[0] = a03;\n        tmpVec4[1] = a13;\n        tmpVec4[2] = a23;\n        tmpVec4[3] = a33;\n        // Solve the equation by inverting perspectiveMatrix and multiplying\n        // rightHandSide by the inverse.\n        // resuing the perspectiveMatrix here since it's no longer needed\n        var ret = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert(perspectiveMatrix, perspectiveMatrix);\n        if (!ret) return false;\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.transpose(perspectiveMatrix, perspectiveMatrix);\n        // multiply by transposed inverse perspective matrix, into perspective vec4\n        gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(perspective, tmpVec4, perspectiveMatrix);\n    } else {\n        // no perspective\n        perspective[0] = perspective[1] = perspective[2] = 0;\n        perspective[3] = 1;\n    }\n    // Next take care of translation\n    translation[0] = a30;\n    translation[1] = a31;\n    translation[2] = a32;\n    // Now get scale and shear. 'row' is a 3 element array of 3 component vectors\n    mat3from4(row, tmp);\n    // Compute X scale factor and normalize first row.\n    scale[0] = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(row[0]);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.normalize(row[0], row[0]);\n    // Compute XY shear factor and make 2nd row orthogonal to 1st.\n    skew[0] = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(row[0], row[1]);\n    combine(row[1], row[1], row[0], 1.0, -skew[0]);\n    // Now, compute Y scale and normalize 2nd row.\n    scale[1] = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(row[1]);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.normalize(row[1], row[1]);\n    skew[0] /= scale[1];\n    // Compute XZ and YZ shears, orthogonalize 3rd row\n    skew[1] = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(row[0], row[2]);\n    combine(row[2], row[2], row[0], 1.0, -skew[1]);\n    skew[2] = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(row[1], row[2]);\n    combine(row[2], row[2], row[1], 1.0, -skew[2]);\n    // Next, get Z scale and normalize 3rd row.\n    scale[2] = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(row[2]);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.normalize(row[2], row[2]);\n    skew[1] /= scale[2];\n    skew[2] /= scale[2];\n    // At this point, the matrix (in rows) is orthonormal.\n    // Check for a coordinate system flip.  If the determinant\n    // is -1, then negate the matrix and the scaling factors.\n    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.cross(pdum3, row[1], row[2]);\n    if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(row[0], pdum3) < 0) {\n        for(var i = 0; i < 3; i++){\n            scale[i] *= -1;\n            row[i][0] *= -1;\n            row[i][1] *= -1;\n            row[i][2] *= -1;\n        }\n    }\n    // Now, get the rotations out\n    quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));\n    quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));\n    quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));\n    quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));\n    if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];\n    if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];\n    if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];\n    return true;\n}\nfunction normalize(out, mat) {\n    var m44 = mat[15];\n    // Cannot normalize.\n    if (m44 === 0) return false;\n    var scale = 1 / m44;\n    for(var i = 0; i < 16; i++)out[i] = mat[i] * scale;\n    return true;\n}\n// gets upper-left of a 4x4 matrix into a 3x3 of vectors\nfunction mat3from4(out, mat4x4) {\n    out[0][0] = mat4x4[0];\n    out[0][1] = mat4x4[1];\n    out[0][2] = mat4x4[2];\n    out[1][0] = mat4x4[4];\n    out[1][1] = mat4x4[5];\n    out[1][2] = mat4x4[6];\n    out[2][0] = mat4x4[8];\n    out[2][1] = mat4x4[9];\n    out[2][2] = mat4x4[10];\n}\nfunction combine(out, a, b, scale1, scale2) {\n    out[0] = a[0] * scale1 + b[0] * scale2;\n    out[1] = a[1] * scale1 + b[1] * scale2;\n    out[2] = a[2] * scale1 + b[2] * scale2;\n}\n/**\n * Different type of cameras, eg. simple camera used in 2D scene or\n * advanced camera which can do actions & switch between landmarks.\n */ var CameraType = /*#__PURE__*/ function(CameraType) {\n    /**\n   * Performs all the rotational operations with the focal point instead of the camera position.\n   * This type of camera is useful in applications(like CAD) where 3D objects are being designed or explored.\n   * Camera cannot orbits over the north & south poles.\n   * @see http://voxelent.com/tutorial-cameras/\n   *\n   * In Three.js it's used in OrbitControls.\n   * @see https://threejs.org/docs/#examples/zh/controls/OrbitControls\n   */ CameraType[CameraType[\"ORBITING\"] = 0] = \"ORBITING\";\n    /**\n   * It's similar to the ORBITING camera, but it allows the camera to orbit over the north or south poles.\n   *\n   * In Three.js it's used in OrbitControls.\n   * @see https://threejs.org/docs/#examples/en/controls/TrackballControls\n   */ CameraType[CameraType[\"EXPLORING\"] = 1] = \"EXPLORING\";\n    /**\n   * Performs all the rotational operations with the camera position.\n   * It's useful in first person shooting games.\n   * Camera cannot orbits over the north & south poles.\n   *\n   * In Three.js it's used in FirstPersonControls.\n   * @see https://threejs.org/docs/#examples/en/controls/FirstPersonControls\n   */ CameraType[CameraType[\"TRACKING\"] = 2] = \"TRACKING\";\n    return CameraType;\n}({});\n/**\n * CameraType must be TRACKING\n */ var CameraTrackingMode = /*#__PURE__*/ function(CameraTrackingMode) {\n    CameraTrackingMode[CameraTrackingMode[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    CameraTrackingMode[CameraTrackingMode[\"ROTATIONAL\"] = 1] = \"ROTATIONAL\";\n    CameraTrackingMode[CameraTrackingMode[\"TRANSLATIONAL\"] = 2] = \"TRANSLATIONAL\";\n    CameraTrackingMode[CameraTrackingMode[\"CINEMATIC\"] = 3] = \"CINEMATIC\";\n    return CameraTrackingMode;\n}({});\nvar CameraProjectionMode = /*#__PURE__*/ function(CameraProjectionMode) {\n    CameraProjectionMode[CameraProjectionMode[\"ORTHOGRAPHIC\"] = 0] = \"ORTHOGRAPHIC\";\n    CameraProjectionMode[CameraProjectionMode[\"PERSPECTIVE\"] = 1] = \"PERSPECTIVE\";\n    return CameraProjectionMode;\n}({});\nvar CameraEvent = {\n    UPDATED: \"updated\"\n};\nvar MIN_DISTANCE = 0.0002;\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * @see https://github.com/d13g0/nucleo.js/blob/master/source/camera/Camera.js\n *\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */ var Camera = /*#__PURE__*/ function() {\n    function Camera() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Camera);\n        /**\n     * Clip space near Z, default to range `[-1, 1]`\n     */ this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;\n        this.eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n        /**\n     * Matrix of camera\n     */ this.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n        /**\n     * u axis +X is right\n     * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition\n     */ this.right = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(1, 0, 0);\n        /**\n     * v axis +Y is up\n     */ this.up = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 1, 0);\n        /**\n     * n axis +Z is inside\n     */ this.forward = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 0, 1);\n        /**\n     * Position of camera.\n     */ this.position = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 0, 1);\n        /**\n     * Position of focal point.\n     */ this.focalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 0, 0);\n        /**\n     * vector from focalPoint to position\n     */ this.distanceVector = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 0, -1);\n        /**\n     * length(focalPoint - position)\n     */ this.distance = 1;\n        /**\n     * @see https://en.wikipedia.org/wiki/Azimuth\n     */ this.azimuth = 0;\n        this.elevation = 0;\n        this.roll = 0;\n        this.relAzimuth = 0;\n        this.relElevation = 0;\n        this.relRoll = 0;\n        /**\n     * 沿 n 轴移动时，保证移动速度从快到慢\n     */ this.dollyingStep = 0;\n        this.maxDistance = Infinity;\n        this.minDistance = -Infinity;\n        /**\n     * zoom factor of the camera, default is 1\n     * eg. https://threejs.org/docs/#api/en/cameras/OrthographicCamera.zoom\n     */ this.zoom = 1;\n        /**\n     * invert the horizontal coordinate system HCS\n     */ this.rotateWorld = false;\n        /**\n     * 投影矩阵参数\n     */ /**\n     * field of view [0-360]\n     * @see http://en.wikipedia.org/wiki/Angle_of_view\n     */ this.fov = 30;\n        this.near = 0.1;\n        this.far = 1000;\n        this.aspect = 1;\n        this.projectionMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n        this.projectionMatrixInverse = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n        this.jitteredProjectionMatrix = undefined;\n        this.enableUpdate = true;\n        // protected following = undefined;\n        this.type = CameraType.EXPLORING;\n        this.trackingMode = CameraTrackingMode.DEFAULT;\n        this.projectionMode = CameraProjectionMode.PERSPECTIVE;\n        /**\n     * for culling use\n     */ this.frustum = new Frustum();\n        /**\n     * ortho matrix for Canvas2D & SVG\n     */ this.orthoMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Camera, [\n        {\n            key: \"isOrtho\",\n            value: // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {\n            //   this.setType(type, trackingMode);\n            // }\n            function isOrtho() {\n                return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;\n            }\n        },\n        {\n            key: \"getProjectionMode\",\n            value: function getProjectionMode() {\n                return this.projectionMode;\n            }\n        },\n        {\n            key: \"getPerspective\",\n            value: function getPerspective() {\n                // account for TAA\n                return this.jitteredProjectionMatrix || this.projectionMatrix;\n            }\n        },\n        {\n            key: \"getPerspectiveInverse\",\n            value: function getPerspectiveInverse() {\n                return this.projectionMatrixInverse;\n            }\n        },\n        {\n            key: \"getFrustum\",\n            value: function getFrustum() {\n                return this.frustum;\n            }\n        },\n        {\n            key: \"getPosition\",\n            value: function getPosition() {\n                return this.position;\n            }\n        },\n        {\n            key: \"getFocalPoint\",\n            value: function getFocalPoint() {\n                return this.focalPoint;\n            }\n        },\n        {\n            key: \"getDollyingStep\",\n            value: function getDollyingStep() {\n                return this.dollyingStep;\n            }\n        },\n        {\n            key: \"getNear\",\n            value: function getNear() {\n                return this.near;\n            }\n        },\n        {\n            key: \"getFar\",\n            value: function getFar() {\n                return this.far;\n            }\n        },\n        {\n            key: \"getZoom\",\n            value: function getZoom() {\n                return this.zoom;\n            }\n        },\n        {\n            key: \"getOrthoMatrix\",\n            value: function getOrthoMatrix() {\n                return this.orthoMatrix;\n            }\n        },\n        {\n            key: \"getView\",\n            value: function getView() {\n                return this.view;\n            }\n        },\n        {\n            key: \"setEnableUpdate\",\n            value: function setEnableUpdate(enabled) {\n                this.enableUpdate = enabled;\n            }\n        },\n        {\n            key: \"setType\",\n            value: function setType(type, trackingMode) {\n                this.type = type;\n                if (this.type === CameraType.EXPLORING) {\n                    this.setWorldRotation(true);\n                } else {\n                    this.setWorldRotation(false);\n                }\n                this._getAngles();\n                if (this.type === CameraType.TRACKING && trackingMode !== undefined) {\n                    this.setTrackingMode(trackingMode);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setProjectionMode\",\n            value: function setProjectionMode(projectionMode) {\n                this.projectionMode = projectionMode;\n                return this;\n            }\n        },\n        {\n            key: \"setTrackingMode\",\n            value: function setTrackingMode(trackingMode) {\n                if (this.type !== CameraType.TRACKING) {\n                    throw new Error(\"Impossible to set a tracking mode if the camera is not of tracking type\");\n                }\n                this.trackingMode = trackingMode;\n                return this;\n            }\n        },\n        {\n            key: \"setWorldRotation\",\n            value: function setWorldRotation(flag) {\n                this.rotateWorld = flag;\n                this._getAngles();\n                return this;\n            }\n        },\n        {\n            key: \"getViewTransform\",\n            value: function getViewTransform() {\n                // mat4.scale(this.matrix, this.matrix, vec3.fromValues(1, -1, 1));\n                return gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), this.matrix);\n            }\n        },\n        {\n            key: \"getWorldTransform\",\n            value: function getWorldTransform() {\n                return this.matrix;\n            }\n        },\n        {\n            key: \"jitterProjectionMatrix\",\n            value: function jitterProjectionMatrix(x, y) {\n                var translation = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), [\n                    x,\n                    y,\n                    0\n                ]);\n                this.jitteredProjectionMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), translation, this.projectionMatrix);\n            }\n        },\n        {\n            key: \"clearJitterProjectionMatrix\",\n            value: function clearJitterProjectionMatrix() {\n                this.jitteredProjectionMatrix = undefined;\n            }\n        },\n        {\n            key: \"setMatrix\",\n            value: function setMatrix(matrix) {\n                this.matrix = matrix;\n                this._update();\n                return this;\n            }\n        },\n        {\n            key: \"setProjectionMatrix\",\n            value: function setProjectionMatrix(matrix) {\n                this.projectionMatrix = matrix;\n            }\n        },\n        {\n            key: \"setFov\",\n            value: function setFov(fov) {\n                this.setPerspective(this.near, this.far, fov, this.aspect);\n                return this;\n            }\n        },\n        {\n            key: \"setAspect\",\n            value: function setAspect(aspect) {\n                this.setPerspective(this.near, this.far, this.fov, aspect);\n                return this;\n            }\n        },\n        {\n            key: \"setNear\",\n            value: function setNear(near) {\n                if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {\n                    this.setPerspective(near, this.far, this.fov, this.aspect);\n                } else {\n                    this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setFar\",\n            value: function setFar(far) {\n                if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {\n                    this.setPerspective(this.near, far, this.fov, this.aspect);\n                } else {\n                    this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setViewOffset\",\n            value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n                this.aspect = fullWidth / fullHeight;\n                if (this.view === undefined) {\n                    this.view = {\n                        enabled: true,\n                        fullWidth: 1,\n                        fullHeight: 1,\n                        offsetX: 0,\n                        offsetY: 0,\n                        width: 1,\n                        height: 1\n                    };\n                }\n                this.view.enabled = true;\n                this.view.fullWidth = fullWidth;\n                this.view.fullHeight = fullHeight;\n                this.view.offsetX = x;\n                this.view.offsetY = y;\n                this.view.width = width;\n                this.view.height = height;\n                if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {\n                    this.setPerspective(this.near, this.far, this.fov, this.aspect);\n                } else {\n                    this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"clearViewOffset\",\n            value: function clearViewOffset() {\n                if (this.view !== undefined) {\n                    this.view.enabled = false;\n                }\n                if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {\n                    this.setPerspective(this.near, this.far, this.fov, this.aspect);\n                } else {\n                    this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setZoom\",\n            value: function setZoom(zoom) {\n                this.zoom = zoom;\n                if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {\n                    this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n                } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {\n                    this.setPerspective(this.near, this.far, this.fov, this.aspect);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setZoomByViewportPoint\",\n            value: function setZoomByViewportPoint(zoom, viewportPoint) {\n                var _this$canvas$viewport = this.canvas.viewport2Canvas({\n                    x: viewportPoint[0],\n                    y: viewportPoint[1]\n                }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;\n                var roll = this.roll;\n                this.rotate(0, 0, -roll);\n                this.setPosition(ox, oy);\n                this.setFocalPoint(ox, oy);\n                this.setZoom(zoom);\n                this.rotate(0, 0, roll);\n                var _this$canvas$viewport2 = this.canvas.viewport2Canvas({\n                    x: viewportPoint[0],\n                    y: viewportPoint[1]\n                }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;\n                // project to rotated axis\n                var dvec = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cx - ox, cy - oy, 0);\n                var dx = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(dvec, this.right) / gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(this.right);\n                var dy = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(dvec, this.up) / gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(this.up);\n                var _this$getPosition = this.getPosition(), _this$getPosition2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_this$getPosition, 2), px = _this$getPosition2[0], py = _this$getPosition2[1];\n                var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];\n                this.setPosition(px - dx, py - dy);\n                this.setFocalPoint(fx - dx, fy - dy);\n                return this;\n            }\n        },\n        {\n            key: \"setPerspective\",\n            value: function setPerspective(near, far, fov, aspect) {\n                var _this$view;\n                this.projectionMode = CameraProjectionMode.PERSPECTIVE;\n                this.fov = fov;\n                this.near = near;\n                this.far = far;\n                this.aspect = aspect;\n                var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;\n                var height = 2 * top;\n                var width = this.aspect * height;\n                var left = -0.5 * width;\n                if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {\n                    var fullWidth = this.view.fullWidth;\n                    var fullHeight = this.view.fullHeight;\n                    left += this.view.offsetX * width / fullWidth;\n                    top -= this.view.offsetY * height / fullHeight;\n                    width *= this.view.width / fullWidth;\n                    height *= this.view.height / fullHeight;\n                }\n                makePerspective(this.projectionMatrix, left, left + width, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert(this.projectionMatrixInverse, this.projectionMatrix);\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"setOrthographic\",\n            value: function setOrthographic(l, r, t, b, near, far) {\n                var _this$view2;\n                this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;\n                this.rright = r;\n                this.left = l;\n                this.top = t;\n                this.bottom = b;\n                this.near = near;\n                this.far = far;\n                var dx = (this.rright - this.left) / (2 * this.zoom);\n                var dy = (this.top - this.bottom) / (2 * this.zoom);\n                var cx = (this.rright + this.left) / 2;\n                var cy = (this.top + this.bottom) / 2;\n                var left = cx - dx;\n                var right = cx + dx;\n                var top = cy + dy;\n                var bottom = cy - dy;\n                if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {\n                    var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;\n                    var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n                    left += scaleW * this.view.offsetX;\n                    right = left + scaleW * this.view.width;\n                    top -= scaleH * this.view.offsetY;\n                    bottom = top - scaleH * this.view.height;\n                }\n                if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {\n                    // FlipY with switching bottom & top.\n                    // @see https://stackoverflow.com/a/4886656\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.ortho(this.projectionMatrix, left, right, top, bottom, near, far);\n                } else {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.orthoZO(this.projectionMatrix, left, right, top, bottom, near, far);\n                }\n                gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert(this.projectionMatrixInverse, this.projectionMatrix);\n                this._getOrthoMatrix();\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"setPosition\",\n            value: function setPosition(x) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.position[1];\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.position[2];\n                var position = createVec3(x, y, z);\n                this._setPosition(position);\n                this.setFocalPoint(this.focalPoint);\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"setFocalPoint\",\n            value: function setFocalPoint(x) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.focalPoint[1];\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.focalPoint[2];\n                var up = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(0, 1, 0);\n                this.focalPoint = createVec3(x, y, z);\n                if (this.trackingMode === CameraTrackingMode.CINEMATIC) {\n                    var d = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), this.focalPoint, this.position);\n                    x = d[0];\n                    y = d[1];\n                    z = d[2];\n                    var r = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(d);\n                    var el = rad2deg(Math.asin(y / r));\n                    var az = 90 + rad2deg(Math.atan2(z, x));\n                    var m = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.rotateY(m, m, deg2rad(az));\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.rotateX(m, m, deg2rad(el));\n                    up = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), [\n                        0,\n                        1,\n                        0\n                    ], m);\n                }\n                gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert(this.matrix, gl_matrix__WEBPACK_IMPORTED_MODULE_19__.lookAt(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), this.position, this.focalPoint, up));\n                this._getAxes();\n                this._getDistance();\n                this._getAngles();\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"getDistance\",\n            value: function getDistance() {\n                return this.distance;\n            }\n        },\n        {\n            key: \"getDistanceVector\",\n            value: function getDistanceVector() {\n                return this.distanceVector;\n            }\n        },\n        {\n            key: \"setDistance\",\n            value: function setDistance(d) {\n                if (this.distance === d || d < 0) {\n                    return this;\n                }\n                this.distance = d;\n                if (this.distance < MIN_DISTANCE) {\n                    this.distance = MIN_DISTANCE;\n                }\n                this.dollyingStep = this.distance / 100;\n                var pos = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\n                d = this.distance;\n                var n = this.forward;\n                var f = this.focalPoint;\n                pos[0] = d * n[0] + f[0];\n                pos[1] = d * n[1] + f[1];\n                pos[2] = d * n[2] + f[2];\n                this._setPosition(pos);\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"setMaxDistance\",\n            value: function setMaxDistance(d) {\n                this.maxDistance = d;\n                return this;\n            }\n        },\n        {\n            key: \"setMinDistance\",\n            value: function setMinDistance(d) {\n                this.minDistance = d;\n                return this;\n            }\n        },\n        {\n            key: \"setAzimuth\",\n            value: function setAzimuth(az) {\n                this.azimuth = getAngle(az);\n                this.computeMatrix();\n                this._getAxes();\n                if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {\n                    this._getPosition();\n                } else if (this.type === CameraType.TRACKING) {\n                    this._getFocalPoint();\n                }\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"getAzimuth\",\n            value: function getAzimuth() {\n                return this.azimuth;\n            }\n        },\n        {\n            key: \"setElevation\",\n            value: function setElevation(el) {\n                this.elevation = getAngle(el);\n                this.computeMatrix();\n                this._getAxes();\n                if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {\n                    this._getPosition();\n                } else if (this.type === CameraType.TRACKING) {\n                    this._getFocalPoint();\n                }\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"getElevation\",\n            value: function getElevation() {\n                return this.elevation;\n            }\n        },\n        {\n            key: \"setRoll\",\n            value: function setRoll(angle) {\n                this.roll = getAngle(angle);\n                this.computeMatrix();\n                this._getAxes();\n                if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {\n                    this._getPosition();\n                } else if (this.type === CameraType.TRACKING) {\n                    this._getFocalPoint();\n                }\n                this.triggerUpdate();\n                return this;\n            }\n        },\n        {\n            key: \"getRoll\",\n            value: function getRoll() {\n                return this.roll;\n            }\n        },\n        {\n            key: \"_update\",\n            value: function _update() {\n                this._getAxes();\n                this._getPosition();\n                this._getDistance();\n                this._getAngles();\n                this._getOrthoMatrix();\n                this.triggerUpdate();\n            }\n        },\n        {\n            key: \"computeMatrix\",\n            value: function computeMatrix() {\n                // 使用四元数描述 3D 旋转\n                // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n                var rotZ = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create(), [\n                    0,\n                    0,\n                    1\n                ], deg2rad(this.roll));\n                gl_matrix__WEBPACK_IMPORTED_MODULE_19__.identity(this.matrix);\n                // only consider HCS for EXPLORING and ORBITING cameras\n                var rotX = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create(), [\n                    1,\n                    0,\n                    0\n                ], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));\n                var rotY = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create(), [\n                    0,\n                    1,\n                    0\n                ], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));\n                var rotQ = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.multiply(gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create(), rotY, rotX);\n                rotQ = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.multiply(gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create(), rotQ, rotZ);\n                var rotMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromQuat(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), rotQ);\n                if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.translate(this.matrix, this.matrix, this.focalPoint);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(this.matrix, this.matrix, rotMatrix);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.translate(this.matrix, this.matrix, [\n                        0,\n                        0,\n                        this.distance\n                    ]);\n                } else if (this.type === CameraType.TRACKING) {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.translate(this.matrix, this.matrix, this.position);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(this.matrix, this.matrix, rotMatrix);\n                }\n            }\n        },\n        {\n            key: \"_setPosition\",\n            value: function _setPosition(x, y, z) {\n                this.position = createVec3(x, y, z);\n                var m = this.matrix;\n                m[12] = this.position[0];\n                m[13] = this.position[1];\n                m[14] = this.position[2];\n                m[15] = 1;\n                this._getOrthoMatrix();\n            }\n        },\n        {\n            key: \"_getAxes\",\n            value: function _getAxes() {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(this.right, createVec3(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create(), [\n                    1,\n                    0,\n                    0,\n                    0\n                ], this.matrix)));\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(this.up, createVec3(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create(), [\n                    0,\n                    1,\n                    0,\n                    0\n                ], this.matrix)));\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(this.forward, createVec3(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create(), [\n                    0,\n                    0,\n                    1,\n                    0\n                ], this.matrix)));\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.normalize(this.right, this.right);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.normalize(this.up, this.up);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.normalize(this.forward, this.forward);\n            }\n        },\n        {\n            key: \"_getAngles\",\n            value: function _getAngles() {\n                // Recalculates angles\n                var x = this.distanceVector[0];\n                var y = this.distanceVector[1];\n                var z = this.distanceVector[2];\n                var r = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(this.distanceVector);\n                // FAST FAIL: If there is no distance we cannot compute angles\n                if (r === 0) {\n                    this.elevation = 0;\n                    this.azimuth = 0;\n                    return;\n                }\n                if (this.type === CameraType.TRACKING) {\n                    this.elevation = rad2deg(Math.asin(y / r));\n                    this.azimuth = rad2deg(Math.atan2(-x, -z));\n                } else if (this.rotateWorld) {\n                    this.elevation = rad2deg(Math.asin(y / r));\n                    this.azimuth = rad2deg(Math.atan2(-x, -z));\n                } else {\n                    this.elevation = -rad2deg(Math.asin(y / r));\n                    this.azimuth = -rad2deg(Math.atan2(-x, -z));\n                }\n            }\n        },\n        {\n            key: \"_getPosition\",\n            value: function _getPosition() {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(this.position, createVec3(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_17__.create(), [\n                    0,\n                    0,\n                    0,\n                    1\n                ], this.matrix)));\n                // 相机位置变化，需要重新计算视距\n                this._getDistance();\n            }\n        },\n        {\n            key: \"_getFocalPoint\",\n            value: function _getFocalPoint() {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat3(this.distanceVector, [\n                    0,\n                    0,\n                    -this.distance\n                ], gl_matrix__WEBPACK_IMPORTED_MODULE_20__.fromMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_20__.create(), this.matrix));\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.add(this.focalPoint, this.position, this.distanceVector);\n                // 视点变化，需要重新计算视距\n                this._getDistance();\n            }\n        },\n        {\n            key: \"_getDistance\",\n            value: function _getDistance() {\n                this.distanceVector = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), this.focalPoint, this.position);\n                this.distance = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.length(this.distanceVector);\n                this.dollyingStep = this.distance / 100;\n            }\n        },\n        {\n            key: \"_getOrthoMatrix\",\n            value: function _getOrthoMatrix() {\n                if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {\n                    return;\n                }\n                var position = this.position;\n                var rotZ = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create(), [\n                    0,\n                    0,\n                    1\n                ], -this.roll * Math.PI / 180);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(this.zoom, this.zoom, 1), position);\n            }\n        },\n        {\n            key: \"triggerUpdate\",\n            value: function triggerUpdate() {\n                if (this.enableUpdate) {\n                    // update frustum\n                    var viewMatrix = this.getViewTransform();\n                    var vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), this.getPerspective(), viewMatrix);\n                    this.getFrustum().extractFromVPMatrix(vpMatrix);\n                    this.eventEmitter.emit(CameraEvent.UPDATED);\n                }\n            }\n        },\n        {\n            key: \"rotate\",\n            value: function rotate(azimuth, elevation, roll) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"pan\",\n            value: function pan(tx, ty) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"dolly\",\n            value: function dolly(value) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"createLandmark\",\n            value: function createLandmark(name, params) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"gotoLandmark\",\n            value: function gotoLandmark(name, options) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"cancelLandmarkAnimation\",\n            value: function cancelLandmarkAnimation() {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        }\n    ]);\n}();\n/**\n * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy\n */ var Strategy = /*#__PURE__*/ function(Strategy) {\n    Strategy[Strategy[\"Standard\"] = 0] = \"Standard\";\n    return Strategy;\n}({});\nvar SortReason = /*#__PURE__*/ function(SortReason) {\n    SortReason[SortReason[\"ADDED\"] = 0] = \"ADDED\";\n    SortReason[SortReason[\"REMOVED\"] = 1] = \"REMOVED\";\n    SortReason[SortReason[\"Z_INDEX_CHANGED\"] = 2] = \"Z_INDEX_CHANGED\";\n    return SortReason;\n}({});\nvar EMPTY_PARSED_PATH = {\n    absolutePath: [],\n    hasArc: false,\n    segments: [],\n    polygons: [],\n    polylines: [],\n    curve: null,\n    totalLength: 0,\n    rect: new Rectangle(0, 0, 0, 0)\n};\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type\n */ var PropertySyntax = /*#__PURE__*/ function(PropertySyntax) {\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#coordinate\n   */ PropertySyntax[\"COORDINATE\"] = \"<coordinate>\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#color\n   */ PropertySyntax[\"COLOR\"] = \"<color>\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#paint\n   */ PropertySyntax[\"PAINT\"] = \"<paint>\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#number\n   */ PropertySyntax[\"NUMBER\"] = \"<number>\";\n    /**\n   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle\n   */ PropertySyntax[\"ANGLE\"] = \"<angle>\";\n    /**\n   * <number> with range 0..1\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#opacity_value\n   */ PropertySyntax[\"OPACITY_VALUE\"] = \"<opacity-value>\";\n    /**\n   * <number> with range 0..Infinity\n   */ PropertySyntax[\"SHADOW_BLUR\"] = \"<shadow-blur>\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#length\n   */ PropertySyntax[\"LENGTH\"] = \"<length>\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#percentage\n   */ PropertySyntax[\"PERCENTAGE\"] = \"<percentage>\";\n    PropertySyntax[\"LENGTH_PERCENTAGE\"] = \"<length> | <percentage>\";\n    PropertySyntax[\"LENGTH_PERCENTAGE_12\"] = \"[<length> | <percentage>]{1,2}\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/margin#formal_syntax\n   */ PropertySyntax[\"LENGTH_PERCENTAGE_14\"] = \"[<length> | <percentage>]{1,4}\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#list-of-ts\n   */ PropertySyntax[\"LIST_OF_POINTS\"] = \"<list-of-points>\";\n    PropertySyntax[\"PATH\"] = \"<path>\";\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/filter#formal_syntax\n   */ PropertySyntax[\"FILTER\"] = \"<filter>\";\n    PropertySyntax[\"Z_INDEX\"] = \"<z-index>\";\n    PropertySyntax[\"OFFSET_DISTANCE\"] = \"<offset-distance>\";\n    PropertySyntax[\"DEFINED_PATH\"] = \"<defined-path>\";\n    PropertySyntax[\"MARKER\"] = \"<marker>\";\n    PropertySyntax[\"TRANSFORM\"] = \"<transform>\";\n    PropertySyntax[\"TRANSFORM_ORIGIN\"] = \"<transform-origin>\";\n    PropertySyntax[\"TEXT\"] = \"<text>\";\n    PropertySyntax[\"TEXT_TRANSFORM\"] = \"<text-transform>\";\n    return PropertySyntax;\n}({});\nfunction define(constructor, factory, prototype) {\n    constructor.prototype = factory.prototype = prototype;\n    prototype.constructor = constructor;\n}\nfunction extend(parent, definition) {\n    var prototype = Object.create(parent.prototype);\n    for(var key in definition)prototype[key] = definition[key];\n    return prototype;\n}\nfunction Color() {}\nvar darker = 0.7;\nvar brighter = 1 / darker;\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\", reN = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\", reP = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\\\(${reI},${reI},${reI}\\\\)$`), reRgbPercent = new RegExp(`^rgb\\\\(${reP},${reP},${reP}\\\\)$`), reRgbaInteger = new RegExp(`^rgba\\\\(${reI},${reI},${reI},${reN}\\\\)$`), reRgbaPercent = new RegExp(`^rgba\\\\(${reP},${reP},${reP},${reN}\\\\)$`), reHslPercent = new RegExp(`^hsl\\\\(${reN},${reP},${reP}\\\\)$`), reHslaPercent = new RegExp(`^hsla\\\\(${reN},${reP},${reP},${reN}\\\\)$`);\nvar named = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n};\ndefine(Color, color, {\n    copy (channels) {\n        return Object.assign(new this.constructor, this, channels);\n    },\n    displayable () {\n        return this.rgb().displayable();\n    },\n    hex: color_formatHex,\n    formatHex: color_formatHex,\n    formatHex8: color_formatHex8,\n    formatHsl: color_formatHsl,\n    formatRgb: color_formatRgb,\n    toString: color_formatRgb\n});\nfunction color_formatHex() {\n    return this.rgb().formatHex();\n}\nfunction color_formatHex8() {\n    return this.rgb().formatHex8();\n}\nfunction color_formatHsl() {\n    return hslConvert(this).formatHsl();\n}\nfunction color_formatRgb() {\n    return this.rgb().formatRgb();\n}\nfunction color(format) {\n    var m, l;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000\n     : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00\n     : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000\n     : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000\n     : null // invalid hex\n    ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n     : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n     : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n     : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n     : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n     : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n     : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins\n     : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0) : null;\n}\nfunction rgbn(n) {\n    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\nfunction rgba(r, g, b, a) {\n    if (a <= 0) r = g = b = NaN;\n    return new Rgb(r, g, b, a);\n}\nfunction rgbConvert(o) {\n    if (!(o instanceof Color)) o = color(o);\n    if (!o) return new Rgb;\n    o = o.rgb();\n    return new Rgb(o.r, o.g, o.b, o.opacity);\n}\nfunction rgb(r, g, b, opacity) {\n    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\nfunction Rgb(r, g, b, opacity) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n    this.opacity = +opacity;\n}\ndefine(Rgb, rgb, extend(Color, {\n    brighter (k) {\n        k = k == null ? brighter : Math.pow(brighter, k);\n        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n    },\n    darker (k) {\n        k = k == null ? darker : Math.pow(darker, k);\n        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n    },\n    rgb () {\n        return this;\n    },\n    clamp () {\n        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));\n    },\n    displayable () {\n        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;\n    },\n    hex: rgb_formatHex,\n    formatHex: rgb_formatHex,\n    formatHex8: rgb_formatHex8,\n    formatRgb: rgb_formatRgb,\n    toString: rgb_formatRgb\n}));\nfunction rgb_formatHex() {\n    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;\n}\nfunction rgb_formatHex8() {\n    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction rgb_formatRgb() {\n    const a = clampa(this.opacity);\n    return `${a === 1 ? \"rgb(\" : \"rgba(\"}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? \")\" : `, ${a})`}`;\n}\nfunction clampa(opacity) {\n    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));\n}\nfunction clampi(value) {\n    return Math.max(0, Math.min(255, Math.round(value) || 0));\n}\nfunction hex(value) {\n    value = clampi(value);\n    return (value < 16 ? \"0\" : \"\") + value.toString(16);\n}\nfunction hsla(h, s, l, a) {\n    if (a <= 0) h = s = l = NaN;\n    else if (l <= 0 || l >= 1) h = s = NaN;\n    else if (s <= 0) h = NaN;\n    return new Hsl(h, s, l, a);\n}\nfunction hslConvert(o) {\n    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n    if (!(o instanceof Color)) o = color(o);\n    if (!o) return new Hsl;\n    if (o instanceof Hsl) return o;\n    o = o.rgb();\n    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;\n    if (s) {\n        if (r === max) h = (g - b) / s + (g < b) * 6;\n        else if (g === max) h = (b - r) / s + 2;\n        else h = (r - g) / s + 4;\n        s /= l < 0.5 ? max + min : 2 - max - min;\n        h *= 60;\n    } else {\n        s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new Hsl(h, s, l, o.opacity);\n}\nfunction hsl(h, s, l, opacity) {\n    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\nfunction Hsl(h, s, l, opacity) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n    this.opacity = +opacity;\n}\ndefine(Hsl, hsl, extend(Color, {\n    brighter (k) {\n        k = k == null ? brighter : Math.pow(brighter, k);\n        return new Hsl(this.h, this.s, this.l * k, this.opacity);\n    },\n    darker (k) {\n        k = k == null ? darker : Math.pow(darker, k);\n        return new Hsl(this.h, this.s, this.l * k, this.opacity);\n    },\n    rgb () {\n        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;\n        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);\n    },\n    clamp () {\n        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));\n    },\n    displayable () {\n        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;\n    },\n    formatHsl () {\n        const a = clampa(this.opacity);\n        return `${a === 1 ? \"hsl(\" : \"hsla(\"}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? \")\" : `, ${a})`}`;\n    }\n}));\nfunction clamph(value) {\n    value = (value || 0) % 360;\n    return value < 0 ? value + 360 : value;\n}\nfunction clampt(value) {\n    return Math.max(0, Math.min(1, value || 0));\n}\n/* From FvD 13.37, CSS Color Module Level 3 */ function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;\n}\nfunction memoize(func, resolver) {\n    if (typeof func !== \"function\" || resolver != null && typeof resolver !== \"function\") {\n        throw new TypeError(\"Expected a function\");\n    }\n    var _memoized = function memoized() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var key = resolver ? resolver.apply(this, args) : args[0];\n        var cache = _memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        _memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    _memoized.cache = new (memoize.Cache || Map)();\n    memoize.cacheList.push(_memoized.cache);\n    return _memoized;\n}\nmemoize.Cache = Map;\nmemoize.cacheList = [];\nmemoize.clearCache = function() {\n    memoize.cacheList.forEach(function(cache) {\n        return cache.clear();\n    });\n};\n// These units are iterated through, so be careful when adding or changing the\n// order.\nvar UnitType = /*#__PURE__*/ function(UnitType) {\n    UnitType[UnitType[\"kUnknown\"] = 0] = \"kUnknown\";\n    UnitType[UnitType[\"kNumber\"] = 1] = \"kNumber\";\n    UnitType[UnitType[\"kPercentage\"] = 2] = \"kPercentage\";\n    // Length units\n    UnitType[UnitType[\"kEms\"] = 3] = \"kEms\";\n    // kExs,\n    UnitType[UnitType[\"kPixels\"] = 4] = \"kPixels\";\n    // kCentimeters,\n    // kMillimeters,\n    // kInches,\n    // kPoints,\n    // kPicas,\n    // kQuarterMillimeters,\n    // https://drafts.csswg.org/css-values-4/#viewport-relative-lengths\n    //\n    // See also IsViewportPercentageLength.\n    // kViewportWidth,\n    // kViewportHeight,\n    // kViewportInlineSize,\n    // kViewportBlockSize,\n    // kViewportMin,\n    // kViewportMax,\n    // kSmallViewportWidth,\n    // kSmallViewportHeight,\n    // kSmallViewportInlineSize,\n    // kSmallViewportBlockSize,\n    // kSmallViewportMin,\n    // kSmallViewportMax,\n    // kLargeViewportWidth,\n    // kLargeViewportHeight,\n    // kLargeViewportInlineSize,\n    // kLargeViewportBlockSize,\n    // kLargeViewportMin,\n    // kLargeViewportMax,\n    // kDynamicViewportWidth,\n    // kDynamicViewportHeight,\n    // kDynamicViewportInlineSize,\n    // kDynamicViewportBlockSize,\n    // kDynamicViewportMin,\n    // kDynamicViewportMax,\n    // https://drafts.csswg.org/css-contain-3/#container-lengths\n    //\n    // See also IsContainerPercentageLength.\n    // kContainerWidth,\n    // kContainerHeight,\n    // kContainerInlineSize,\n    // kContainerBlockSize,\n    // kContainerMin,\n    // kContainerMax,\n    UnitType[UnitType[\"kRems\"] = 5] = \"kRems\";\n    // kChs,\n    // kUserUnits, // The SVG term for unitless lengths\n    // Angle units\n    UnitType[UnitType[\"kDegrees\"] = 6] = \"kDegrees\";\n    UnitType[UnitType[\"kRadians\"] = 7] = \"kRadians\";\n    UnitType[UnitType[\"kGradians\"] = 8] = \"kGradians\";\n    UnitType[UnitType[\"kTurns\"] = 9] = \"kTurns\";\n    // Time units\n    UnitType[UnitType[\"kMilliseconds\"] = 10] = \"kMilliseconds\";\n    UnitType[UnitType[\"kSeconds\"] = 11] = \"kSeconds\";\n    // kHertz,\n    // kKilohertz,\n    // Resolution\n    // kDotsPerPixel,\n    // kDotsPerInch,\n    // kDotsPerCentimeter,\n    // Other units\n    // kFraction,\n    UnitType[UnitType[\"kInteger\"] = 12] = \"kInteger\"; // This value is used to handle quirky margins in reflow roots (body, td,\n    // and th) like WinIE. The basic idea is that a stylesheet can use the value\n    // __qem (for quirky em) instead of em. When the quirky value is used, if\n    // you're in quirks mode, the margin will collapse away inside a table cell.\n    // This quirk is specified in the HTML spec but our impl is different.\n    // TODO: Remove this. crbug.com/443952\n    // kQuirkyEms,\n    return UnitType;\n}({});\nvar UnitCategory = /*#__PURE__*/ function(UnitCategory) {\n    UnitCategory[UnitCategory[\"kUNumber\"] = 0] = \"kUNumber\";\n    UnitCategory[UnitCategory[\"kUPercent\"] = 1] = \"kUPercent\";\n    UnitCategory[UnitCategory[\"kULength\"] = 2] = \"kULength\";\n    UnitCategory[UnitCategory[\"kUAngle\"] = 3] = \"kUAngle\";\n    UnitCategory[UnitCategory[\"kUTime\"] = 4] = \"kUTime\";\n    // kUFrequency,\n    // kUResolution,\n    UnitCategory[UnitCategory[\"kUOther\"] = 5] = \"kUOther\";\n    return UnitCategory;\n}({});\nvar Nested = /*#__PURE__*/ function(Nested) {\n    Nested[Nested[\"kYes\"] = 0] = \"kYes\";\n    Nested[Nested[\"kNo\"] = 1] = \"kNo\";\n    return Nested;\n}({});\nvar ParenLess = /*#__PURE__*/ function(ParenLess) {\n    ParenLess[ParenLess[\"kYes\"] = 0] = \"kYes\";\n    ParenLess[ParenLess[\"kNo\"] = 1] = \"kNo\";\n    return ParenLess;\n}({});\n// This file specifies the unit strings used in CSSPrimitiveValues.\nvar data = [\n    {\n        name: \"em\",\n        unit_type: UnitType.kEms\n    },\n    // {\n    //   name: 'ex',\n    //   unit_type: UnitType.kExs,\n    // },\n    {\n        name: \"px\",\n        unit_type: UnitType.kPixels\n    },\n    // {\n    //   name: \"cm\",\n    //   unit_type: UnitType.kCentimeters,\n    // },\n    // {\n    //   name: \"mm\",\n    //   unit_type: UnitType.kMillimeters,\n    // },\n    // {\n    //   name: \"q\",\n    //   unit_type: UnitType.kQuarterMillimeters,\n    // },\n    // {\n    //   name: \"in\",\n    //   unit_type: UnitType.kInches,\n    // },\n    // {\n    //   name: \"pt\",\n    //   unit_type: UnitType.kPoints,\n    // },\n    // {\n    //   name: \"pc\",\n    //   unit_type: UnitType.kPicas,\n    // },\n    {\n        name: \"deg\",\n        unit_type: UnitType.kDegrees\n    },\n    {\n        name: \"rad\",\n        unit_type: UnitType.kRadians\n    },\n    {\n        name: \"grad\",\n        unit_type: UnitType.kGradians\n    },\n    {\n        name: \"ms\",\n        unit_type: UnitType.kMilliseconds\n    },\n    {\n        name: \"s\",\n        unit_type: UnitType.kSeconds\n    },\n    // {\n    //   name: \"hz\",\n    //   unit_type: UnitType.kHertz,\n    // },\n    // {\n    //   name: \"khz\",\n    //   unit_type: UnitType.kKilohertz,\n    // },\n    // {\n    //   name: \"dpi\",\n    //   unit_type: \"kDotsPerInch\",\n    // },\n    // {\n    //   name: \"dpcm\",\n    //   unit_type: \"kDotsPerCentimeter\",\n    // },\n    // {\n    //   name: \"dppx\",\n    //   unit_type: \"kDotsPerPixel\",\n    // },\n    // {\n    //   name: \"x\",\n    //   unit_type: \"kDotsPerPixel\",\n    // },\n    // {\n    //   name: \"vw\",\n    //   unit_type: \"kViewportWidth\",\n    // },\n    // {\n    //   name: \"vh\",\n    //   unit_type: \"kViewportHeight\",\n    // },\n    // {\n    //   name: \"vi\",\n    //   unit_type: \"kViewportInlineSize\",\n    // },\n    // {\n    //   name: \"vb\",\n    //   unit_type: \"kViewportBlockSize\",\n    // },\n    // {\n    //   name: \"vmin\",\n    //   unit_type: UnitType.kViewportMin,\n    // },\n    // {\n    //   name: \"vmax\",\n    //   unit_type: UnitType.kViewportMax,\n    // },\n    // {\n    //   name: \"svw\",\n    //   unit_type: \"kSmallViewportWidth\",\n    // },\n    // {\n    //   name: \"svh\",\n    //   unit_type: \"kSmallViewportHeight\",\n    // },\n    // {\n    //   name: \"svi\",\n    //   unit_type: \"kSmallViewportInlineSize\",\n    // },\n    // {\n    //   name: \"svb\",\n    //   unit_type: \"kSmallViewportBlockSize\",\n    // },\n    // {\n    //   name: \"svmin\",\n    //   unit_type: \"kSmallViewportMin\",\n    // },\n    // {\n    //   name: \"svmax\",\n    //   unit_type: \"kSmallViewportMax\",\n    // },\n    // {\n    //   name: \"lvw\",\n    //   unit_type: \"kLargeViewportWidth\",\n    // },\n    // {\n    //   name: \"lvh\",\n    //   unit_type: \"kLargeViewportHeight\",\n    // },\n    // {\n    //   name: \"lvi\",\n    //   unit_type: \"kLargeViewportInlineSize\",\n    // },\n    // {\n    //   name: \"lvb\",\n    //   unit_type: \"kLargeViewportBlockSize\",\n    // },\n    // {\n    //   name: \"lvmin\",\n    //   unit_type: UnitType.kLargeViewportMin,\n    // },\n    // {\n    //   name: \"lvmax\",\n    //   unit_type: UnitType.kLargeViewportMax,\n    // },\n    // {\n    //   name: \"dvw\",\n    //   unit_type: UnitType.kDynamicViewportWidth,\n    // },\n    // {\n    //   name: \"dvh\",\n    //   unit_type: UnitType.kDynamicViewportHeight,\n    // },\n    // {\n    //   name: \"dvi\",\n    //   unit_type: UnitType.kDynamicViewportInlineSize,\n    // },\n    // {\n    //   name: \"dvb\",\n    //   unit_type: UnitType.kDynamicViewportBlockSize,\n    // },\n    // {\n    //   name: \"dvmin\",\n    //   unit_type: UnitType.kDynamicViewportMin,\n    // },\n    // {\n    //   name: \"dvmax\",\n    //   unit_type: UnitType.kDynamicViewportMax,\n    // },\n    // {\n    //   name: \"cqw\",\n    //   unit_type: UnitType.kContainerWidth,\n    // },\n    // {\n    //   name: \"cqh\",\n    //   unit_type: UnitType.kContainerHeight,\n    // },\n    // {\n    //   name: \"cqi\",\n    //   unit_type: UnitType.kContainerInlineSize,\n    // },\n    // {\n    //   name: \"cqb\",\n    //   unit_type: UnitType.kContainerBlockSize,\n    // },\n    // {\n    //   name: \"cqmin\",\n    //   unit_type: UnitType.kContainerMin,\n    // },\n    // {\n    //   name: \"cqmax\",\n    //   unit_type: UnitType.kContainerMax,\n    // },\n    {\n        name: \"rem\",\n        unit_type: UnitType.kRems\n    },\n    // {\n    //   name: 'fr',\n    //   unit_type: UnitType.kFraction,\n    // },\n    {\n        name: \"turn\",\n        unit_type: UnitType.kTurns\n    }\n];\nvar CSSStyleValueType = /*#__PURE__*/ function(CSSStyleValueType) {\n    CSSStyleValueType[CSSStyleValueType[\"kUnknownType\"] = 0] = \"kUnknownType\";\n    CSSStyleValueType[CSSStyleValueType[\"kUnparsedType\"] = 1] = \"kUnparsedType\";\n    CSSStyleValueType[CSSStyleValueType[\"kKeywordType\"] = 2] = \"kKeywordType\";\n    // Start of CSSNumericValue subclasses\n    CSSStyleValueType[CSSStyleValueType[\"kUnitType\"] = 3] = \"kUnitType\";\n    CSSStyleValueType[CSSStyleValueType[\"kSumType\"] = 4] = \"kSumType\";\n    CSSStyleValueType[CSSStyleValueType[\"kProductType\"] = 5] = \"kProductType\";\n    CSSStyleValueType[CSSStyleValueType[\"kNegateType\"] = 6] = \"kNegateType\";\n    CSSStyleValueType[CSSStyleValueType[\"kInvertType\"] = 7] = \"kInvertType\";\n    CSSStyleValueType[CSSStyleValueType[\"kMinType\"] = 8] = \"kMinType\";\n    CSSStyleValueType[CSSStyleValueType[\"kMaxType\"] = 9] = \"kMaxType\";\n    CSSStyleValueType[CSSStyleValueType[\"kClampType\"] = 10] = \"kClampType\";\n    // End of CSSNumericValue subclasses\n    CSSStyleValueType[CSSStyleValueType[\"kTransformType\"] = 11] = \"kTransformType\";\n    CSSStyleValueType[CSSStyleValueType[\"kPositionType\"] = 12] = \"kPositionType\";\n    CSSStyleValueType[CSSStyleValueType[\"kURLImageType\"] = 13] = \"kURLImageType\";\n    CSSStyleValueType[CSSStyleValueType[\"kColorType\"] = 14] = \"kColorType\";\n    CSSStyleValueType[CSSStyleValueType[\"kUnsupportedColorType\"] = 15] = \"kUnsupportedColorType\";\n    return CSSStyleValueType;\n}({});\n// function parseCSSStyleValue(propertyName: string, value: string): CSSStyleValue[] {\n//   // const propertyId = cssPropertyID(propertyName);\n//   // if (propertyId === CSSPropertyID.kInvalid) {\n//   //   return [];\n//   // }\n//   // const customPropertyName = propertyId === CSSPropertyID.kVariable ? propertyName : null;\n//   // return fromString(propertyId, customPropertyName, value);\n//   return [];\n// }\nvar stringToUnitType = function stringToUnitType(name) {\n    return data.find(function(item) {\n        return item.name === name;\n    }).unit_type;\n};\nvar unitFromName = function unitFromName(name) {\n    if (!name) {\n        return UnitType.kUnknown;\n    }\n    if (name === \"number\") {\n        return UnitType.kNumber;\n    }\n    if (name === \"percent\" || name === \"%\") {\n        return UnitType.kPercentage;\n    }\n    return stringToUnitType(name);\n};\nvar unitTypeToUnitCategory = function unitTypeToUnitCategory(type) {\n    switch(type){\n        case UnitType.kNumber:\n        case UnitType.kInteger:\n            return UnitCategory.kUNumber;\n        case UnitType.kPercentage:\n            return UnitCategory.kUPercent;\n        case UnitType.kPixels:\n            // case UnitType.kCentimeters:\n            // case UnitType.kMillimeters:\n            // case UnitType.kQuarterMillimeters:\n            // case UnitType.kInches:\n            // case UnitType.kPoints:\n            // case UnitType.kPicas:\n            // case UnitType.kUserUnits:\n            return UnitCategory.kULength;\n        case UnitType.kMilliseconds:\n        case UnitType.kSeconds:\n            return UnitCategory.kUTime;\n        case UnitType.kDegrees:\n        case UnitType.kRadians:\n        case UnitType.kGradians:\n        case UnitType.kTurns:\n            return UnitCategory.kUAngle;\n        // case UnitType.kHertz:\n        // case UnitType.kKilohertz:\n        //   return UnitCategory.kUFrequency;\n        // case UnitType.kDotsPerPixel:\n        // case UnitType.kDotsPerInch:\n        // case UnitType.kDotsPerCentimeter:\n        //   return UnitCategory.kUResolution;\n        default:\n            return UnitCategory.kUOther;\n    }\n};\nvar canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory(category) {\n    // The canonical unit type is chosen according to the way\n    // CSSPropertyParser.ValidUnit() chooses the default unit in each category\n    // (based on unitflags).\n    switch(category){\n        case UnitCategory.kUNumber:\n            return UnitType.kNumber;\n        case UnitCategory.kULength:\n            return UnitType.kPixels;\n        case UnitCategory.kUPercent:\n            return UnitType.kPercentage;\n        // return UnitType.kUnknown; // Cannot convert between numbers and percent.\n        case UnitCategory.kUTime:\n            return UnitType.kSeconds;\n        case UnitCategory.kUAngle:\n            return UnitType.kDegrees;\n        // case UnitCategory.kUFrequency:\n        //   return UnitType.kHertz;\n        // case UnitCategory.kUResolution:\n        //   return UnitType.kDotsPerPixel;\n        default:\n            return UnitType.kUnknown;\n    }\n};\n/**\n * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/css_primitive_value.cc#353\n */ var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor(unit_type) {\n    var factor = 1.0;\n    // FIXME: the switch can be replaced by an array of scale factors.\n    switch(unit_type){\n        // These are \"canonical\" units in their respective categories.\n        case UnitType.kPixels:\n        // case UnitType.kUserUnits:\n        case UnitType.kDegrees:\n        case UnitType.kSeconds:\n            break;\n        case UnitType.kMilliseconds:\n            factor = 0.001;\n            break;\n        // case UnitType.kCentimeters:\n        //   // factor = kCssPixelsPerCentimeter;\n        //   break;\n        // case UnitType.kDotsPerCentimeter:\n        //   // factor = 1 / kCssPixelsPerCentimeter;\n        //   break;\n        // case UnitType.kMillimeters:\n        //   // factor = kCssPixelsPerMillimeter;\n        //   break;\n        // case UnitType.kQuarterMillimeters:\n        //   // factor = kCssPixelsPerQuarterMillimeter;\n        //   break;\n        // case UnitType.kInches:\n        //   // factor = kCssPixelsPerInch;\n        //   break;\n        // case UnitType.kDotsPerInch:\n        //   // factor = 1 / kCssPixelsPerInch;\n        //   break;\n        // case UnitType.kPoints:\n        //   // factor = kCssPixelsPerPoint;\n        //   break;\n        // case UnitType.kPicas:\n        //   // factor = kCssPixelsPerPica;\n        //   break;\n        case UnitType.kRadians:\n            factor = 180 / Math.PI;\n            break;\n        case UnitType.kGradians:\n            factor = 0.9;\n            break;\n        case UnitType.kTurns:\n            factor = 360;\n            break;\n    }\n    return factor;\n};\nvar unitTypeToString = function unitTypeToString(type) {\n    switch(type){\n        case UnitType.kNumber:\n        case UnitType.kInteger:\n            // case UnitType.kUserUnits:\n            return \"\";\n        case UnitType.kPercentage:\n            return \"%\";\n        case UnitType.kEms:\n            // case UnitType.kQuirkyEms:\n            return \"em\";\n        // case UnitType.kExs:\n        //   return 'ex';\n        case UnitType.kRems:\n            return \"rem\";\n        // case UnitType.kChs:\n        //   return 'ch';\n        case UnitType.kPixels:\n            return \"px\";\n        // case UnitType.kCentimeters:\n        //   return 'cm';\n        // case UnitType.kDotsPerPixel:\n        //   return 'dppx';\n        // case UnitType.kDotsPerInch:\n        //   return 'dpi';\n        // case UnitType.kDotsPerCentimeter:\n        //   return 'dpcm';\n        // case UnitType.kMillimeters:\n        //   return 'mm';\n        // case UnitType.kQuarterMillimeters:\n        //   return 'q';\n        // case UnitType.kInches:\n        //   return 'in';\n        // case UnitType.kPoints:\n        //   return 'pt';\n        // case UnitType.kPicas:\n        //   return 'pc';\n        case UnitType.kDegrees:\n            return \"deg\";\n        case UnitType.kRadians:\n            return \"rad\";\n        case UnitType.kGradians:\n            return \"grad\";\n        case UnitType.kMilliseconds:\n            return \"ms\";\n        case UnitType.kSeconds:\n            return \"s\";\n        // case UnitType.kHertz:\n        //   return 'hz';\n        // case UnitType.kKilohertz:\n        //   return 'khz';\n        case UnitType.kTurns:\n            return \"turn\";\n    }\n    return \"\";\n};\n/**\n * CSSStyleValue is the base class for all CSS values accessible from Typed OM.\n * Values that are not yet supported as specific types are also returned as base CSSStyleValues.\n *\n * Spec @see https://drafts.css-houdini.org/css-typed-om/#stylevalue-objects\n * Docs @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleValue\n */ var CSSStyleValue = /*#__PURE__*/ function() {\n    function CSSStyleValue() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSStyleValue);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSStyleValue, [\n        {\n            key: \"toString\",\n            value: // protected abstract toCSSValue(): CSSValue;\n            function toString() {\n                return this.buildCSSText(Nested.kNo, ParenLess.kNo, \"\");\n            }\n        },\n        {\n            key: \"isNumericValue\",\n            value: function isNumericValue() {\n                return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;\n            }\n        }\n    ], [\n        {\n            key: \"isAngle\",\n            value: // static parse(propertyName: string, value: string): CSSStyleValue {\n            //   return parseCSSStyleValue(propertyName, value)[0];\n            // }\n            // static parseAll(propertyName: string, value: string): CSSStyleValue[] {\n            //   return parseCSSStyleValue(propertyName, value);\n            // }\n            function isAngle(unit) {\n                return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;\n            }\n        },\n        {\n            key: \"isLength\",\n            value: function isLength(type) {\n                // return (type >= UnitType.kEms && type <= UnitType.kUserUnits) || type == UnitType.kQuirkyEms;\n                return type >= UnitType.kEms && type < UnitType.kDegrees;\n            }\n        },\n        {\n            key: \"isRelativeUnit\",\n            value: function isRelativeUnit(type) {\n                return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||\n                type === UnitType.kRems;\n            }\n        },\n        {\n            key: \"isTime\",\n            value: function isTime(unit) {\n                return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;\n            }\n        }\n    ]);\n}();\n/**\n * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-colorspace\n */ /**\n * CSSColorValue is the base class used for the various CSS color interfaces.\n *\n * @see https://drafts.css-houdini.org/css-typed-om-1/#colorvalue-objects\n */ var CSSColorValue = /*#__PURE__*/ function(_CSSStyleValue) {\n    function CSSColorValue(colorSpace) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSColorValue);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CSSColorValue);\n        _this.colorSpace = colorSpace;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSColorValue, _CSSStyleValue);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSColorValue, [\n        {\n            key: \"getType\",\n            value: function getType() {\n                return CSSStyleValueType.kColorType;\n            }\n        },\n        {\n            key: \"to\",\n            value: function to(colorSpace) {\n                return this;\n            }\n        }\n    ]);\n}(CSSStyleValue);\nvar GradientType = /*#__PURE__*/ function(GradientType) {\n    GradientType[GradientType[\"Constant\"] = 0] = \"Constant\";\n    GradientType[GradientType[\"LinearGradient\"] = 1] = \"LinearGradient\";\n    GradientType[GradientType[\"RadialGradient\"] = 2] = \"RadialGradient\";\n    return GradientType;\n}({});\nvar CSSGradientValue = /*#__PURE__*/ function(_CSSStyleValue) {\n    function CSSGradientValue(type, value) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSGradientValue);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CSSGradientValue);\n        _this.type = type;\n        _this.value = value;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSGradientValue, _CSSStyleValue);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSGradientValue, [\n        {\n            key: \"clone\",\n            value: function clone() {\n                return new CSSGradientValue(this.type, this.value);\n            }\n        },\n        {\n            key: \"buildCSSText\",\n            value: function buildCSSText(n, p, result) {\n                return result;\n            }\n        },\n        {\n            key: \"getType\",\n            value: function getType() {\n                return CSSStyleValueType.kColorType;\n            }\n        }\n    ]);\n}(CSSStyleValue);\n/**\n * CSSKeywordValue represents CSS Values that are specified as keywords\n * eg. 'initial'\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSKeywordValue\n * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_keyword_value.idl\n */ var CSSKeywordValue = /*#__PURE__*/ function(_CSSStyleValue) {\n    function CSSKeywordValue(value) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSKeywordValue);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CSSKeywordValue);\n        _this.value = value;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSKeywordValue, _CSSStyleValue);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSKeywordValue, [\n        {\n            key: \"clone\",\n            value: function clone() {\n                return new CSSKeywordValue(this.value);\n            }\n        },\n        {\n            key: \"getType\",\n            value: function getType() {\n                return CSSStyleValueType.kKeywordType;\n            }\n        },\n        {\n            key: \"buildCSSText\",\n            value: function buildCSSText(n, p, result) {\n                return result + this.value;\n            }\n        }\n    ]);\n}(CSSStyleValue);\nvar formatInfinityOrNaN = function formatInfinityOrNaN(number) {\n    var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var result = \"\";\n    if (!Number.isFinite(number)) {\n        if (number > 0) result = \"infinity\";\n        else result = \"-infinity\";\n    } else {\n        result = \"NaN\";\n    }\n    return result += suffix;\n};\nvar toCanonicalUnit = function toCanonicalUnit(unit) {\n    return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));\n};\n/**\n * CSSNumericValue is the base class for numeric and length typed CSS Values.\n * @see https://drafts.css-houdini.org/css-typed-om/#numeric-objects\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue\n * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.idl\n */ /**\n * Represents numeric values that can be expressed as a single number plus a\n * unit (or a naked number or percentage).\n * @see https://drafts.css-houdini.org/css-typed-om/#cssunitvalue\n */ var CSSUnitValue = /*#__PURE__*/ function(_CSSStyleValue) {\n    function CSSUnitValue(value) {\n        var _this;\n        var unitOrName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UnitType.kNumber;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSUnitValue);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CSSUnitValue);\n        var unit;\n        if (typeof unitOrName === \"string\") {\n            unit = unitFromName(unitOrName);\n        } else {\n            unit = unitOrName;\n        }\n        _this.unit = unit;\n        _this.value = value;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSUnitValue, _CSSStyleValue);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSUnitValue, [\n        {\n            key: \"clone\",\n            value: function clone() {\n                return new CSSUnitValue(this.value, this.unit);\n            }\n        },\n        {\n            key: \"equals\",\n            value: function equals(other) {\n                var other_unit_value = other;\n                return this.value === other_unit_value.value && this.unit === other_unit_value.unit;\n            }\n        },\n        {\n            key: \"getType\",\n            value: function getType() {\n                return CSSStyleValueType.kUnitType;\n            }\n        },\n        {\n            key: \"convertTo\",\n            value: function convertTo(target_unit) {\n                if (this.unit === target_unit) {\n                    return new CSSUnitValue(this.value, this.unit);\n                }\n                // Instead of defining the scale factors for every unit to every other unit,\n                // we simply convert to the canonical unit and back since we already have\n                // the scale factors for canonical units.\n                var canonical_unit = toCanonicalUnit(this.unit);\n                if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {\n                    return null;\n                }\n                var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);\n                return new CSSUnitValue(this.value * scale_factor, target_unit);\n            }\n        },\n        {\n            key: \"buildCSSText\",\n            value: function buildCSSText(n, p, result) {\n                var text;\n                switch(this.unit){\n                    case UnitType.kUnknown:\n                        break;\n                    case UnitType.kInteger:\n                        text = Number(this.value).toFixed(0);\n                        break;\n                    case UnitType.kNumber:\n                    case UnitType.kPercentage:\n                    case UnitType.kEms:\n                    // case UnitType.kQuirkyEms:\n                    // case UnitType.kExs:\n                    case UnitType.kRems:\n                    // case UnitType.kChs:\n                    case UnitType.kPixels:\n                    // case UnitType.kCentimeters:\n                    // case UnitType.kDotsPerPixel:\n                    // case UnitType.kDotsPerInch:\n                    // case UnitType.kDotsPerCentimeter:\n                    // case UnitType.kMillimeters:\n                    // case UnitType.kQuarterMillimeters:\n                    // case UnitType.kInches:\n                    // case UnitType.kPoints:\n                    // case UnitType.kPicas:\n                    // case UnitType.kUserUnits:\n                    case UnitType.kDegrees:\n                    case UnitType.kRadians:\n                    case UnitType.kGradians:\n                    case UnitType.kMilliseconds:\n                    case UnitType.kSeconds:\n                    // case UnitType.kHertz:\n                    // case UnitType.kKilohertz:\n                    case UnitType.kTurns:\n                        {\n                            // case UnitType.kContainerMax: { // case UnitType.kContainerMin: // case UnitType.kContainerBlockSize: // case UnitType.kContainerInlineSize: // case UnitType.kContainerHeight: // case UnitType.kContainerWidth: // case UnitType.kDynamicViewportMax: // case UnitType.kDynamicViewportMin: // case UnitType.kDynamicViewportBlockSize: // case UnitType.kDynamicViewportInlineSize: // case UnitType.kDynamicViewportHeight: // case UnitType.kDynamicViewportWidth: // case UnitType.kLargeViewportMax: // case UnitType.kLargeViewportMin: // case UnitType.kLargeViewportBlockSize: // case UnitType.kLargeViewportInlineSize: // case UnitType.kLargeViewportHeight: // case UnitType.kLargeViewportWidth: // case UnitType.kSmallViewportMax: // case UnitType.kSmallViewportMin: // case UnitType.kSmallViewportBlockSize: // case UnitType.kSmallViewportInlineSize: // case UnitType.kSmallViewportHeight: // case UnitType.kSmallViewportWidth: // case UnitType.kViewportMax: // case UnitType.kViewportMin: // case UnitType.kViewportBlockSize: // case UnitType.kViewportInlineSize: // case UnitType.kViewportHeight: // case UnitType.kViewportWidth: // case UnitType.kFraction:\n                            var kMinInteger = -999999;\n                            var kMaxInteger = 999999;\n                            var value = this.value;\n                            var unit = unitTypeToString(this.unit);\n                            if (value < kMinInteger || value > kMaxInteger) {\n                                var _unit = unitTypeToString(this.unit);\n                                if (!Number.isFinite(value) || Number.isNaN(value)) {\n                                    text = formatInfinityOrNaN(value, _unit);\n                                } else {\n                                    text = value + (_unit || \"\");\n                                }\n                            } else {\n                                text = \"\".concat(value).concat(unit);\n                            }\n                        }\n                }\n                result += text;\n                return result;\n            }\n        }\n    ]);\n}(CSSStyleValue);\nvar Opx = new CSSUnitValue(0, \"px\");\nnew CSSUnitValue(1, \"px\");\nvar Odeg = new CSSUnitValue(0, \"deg\");\n/**\n * The CSSRGB class represents the CSS rgb()/rgba() functions.\n *\n * @see https://drafts.css-houdini.org/css-typed-om-1/#cssrgb\n */ var CSSRGB = /*#__PURE__*/ function(_CSSColorValue) {\n    function CSSRGB(r, g, b) {\n        var _this;\n        var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n        var isNone = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSRGB);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CSSRGB, [\n            \"rgb\"\n        ]);\n        _this.r = r;\n        _this.g = g;\n        _this.b = b;\n        _this.alpha = alpha;\n        _this.isNone = isNone;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSRGB, _CSSColorValue);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSRGB, [\n        {\n            key: \"clone\",\n            value: function clone() {\n                return new CSSRGB(this.r, this.g, this.b, this.alpha);\n            }\n        },\n        {\n            key: \"buildCSSText\",\n            value: function buildCSSText(n, p, result) {\n                return \"\".concat(result, \"rgba(\").concat(this.r, \",\").concat(this.g, \",\").concat(this.b, \",\").concat(this.alpha, \")\");\n            }\n        }\n    ]);\n}(CSSColorValue);\n/**\n * CSSKeywordValue\n */ var unsetKeywordValue = new CSSKeywordValue(\"unset\");\nvar initialKeywordValue = new CSSKeywordValue(\"initial\");\nvar inheritKeywordValue = new CSSKeywordValue(\"inherit\");\nvar keywordCache = {\n    \"\": unsetKeywordValue,\n    unset: unsetKeywordValue,\n    initial: initialKeywordValue,\n    inherit: inheritKeywordValue\n};\nvar getOrCreateKeyword = function getOrCreateKeyword(name) {\n    if (!keywordCache[name]) {\n        keywordCache[name] = new CSSKeywordValue(name);\n    }\n    return keywordCache[name];\n};\n/**\n * CSSColor\n */ var noneColor = new CSSRGB(0, 0, 0, 0, true);\nvar transparentColor = new CSSRGB(0, 0, 0, 0);\nvar getOrCreateRGBA = memoize(function(r, g, b, a) {\n    return new CSSRGB(r, g, b, a);\n}, function(r, g, b, a) {\n    return \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\");\n});\n// export const getOrCreateUnitValue = memoize(\n//   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {\n//     return new CSSUnitValue(value, unitOrName);\n//   },\n//   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {\n//     return `${value}${unitOrName}`;\n//   },\n// );\nvar getOrCreateUnitValue = function getOrCreateUnitValue(value) {\n    var unitOrName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UnitType.kNumber;\n    return new CSSUnitValue(value, unitOrName);\n};\nnew CSSUnitValue(50, \"%\");\n/**\n * borrow from gradient-parser, but we delete some browser compatible prefix such as `-webkit-`\n * @see https://github.com/rafaelcaricio/gradient-parser\n */ function colorStopToString(colorStop) {\n    var type = colorStop.type, value = colorStop.value;\n    if (type === \"hex\") {\n        return \"#\".concat(value);\n    }\n    if (type === \"literal\") {\n        return value;\n    }\n    if (type === \"rgb\") {\n        return \"rgb(\".concat(value.join(\",\"), \")\");\n    }\n    return \"rgba(\".concat(value.join(\",\"), \")\");\n}\nvar parseGradient$1 = function() {\n    var tokens = {\n        linearGradient: /^(linear\\-gradient)/i,\n        repeatingLinearGradient: /^(repeating\\-linear\\-gradient)/i,\n        radialGradient: /^(radial\\-gradient)/i,\n        repeatingRadialGradient: /^(repeating\\-radial\\-gradient)/i,\n        /**\n     * @see https://projects.verou.me/conic-gradient/\n     */ conicGradient: /^(conic\\-gradient)/i,\n        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,\n        extentKeywords: /^(closest\\-side|closest\\-corner|farthest\\-side|farthest\\-corner|contain|cover)/,\n        positionKeywords: /^(left|center|right|top|bottom)/i,\n        pixelValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))px/,\n        percentageValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))\\%/,\n        emValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))em/,\n        angleValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))deg/,\n        startCall: /^\\(/,\n        endCall: /^\\)/,\n        comma: /^,/,\n        hexColor: /^\\#([0-9a-fA-F]+)/,\n        literalColor: /^([a-zA-Z]+)/,\n        rgbColor: /^rgb/i,\n        rgbaColor: /^rgba/i,\n        number: /^(([0-9]*\\.[0-9]+)|([0-9]+\\.?))/\n    };\n    var input = \"\";\n    function error(msg) {\n        throw new Error(\"\".concat(input, \": \").concat(msg));\n    }\n    function getAST() {\n        var ast = matchListDefinitions();\n        if (input.length > 0) {\n            error(\"Invalid input not EOF\");\n        }\n        return ast;\n    }\n    function matchListDefinitions() {\n        return matchListing(matchDefinition);\n    }\n    function matchDefinition() {\n        return matchGradient(\"linear-gradient\", tokens.linearGradient, matchLinearOrientation) || matchGradient(\"repeating-linear-gradient\", tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient(\"radial-gradient\", tokens.radialGradient, matchListRadialOrientations) || matchGradient(\"repeating-radial-gradient\", tokens.repeatingRadialGradient, matchListRadialOrientations) || matchGradient(\"conic-gradient\", tokens.conicGradient, matchListRadialOrientations);\n    }\n    function matchGradient(gradientType, pattern, orientationMatcher) {\n        return matchCall(pattern, function(captures) {\n            var orientation = orientationMatcher();\n            if (orientation) {\n                if (!scan(tokens.comma)) {\n                    error(\"Missing comma before color stops\");\n                }\n            }\n            return {\n                type: gradientType,\n                orientation: orientation,\n                colorStops: matchListing(matchColorStop)\n            };\n        });\n    }\n    function matchCall(pattern, callback) {\n        var captures = scan(pattern);\n        if (captures) {\n            if (!scan(tokens.startCall)) {\n                error(\"Missing (\");\n            }\n            var result = callback(captures);\n            if (!scan(tokens.endCall)) {\n                error(\"Missing )\");\n            }\n            return result;\n        }\n    }\n    function matchLinearOrientation() {\n        return matchSideOrCorner() || matchAngle();\n    }\n    function matchSideOrCorner() {\n        return match(\"directional\", tokens.sideOrCorner, 1);\n    }\n    function matchAngle() {\n        return match(\"angular\", tokens.angleValue, 1);\n    }\n    function matchListRadialOrientations() {\n        var radialOrientations;\n        var radialOrientation = matchRadialOrientation();\n        var lookaheadCache;\n        if (radialOrientation) {\n            radialOrientations = [];\n            radialOrientations.push(radialOrientation);\n            lookaheadCache = input;\n            if (scan(tokens.comma)) {\n                radialOrientation = matchRadialOrientation();\n                if (radialOrientation) {\n                    radialOrientations.push(radialOrientation);\n                } else {\n                    input = lookaheadCache;\n                }\n            }\n        }\n        return radialOrientations;\n    }\n    function matchRadialOrientation() {\n        var radialType = matchCircle() || matchEllipse();\n        if (radialType) {\n            // @ts-ignore\n            radialType.at = matchAtPosition();\n        } else {\n            var extent = matchExtentKeyword();\n            if (extent) {\n                radialType = extent;\n                var positionAt = matchAtPosition();\n                if (positionAt) {\n                    // @ts-ignore\n                    radialType.at = positionAt;\n                }\n            } else {\n                var defaultPosition = matchPositioning();\n                if (defaultPosition) {\n                    radialType = {\n                        type: \"default-radial\",\n                        // @ts-ignore\n                        at: defaultPosition\n                    };\n                }\n            }\n        }\n        return radialType;\n    }\n    function matchCircle() {\n        var circle = match(\"shape\", /^(circle)/i, 0);\n        if (circle) {\n            // @ts-ignore\n            circle.style = matchLength() || matchExtentKeyword();\n        }\n        return circle;\n    }\n    function matchEllipse() {\n        var ellipse = match(\"shape\", /^(ellipse)/i, 0);\n        if (ellipse) {\n            // @ts-ignore\n            ellipse.style = matchDistance() || matchExtentKeyword();\n        }\n        return ellipse;\n    }\n    function matchExtentKeyword() {\n        return match(\"extent-keyword\", tokens.extentKeywords, 1);\n    }\n    function matchAtPosition() {\n        if (match(\"position\", /^at/, 0)) {\n            var positioning = matchPositioning();\n            if (!positioning) {\n                error(\"Missing positioning value\");\n            }\n            return positioning;\n        }\n    }\n    function matchPositioning() {\n        var location = matchCoordinates();\n        if (location.x || location.y) {\n            return {\n                type: \"position\",\n                value: location\n            };\n        }\n    }\n    function matchCoordinates() {\n        return {\n            x: matchDistance(),\n            y: matchDistance()\n        };\n    }\n    function matchListing(matcher) {\n        var captures = matcher();\n        var result = [];\n        if (captures) {\n            result.push(captures);\n            while(scan(tokens.comma)){\n                captures = matcher();\n                if (captures) {\n                    result.push(captures);\n                } else {\n                    error(\"One extra comma\");\n                }\n            }\n        }\n        return result;\n    }\n    function matchColorStop() {\n        var color = matchColor();\n        if (!color) {\n            error(\"Expected color definition\");\n        }\n        color.length = matchDistance();\n        return color;\n    }\n    function matchColor() {\n        return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();\n    }\n    function matchLiteralColor() {\n        return match(\"literal\", tokens.literalColor, 0);\n    }\n    function matchHexColor() {\n        return match(\"hex\", tokens.hexColor, 1);\n    }\n    function matchRGBColor() {\n        return matchCall(tokens.rgbColor, function() {\n            return {\n                type: \"rgb\",\n                value: matchListing(matchNumber)\n            };\n        });\n    }\n    function matchRGBAColor() {\n        return matchCall(tokens.rgbaColor, function() {\n            return {\n                type: \"rgba\",\n                value: matchListing(matchNumber)\n            };\n        });\n    }\n    function matchNumber() {\n        return scan(tokens.number)[1];\n    }\n    function matchDistance() {\n        return match(\"%\", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();\n    }\n    function matchPositionKeyword() {\n        return match(\"position-keyword\", tokens.positionKeywords, 1);\n    }\n    function matchLength() {\n        return match(\"px\", tokens.pixelValue, 1) || match(\"em\", tokens.emValue, 1);\n    }\n    function match(type, pattern, captureIndex) {\n        var captures = scan(pattern);\n        if (captures) {\n            return {\n                type: type,\n                value: captures[captureIndex]\n            };\n        }\n    }\n    function scan(regexp) {\n        var blankCaptures = /^[\\n\\r\\t\\s]+/.exec(input);\n        if (blankCaptures) {\n            consume(blankCaptures[0].length);\n        }\n        var captures = regexp.exec(input);\n        if (captures) {\n            consume(captures[0].length);\n        }\n        return captures;\n    }\n    function consume(size) {\n        input = input.substring(size);\n    }\n    return function(code) {\n        input = code;\n        return getAST();\n    };\n}();\nfunction computeLinearGradient(min, width, height, angle) {\n    var rad = deg2rad(angle.value);\n    var rx = 0;\n    var ry = 0;\n    var rcx = rx + width / 2;\n    var rcy = ry + height / 2;\n    // get the length of gradient line\n    // @see https://observablehq.com/@danburzo/css-gradient-line\n    var length = Math.abs(width * Math.cos(rad)) + Math.abs(height * Math.sin(rad));\n    var x1 = min[0] + rcx - Math.cos(rad) * length / 2;\n    var y1 = min[1] + rcy - Math.sin(rad) * length / 2;\n    var x2 = min[0] + rcx + Math.cos(rad) * length / 2;\n    var y2 = min[1] + rcy + Math.sin(rad) * length / 2;\n    return {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    };\n}\nfunction computeRadialGradient(min, width, height, cx, cy, size) {\n    // 'px'\n    var x = cx.value;\n    var y = cy.value;\n    // TODO: 'em'\n    // '%'\n    if (cx.unit === UnitType.kPercentage) {\n        x = cx.value / 100 * width;\n    }\n    if (cy.unit === UnitType.kPercentage) {\n        y = cy.value / 100 * height;\n    }\n    // default to farthest-side\n    var r = Math.max((0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n        0,\n        0\n    ], [\n        x,\n        y\n    ]), (0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n        0,\n        height\n    ], [\n        x,\n        y\n    ]), (0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n        width,\n        height\n    ], [\n        x,\n        y\n    ]), (0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n        width,\n        0\n    ], [\n        x,\n        y\n    ]));\n    if (size) {\n        if (size instanceof CSSUnitValue) {\n            r = size.value;\n        } else if (size instanceof CSSKeywordValue) {\n            // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients#example_closest-side_for_circles\n            if (size.value === \"closest-side\") {\n                r = Math.min(x, width - x, y, height - y);\n            } else if (size.value === \"farthest-side\") {\n                r = Math.max(x, width - x, y, height - y);\n            } else if (size.value === \"closest-corner\") {\n                r = Math.min((0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n                    0,\n                    0\n                ], [\n                    x,\n                    y\n                ]), (0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n                    0,\n                    height\n                ], [\n                    x,\n                    y\n                ]), (0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n                    width,\n                    height\n                ], [\n                    x,\n                    y\n                ]), (0,_antv_util__WEBPACK_IMPORTED_MODULE_22__.distanceSquareRoot)([\n                    width,\n                    0\n                ], [\n                    x,\n                    y\n                ]));\n            }\n        }\n    }\n    return {\n        x: x + min[0],\n        y: y + min[1],\n        r: r\n    };\n}\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\nfunction spaceColorStops(colorStops) {\n    var _colorStops$length;\n    var length = colorStops.length;\n    colorStops[length - 1].length = (_colorStops$length = colorStops[length - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {\n        type: \"%\",\n        value: \"100\"\n    };\n    if (length > 1) {\n        var _colorStops$0$length;\n        colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {\n            type: \"%\",\n            value: \"0\"\n        };\n    }\n    var previousIndex = 0;\n    var previousOffset = Number(colorStops[0].length.value);\n    for(var i = 1; i < length; i++){\n        var _colorStops$i$length;\n        // support '%' & 'px'\n        var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;\n        if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(offset) && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(previousOffset)) {\n            for(var j = 1; j < i - previousIndex; j++)colorStops[previousIndex + j].length = {\n                type: \"%\",\n                value: \"\".concat(previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))\n            };\n            previousIndex = i;\n            previousOffset = Number(offset);\n        }\n    }\n}\n// The position of the gradient line's starting point.\n// different from CSS side(to top) @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#values\nvar SideOrCornerToDegMap = {\n    left: 270 - 90,\n    top: 0 - 90,\n    bottom: 180 - 90,\n    right: 90 - 90,\n    \"left top\": 315 - 90,\n    \"top left\": 315 - 90,\n    \"left bottom\": 225 - 90,\n    \"bottom left\": 225 - 90,\n    \"right top\": 45 - 90,\n    \"top right\": 45 - 90,\n    \"right bottom\": 135 - 90,\n    \"bottom right\": 135 - 90\n};\nvar angleToDeg = memoize(function(orientation) {\n    var angle;\n    if (orientation.type === \"angular\") {\n        angle = Number(orientation.value);\n    } else {\n        angle = SideOrCornerToDegMap[orientation.value] || 0;\n    }\n    return getOrCreateUnitValue(angle, \"deg\");\n});\nvar positonToCSSUnitValue = memoize(function(position) {\n    var cx = 50;\n    var cy = 50;\n    var unitX = \"%\";\n    var unitY = \"%\";\n    if ((position === null || position === void 0 ? void 0 : position.type) === \"position\") {\n        var _position$value = position.value, x = _position$value.x, y = _position$value.y;\n        if ((x === null || x === void 0 ? void 0 : x.type) === \"position-keyword\") {\n            if (x.value === \"left\") {\n                cx = 0;\n            } else if (x.value === \"center\") {\n                cx = 50;\n            } else if (x.value === \"right\") {\n                cx = 100;\n            } else if (x.value === \"top\") {\n                cy = 0;\n            } else if (x.value === \"bottom\") {\n                cy = 100;\n            }\n        }\n        if ((y === null || y === void 0 ? void 0 : y.type) === \"position-keyword\") {\n            if (y.value === \"left\") {\n                cx = 0;\n            } else if (y.value === \"center\") {\n                cy = 50;\n            } else if (y.value === \"right\") {\n                cx = 100;\n            } else if (y.value === \"top\") {\n                cy = 0;\n            } else if (y.value === \"bottom\") {\n                cy = 100;\n            }\n        }\n        if ((x === null || x === void 0 ? void 0 : x.type) === \"px\" || (x === null || x === void 0 ? void 0 : x.type) === \"%\" || (x === null || x === void 0 ? void 0 : x.type) === \"em\") {\n            unitX = x === null || x === void 0 ? void 0 : x.type;\n            cx = Number(x.value);\n        }\n        if ((y === null || y === void 0 ? void 0 : y.type) === \"px\" || (y === null || y === void 0 ? void 0 : y.type) === \"%\" || (y === null || y === void 0 ? void 0 : y.type) === \"em\") {\n            unitY = y === null || y === void 0 ? void 0 : y.type;\n            cy = Number(y.value);\n        }\n    }\n    return {\n        cx: getOrCreateUnitValue(cx, unitX),\n        cy: getOrCreateUnitValue(cy, unitY)\n    };\n});\nvar parseGradient = memoize(function(colorStr) {\n    if (colorStr.indexOf(\"linear\") > -1 || colorStr.indexOf(\"radial\") > -1) {\n        var ast = parseGradient$1(colorStr);\n        return ast.map(function(_ref) {\n            var type = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;\n            spaceColorStops(colorStops);\n            var steps = colorStops.map(function(colorStop) {\n                // TODO: only support % for now, should calc percentage of axis length when using px/em\n                return {\n                    offset: getOrCreateUnitValue(Number(colorStop.length.value), \"%\"),\n                    color: colorStopToString(colorStop)\n                };\n            });\n            if (type === \"linear-gradient\") {\n                return new CSSGradientValue(GradientType.LinearGradient, {\n                    angle: orientation ? angleToDeg(orientation) : Odeg,\n                    steps: steps\n                });\n            }\n            if (type === \"radial-gradient\") {\n                if (!orientation) {\n                    orientation = [\n                        {\n                            type: \"shape\",\n                            value: \"circle\"\n                        }\n                    ];\n                }\n                if (orientation[0].type === \"shape\" && orientation[0].value === \"circle\") {\n                    var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;\n                    var size;\n                    if (orientation[0].style) {\n                        var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;\n                        if (_type === \"extent-keyword\") {\n                            size = getOrCreateKeyword(value);\n                        } else {\n                            size = getOrCreateUnitValue(value, _type);\n                        }\n                    }\n                    return new CSSGradientValue(GradientType.RadialGradient, {\n                        cx: cx,\n                        cy: cy,\n                        size: size,\n                        steps: steps\n                    });\n                }\n            // TODO: support ellipse shape\n            // TODO: repeating-linear-gradient & repeating-radial-gradient\n            // } else if (type === 'repeating-linear-gradient') {\n            // } else if (type === 'repeating-radial-gradient') {\n            }\n            return undefined;\n        });\n    }\n    // legacy format, should be deprecated later\n    var type = colorStr[0];\n    if (colorStr[1] === \"(\" || colorStr[2] === \"(\") {\n        if (type === \"l\") {\n            var arr = regexLG.exec(colorStr);\n            if (arr) {\n                var _arr$2$match;\n                var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {\n                    return stop.split(\":\");\n                })) || [];\n                return [\n                    new CSSGradientValue(GradientType.LinearGradient, {\n                        angle: getOrCreateUnitValue(parseFloat(arr[1]), \"deg\"),\n                        steps: steps.map(function(_ref2) {\n                            var _ref3 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_ref2, 2), offset = _ref3[0], color = _ref3[1];\n                            return {\n                                offset: getOrCreateUnitValue(Number(offset) * 100, \"%\"),\n                                color: color\n                            };\n                        })\n                    })\n                ];\n            }\n        } else if (type === \"r\") {\n            var parsedRadialGradient = parseRadialGradient(colorStr);\n            if (parsedRadialGradient) {\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(parsedRadialGradient)) {\n                    colorStr = parsedRadialGradient;\n                } else {\n                    return [\n                        new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)\n                    ];\n                }\n            }\n        } else if (type === \"p\") {\n            return parsePattern(colorStr);\n        }\n    }\n});\nfunction parseRadialGradient(gradientStr) {\n    var arr = regexRG.exec(gradientStr);\n    if (arr) {\n        var _arr$4$match;\n        var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {\n            return stop.split(\":\");\n        })) || [];\n        return {\n            cx: getOrCreateUnitValue(50, \"%\"),\n            cy: getOrCreateUnitValue(50, \"%\"),\n            steps: steps.map(function(_ref4) {\n                var _ref5 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_ref4, 2), offset = _ref5[0], color = _ref5[1];\n                return {\n                    offset: getOrCreateUnitValue(Number(offset) * 100, \"%\"),\n                    color: color\n                };\n            })\n        };\n    }\n    return null;\n}\nfunction parsePattern(patternStr) {\n    var arr = regexPR.exec(patternStr);\n    if (arr) {\n        var repetition = arr[1];\n        var src = arr[2];\n        switch(repetition){\n            case \"a\":\n                repetition = \"repeat\";\n                break;\n            case \"x\":\n                repetition = \"repeat-x\";\n                break;\n            case \"y\":\n                repetition = \"repeat-y\";\n                break;\n            case \"n\":\n                repetition = \"no-repeat\";\n                break;\n            default:\n                repetition = \"no-repeat\";\n        }\n        return {\n            image: src,\n            // @ts-ignore\n            repetition: repetition\n        };\n    }\n    return null;\n}\n/**\n * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createPattern\n */ function isCSSGradientValue(object) {\n    return !!object.type && !!object.value;\n}\nfunction isPattern(object) {\n    return object && !!object.image;\n}\nfunction isCSSRGB(object) {\n    return object && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(object.r) && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(object.g) && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(object.b);\n}\n/**\n * @see https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/parser/CSSParser.cpp#L97\n */ var parseColor = memoize(function(colorStr) {\n    if (isPattern(colorStr)) {\n        return _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n            repetition: \"repeat\"\n        }, colorStr);\n    }\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(colorStr)) {\n        colorStr = \"\";\n    }\n    if (colorStr === \"transparent\") {\n        // transparent black\n        return transparentColor;\n    }\n    if (colorStr === \"currentColor\") {\n        // @see https://github.com/adobe-webplatform/Snap.svg/issues/526\n        colorStr = \"black\";\n    } else if (colorStr === \"none\") {\n        return noneColor;\n    }\n    // support CSS gradient syntax\n    var g = parseGradient(colorStr);\n    if (g) {\n        return g;\n    }\n    // constants\n    var color$1 = color(colorStr);\n    var rgba = [\n        0,\n        0,\n        0,\n        0\n    ];\n    if (color$1 !== null) {\n        rgba[0] = color$1.r || 0;\n        rgba[1] = color$1.g || 0;\n        rgba[2] = color$1.b || 0;\n        rgba[3] = color$1.opacity;\n    }\n    // return new CSSRGB(...rgba);\n    return getOrCreateRGBA.apply(void 0, rgba);\n});\nfunction mergeColors(left, right) {\n    // only support constant value, exclude gradient & pattern\n    if (!isCSSRGB(left) || !isCSSRGB(right)) {\n        return;\n    }\n    return [\n        [\n            Number(left.r),\n            Number(left.g),\n            Number(left.b),\n            Number(left.alpha)\n        ],\n        [\n            Number(right.r),\n            Number(right.g),\n            Number(right.b),\n            Number(right.alpha)\n        ],\n        function(color) {\n            var rgba = color.slice();\n            if (rgba[3]) {\n                for(var i = 0; i < 3; i++)rgba[i] = Math.round((0,_antv_util__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(rgba[i], 0, 255));\n            }\n            rgba[3] = (0,_antv_util__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(rgba[3], 0, 1);\n            return \"rgba(\".concat(rgba.join(\",\"), \")\");\n        }\n    ];\n}\nfunction parseDimension(unitRegExp, string) {\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(string)) {\n        return getOrCreateUnitValue(0, \"px\");\n    }\n    string = \"\".concat(string).trim().toLowerCase();\n    if (isFinite(Number(string))) {\n        if (\"px\".search(unitRegExp) >= 0) {\n            return getOrCreateUnitValue(Number(string), \"px\");\n        }\n        if (\"deg\".search(unitRegExp) >= 0) {\n            return getOrCreateUnitValue(Number(string), \"deg\");\n        }\n    }\n    var matchedUnits = [];\n    string = string.replace(unitRegExp, function(match) {\n        matchedUnits.push(match);\n        return \"U\".concat(match);\n    });\n    var taggedUnitRegExp = \"U(\".concat(unitRegExp.source, \")\");\n    return matchedUnits.map(function(unit) {\n        return getOrCreateUnitValue(Number(string.replace(new RegExp(\"U\".concat(unit), \"g\"), \"\").replace(new RegExp(taggedUnitRegExp, \"g\"), \"*0\")), unit);\n    })[0];\n}\n/**\n * <length>\n * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length\n * length with only absolute unit, eg. 1px\n */ var parseLengthUnmemoize = function parseLengthUnmemoize(css) {\n    return parseDimension(new RegExp(\"px\", \"g\"), css);\n};\nvar parseLength = memoize(parseLengthUnmemoize);\n/**\n * <percentage>\n * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage\n */ var parserPercentageUnmemoize = function parserPercentageUnmemoize(css) {\n    return parseDimension(new RegExp(\"%\", \"g\"), css);\n};\nmemoize(parserPercentageUnmemoize);\n/**\n * length with absolute or relative unit,\n * eg. 1px, 0.7em, 50%, calc(100% - 200px);\n *\n * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length-percentage\n */ var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize(css) {\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(css) || isFinite(Number(css))) {\n        // Number(css) is NaN\n        return getOrCreateUnitValue(Number(css) || 0, \"px\");\n    // return Number(css);\n    }\n    return parseDimension(new RegExp(\"px|%|em|rem\", \"g\"), css);\n};\nvar parseLengthOrPercentage = memoize(parseLengthOrPercentageUnmemoize);\nvar parseAngleUnmemoize = function parseAngleUnmemoize(css) {\n    return parseDimension(new RegExp(\"deg|rad|grad|turn\", \"g\"), css);\n};\nvar parseAngle = memoize(parseAngleUnmemoize);\n/**\n * merge CSSUnitValue\n *\n * @example\n * 10px + 20px = 30px\n * 10deg + 10rad\n * 10% + 20% = 30%\n */ function mergeDimensions(left, right, target, nonNegative) {\n    var index = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var unit = \"\";\n    var leftValue = left.value || 0;\n    var rightValue = right.value || 0;\n    var canonicalUnit = toCanonicalUnit(left.unit);\n    var leftCanonicalUnitValue = left.convertTo(canonicalUnit);\n    var rightCanonicalUnitValue = right.convertTo(canonicalUnit);\n    if (leftCanonicalUnitValue && rightCanonicalUnitValue) {\n        leftValue = leftCanonicalUnitValue.value;\n        rightValue = rightCanonicalUnitValue.value;\n        unit = unitTypeToString(left.unit);\n    } else if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {\n        leftValue = convertPercentUnit(left, index, target);\n        rightValue = convertPercentUnit(right, index, target);\n        unit = \"px\";\n    }\n    return [\n        leftValue,\n        rightValue,\n        function(value) {\n            if (nonNegative) {\n                value = Math.max(value, 0);\n            }\n            return value + unit;\n        }\n    ];\n}\nfunction convertAngleUnit(value) {\n    var deg = 0;\n    if (value.unit === UnitType.kDegrees) {\n        deg = value.value;\n    } else if (value.unit === UnitType.kRadians) {\n        deg = rad2deg(Number(value.value));\n    } else if (value.unit === UnitType.kTurns) {\n        deg = turn2deg(Number(value.value));\n    } else if (value.value) {\n        deg = value.value;\n    }\n    return deg;\n}\nfunction parseDimensionArrayFormat(string, size) {\n    var parsed;\n    if (Array.isArray(string)) {\n        // [1, '2px', 3]\n        parsed = string.map(function(segment) {\n            return Number(segment);\n        });\n    } else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(string)) {\n        parsed = string.split(\" \").map(function(segment) {\n            return Number(segment);\n        });\n    } else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(string)) {\n        parsed = [\n            string\n        ];\n    }\n    if (size === 2) {\n        if (parsed.length === 1) {\n            return [\n                parsed[0],\n                parsed[0]\n            ];\n        }\n        return [\n            parsed[0],\n            parsed[1]\n        ];\n    }\n    if (size === 4) {\n        if (parsed.length === 1) {\n            return [\n                parsed[0],\n                parsed[0],\n                parsed[0],\n                parsed[0]\n            ];\n        }\n        if (parsed.length === 2) {\n            return [\n                parsed[0],\n                parsed[1],\n                parsed[0],\n                parsed[1]\n            ];\n        }\n        if (parsed.length === 3) {\n            return [\n                parsed[0],\n                parsed[1],\n                parsed[2],\n                parsed[1]\n            ];\n        }\n        return [\n            parsed[0],\n            parsed[1],\n            parsed[2],\n            parsed[3]\n        ];\n    }\n    if (size === \"even\" && parsed.length % 2 === 1) {\n        return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(parsed), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(parsed));\n    }\n    return parsed;\n}\n// export function mergeDimensionList(\n//   left: CSSUnitValue[],\n//   right: CSSUnitValue[],\n//   target: IElement | null,\n// ): [number[], number[], (list: number[]) => string] | undefined {\n//   if (left.length !== right.length) {\n//     return;\n//   }\n//   const unit = left[0].unit;\n//   return [\n//     left.map((l) => l.value),\n//     right.map((l) => l.value),\n//     (values: number[]) => {\n//       return values.map((n) => new CSSUnitValue(n, unit)).join(' ');\n//     },\n//   ];\n// }\nfunction convertPercentUnit(valueWithUnit, vec3Index, target) {\n    var useMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (valueWithUnit.unit === UnitType.kPixels) {\n        return Number(valueWithUnit.value);\n    }\n    if (valueWithUnit.unit === UnitType.kPercentage && target) {\n        var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();\n        return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;\n    }\n    return 0;\n}\nvar parseParam = function parseParam(css) {\n    return parseDimension(/deg|rad|grad|turn|px|%/g, css);\n};\nvar supportedFilters = [\n    \"blur\",\n    \"brightness\",\n    \"drop-shadow\",\n    \"contrast\",\n    \"grayscale\",\n    \"sepia\",\n    \"saturate\",\n    \"hue-rotate\",\n    \"invert\"\n];\nfunction parseFilter() {\n    var filterStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    filterStr = filterStr.toLowerCase().trim();\n    if (filterStr === \"none\") {\n        return [];\n    }\n    var filterRegExp = /\\s*([\\w-]+)\\(([^)]*)\\)/g;\n    var result = [];\n    var match;\n    var prevLastIndex = 0;\n    while(match = filterRegExp.exec(filterStr)){\n        if (match.index !== prevLastIndex) {\n            return [];\n        }\n        prevLastIndex = match.index + match[0].length;\n        if (supportedFilters.indexOf(match[1]) > -1) {\n            result.push({\n                name: match[1],\n                params: match[2].split(\" \").map(function(p) {\n                    return parseParam(p) || parseColor(p);\n                })\n            });\n        }\n        if (filterRegExp.lastIndex === filterStr.length) {\n            return result;\n        }\n    }\n    return [];\n}\nfunction numberToString(x) {\n    // scale(0.00000001) -> scale(0)\n    // return x.toFixed(6).replace(/0+$/, '').replace(/\\.$/, '');\n    return x.toString();\n}\n/**\n * parse string or number to CSSUnitValue(numeric)\n *\n * eg.\n * * 0 -> CSSUnitValue(0)\n * * '2' -> CSSUnitValue(2)\n */ var parseNumberUnmemoize = function parseNumberUnmemoize(string) {\n    if (typeof string === \"number\") {\n        return getOrCreateUnitValue(string);\n    }\n    if (/^\\s*[-+]?(\\d*\\.)?\\d+\\s*$/.test(string)) {\n        return getOrCreateUnitValue(Number(string));\n    }\n    return getOrCreateUnitValue(0);\n};\nvar parseNumber = memoize(parseNumberUnmemoize);\nmemoize(function(string) {\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(string)) {\n        return string.split(\" \").map(parseNumber);\n    }\n    return string.map(parseNumber);\n});\nfunction mergeNumbers(left, right) {\n    return [\n        left,\n        right,\n        numberToString\n    ];\n}\nfunction clampedMergeNumbers(min, max) {\n    return function(left, right) {\n        return [\n            left,\n            right,\n            function(x) {\n                return numberToString((0,_antv_util__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(x, min, max));\n            }\n        ];\n    };\n}\nfunction mergeNumberLists(left, right) {\n    if (left.length !== right.length) {\n        return;\n    }\n    return [\n        left,\n        right,\n        function(numberList) {\n            return numberList;\n        }\n    ];\n}\nfunction getOrCalculatePathTotalLength(path) {\n    if (path.parsedStyle.d.totalLength === 0) {\n        path.parsedStyle.d.totalLength = (0,_antv_util__WEBPACK_IMPORTED_MODULE_26__.getTotalLength)(path.parsedStyle.d.absolutePath);\n    }\n    return path.parsedStyle.d.totalLength;\n}\nfunction getOrCalculatePolylineTotalLength(polyline) {\n    if (polyline.parsedStyle.points.totalLength === 0) {\n        polyline.parsedStyle.points.totalLength = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.polylineLength)(polyline.parsedStyle.points.points);\n    }\n    return polyline.parsedStyle.points.totalLength;\n}\nfunction removeRedundantMCommand(path) {\n    for(var i = 0; i < path.length; i++){\n        var prevSegment = path[i - 1];\n        var segment = path[i];\n        var cmd = segment[0];\n        if (cmd === \"M\") {\n            if (prevSegment) {\n                var prevCmd = prevSegment[0];\n                var srcPoint = [\n                    segment[1],\n                    segment[2]\n                ];\n                var destPoint = void 0;\n                if (prevCmd === \"L\" || prevCmd === \"M\") {\n                    destPoint = [\n                        prevSegment[1],\n                        prevSegment[2]\n                    ];\n                } else if (prevCmd === \"C\" || prevCmd === \"A\" || prevCmd === \"Q\") {\n                    destPoint = [\n                        prevSegment[prevSegment.length - 2],\n                        prevSegment[prevSegment.length - 1]\n                    ];\n                }\n                if (destPoint && isSamePoint(srcPoint, destPoint)) {\n                    path.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n}\nfunction hasArcOrBezier(path) {\n    var hasArc = false;\n    var count = path.length;\n    for(var i = 0; i < count; i++){\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === \"C\" || cmd === \"A\" || cmd === \"Q\") {\n            hasArc = true;\n            break;\n        }\n    }\n    return hasArc;\n}\nfunction extractPolygons(pathArray) {\n    var polygons = [];\n    var polylines = [];\n    var points = []; // 防止第一个命令不是 'M'\n    for(var i = 0; i < pathArray.length; i++){\n        var params = pathArray[i];\n        var cmd = params[0];\n        if (cmd === \"M\") {\n            // 遇到 'M' 判定是否是新数组，新数组中没有点\n            if (points.length) {\n                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n                polylines.push(points);\n                points = []; // 创建新的点\n            }\n            points.push([\n                params[1],\n                params[2]\n            ]);\n        } else if (cmd === \"Z\") {\n            if (points.length) {\n                // 存在点\n                polygons.push(points);\n                points = []; // 开始新的点集合\n            }\n        // 如果不存在点，同时 'Z'，则说明是错误，不处理\n        } else {\n            points.push([\n                params[1],\n                params[2]\n            ]);\n        }\n    }\n    // 说明 points 未放入 polygons 或者 polyline\n    // 仅当只有一个 M，没有 Z 时会发生这种情况\n    if (points.length > 0) {\n        polylines.push(points);\n    }\n    return {\n        polygons: polygons,\n        polylines: polylines\n    };\n}\nfunction isSamePoint(point1, point2) {\n    return point1[0] === point2[0] && point1[1] === point2[1];\n}\nfunction getPathBBox(segments, lineWidth) {\n    var xArr = [];\n    var yArr = [];\n    var segmentsWithAngle = [];\n    for(var i = 0; i < segments.length; i++){\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;\n        var box = void 0;\n        switch(segment.command){\n            case \"Q\":\n                box = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.quadBox)(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n                break;\n            case \"C\":\n                box = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.cubicBox)(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);\n                break;\n            case \"A\":\n                var arcParams = segment.arcParams;\n                box = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.arcBox)(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);\n                break;\n            default:\n                xArr.push(currentPoint[0]);\n                yArr.push(currentPoint[1]);\n                break;\n        }\n        if (box) {\n            segment.box = box;\n            xArr.push(box.x, box.x + box.width);\n            yArr.push(box.y, box.y + box.height);\n        }\n        if (lineWidth && (segment.command === \"L\" || segment.command === \"M\") && segment.prePoint && segment.nextPoint) {\n            segmentsWithAngle.push(segment);\n        }\n    }\n    // bbox calculation should ignore NaN for path attribute\n    // ref: https://github.com/antvis/g/issues/210\n    // ref: https://github.com/antvis/G2/issues/3109\n    xArr = xArr.filter(function(item) {\n        return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;\n    });\n    yArr = yArr.filter(function(item) {\n        return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;\n    });\n    var minX = (0,_antv_util__WEBPACK_IMPORTED_MODULE_27__[\"default\"])(xArr);\n    var minY = (0,_antv_util__WEBPACK_IMPORTED_MODULE_27__[\"default\"])(yArr);\n    var maxX = (0,_antv_util__WEBPACK_IMPORTED_MODULE_28__[\"default\"])(xArr);\n    var maxY = (0,_antv_util__WEBPACK_IMPORTED_MODULE_28__[\"default\"])(yArr);\n    if (segmentsWithAngle.length === 0) {\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n    for(var _i = 0; _i < segmentsWithAngle.length; _i++){\n        var _segment = segmentsWithAngle[_i];\n        var _currentPoint = _segment.currentPoint;\n        var extra = void 0;\n        if (_currentPoint[0] === minX) {\n            extra = getExtraFromSegmentWithAngle(_segment, lineWidth);\n            minX -= extra.xExtra;\n        } else if (_currentPoint[0] === maxX) {\n            extra = getExtraFromSegmentWithAngle(_segment, lineWidth);\n            maxX += extra.xExtra;\n        }\n        if (_currentPoint[1] === minY) {\n            extra = getExtraFromSegmentWithAngle(_segment, lineWidth);\n            minY -= extra.yExtra;\n        } else if (_currentPoint[1] === maxY) {\n            extra = getExtraFromSegmentWithAngle(_segment, lineWidth);\n            maxY += extra.yExtra;\n        }\n    }\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getExtraFromSegmentWithAngle(segment, lineWidth) {\n    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;\n    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\n    // 以 currentPoint 为顶点的夹角\n    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));\n    // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n    // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n    if (!currentAngle || Math.sin(currentAngle) === 0 || (0,_antv_util__WEBPACK_IMPORTED_MODULE_29__[\"default\"])(currentAngle, 0)) {\n        return {\n            xExtra: 0,\n            yExtra: 0\n        };\n    }\n    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\n    // 将夹角转为锐角\n    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\n    // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n    // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n    var extra = {\n        // 水平方向投影\n        xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n        // 垂直方向投影\n        yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0\n    };\n    return extra;\n}\n// 点对称\nfunction toSymmetry(point, center) {\n    return [\n        center[0] + (center[0] - point[0]),\n        center[1] + (center[1] - point[1])\n    ];\n}\nvar angleBetween = function angleBetween(v0, v1) {\n    var p = v0.x * v1.x + v0.y * v1.y;\n    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n    var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;\n    var angle = sign * Math.acos(p / n);\n    return angle;\n};\n/**\n * @see https://github.com/rveciana/svg-path-properties/blob/b6bd9a322966f6ef7a311872d80c56e3718de861/src/arc.ts#L121\n */ var pointOnEllipticalArc = function pointOnEllipticalArc(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {\n    // In accordance to: http://www.w3.org/TR/SVG/implnote.html#ArcOutOfRangeParameters\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    xAxisRotation = (0,_antv_util__WEBPACK_IMPORTED_MODULE_30__[\"default\"])(xAxisRotation, 360);\n    var xAxisRotationRadians = deg2rad(xAxisRotation);\n    // If the endpoints are identical, then this is equivalent to omitting the elliptical arc segment entirely.\n    if (p0.x === p1.x && p0.y === p1.y) {\n        return {\n            x: p0.x,\n            y: p0.y,\n            ellipticalArcAngle: 0\n        }; // Check if angle is correct\n    }\n    // If rx = 0 or ry = 0 then this arc is treated as a straight line segment joining the endpoints.\n    if (rx === 0 || ry === 0) {\n        // return this.pointOnLine(p0, p1, t);\n        return {\n            x: 0,\n            y: 0,\n            ellipticalArcAngle: 0\n        }; // Check if angle is correct\n    }\n    // Following \"Conversion from endpoint to center parameterization\"\n    // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n    // Step #1: Compute transformedPoint\n    var dx = (p0.x - p1.x) / 2;\n    var dy = (p0.y - p1.y) / 2;\n    var transformedPoint = {\n        x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,\n        y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy\n    };\n    // Ensure radii are large enough\n    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);\n    if (radiiCheck > 1) {\n        rx *= Math.sqrt(radiiCheck);\n        ry *= Math.sqrt(radiiCheck);\n    }\n    // Step #2: Compute transformedCenter\n    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);\n    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);\n    var cRadicand = cSquareNumerator / cSquareRootDenom;\n    // Make sure this never drops below zero because of precision\n    cRadicand = cRadicand < 0 ? 0 : cRadicand;\n    var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);\n    var transformedCenter = {\n        x: cCoef * (rx * transformedPoint.y / ry),\n        y: cCoef * (-(ry * transformedPoint.x) / rx)\n    };\n    // Step #3: Compute center\n    var center = {\n        x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,\n        y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2\n    };\n    // Step #4: Compute start/sweep angles\n    // Start angle of the elliptical arc prior to the stretch and rotate operations.\n    // Difference between the start and end angles\n    var startVector = {\n        x: (transformedPoint.x - transformedCenter.x) / rx,\n        y: (transformedPoint.y - transformedCenter.y) / ry\n    };\n    var startAngle = angleBetween({\n        x: 1,\n        y: 0\n    }, startVector);\n    var endVector = {\n        x: (-transformedPoint.x - transformedCenter.x) / rx,\n        y: (-transformedPoint.y - transformedCenter.y) / ry\n    };\n    var sweepAngle = angleBetween(startVector, endVector);\n    if (!sweepFlag && sweepAngle > 0) {\n        sweepAngle -= 2 * Math.PI;\n    } else if (sweepFlag && sweepAngle < 0) {\n        sweepAngle += 2 * Math.PI;\n    }\n    // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n    sweepAngle %= 2 * Math.PI;\n    // From http://www.w3.org/TR/SVG/implnote.html#ArcParameterizationAlternatives\n    var angle = startAngle + sweepAngle * t;\n    var ellipseComponentX = rx * Math.cos(angle);\n    var ellipseComponentY = ry * Math.sin(angle);\n    var point = {\n        x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,\n        y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,\n        ellipticalArcStartAngle: startAngle,\n        ellipticalArcEndAngle: startAngle + sweepAngle,\n        ellipticalArcAngle: angle,\n        ellipticalArcCenter: center,\n        resultantRx: rx,\n        resultantRy: ry\n    };\n    return point;\n};\nfunction path2Segments(path) {\n    var segments = [];\n    var currentPoint = null; // 当前图形\n    var nextParams = null; // 下一节点的 path 参数\n    var startMovePoint = null; // 开始 M 的点，可能会有多个\n    var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n    var count = path.length;\n    for(var i = 0; i < count; i++){\n        var params = path[i];\n        nextParams = path[i + 1];\n        var command = params[0];\n        // 数学定义上的参数，便于后面的计算\n        var segment = {\n            command: command,\n            prePoint: currentPoint,\n            params: params,\n            startTangent: null,\n            endTangent: null,\n            currentPoint: null,\n            nextPoint: null,\n            arcParams: null,\n            box: null,\n            cubicParams: null\n        };\n        switch(command){\n            case \"M\":\n                startMovePoint = [\n                    params[1],\n                    params[2]\n                ];\n                lastStartMovePointIndex = i;\n                break;\n            case \"A\":\n                var arcParams = getArcParams(currentPoint, params);\n                segment.arcParams = arcParams;\n                break;\n        }\n        if (command === \"Z\") {\n            // 有了 Z 后，当前节点从开始 M 的点开始\n            currentPoint = startMovePoint;\n            // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n            nextParams = path[lastStartMovePointIndex + 1];\n        } else {\n            var len = params.length;\n            currentPoint = [\n                params[len - 2],\n                params[len - 1]\n            ];\n        }\n        if (nextParams && nextParams[0] === \"Z\") {\n            // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n            nextParams = path[lastStartMovePointIndex];\n            if (segments[lastStartMovePointIndex]) {\n                // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n                segments[lastStartMovePointIndex].prePoint = currentPoint;\n            }\n        }\n        segment.currentPoint = currentPoint;\n        // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n        if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n            segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n        }\n        var nextPoint = nextParams ? [\n            nextParams[nextParams.length - 2],\n            nextParams[nextParams.length - 1]\n        ] : null;\n        segment.nextPoint = nextPoint;\n        // Add startTangent and endTangent\n        var prePoint = segment.prePoint;\n        if ([\n            \"L\",\n            \"H\",\n            \"V\"\n        ].includes(command)) {\n            segment.startTangent = [\n                prePoint[0] - currentPoint[0],\n                prePoint[1] - currentPoint[1]\n            ];\n            segment.endTangent = [\n                currentPoint[0] - prePoint[0],\n                currentPoint[1] - prePoint[1]\n            ];\n        } else if (command === \"Q\") {\n            // 二次贝塞尔曲线只有一个控制点\n            var cp = [\n                params[1],\n                params[2]\n            ];\n            // 二次贝塞尔曲线的终点为 currentPoint\n            segment.startTangent = [\n                prePoint[0] - cp[0],\n                prePoint[1] - cp[1]\n            ];\n            segment.endTangent = [\n                currentPoint[0] - cp[0],\n                currentPoint[1] - cp[1]\n            ];\n        } else if (command === \"T\") {\n            var preSegment = segments[i - 1];\n            var _cp = toSymmetry(preSegment.currentPoint, prePoint);\n            if (preSegment.command === \"Q\") {\n                segment.command = \"Q\";\n                segment.startTangent = [\n                    prePoint[0] - _cp[0],\n                    prePoint[1] - _cp[1]\n                ];\n                segment.endTangent = [\n                    currentPoint[0] - _cp[0],\n                    currentPoint[1] - _cp[1]\n                ];\n            } else {\n                // @ts-ignore\n                segment.command = \"TL\";\n                segment.startTangent = [\n                    prePoint[0] - currentPoint[0],\n                    prePoint[1] - currentPoint[1]\n                ];\n                segment.endTangent = [\n                    currentPoint[0] - prePoint[0],\n                    currentPoint[1] - prePoint[1]\n                ];\n            }\n        } else if (command === \"C\") {\n            // 三次贝塞尔曲线有两个控制点\n            var cp1 = [\n                params[1],\n                params[2]\n            ];\n            var cp2 = [\n                params[3],\n                params[4]\n            ];\n            segment.startTangent = [\n                prePoint[0] - cp1[0],\n                prePoint[1] - cp1[1]\n            ];\n            segment.endTangent = [\n                currentPoint[0] - cp2[0],\n                currentPoint[1] - cp2[1]\n            ];\n            // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n            if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n                segment.startTangent = [\n                    cp1[0] - cp2[0],\n                    cp1[1] - cp2[1]\n                ];\n            }\n            if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n                segment.endTangent = [\n                    cp2[0] - cp1[0],\n                    cp2[1] - cp1[1]\n                ];\n            }\n        } else if (command === \"S\") {\n            var _preSegment = segments[i - 1];\n            var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);\n            var _cp3 = [\n                params[1],\n                params[2]\n            ];\n            if (_preSegment.command === \"C\") {\n                segment.command = \"C\"; // 将 S 命令变换为 C 命令\n                segment.startTangent = [\n                    prePoint[0] - _cp2[0],\n                    prePoint[1] - _cp2[1]\n                ];\n                segment.endTangent = [\n                    currentPoint[0] - _cp3[0],\n                    currentPoint[1] - _cp3[1]\n                ];\n            } else {\n                // @ts-ignore\n                segment.command = \"SQ\"; // 将 S 命令变换为 SQ 命令\n                segment.startTangent = [\n                    prePoint[0] - _cp3[0],\n                    prePoint[1] - _cp3[1]\n                ];\n                segment.endTangent = [\n                    currentPoint[0] - _cp3[0],\n                    currentPoint[1] - _cp3[1]\n                ];\n            }\n        } else if (command === \"A\") {\n            var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;\n            var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;\n            segment.startTangent = [\n                dx1,\n                dy1\n            ];\n            segment.endTangent = [\n                dx2,\n                dy2\n            ];\n        }\n        segments.push(segment);\n    }\n    return segments;\n}\n/**\n * Use length instead of ratio\n */ function getTangentAtRatio(segment, ratio) {\n    var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;\n    var p1 = pointOnEllipticalArc({\n        x: segment.prePoint[0],\n        y: segment.prePoint[1]\n    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {\n        x: segment.currentPoint[0],\n        y: segment.currentPoint[1]\n    }, ratio);\n    var p2 = pointOnEllipticalArc({\n        x: segment.prePoint[0],\n        y: segment.prePoint[1]\n    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {\n        x: segment.currentPoint[0],\n        y: segment.currentPoint[1]\n    }, sign ? ratio + 0.005 : ratio - 0.005);\n    var xDist = p2.x - p1.x;\n    var yDist = p2.y - p1.y;\n    var dist = Math.sqrt(xDist * xDist + yDist * yDist);\n    return {\n        x: -xDist / dist,\n        y: -yDist / dist\n    };\n}\n// 向量长度\nfunction vMag(v) {\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n// u.v/|u||v|，计算夹角的余弦值\nfunction vRatio(u, v) {\n    // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\n    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\n}\n// 向量角度\nfunction vAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\nfunction getArcParams(startPoint, params) {\n    var rx = params[1];\n    var ry = params[2];\n    var xRotation = (0,_antv_util__WEBPACK_IMPORTED_MODULE_30__[\"default\"])(deg2rad(params[3]), Math.PI * 2);\n    var arcFlag = params[4];\n    var sweepFlag = params[5];\n    // 弧形起点坐标\n    var x1 = startPoint[0];\n    var y1 = startPoint[1];\n    // 弧形终点坐标\n    var x2 = params[6];\n    var y2 = params[7];\n    var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;\n    var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;\n    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\n    if (arcFlag === sweepFlag) {\n        f *= -1;\n    }\n    if (isNaN(f)) {\n        f = 0;\n    }\n    // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\n    var cxp = ry ? f * rx * yp / ry : 0;\n    var cyp = rx ? f * -ry * xp / rx : 0;\n    // 椭圆圆心坐标\n    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\n    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\n    // 起始点的单位向量\n    var u = [\n        (xp - cxp) / rx,\n        (yp - cyp) / ry\n    ];\n    // 终止点的单位向量\n    var v = [\n        (-1 * xp - cxp) / rx,\n        (-1 * yp - cyp) / ry\n    ];\n    // 计算起始点和圆心的连线，与 x 轴正方向的夹角\n    var theta = vAngle([\n        1,\n        0\n    ], u);\n    // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\n    var dTheta = vAngle(u, v);\n    if (vRatio(u, v) <= -1) {\n        dTheta = Math.PI;\n    }\n    if (vRatio(u, v) >= 1) {\n        dTheta = 0;\n    }\n    if (sweepFlag === 0 && dTheta > 0) {\n        dTheta -= 2 * Math.PI;\n    }\n    if (sweepFlag === 1 && dTheta < 0) {\n        dTheta += 2 * Math.PI;\n    }\n    return {\n        cx: cx,\n        cy: cy,\n        // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\n        rx: isSamePoint(startPoint, [\n            x2,\n            y2\n        ]) ? 0 : rx,\n        ry: isSamePoint(startPoint, [\n            x2,\n            y2\n        ]) ? 0 : ry,\n        startAngle: theta,\n        endAngle: theta + dTheta,\n        xRotation: xRotation,\n        arcFlag: arcFlag,\n        sweepFlag: sweepFlag\n    };\n}\nfunction commandsToPathString(commands, object, transform) {\n    return commands.reduce(function(prev, cur) {\n        var path = \"\";\n        if (cur[0] === \"M\" || cur[0] === \"L\") {\n            var p = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[1], cur[2], 0);\n            if (transform) {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(p, p, transform);\n            }\n            path = \"\".concat(cur[0]).concat(p[0], \",\").concat(p[1]);\n        } else if (cur[0] === \"Z\") {\n            path = cur[0];\n        } else if (cur[0] === \"C\") {\n            var p1 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[1], cur[2], 0);\n            var p2 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[3], cur[4], 0);\n            var p3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[5], cur[6], 0);\n            if (transform) {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(p1, p1, transform);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(p2, p2, transform);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(p3, p3, transform);\n            }\n            path = \"\".concat(cur[0]).concat(p1[0], \",\").concat(p1[1], \",\").concat(p2[0], \",\").concat(p2[1], \",\").concat(p3[0], \",\").concat(p3[1]);\n        } else if (cur[0] === \"A\") {\n            var c = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[6], cur[7], 0);\n            if (transform) {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(c, c, transform);\n            }\n            path = \"\".concat(cur[0]).concat(cur[1], \",\").concat(cur[2], \",\").concat(cur[3], \",\").concat(cur[4], \",\").concat(cur[5], \",\").concat(c[0], \",\").concat(c[1]);\n        } else if (cur[0] === \"Q\") {\n            var _p = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[1], cur[2], 0);\n            var _p2 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(cur[3], cur[4], 0);\n            if (transform) {\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(_p, _p, transform);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(_p2, _p2, transform);\n            }\n            path = \"\".concat(cur[0]).concat(cur[1], \",\").concat(cur[2], \",\").concat(cur[3], \",\").concat(cur[4], \"}\");\n        }\n        return prev += path;\n    }, \"\");\n}\nfunction lineToCommands(x1, y1, x2, y2) {\n    return [\n        [\n            \"M\",\n            x1,\n            y1\n        ],\n        [\n            \"L\",\n            x2,\n            y2\n        ]\n    ];\n}\nfunction ellipseToCommands(rx, ry, cx, cy) {\n    var factor = (-1 + Math.sqrt(2)) / 3 * 4;\n    var dx = rx * factor;\n    var dy = ry * factor;\n    var left = cx - rx;\n    var right = cx + rx;\n    var top = cy - ry;\n    var bottom = cy + ry;\n    return [\n        [\n            \"M\",\n            left,\n            cy\n        ],\n        [\n            \"C\",\n            left,\n            cy - dy,\n            cx - dx,\n            top,\n            cx,\n            top\n        ],\n        [\n            \"C\",\n            cx + dx,\n            top,\n            right,\n            cy - dy,\n            right,\n            cy\n        ],\n        [\n            \"C\",\n            right,\n            cy + dy,\n            cx + dx,\n            bottom,\n            cx,\n            bottom\n        ],\n        [\n            \"C\",\n            cx - dx,\n            bottom,\n            left,\n            cy + dy,\n            left,\n            cy\n        ],\n        [\n            \"Z\"\n        ]\n    ];\n}\nfunction polygonToCommands(points, closed) {\n    var result = points.map(function(point, i) {\n        return [\n            i === 0 ? \"M\" : \"L\",\n            point[0],\n            point[1]\n        ];\n    });\n    if (closed) {\n        result.push([\n            \"Z\"\n        ]);\n    }\n    return result;\n}\nfunction rectToCommands(width, height, x, y, radius) {\n    // @see https://gist.github.com/danielpquinn/dd966af424030d47e476\n    if (radius) {\n        var _radius = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(radius, 4), tlr = _radius[0], trr = _radius[1], brr = _radius[2], blr = _radius[3];\n        var signX = width > 0 ? 1 : -1;\n        var signY = height > 0 ? 1 : -1;\n        // sweep-flag @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths#arcs\n        var sweepFlag = signX + signY !== 0 ? 1 : 0;\n        return [\n            [\n                \"M\",\n                signX * tlr + x,\n                y\n            ],\n            [\n                \"L\",\n                width - signX * trr + x,\n                y\n            ],\n            trr ? [\n                \"A\",\n                trr,\n                trr,\n                0,\n                0,\n                sweepFlag,\n                width + x,\n                signY * trr + y\n            ] : null,\n            [\n                \"L\",\n                width + x,\n                height - signY * brr + y\n            ],\n            brr ? [\n                \"A\",\n                brr,\n                brr,\n                0,\n                0,\n                sweepFlag,\n                width + x - signX * brr,\n                height + y\n            ] : null,\n            [\n                \"L\",\n                x + signX * blr,\n                height + y\n            ],\n            blr ? [\n                \"A\",\n                blr,\n                blr,\n                0,\n                0,\n                sweepFlag,\n                x,\n                height + y - signY * blr\n            ] : null,\n            [\n                \"L\",\n                x,\n                signY * tlr + y\n            ],\n            tlr ? [\n                \"A\",\n                tlr,\n                tlr,\n                0,\n                0,\n                sweepFlag,\n                signX * tlr + x,\n                y\n            ] : null,\n            [\n                \"Z\"\n            ]\n        ].filter(function(command) {\n            return command;\n        });\n    }\n    return [\n        [\n            \"M\",\n            x,\n            y\n        ],\n        [\n            \"L\",\n            x + width,\n            y\n        ],\n        [\n            \"L\",\n            x + width,\n            y + height\n        ],\n        [\n            \"L\",\n            x,\n            y + height\n        ],\n        [\n            \"Z\"\n        ]\n    ];\n}\n/**\n * convert object to path, should account for:\n * * transform & origin\n * * lineWidth\n */ function convertToPath(object) {\n    var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : object.getLocalTransform();\n    var commands = [];\n    switch(object.nodeName){\n        case Shape.LINE:\n            var _parsedStyle = object.parsedStyle, _parsedStyle$x = _parsedStyle.x1, x1 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = _parsedStyle.y1, y1 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$x2 = _parsedStyle.x2, x2 = _parsedStyle$x2 === void 0 ? 0 : _parsedStyle$x2, _parsedStyle$y2 = _parsedStyle.y2, y2 = _parsedStyle$y2 === void 0 ? 0 : _parsedStyle$y2;\n            commands = lineToCommands(x1, y1, x2, y2);\n            break;\n        case Shape.CIRCLE:\n            {\n                var _parsedStyle2 = object.parsedStyle, _parsedStyle2$r = _parsedStyle2.r, r = _parsedStyle2$r === void 0 ? 0 : _parsedStyle2$r, _parsedStyle2$cx = _parsedStyle2.cx, cx = _parsedStyle2$cx === void 0 ? 0 : _parsedStyle2$cx, _parsedStyle2$cy = _parsedStyle2.cy, cy = _parsedStyle2$cy === void 0 ? 0 : _parsedStyle2$cy;\n                commands = ellipseToCommands(r, r, cx, cy);\n                break;\n            }\n        case Shape.ELLIPSE:\n            {\n                var _parsedStyle3 = object.parsedStyle, _parsedStyle3$rx = _parsedStyle3.rx, rx = _parsedStyle3$rx === void 0 ? 0 : _parsedStyle3$rx, _parsedStyle3$ry = _parsedStyle3.ry, ry = _parsedStyle3$ry === void 0 ? 0 : _parsedStyle3$ry, _parsedStyle3$cx = _parsedStyle3.cx, _cx = _parsedStyle3$cx === void 0 ? 0 : _parsedStyle3$cx, _parsedStyle3$cy = _parsedStyle3.cy, _cy = _parsedStyle3$cy === void 0 ? 0 : _parsedStyle3$cy;\n                commands = ellipseToCommands(rx, ry, _cx, _cy);\n                break;\n            }\n        case Shape.POLYLINE:\n        case Shape.POLYGON:\n            var points = object.parsedStyle.points;\n            commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);\n            break;\n        case Shape.RECT:\n            var _parsedStyle4 = object.parsedStyle, _parsedStyle4$width = _parsedStyle4.width, width = _parsedStyle4$width === void 0 ? 0 : _parsedStyle4$width, _parsedStyle4$height = _parsedStyle4.height, height = _parsedStyle4$height === void 0 ? 0 : _parsedStyle4$height, _parsedStyle4$x = _parsedStyle4.x, x = _parsedStyle4$x === void 0 ? 0 : _parsedStyle4$x, _parsedStyle4$y = _parsedStyle4.y, y = _parsedStyle4$y === void 0 ? 0 : _parsedStyle4$y, radius = _parsedStyle4.radius;\n            var hasRadius = radius && radius.some(function(r) {\n                return r !== 0;\n            });\n            commands = rectToCommands(width, height, x, y, hasRadius && radius.map(function(r) {\n                return (0,_antv_util__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));\n            }));\n            break;\n        case Shape.PATH:\n            var absolutePath = object.parsedStyle.d.absolutePath;\n            commands = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(absolutePath);\n            break;\n    }\n    if (commands.length) {\n        return commandsToPathString(commands, object, transform);\n    }\n}\nfunction translatePathToString(absolutePath) {\n    var startOffsetX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var startOffsetY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var endOffsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var endOffsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var newValue = absolutePath.map(function(params, i) {\n        var command = params[0];\n        var nextSegment = absolutePath[i + 1];\n        var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);\n        var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === \"M\" || nextSegment[0] === \"Z\")) && endOffsetX !== 0 && endOffsetY !== 0;\n        var _ref = useStartOffset ? [\n            startOffsetX,\n            startOffsetY\n        ] : [\n            0,\n            0\n        ], _ref2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];\n        var _ref3 = useEndOffset ? [\n            endOffsetX,\n            endOffsetY\n        ] : [\n            0,\n            0\n        ], _ref4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];\n        switch(command){\n            case \"M\":\n                return \"M \".concat(params[1] + startOffsetXTemp, \",\").concat(params[2] + startOffsetYTemp);\n            case \"L\":\n                return \"L \".concat(params[1] + endOffsetXTemp, \",\").concat(params[2] + endOffsetYTemp);\n            case \"Q\":\n                return \"Q \".concat(params[1], \" \").concat(params[2], \",\").concat(params[3] + endOffsetXTemp, \" \").concat(params[4] + endOffsetYTemp);\n            case \"C\":\n                return \"C \".concat(params[1], \" \").concat(params[2], \",\").concat(params[3], \" \").concat(params[4], \",\").concat(params[5] + endOffsetXTemp, \" \").concat(params[6] + endOffsetYTemp);\n            case \"A\":\n                return \"A \".concat(params[1], \" \").concat(params[2], \" \").concat(params[3], \" \").concat(params[4], \" \").concat(params[5], \" \").concat(params[6], \" \").concat(params[7]).concat(useEndOffset ? \" L \".concat(params[6] + endOffsetX, \",\").concat(params[7] + endOffsetY) : \"\");\n            case \"Z\":\n                return \"Z\";\n            default:\n                return null;\n        }\n    }).filter(function(item) {\n        return item !== null;\n    }).join(\" \");\n    if (~newValue.indexOf(\"NaN\")) {\n        return \"\";\n    }\n    return newValue;\n}\nvar internalParsePath = function internalParsePath(path) {\n    // empty path\n    if (path === \"\" || Array.isArray(path) && path.length === 0) {\n        return {\n            absolutePath: [],\n            hasArc: false,\n            segments: [],\n            polygons: [],\n            polylines: [],\n            curve: null,\n            totalLength: 0,\n            rect: {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            }\n        };\n    }\n    var absolutePath;\n    try {\n        absolutePath = (0,_antv_util__WEBPACK_IMPORTED_MODULE_31__.normalizePath)(path);\n    } catch (_unused) {\n        absolutePath = (0,_antv_util__WEBPACK_IMPORTED_MODULE_31__.normalizePath)(\"\");\n        console.error(\"[g]: Invalid SVG Path definition: \".concat(path));\n    }\n    removeRedundantMCommand(absolutePath);\n    var hasArc = hasArcOrBezier(absolutePath);\n    var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;\n    // for later use\n    var segments = path2Segments(absolutePath);\n    // Only calculate bbox here since we don't need length now.\n    var _getPathBBox = getPathBBox(segments, 0), x = _getPathBBox.x, y = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;\n    return {\n        absolutePath: absolutePath,\n        hasArc: hasArc,\n        segments: segments,\n        polygons: polygons,\n        polylines: polylines,\n        // curve,\n        // Delay the calculation of length.\n        totalLength: 0,\n        rect: {\n            x: Number.isFinite(x) ? x : 0,\n            y: Number.isFinite(y) ? y : 0,\n            width: Number.isFinite(width) ? width : 0,\n            height: Number.isFinite(height) ? height : 0\n        }\n    };\n};\nvar memoizedParsePath = memoize(internalParsePath);\nfunction parsePath(path) {\n    return (0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(path) ? memoizedParsePath(path) : internalParsePath(path);\n}\nfunction mergePaths(left, right, object) {\n    var curve1 = left.curve;\n    var curve2 = right.curve;\n    if (!curve1 || curve1.length === 0) {\n        // convert to curves to do morphing & picking later\n        // @see http://thednp.github.io/kute.js/svgCubicMorph.html\n        curve1 = (0,_antv_util__WEBPACK_IMPORTED_MODULE_32__.path2Curve)(left.absolutePath, false);\n        left.curve = curve1;\n    }\n    if (!curve2 || curve2.length === 0) {\n        curve2 = (0,_antv_util__WEBPACK_IMPORTED_MODULE_32__.path2Curve)(right.absolutePath, false);\n        right.curve = curve2;\n    }\n    var curves = [\n        curve1,\n        curve2\n    ];\n    if (curve1.length !== curve2.length) {\n        curves = (0,_antv_util__WEBPACK_IMPORTED_MODULE_33__.equalizeSegments)(curve1, curve2);\n    }\n    var curve0 = (0,_antv_util__WEBPACK_IMPORTED_MODULE_34__.getDrawDirection)(curves[0]) !== (0,_antv_util__WEBPACK_IMPORTED_MODULE_34__.getDrawDirection)(curves[1]) ? (0,_antv_util__WEBPACK_IMPORTED_MODULE_35__.reverseCurve)(curves[0]) : (0,_antv_util__WEBPACK_IMPORTED_MODULE_36__.clonePath)(curves[0]);\n    return [\n        curve0,\n        (0,_antv_util__WEBPACK_IMPORTED_MODULE_37__.getRotatedCurve)(curves[1], curve0),\n        function(pathArray) {\n            // need converting to path string?\n            return pathArray;\n        }\n    ];\n}\n/**\n * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/points\n *\n * @example\n * points=\"100,10 250,150 200,110\"\n */ function parsePoints(pointsOrStr, object) {\n    var points;\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(pointsOrStr)) {\n        points = pointsOrStr.split(\" \").map(function(pointStr) {\n            var _pointStr$split = pointStr.split(\",\"), _pointStr$split2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_pointStr$split, 2), x = _pointStr$split2[0], y = _pointStr$split2[1];\n            return [\n                Number(x),\n                Number(y)\n            ];\n        });\n    } else {\n        points = pointsOrStr;\n    }\n    return {\n        points: points,\n        totalLength: 0,\n        segments: []\n    };\n}\nfunction mergePoints(left, right) {\n    return [\n        left.points,\n        right.points,\n        function(points) {\n            return points;\n        }\n    ];\n}\n// eg. { t: 'scale', d: [CSSUnitValue(1), CSSUnitValue(2)] }\nvar _ = null;\nvar TRANSFORM_REGEXP = /\\s*(\\w+)\\(([^)]*)\\)/g;\nfunction cast(pattern) {\n    return function(contents) {\n        var i = 0;\n        return pattern.map(function(x) {\n            return x === _ ? contents[i++] : x;\n        });\n    };\n}\nfunction id(x) {\n    return x;\n}\n// type: [argTypes, convertTo3D, convertTo2D]\n// In the argument types string, lowercase characters represent optional arguments\nvar transformFunctions = {\n    // @ts-ignore\n    matrix: [\n        \"NNNNNN\",\n        [\n            _,\n            _,\n            0,\n            0,\n            _,\n            _,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            _,\n            _,\n            0,\n            1\n        ],\n        id\n    ],\n    matrix3d: [\n        \"NNNNNNNNNNNNNNNN\",\n        id\n    ],\n    rotate: [\n        \"A\"\n    ],\n    rotateX: [\n        \"A\"\n    ],\n    rotateY: [\n        \"A\"\n    ],\n    rotateZ: [\n        \"A\"\n    ],\n    rotate3d: [\n        \"NNNA\"\n    ],\n    perspective: [\n        \"L\"\n    ],\n    scale: [\n        \"Nn\",\n        cast([\n            _,\n            _,\n            new CSSUnitValue(1)\n        ]),\n        id\n    ],\n    scaleX: [\n        \"N\",\n        cast([\n            _,\n            new CSSUnitValue(1),\n            new CSSUnitValue(1)\n        ]),\n        cast([\n            _,\n            new CSSUnitValue(1)\n        ])\n    ],\n    scaleY: [\n        \"N\",\n        cast([\n            new CSSUnitValue(1),\n            _,\n            new CSSUnitValue(1)\n        ]),\n        cast([\n            new CSSUnitValue(1),\n            _\n        ])\n    ],\n    scaleZ: [\n        \"N\",\n        cast([\n            new CSSUnitValue(1),\n            new CSSUnitValue(1),\n            _\n        ])\n    ],\n    scale3d: [\n        \"NNN\",\n        id\n    ],\n    skew: [\n        \"Aa\",\n        null,\n        id\n    ],\n    skewX: [\n        \"A\",\n        null,\n        cast([\n            _,\n            Odeg\n        ])\n    ],\n    skewY: [\n        \"A\",\n        null,\n        cast([\n            Odeg,\n            _\n        ])\n    ],\n    translate: [\n        \"Tt\",\n        cast([\n            _,\n            _,\n            Opx\n        ]),\n        id\n    ],\n    translateX: [\n        \"T\",\n        cast([\n            _,\n            Opx,\n            Opx\n        ]),\n        cast([\n            _,\n            Opx\n        ])\n    ],\n    translateY: [\n        \"T\",\n        cast([\n            Opx,\n            _,\n            Opx\n        ]),\n        cast([\n            Opx,\n            _\n        ])\n    ],\n    translateZ: [\n        \"L\",\n        cast([\n            Opx,\n            Opx,\n            _\n        ])\n    ],\n    translate3d: [\n        \"TTL\",\n        id\n    ]\n};\nfunction parseArrayTransform(transform) {\n    var result = [];\n    var length = transform.length;\n    for(var i = 0; i < length; i++){\n        var item = transform[i];\n        var name = item[0];\n        var args = item.slice(1);\n        // infer default value\n        if (name === \"translate\" || name === \"skew\") {\n            if (args.length === 1) args.push(0);\n        } else if (name === \"scale\") {\n            if (args.length === 1) args.push(args[0]);\n        }\n        var functionData = transformFunctions[name];\n        if (!functionData) return [];\n        var parsedArgs = args.map(function(value) {\n            return getOrCreateUnitValue(value);\n        });\n        result.push({\n            t: name,\n            d: parsedArgs\n        });\n    }\n    return result;\n}\n/**\n * none\n * scale(1) scale(1, 2)\n * scaleX(1)\n */ function parseTransform(transform) {\n    if (Array.isArray(transform)) {\n        return parseArrayTransform(transform);\n    }\n    transform = (transform || \"none\").trim();\n    if (transform === \"none\") {\n        return [];\n    }\n    var result = [];\n    var match;\n    var prevLastIndex = 0;\n    TRANSFORM_REGEXP.lastIndex = 0;\n    while(match = TRANSFORM_REGEXP.exec(transform)){\n        if (match.index !== prevLastIndex) {\n            return [];\n        }\n        prevLastIndex = match.index + match[0].length;\n        var functionName = match[1]; // scale\n        var functionData = transformFunctions[functionName]; // scale(1, 2)\n        if (!functionData) {\n            // invalid, eg. scale()\n            return [];\n        }\n        var args = match[2].split(\",\"); // 1,2\n        var argTypes = functionData[0]; // Nn\n        if (argTypes.length < args.length) {\n            // scale(N, n)\n            return [];\n        }\n        var parsedArgs = [];\n        for(var i = 0; i < argTypes.length; i++){\n            var arg = args[i];\n            var type = argTypes[i];\n            var parsedArg = void 0;\n            if (!arg) {\n                // @ts-ignore\n                parsedArg = ({\n                    a: Odeg,\n                    n: parsedArgs[0],\n                    t: Opx\n                })[type];\n            } else {\n                // @ts-ignore\n                parsedArg = ({\n                    A: function A(s) {\n                        return s.trim() === \"0\" ? Odeg : parseAngle(s);\n                    },\n                    N: parseNumber,\n                    T: parseLengthOrPercentage,\n                    L: parseLength\n                })[type.toUpperCase()](arg);\n            }\n            if (parsedArg === undefined) {\n                return [];\n            }\n            parsedArgs.push(parsedArg);\n        }\n        result.push({\n            t: functionName,\n            d: parsedArgs\n        }); // { t: scale, d: [1, 2] }\n        if (TRANSFORM_REGEXP.lastIndex === transform.length) {\n            return result;\n        }\n    }\n    return [];\n}\nfunction parseTransformUnmemoize(transform) {\n    if (Array.isArray(transform)) {\n        return parseArrayTransform(transform);\n    }\n    transform = (transform || \"none\").trim();\n    if (transform === \"none\") {\n        return [];\n    }\n    var result = [];\n    var match;\n    var prevLastIndex = 0;\n    TRANSFORM_REGEXP.lastIndex = 0;\n    while(match = TRANSFORM_REGEXP.exec(transform)){\n        if (match.index !== prevLastIndex) {\n            return [];\n        }\n        prevLastIndex = match.index + match[0].length;\n        var functionName = match[1]; // scale\n        var functionData = transformFunctions[functionName]; // scale(1, 2)\n        if (!functionData) {\n            // invalid, eg. scale()\n            return [];\n        }\n        var args = match[2].split(\",\"); // 1,2\n        var argTypes = functionData[0]; // Nn\n        if (argTypes.length < args.length) {\n            // scale(N, n)\n            return [];\n        }\n        var parsedArgs = [];\n        for(var i = 0; i < argTypes.length; i++){\n            var arg = args[i];\n            var type = argTypes[i];\n            var parsedArg = void 0;\n            if (!arg) {\n                // @ts-ignore\n                parsedArg = ({\n                    a: Odeg,\n                    n: parsedArgs[0],\n                    t: Opx\n                })[type];\n            } else {\n                // @ts-ignore\n                parsedArg = ({\n                    A: function A(s) {\n                        return s.trim() === \"0\" ? Odeg : parseAngleUnmemoize(s);\n                    },\n                    N: parseNumberUnmemoize,\n                    T: parseLengthOrPercentageUnmemoize,\n                    L: parseLengthUnmemoize\n                })[type.toUpperCase()](arg);\n            }\n            if (parsedArg === undefined) {\n                return [];\n            }\n            parsedArgs.push(parsedArg);\n        }\n        result.push({\n            t: functionName,\n            d: parsedArgs\n        }); // { t: scale, d: [1, 2] }\n        if (TRANSFORM_REGEXP.lastIndex === transform.length) {\n            return result;\n        }\n    }\n    return [];\n}\nfunction convertItemToMatrix(item) {\n    var x;\n    var y;\n    var z;\n    var angle;\n    switch(item.t){\n        case \"rotateX\":\n            angle = deg2rad(convertAngleUnit(item.d[0]));\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                Math.cos(angle),\n                Math.sin(angle),\n                0,\n                0,\n                -Math.sin(angle),\n                Math.cos(angle),\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"rotateY\":\n            angle = deg2rad(convertAngleUnit(item.d[0]));\n            return [\n                Math.cos(angle),\n                0,\n                -Math.sin(angle),\n                0,\n                0,\n                1,\n                0,\n                0,\n                Math.sin(angle),\n                0,\n                Math.cos(angle),\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"rotate\":\n        case \"rotateZ\":\n            angle = deg2rad(convertAngleUnit(item.d[0]));\n            return [\n                Math.cos(angle),\n                Math.sin(angle),\n                0,\n                0,\n                -Math.sin(angle),\n                Math.cos(angle),\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"rotate3d\":\n            x = item.d[0].value;\n            y = item.d[1].value;\n            z = item.d[2].value;\n            angle = deg2rad(convertAngleUnit(item.d[3]));\n            var sqrLength = x * x + y * y + z * z;\n            if (sqrLength === 0) {\n                x = 1;\n                y = 0;\n                z = 0;\n            } else if (sqrLength !== 1) {\n                var length = Math.sqrt(sqrLength);\n                x /= length;\n                y /= length;\n                z /= length;\n            }\n            var s = Math.sin(angle / 2);\n            var sc = s * Math.cos(angle / 2);\n            var sq = s * s;\n            return [\n                1 - 2 * (y * y + z * z) * sq,\n                2 * (x * y * sq + z * sc),\n                2 * (x * z * sq - y * sc),\n                0,\n                2 * (x * y * sq - z * sc),\n                1 - 2 * (x * x + z * z) * sq,\n                2 * (y * z * sq + x * sc),\n                0,\n                2 * (x * z * sq + y * sc),\n                2 * (y * z * sq - x * sc),\n                1 - 2 * (x * x + y * y) * sq,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"scale\":\n            return [\n                item.d[0].value,\n                0,\n                0,\n                0,\n                0,\n                item.d[1].value,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"scaleX\":\n            return [\n                item.d[0].value,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"scaleY\":\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                item.d[0].value,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"scaleZ\":\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                item.d[0].value,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"scale3d\":\n            return [\n                item.d[0].value,\n                0,\n                0,\n                0,\n                0,\n                item.d[1].value,\n                0,\n                0,\n                0,\n                0,\n                item.d[2].value,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"skew\":\n            var xAngle = deg2rad(convertAngleUnit(item.d[0]));\n            var yAngle = deg2rad(convertAngleUnit(item.d[1]));\n            return [\n                1,\n                Math.tan(yAngle),\n                0,\n                0,\n                Math.tan(xAngle),\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"skewX\":\n            angle = deg2rad(convertAngleUnit(item.d[0]));\n            return [\n                1,\n                0,\n                0,\n                0,\n                Math.tan(angle),\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"skewY\":\n            angle = deg2rad(convertAngleUnit(item.d[0]));\n            return [\n                1,\n                Math.tan(angle),\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"translate\":\n            // TODO: pass target\n            x = convertPercentUnit(item.d[0], 0, null) || 0;\n            y = convertPercentUnit(item.d[1], 0, null) || 0;\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                x,\n                y,\n                0,\n                1\n            ];\n        case \"translateX\":\n            x = convertPercentUnit(item.d[0], 0, null) || 0;\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                x,\n                0,\n                0,\n                1\n            ];\n        case \"translateY\":\n            y = convertPercentUnit(item.d[0], 0, null) || 0;\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                y,\n                0,\n                1\n            ];\n        case \"translateZ\":\n            z = convertPercentUnit(item.d[0], 0, null) || 0;\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                z,\n                1\n            ];\n        case \"translate3d\":\n            x = convertPercentUnit(item.d[0], 0, null) || 0;\n            y = convertPercentUnit(item.d[1], 0, null) || 0;\n            z = convertPercentUnit(item.d[2], 0, null) || 0;\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                x,\n                y,\n                z,\n                1\n            ];\n        case \"perspective\":\n            var t = convertPercentUnit(item.d[0], 0, null) || 0;\n            var p = t ? -1 / t : 0;\n            return [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                p,\n                0,\n                0,\n                0,\n                1\n            ];\n        case \"matrix\":\n            return [\n                item.d[0].value,\n                item.d[1].value,\n                0,\n                0,\n                item.d[2].value,\n                item.d[3].value,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                item.d[4].value,\n                item.d[5].value,\n                0,\n                1\n            ];\n        case \"matrix3d\":\n            return item.d.map(function(d) {\n                return d.value;\n            });\n    }\n}\nfunction multiplyMatrices(a, b) {\n    return [\n        a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3],\n        a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3],\n        a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3],\n        a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3],\n        a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7],\n        a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7],\n        a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7],\n        a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7],\n        a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11],\n        a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11],\n        a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11],\n        a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11],\n        a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15],\n        a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15],\n        a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15],\n        a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]\n    ];\n}\nfunction convertToMatrix(transformList) {\n    if (transformList.length === 0) {\n        return [\n            1,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            1\n        ];\n    }\n    return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);\n}\nfunction makeMatrixDecomposition(transformList) {\n    var translate = [\n        0,\n        0,\n        0\n    ];\n    var scale = [\n        1,\n        1,\n        1\n    ];\n    var skew = [\n        0,\n        0,\n        0\n    ];\n    var perspective = [\n        0,\n        0,\n        0,\n        1\n    ];\n    var quaternion = [\n        0,\n        0,\n        0,\n        1\n    ];\n    decomposeMat4(// @ts-ignore\n    convertToMatrix(transformList), translate, scale, skew, perspective, quaternion);\n    return [\n        [\n            translate,\n            scale,\n            skew,\n            quaternion,\n            perspective\n        ]\n    ];\n}\nvar composeMatrix = function() {\n    function multiply(a, b) {\n        var result = [\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        for(var i = 0; i < 4; i++){\n            for(var j = 0; j < 4; j++){\n                for(var k = 0; k < 4; k++){\n                    result[i][j] += b[i][k] * a[k][j];\n                }\n            }\n        }\n        return result;\n    }\n    function is2D(m) {\n        return m[0][2] === 0 && m[0][3] === 0 && m[1][2] === 0 && m[1][3] === 0 && m[2][0] === 0 && m[2][1] === 0 && m[2][2] === 1 && m[2][3] === 0 && m[3][2] === 0 && m[3][3] === 1;\n    }\n    function composeMatrix(translate, scale, skew, quat, perspective) {\n        var matrix = [\n            [\n                1,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                1,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                1,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                1\n            ]\n        ];\n        for(var i = 0; i < 4; i++){\n            matrix[i][3] = perspective[i];\n        }\n        for(var _i = 0; _i < 3; _i++){\n            for(var j = 0; j < 3; j++){\n                matrix[3][_i] += translate[j] * matrix[j][_i];\n            }\n        }\n        var x = quat[0];\n        var y = quat[1];\n        var z = quat[2];\n        var w = quat[3];\n        var rotMatrix = [\n            [\n                1,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                1,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                1,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                1\n            ]\n        ];\n        rotMatrix[0][0] = 1 - 2 * (y * y + z * z);\n        rotMatrix[0][1] = 2 * (x * y - z * w);\n        rotMatrix[0][2] = 2 * (x * z + y * w);\n        rotMatrix[1][0] = 2 * (x * y + z * w);\n        rotMatrix[1][1] = 1 - 2 * (x * x + z * z);\n        rotMatrix[1][2] = 2 * (y * z - x * w);\n        rotMatrix[2][0] = 2 * (x * z - y * w);\n        rotMatrix[2][1] = 2 * (y * z + x * w);\n        rotMatrix[2][2] = 1 - 2 * (x * x + y * y);\n        matrix = multiply(matrix, rotMatrix);\n        var temp = [\n            [\n                1,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                1,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                1,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                1\n            ]\n        ];\n        if (skew[2]) {\n            temp[2][1] = skew[2];\n            matrix = multiply(matrix, temp);\n        }\n        if (skew[1]) {\n            temp[2][1] = 0;\n            temp[2][0] = skew[0];\n            matrix = multiply(matrix, temp);\n        }\n        if (skew[0]) {\n            temp[2][0] = 0;\n            temp[1][0] = skew[0];\n            matrix = multiply(matrix, temp);\n        }\n        for(var _i2 = 0; _i2 < 3; _i2++){\n            for(var _j = 0; _j < 3; _j++){\n                matrix[_i2][_j] *= scale[_i2];\n            }\n        }\n        if (is2D(matrix)) {\n            return [\n                matrix[0][0],\n                matrix[0][1],\n                matrix[1][0],\n                matrix[1][1],\n                matrix[3][0],\n                matrix[3][1]\n            ];\n        }\n        return matrix[0].concat(matrix[1], matrix[2], matrix[3]);\n    }\n    return composeMatrix;\n}();\nfunction numberToLongString(x) {\n    return x.toFixed(6).replace(\".000000\", \"\");\n}\nfunction mergeMatrices(left, right) {\n    var leftArgs;\n    var rightArgs;\n    // @ts-ignore\n    if (left.decompositionPair !== right) {\n        // @ts-ignore\n        left.decompositionPair = right;\n        // @ts-ignore\n        leftArgs = makeMatrixDecomposition(left);\n    }\n    // @ts-ignore\n    if (right.decompositionPair !== left) {\n        // @ts-ignore\n        right.decompositionPair = left;\n        // @ts-ignore\n        rightArgs = makeMatrixDecomposition(right);\n    }\n    if (leftArgs[0] === null || rightArgs[0] === null) return [\n        // @ts-ignore\n        [\n            false\n        ],\n        // @ts-ignore\n        [\n            true\n        ],\n        // @ts-ignore\n        function(x) {\n            return x ? right[0].d : left[0].d;\n        }\n    ];\n    leftArgs[0].push(0);\n    rightArgs[0].push(1);\n    return [\n        leftArgs,\n        rightArgs,\n        // @ts-ignore\n        function(list) {\n            // @ts-ignore\n            var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);\n            var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);\n            var stringifiedArgs = mat.map(numberToLongString).join(\",\");\n            return stringifiedArgs;\n        }\n    ];\n}\nfunction dot(v1, v2) {\n    var result = 0;\n    for(var i = 0; i < v1.length; i++){\n        result += v1[i] * v2[i];\n    }\n    return result;\n}\nfunction quat(fromQ, toQ, f) {\n    var product = dot(fromQ, toQ);\n    product = (0,_antv_util__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(product, -1.0, 1.0);\n    var quat = [];\n    if (product === 1.0) {\n        quat = fromQ;\n    } else {\n        var theta = Math.acos(product);\n        var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);\n        for(var i = 0; i < 4; i++){\n            quat.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);\n        }\n    }\n    return quat;\n}\n// scaleX/Y/Z -> scale\nfunction typeTo2D(type) {\n    return type.replace(/[XY]/, \"\");\n}\n// scaleX/Y/Z -> scale3d\nfunction typeTo3D(type) {\n    return type.replace(/(X|Y|Z|3d)?$/, \"3d\");\n}\nvar isMatrixOrPerspective = function isMatrixOrPerspective(lt, rt) {\n    return lt === \"perspective\" && rt === \"perspective\" || (lt === \"matrix\" || lt === \"matrix3d\") && (rt === \"matrix\" || rt === \"matrix3d\");\n};\nfunction mergeTransforms(left, right, target) {\n    var flipResults = false;\n    // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)\n    if (!left.length || !right.length) {\n        if (!left.length) {\n            flipResults = true;\n            left = right;\n            right = [];\n        }\n        var _loop = function _loop() {\n            var _left$i = left[i], type = _left$i.t, args = _left$i.d;\n            // none -> scale(1)/translateX(0)\n            var defaultValue = type.substring(0, 5) === \"scale\" ? 1 : 0;\n            right.push({\n                t: type,\n                d: args.map(function(arg) {\n                    if (typeof arg === \"number\") {\n                        return getOrCreateUnitValue(defaultValue);\n                    }\n                    return getOrCreateUnitValue(defaultValue, arg.unit);\n                //   {\n                //     unit: arg.unit,\n                //     value: defaultValue,\n                //   };\n                })\n            });\n        };\n        for(var i = 0; i < left.length; i++){\n            _loop();\n        }\n    }\n    var leftResult = [];\n    var rightResult = [];\n    var types = [];\n    // merge matrix() with matrix3d()\n    if (left.length !== right.length) {\n        var merged = mergeMatrices(left, right);\n        // @ts-ignore\n        leftResult = [\n            merged[0]\n        ];\n        // @ts-ignore\n        rightResult = [\n            merged[1]\n        ];\n        types = [\n            [\n                \"matrix\",\n                [\n                    merged[2]\n                ]\n            ]\n        ];\n    } else {\n        for(var _i3 = 0; _i3 < left.length; _i3++){\n            var leftType = left[_i3].t;\n            var rightType = right[_i3].t;\n            var leftArgs = left[_i3].d;\n            var rightArgs = right[_i3].d;\n            var leftFunctionData = transformFunctions[leftType];\n            var rightFunctionData = transformFunctions[rightType];\n            var type = void 0;\n            if (isMatrixOrPerspective(leftType, rightType)) {\n                var _merged = mergeMatrices([\n                    left[_i3]\n                ], [\n                    right[_i3]\n                ]);\n                // @ts-ignore\n                leftResult.push(_merged[0]);\n                // @ts-ignore\n                rightResult.push(_merged[1]);\n                types.push([\n                    \"matrix\",\n                    [\n                        _merged[2]\n                    ]\n                ]);\n                continue;\n            } else if (leftType === rightType) {\n                type = leftType;\n            } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {\n                type = typeTo2D(leftType);\n                // @ts-ignore\n                leftArgs = leftFunctionData[2](leftArgs);\n                // @ts-ignore\n                rightArgs = rightFunctionData[2](rightArgs);\n            } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {\n                type = typeTo3D(leftType);\n                // @ts-ignore\n                leftArgs = leftFunctionData[1](leftArgs);\n                // @ts-ignore\n                rightArgs = rightFunctionData[1](rightArgs);\n            } else {\n                var _merged2 = mergeMatrices(left, right);\n                // @ts-ignore\n                leftResult = [\n                    _merged2[0]\n                ];\n                // @ts-ignore\n                rightResult = [\n                    _merged2[1]\n                ];\n                types = [\n                    [\n                        \"matrix\",\n                        [\n                            _merged2[2]\n                        ]\n                    ]\n                ];\n                break;\n            }\n            var leftArgsCopy = [];\n            var rightArgsCopy = [];\n            var stringConversions = [];\n            for(var j = 0; j < leftArgs.length; j++){\n                // const merge = leftArgs[j].unit === UnitType.kNumber ? mergeDimensions : mergeDimensions;\n                var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);\n                leftArgsCopy[j] = _merged3[0];\n                rightArgsCopy[j] = _merged3[1];\n                stringConversions.push(_merged3[2]);\n            }\n            leftResult.push(leftArgsCopy);\n            rightResult.push(rightArgsCopy);\n            types.push([\n                type,\n                stringConversions\n            ]);\n        }\n    }\n    if (flipResults) {\n        var tmp = leftResult;\n        leftResult = rightResult;\n        rightResult = tmp;\n    }\n    return [\n        leftResult,\n        rightResult,\n        function(list) {\n            return list.map(function(args, i) {\n                var stringifiedArgs = args.map(function(arg, j) {\n                    return types[i][1][j](arg);\n                }).join(\",\");\n                if (types[i][0] === \"matrix\" && stringifiedArgs.split(\",\").length === 16) {\n                    types[i][0] = \"matrix3d\";\n                }\n                if (types[i][0] === \"matrix3d\" && stringifiedArgs.split(\",\").length === 6) {\n                    types[i][0] = \"matrix\";\n                }\n                return \"\".concat(types[i][0], \"(\").concat(stringifiedArgs, \")\");\n            }).join(\" \");\n        }\n    ];\n}\n/**\n * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin\n * eg. 'center' 'top left' '50px 50px'\n */ var parseTransformOrigin = memoize(function(value) {\n    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(value)) {\n        if (value === \"text-anchor\") {\n            return [\n                getOrCreateUnitValue(0, \"px\"),\n                getOrCreateUnitValue(0, \"px\")\n            ];\n        }\n        var values = value.split(\" \");\n        if (values.length === 1) {\n            if (values[0] === \"top\" || values[0] === \"bottom\") {\n                // 'top' -> 'center top'\n                values[1] = values[0];\n                values[0] = \"center\";\n            } else {\n                // '50px' -> '50px center'\n                values[1] = \"center\";\n            }\n        }\n        if (values.length !== 2) {\n            return null;\n        }\n        // eg. center bottom\n        return [\n            parseLengthOrPercentage(convertKeyword2Percent(values[0])),\n            parseLengthOrPercentage(convertKeyword2Percent(values[1]))\n        ];\n    }\n    return [\n        getOrCreateUnitValue(value[0] || 0, \"px\"),\n        getOrCreateUnitValue(value[1] || 0, \"px\")\n    ];\n});\nfunction convertKeyword2Percent(keyword) {\n    if (keyword === \"center\") {\n        return \"50%\";\n    }\n    if (keyword === \"left\" || keyword === \"top\") {\n        return \"0%\";\n    }\n    if (keyword === \"right\" || keyword === \"bottom\") {\n        return \"100%\";\n    }\n    return keyword;\n}\n/**\n * Blink used them in code generation(css_properties.json5)\n */ var BUILT_IN_PROPERTIES = [\n    {\n        /**\n   * used in CSS Layout API\n   * eg. `display: 'flex'`\n   */ n: \"display\",\n        k: [\n            \"none\"\n        ]\n    },\n    {\n        /**\n   * range [0.0, 1.0]\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity\n   */ n: \"opacity\",\n        \"int\": true,\n        inh: true,\n        d: \"1\",\n        syntax: PropertySyntax.OPACITY_VALUE\n    },\n    {\n        /**\n   * inheritable, range [0.0, 1.0]\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity\n   * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity\n   */ n: \"fillOpacity\",\n        \"int\": true,\n        inh: true,\n        d: \"1\",\n        syntax: PropertySyntax.OPACITY_VALUE\n    },\n    {\n        /**\n   * inheritable, range [0.0, 1.0]\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity\n   * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity\n   */ n: \"strokeOpacity\",\n        \"int\": true,\n        inh: true,\n        d: \"1\",\n        syntax: PropertySyntax.OPACITY_VALUE\n    },\n    {\n        /**\n   * background-color is not inheritable\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes\n   */ n: \"fill\",\n        \"int\": true,\n        k: [\n            \"none\"\n        ],\n        d: \"none\",\n        syntax: PropertySyntax.PAINT\n    },\n    {\n        n: \"fillRule\",\n        k: [\n            \"nonzero\",\n            \"evenodd\"\n        ],\n        d: \"nonzero\"\n    },\n    /**\n * default to none\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes\n */ {\n        n: \"stroke\",\n        \"int\": true,\n        k: [\n            \"none\"\n        ],\n        d: \"none\",\n        syntax: PropertySyntax.PAINT,\n        /**\n   * Stroke 'none' won't affect geometry but others will.\n   */ l: true\n    },\n    {\n        n: \"shadowType\",\n        k: [\n            \"inner\",\n            \"outer\",\n            \"both\"\n        ],\n        d: \"outer\",\n        l: true\n    },\n    {\n        n: \"shadowColor\",\n        \"int\": true,\n        syntax: PropertySyntax.COLOR\n    },\n    {\n        n: \"shadowOffsetX\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"shadowOffsetY\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"shadowBlur\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.SHADOW_BLUR\n    },\n    {\n        /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width\n   */ n: \"lineWidth\",\n        \"int\": true,\n        inh: true,\n        d: \"1\",\n        l: true,\n        a: [\n            \"strokeWidth\"\n        ],\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"increasedLineWidthForHitTesting\",\n        inh: true,\n        d: \"0\",\n        l: true,\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"lineJoin\",\n        inh: true,\n        l: true,\n        a: [\n            \"strokeLinejoin\"\n        ],\n        k: [\n            \"miter\",\n            \"bevel\",\n            \"round\"\n        ],\n        d: \"miter\"\n    },\n    {\n        n: \"lineCap\",\n        inh: true,\n        l: true,\n        a: [\n            \"strokeLinecap\"\n        ],\n        k: [\n            \"butt\",\n            \"round\",\n            \"square\"\n        ],\n        d: \"butt\"\n    },\n    {\n        n: \"lineDash\",\n        \"int\": true,\n        inh: true,\n        k: [\n            \"none\"\n        ],\n        a: [\n            \"strokeDasharray\"\n        ],\n        syntax: PropertySyntax.LENGTH_PERCENTAGE_12\n    },\n    {\n        n: \"lineDashOffset\",\n        \"int\": true,\n        inh: true,\n        d: \"0\",\n        a: [\n            \"strokeDashoffset\"\n        ],\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"offsetPath\",\n        syntax: PropertySyntax.DEFINED_PATH\n    },\n    {\n        n: \"offsetDistance\",\n        \"int\": true,\n        syntax: PropertySyntax.OFFSET_DISTANCE\n    },\n    {\n        n: \"dx\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"dy\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"zIndex\",\n        ind: true,\n        \"int\": true,\n        d: \"0\",\n        k: [\n            \"auto\"\n        ],\n        syntax: PropertySyntax.Z_INDEX\n    },\n    {\n        n: \"visibility\",\n        k: [\n            \"visible\",\n            \"hidden\"\n        ],\n        ind: true,\n        inh: true,\n        /**\n   * support interpolation\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation\n   */ \"int\": true,\n        d: \"visible\"\n    },\n    {\n        n: \"pointerEvents\",\n        inh: true,\n        k: [\n            \"none\",\n            \"auto\",\n            \"stroke\",\n            \"fill\",\n            \"painted\",\n            \"visible\",\n            \"visiblestroke\",\n            \"visiblefill\",\n            \"visiblepainted\",\n            // 'bounding-box',\n            \"all\"\n        ],\n        d: \"auto\"\n    },\n    {\n        n: \"filter\",\n        ind: true,\n        l: true,\n        k: [\n            \"none\"\n        ],\n        d: \"none\",\n        syntax: PropertySyntax.FILTER\n    },\n    {\n        n: \"clipPath\",\n        syntax: PropertySyntax.DEFINED_PATH\n    },\n    {\n        n: \"textPath\",\n        syntax: PropertySyntax.DEFINED_PATH\n    },\n    {\n        n: \"textPathSide\",\n        k: [\n            \"left\",\n            \"right\"\n        ],\n        d: \"left\"\n    },\n    {\n        n: \"textPathStartOffset\",\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"transform\",\n        p: 100,\n        \"int\": true,\n        k: [\n            \"none\"\n        ],\n        d: \"none\",\n        syntax: PropertySyntax.TRANSFORM\n    },\n    {\n        n: \"transformOrigin\",\n        p: 100,\n        d: \"0 0\",\n        // // int: true,\n        // d: (nodeName: string) => {\n        //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {\n        //     return 'center';\n        //   }\n        //   if (nodeName === Shape.TEXT) {\n        //     return 'text-anchor';\n        //   }\n        //   return 'left top';\n        // },\n        l: true,\n        syntax: PropertySyntax.TRANSFORM_ORIGIN\n    },\n    {\n        n: \"cx\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"cy\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"cz\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"r\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"rx\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"ry\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    // Rect Image Group\n    {\n        // x in local space\n        n: \"x\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        // y in local space\n        n: \"y\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        // z in local space\n        n: \"z\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"width\",\n        \"int\": true,\n        l: true,\n        /**\n   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width\n   */ k: [\n            \"auto\",\n            \"fit-content\",\n            \"min-content\",\n            \"max-content\"\n        ],\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"height\",\n        \"int\": true,\n        l: true,\n        /**\n   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height\n   */ k: [\n            \"auto\",\n            \"fit-content\",\n            \"min-content\",\n            \"max-content\"\n        ],\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"radius\",\n        \"int\": true,\n        l: true,\n        d: \"0\",\n        syntax: PropertySyntax.LENGTH_PERCENTAGE_14\n    },\n    // Line\n    {\n        n: \"x1\",\n        \"int\": true,\n        l: true,\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"y1\",\n        \"int\": true,\n        l: true,\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"z1\",\n        \"int\": true,\n        l: true,\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"x2\",\n        \"int\": true,\n        l: true,\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"y2\",\n        \"int\": true,\n        l: true,\n        syntax: PropertySyntax.COORDINATE\n    },\n    {\n        n: \"z2\",\n        \"int\": true,\n        l: true,\n        syntax: PropertySyntax.COORDINATE\n    },\n    // Path\n    {\n        n: \"d\",\n        \"int\": true,\n        l: true,\n        d: \"\",\n        syntax: PropertySyntax.PATH,\n        p: 50\n    },\n    // Polyline & Polygon\n    {\n        n: \"points\",\n        /**\n   * support interpolation\n   */ \"int\": true,\n        l: true,\n        syntax: PropertySyntax.LIST_OF_POINTS,\n        p: 50\n    },\n    // Text\n    {\n        n: \"text\",\n        l: true,\n        d: \"\",\n        syntax: PropertySyntax.TEXT,\n        p: 50\n    },\n    {\n        n: \"textTransform\",\n        l: true,\n        inh: true,\n        k: [\n            \"capitalize\",\n            \"uppercase\",\n            \"lowercase\",\n            \"none\"\n        ],\n        d: \"none\",\n        syntax: PropertySyntax.TEXT_TRANSFORM,\n        p: 51 // it must get parsed after text\n    },\n    {\n        n: \"font\",\n        l: true\n    },\n    {\n        n: \"fontSize\",\n        \"int\": true,\n        inh: true,\n        /**\n   * @see https://www.w3schools.com/css/css_font_size.asp\n   */ d: \"16px\",\n        l: true,\n        syntax: PropertySyntax.LENGTH_PERCENTAGE\n    },\n    {\n        n: \"fontFamily\",\n        l: true,\n        inh: true,\n        d: \"sans-serif\"\n    },\n    {\n        n: \"fontStyle\",\n        l: true,\n        inh: true,\n        k: [\n            \"normal\",\n            \"italic\",\n            \"oblique\"\n        ],\n        d: \"normal\"\n    },\n    {\n        n: \"fontWeight\",\n        l: true,\n        inh: true,\n        k: [\n            \"normal\",\n            \"bold\",\n            \"bolder\",\n            \"lighter\"\n        ],\n        d: \"normal\"\n    },\n    {\n        n: \"fontVariant\",\n        l: true,\n        inh: true,\n        k: [\n            \"normal\",\n            \"small-caps\"\n        ],\n        d: \"normal\"\n    },\n    {\n        n: \"lineHeight\",\n        l: true,\n        syntax: PropertySyntax.LENGTH,\n        \"int\": true,\n        d: \"0\"\n    },\n    {\n        n: \"letterSpacing\",\n        l: true,\n        syntax: PropertySyntax.LENGTH,\n        \"int\": true,\n        d: \"0\"\n    },\n    {\n        n: \"miterLimit\",\n        l: true,\n        syntax: PropertySyntax.NUMBER,\n        d: function d(nodeName) {\n            if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {\n                return \"4\";\n            }\n            return \"10\";\n        }\n    },\n    {\n        n: \"wordWrap\",\n        l: true\n    },\n    {\n        n: \"wordWrapWidth\",\n        l: true\n    },\n    {\n        n: \"maxLines\",\n        l: true\n    },\n    {\n        n: \"textOverflow\",\n        l: true,\n        d: \"clip\"\n    },\n    {\n        n: \"leading\",\n        l: true\n    },\n    {\n        n: \"textBaseline\",\n        l: true,\n        inh: true,\n        k: [\n            \"top\",\n            \"hanging\",\n            \"middle\",\n            \"alphabetic\",\n            \"ideographic\",\n            \"bottom\"\n        ],\n        d: \"alphabetic\"\n    },\n    {\n        n: \"textAlign\",\n        l: true,\n        inh: true,\n        k: [\n            \"start\",\n            \"center\",\n            \"middle\",\n            \"end\",\n            \"left\",\n            \"right\"\n        ],\n        d: \"start\"\n    },\n    // {\n    //   n: 'whiteSpace',\n    //   l: true,\n    // },\n    {\n        n: \"markerStart\",\n        syntax: PropertySyntax.MARKER\n    },\n    {\n        n: \"markerEnd\",\n        syntax: PropertySyntax.MARKER\n    },\n    {\n        n: \"markerMid\",\n        syntax: PropertySyntax.MARKER\n    },\n    {\n        n: \"markerStartOffset\",\n        syntax: PropertySyntax.LENGTH,\n        l: true,\n        \"int\": true,\n        d: \"0\"\n    },\n    {\n        n: \"markerEndOffset\",\n        syntax: PropertySyntax.LENGTH,\n        l: true,\n        \"int\": true,\n        d: \"0\"\n    }\n];\nvar GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n) {\n    return !!n.l;\n}).map(function(n) {\n    return n.n;\n}));\nvar propertyMetadataCache = {};\nvar DefaultStyleValueRegistry = /*#__PURE__*/ function() {\n    function DefaultStyleValueRegistry(runtime) {\n        var _this = this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DefaultStyleValueRegistry);\n        this.runtime = runtime;\n        BUILT_IN_PROPERTIES.forEach(function(property) {\n            _this.registerMetadata(property);\n        });\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(DefaultStyleValueRegistry, [\n        {\n            key: \"registerMetadata\",\n            value: function registerMetadata(metadata) {\n                [\n                    metadata.n\n                ].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(metadata.a || [])).forEach(function(name) {\n                    propertyMetadataCache[name] = metadata;\n                });\n            }\n        },\n        {\n            key: \"getPropertySyntax\",\n            value: function getPropertySyntax(syntax) {\n                return this.runtime.CSSPropertySyntaxFactory[syntax];\n            }\n        },\n        {\n            key: \"processProperties\",\n            value: function processProperties(object, attributes) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n                    skipUpdateAttribute: false,\n                    skipParse: false,\n                    forceUpdateGeometry: false,\n                    usedAttributes: [],\n                    memoize: true\n                };\n                Object.assign(object.attributes, attributes);\n                // clipPath\n                var oldClipPath = object.parsedStyle.clipPath;\n                var oldOffsetPath = object.parsedStyle.offsetPath;\n                assignParsedStyle(object, attributes);\n                var needUpdateGeometry = !!options.forceUpdateGeometry;\n                if (!needUpdateGeometry) {\n                    for(var i in attributes){\n                        if (GEOMETRY_ATTRIBUTE_NAMES.has(i)) {\n                            needUpdateGeometry = true;\n                            break;\n                        }\n                    }\n                }\n                var list = getParsedStyleListOf(object);\n                if (list.has(\"fill\") && attributes.fill) {\n                    object.parsedStyle.fill = parseColor(attributes.fill);\n                }\n                if (list.has(\"stroke\") && attributes.stroke) {\n                    object.parsedStyle.stroke = parseColor(attributes.stroke);\n                }\n                if (list.has(\"shadowColor\") && attributes.shadowColor) {\n                    object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);\n                }\n                if (list.has(\"filter\") && attributes.filter) {\n                    object.parsedStyle.filter = parseFilter(attributes.filter);\n                }\n                // Rect\n                // @ts-ignore\n                if (list.has(\"radius\") && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(attributes.radius)) {\n                    // @ts-ignore\n                    object.parsedStyle.radius = parseDimensionArrayFormat(// @ts-ignore\n                    attributes.radius, 4);\n                }\n                // Polyline\n                if (list.has(\"lineDash\") && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(attributes.lineDash)) {\n                    // dom标准自动转化奇数长度数组,webgl需要手动处理\n                    object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, \"even\");\n                }\n                // @ts-ignore\n                if (list.has(\"points\") && attributes.points) {\n                    // @ts-ignore\n                    object.parsedStyle.points = parsePoints(attributes.points);\n                }\n                // Path\n                // @ts-ignore\n                if (list.has(\"d\") && attributes.d === \"\") {\n                    object.parsedStyle.d = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, EMPTY_PARSED_PATH);\n                }\n                // @ts-ignore\n                if (list.has(\"d\") && attributes.d) {\n                    object.parsedStyle.d = parsePath(// @ts-ignore\n                    attributes.d);\n                }\n                // Text\n                if (list.has(\"textTransform\") && attributes.textTransform) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {\n                        value: attributes.textTransform\n                    }, object, null);\n                }\n                if (list.has(\"clipPath\") && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(attributes.clipPath)) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator(\"clipPath\", oldClipPath, attributes.clipPath, object, this.runtime);\n                }\n                if (list.has(\"offsetPath\") && attributes.offsetPath) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator(\"offsetPath\", oldOffsetPath, attributes.offsetPath, object, this.runtime);\n                }\n                if (list.has(\"transform\") && attributes.transform) {\n                    object.parsedStyle.transform = parseTransform(attributes.transform);\n                }\n                if (list.has(\"transformOrigin\") && attributes.transformOrigin) {\n                    object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);\n                }\n                // Marker\n                // @ts-ignore\n                if (list.has(\"markerStart\") && attributes.markerStart) {\n                    object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(null, // @ts-ignore\n                    attributes.markerStart, // @ts-ignore\n                    attributes.markerStart, null, null);\n                }\n                // @ts-ignore\n                if (list.has(\"markerEnd\") && attributes.markerEnd) {\n                    object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(null, // @ts-ignore\n                    attributes.markerEnd, // @ts-ignore\n                    attributes.markerEnd, null, null);\n                }\n                // @ts-ignore\n                if (list.has(\"markerMid\") && attributes.markerMid) {\n                    object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(\"\", // @ts-ignore\n                    attributes.markerMid, // @ts-ignore\n                    attributes.markerMid, null, null);\n                }\n                if (list.has(\"zIndex\") && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(attributes.zIndex)) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);\n                }\n                if (list.has(\"offsetDistance\") && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(attributes.offsetDistance)) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);\n                }\n                if (list.has(\"transform\") && attributes.transform) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);\n                }\n                if (list.has(\"transformOrigin\") && attributes.transformOrigin) {\n                    this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);\n                }\n                if (needUpdateGeometry) {\n                    object.geometry.dirty = true;\n                    object.renderable.boundsDirty = true;\n                    object.renderable.renderBoundsDirty = true;\n                    if (!options.forceUpdateGeometry) {\n                        this.runtime.sceneGraphService.dirtifyToRoot(object);\n                    }\n                }\n            }\n        },\n        {\n            key: \"updateGeometry\",\n            value: function updateGeometry(object) {\n                var nodeName = object.nodeName;\n                var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];\n                if (geometryUpdater) {\n                    var geometry = object.geometry;\n                    if (!geometry.contentBounds) {\n                        geometry.contentBounds = new AABB();\n                    }\n                    if (!geometry.renderBounds) {\n                        geometry.renderBounds = new AABB();\n                    }\n                    var parsedStyle = object.parsedStyle;\n                    var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;\n                    // init with content box\n                    var halfExtents = [\n                        Math.abs(hwidth),\n                        Math.abs(hheight),\n                        hdepth\n                    ];\n                    // anchor is center by default, don't account for lineWidth here\n                    var stroke = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? \"outer\" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;\n                    var center = [\n                        cx,\n                        cy,\n                        cz\n                    ];\n                    // update geometry's AABB\n                    geometry.contentBounds.update(center, halfExtents);\n                    // @see https://github.molgen.mpg.de/git-mirror/cairo/blob/master/src/cairo-stroke-style.c#L97..L128\n                    var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;\n                    // append border only if stroke existed\n                    var hasStroke = stroke && !stroke.isNone;\n                    if (hasStroke) {\n                        var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;\n                        halfExtents[0] += halfLineWidth;\n                        halfExtents[1] += halfLineWidth;\n                    }\n                    geometry.renderBounds.update(center, halfExtents);\n                    // account for shadow, only support constant value now\n                    if (shadowColor && shadowType && shadowType !== \"inner\") {\n                        var _geometry$renderBound = geometry.renderBounds, min = _geometry$renderBound.min, max = _geometry$renderBound.max;\n                        var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;\n                        var shadowBlurInPixels = shadowBlur || 0;\n                        var shadowOffsetXInPixels = shadowOffsetX || 0;\n                        var shadowOffsetYInPixels = shadowOffsetY || 0;\n                        var shadowLeft = min[0] - shadowBlurInPixels + shadowOffsetXInPixels;\n                        var shadowRight = max[0] + shadowBlurInPixels + shadowOffsetXInPixels;\n                        var shadowTop = min[1] - shadowBlurInPixels + shadowOffsetYInPixels;\n                        var shadowBottom = max[1] + shadowBlurInPixels + shadowOffsetYInPixels;\n                        min[0] = Math.min(min[0], shadowLeft);\n                        max[0] = Math.max(max[0], shadowRight);\n                        min[1] = Math.min(min[1], shadowTop);\n                        max[1] = Math.max(max[1], shadowBottom);\n                        geometry.renderBounds.setMinMax(min, max);\n                    }\n                    // account for filter, eg. blur(5px), drop-shadow()\n                    filter.forEach(function(_ref) {\n                        var name = _ref.name, params = _ref.params;\n                        if (name === \"blur\") {\n                            var blurRadius = params[0].value;\n                            geometry.renderBounds.update(geometry.renderBounds.center, gl_matrix__WEBPACK_IMPORTED_MODULE_16__.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [\n                                blurRadius,\n                                blurRadius,\n                                0\n                            ]));\n                        } else if (name === \"drop-shadow\") {\n                            var _shadowOffsetX = params[0].value;\n                            var _shadowOffsetY = params[1].value;\n                            var _shadowBlur = params[2].value;\n                            var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;\n                            var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;\n                            var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;\n                            var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;\n                            var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;\n                            _min[0] = Math.min(_min[0], _shadowLeft);\n                            _max[0] = Math.max(_max[0], _shadowRight);\n                            _min[1] = Math.min(_min[1], _shadowTop);\n                            _max[1] = Math.max(_max[1], _shadowBottom);\n                            geometry.renderBounds.setMinMax(_min, _max);\n                        }\n                    });\n                    object.geometry.dirty = false;\n                    // @see https://github.com/antvis/g/issues/957\n                    var flipY = hwidth < 0;\n                    var flipX = hheight < 0;\n                    // set transform origin\n                    var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);\n                    var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);\n                    if (usedOriginXValue || usedOriginYValue) {\n                        object.setOrigin(usedOriginXValue, usedOriginYValue);\n                    }\n                }\n            }\n        },\n        {\n            key: \"updateSizeAttenuation\",\n            value: function updateSizeAttenuation(node, zoom) {\n                if (node.style.isSizeAttenuation) {\n                    if (!node.style.rawLineWidth) {\n                        node.style.rawLineWidth = node.style.lineWidth;\n                    }\n                    node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;\n                    if (node.nodeName === Shape.CIRCLE) {\n                        if (!node.style.rawR) {\n                            node.style.rawR = node.style.r;\n                        }\n                        node.style.r = (node.style.rawR || 1) / zoom;\n                    }\n                } else {\n                    if (node.style.rawLineWidth) {\n                        node.style.lineWidth = node.style.rawLineWidth;\n                        delete node.style.rawLineWidth;\n                    }\n                    if (node.nodeName === Shape.CIRCLE) {\n                        if (node.style.rawR) {\n                            node.style.r = node.style.rawR;\n                            delete node.style.rawR;\n                        }\n                    }\n                }\n            }\n        }\n    ]);\n}();\nfunction assignParsedStyle(object, attributes) {\n    var list = getParsedStyleListOf(object);\n    for(var key in attributes){\n        if (list.has(key)) {\n            object.parsedStyle[key] = attributes[key];\n        }\n    }\n}\nfunction getParsedStyleListOf(object) {\n    return object.constructor.PARSED_STYLE_LIST;\n}\nvar CSSPropertyAngle = /*#__PURE__*/ function() {\n    function CSSPropertyAngle() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyAngle);\n        this.mixer = mergeNumbers;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyAngle, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed, object) {\n                return convertAngleUnit(parsed);\n            }\n        }\n    ]);\n}();\n/**\n * clipPath / textPath / offsetPath\n */ var CSSPropertyClipPath = /*#__PURE__*/ function() {\n    function CSSPropertyClipPath() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyClipPath);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyClipPath, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldPath, newPath, object, runtime) {\n                // unset\n                if (newPath instanceof CSSKeywordValue) {\n                    newPath = null;\n                }\n                runtime.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);\n                if (name === \"clipPath\") {\n                    // should affect children\n                    object.forEach(function(leaf) {\n                        if (leaf.childNodes.length === 0) {\n                            runtime.sceneGraphService.dirtifyToRoot(leaf);\n                        }\n                    });\n                }\n                return newPath;\n            }\n        }\n    ]);\n}();\nvar CSSPropertyColor = /*#__PURE__*/ function() {\n    function CSSPropertyColor() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyColor);\n        this.parser = parseColor;\n        this.mixer = mergeColors;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyColor, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed, object) {\n                if (parsed instanceof CSSKeywordValue) {\n                    // 'unset' 'none'\n                    return parsed.value === \"none\" ? noneColor : transparentColor;\n                }\n                return parsed;\n            }\n        }\n    ]);\n}();\nvar CSSPropertyFilter = /*#__PURE__*/ function() {\n    function CSSPropertyFilter() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyFilter);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyFilter, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed) {\n                // unset or none\n                if (parsed instanceof CSSKeywordValue) {\n                    return [];\n                }\n                return parsed;\n            }\n        }\n    ]);\n}();\nfunction getFontSize(object) {\n    var _ref = object.parsedStyle, fontSize = _ref.fontSize;\n    return (0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(fontSize) ? null : fontSize;\n}\n/**\n * <length> & <percentage>\n */ var CSSPropertyLengthOrPercentage = /*#__PURE__*/ function() {\n    function CSSPropertyLengthOrPercentage() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyLengthOrPercentage);\n        this.mixer = mergeNumbers;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyLengthOrPercentage, [\n        {\n            key: \"calculator\",\n            value: /**\n     * according to parent's bounds\n     *\n     * @example\n     * CSS.percent(50) -> CSS.px(0.5 * parent.width)\n     */ function calculator(name, oldParsed, computed, object, runtime) {\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(computed)) {\n                    return computed;\n                }\n                if (CSSUnitValue.isRelativeUnit(computed.unit)) {\n                    if (computed.unit === UnitType.kPercentage) {\n                        // TODO: merge dimensions\n                        return 0;\n                    }\n                    if (computed.unit === UnitType.kEms) {\n                        if (object.parentNode) {\n                            var fontSize = getFontSize(object.parentNode);\n                            if (fontSize) {\n                                fontSize *= computed.value;\n                                return fontSize;\n                            }\n                        }\n                        return 0;\n                    }\n                    if (computed.unit === UnitType.kRems) {\n                        var _object$ownerDocument;\n                        if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {\n                            var _fontSize = getFontSize(object.ownerDocument.documentElement);\n                            if (_fontSize) {\n                                _fontSize *= computed.value;\n                                return _fontSize;\n                            }\n                        }\n                        return 0;\n                    }\n                } else {\n                    // remove listener if exists\n                    // registry.unregisterParentGeometryBoundsChangedHandler(object, name);\n                    // return absolute value\n                    return computed.value;\n                }\n            }\n        }\n    ]);\n}();\n/**\n * format to Tuple2<CSSUnitValue>\n *\n * @example\n * rect.style.lineDash = 10;\n * rect.style.lineDash = [10, 10];\n * rect.style.lineDash = '10 10';\n */ var CSSPropertyLengthOrPercentage12 = /*#__PURE__*/ function() {\n    function CSSPropertyLengthOrPercentage12() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyLengthOrPercentage12);\n        this.mixer = mergeNumberLists;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyLengthOrPercentage12, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, computed) {\n                return computed.map(function(c) {\n                    return c.value;\n                });\n            }\n        }\n    ]);\n}();\n/**\n * used in rounded rect\n *\n * @example\n * rect.style.radius = 10;\n * rect.style.radius = '10 10';\n * rect.style.radius = '10 10 10 10';\n */ var CSSPropertyLengthOrPercentage14 = /*#__PURE__*/ function() {\n    function CSSPropertyLengthOrPercentage14() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyLengthOrPercentage14);\n        this.mixer = mergeNumberLists;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyLengthOrPercentage14, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, computed) {\n                return computed.map(function(c) {\n                    return c.value;\n                });\n            }\n        }\n    ]);\n}();\nvar CSSPropertyMarker = /*#__PURE__*/ function() {\n    function CSSPropertyMarker() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyMarker);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyMarker, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldMarker, newMarker, object) {\n                var _newMarker;\n                // unset\n                if (newMarker instanceof CSSKeywordValue) {\n                    newMarker = null;\n                }\n                var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);\n                if (cloned) {\n                    // FIXME: SVG should not inherit parent's style, add a flag here\n                    cloned.style.isMarker = true;\n                }\n                return cloned;\n            }\n        }\n    ]);\n}();\nvar CSSPropertyNumber = /*#__PURE__*/ function() {\n    function CSSPropertyNumber() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyNumber);\n        this.mixer = mergeNumbers;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyNumber, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, computed) {\n                return computed.value;\n            }\n        }\n    ]);\n}();\nvar CSSPropertyOffsetDistance = /*#__PURE__*/ function() {\n    function CSSPropertyOffsetDistance() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyOffsetDistance);\n        this.mixer = clampedMergeNumbers(0, 1);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyOffsetDistance, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, computed) {\n                return computed.value;\n            }\n        },\n        {\n            key: \"postProcessor\",\n            value: function postProcessor(object) {\n                var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;\n                if (!offsetPath) {\n                    return;\n                }\n                var nodeName = offsetPath.nodeName;\n                if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {\n                    // set position in world space\n                    var point = offsetPath.getPoint(offsetDistance);\n                    if (point) {\n                        object.setLocalPosition(point.x, point.y);\n                    }\n                }\n            }\n        }\n    ]);\n}();\n/**\n * opacity\n */ var CSSPropertyOpacity = /*#__PURE__*/ function() {\n    function CSSPropertyOpacity() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyOpacity);\n        this.mixer = clampedMergeNumbers(0, 1);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyOpacity, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, computed) {\n                return computed.value;\n            }\n        }\n    ]);\n}();\nvar CSSPropertyPath = /*#__PURE__*/ function() {\n    function CSSPropertyPath() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyPath);\n        /**\n     * path2Curve\n     */ this.parser = parsePath;\n        this.mixer = mergePaths;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyPath, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed) {\n                // unset\n                if (parsed instanceof CSSKeywordValue && parsed.value === \"unset\") {\n                    return {\n                        absolutePath: [],\n                        hasArc: false,\n                        segments: [],\n                        polygons: [],\n                        polylines: [],\n                        curve: null,\n                        totalLength: 0,\n                        rect: new Rectangle(0, 0, 0, 0)\n                    };\n                }\n                return parsed;\n            }\n        }\n    ]);\n}();\nvar CSSPropertyPoints = /*#__PURE__*/ _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(function CSSPropertyPoints() {\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyPoints);\n    this.mixer = mergePoints;\n});\nvar CSSPropertyShadowBlur = /*#__PURE__*/ function(_CSSPropertyLengthOrP) {\n    function CSSPropertyShadowBlur() {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyShadowBlur);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CSSPropertyShadowBlur, [].concat(args));\n        _this.mixer = clampedMergeNumbers(0, Infinity);\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CSSPropertyShadowBlur, _CSSPropertyLengthOrP);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyShadowBlur);\n}(CSSPropertyLengthOrPercentage);\nvar CSSPropertyText = /*#__PURE__*/ function() {\n    function CSSPropertyText() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyText);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyText, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed, object) {\n                if (parsed instanceof CSSKeywordValue) {\n                    if (parsed.value === \"unset\") {\n                        return \"\";\n                    }\n                    return parsed.value;\n                }\n                // allow number as valid text content\n                return \"\".concat(parsed);\n            }\n        },\n        {\n            key: \"postProcessor\",\n            value: function postProcessor(object) {\n                object.nodeValue = \"\".concat(object.parsedStyle.text) || \"\";\n            }\n        }\n    ]);\n}();\n/**\n * it must transform after text get parsed\n * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform\n */ var CSSPropertyTextTransform = /*#__PURE__*/ function() {\n    function CSSPropertyTextTransform() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyTextTransform);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyTextTransform, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed, object) {\n                var rawText = object.getAttribute(\"text\");\n                if (rawText) {\n                    var transformedText = rawText;\n                    if (parsed.value === \"capitalize\") {\n                        transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);\n                    } else if (parsed.value === \"lowercase\") {\n                        transformedText = rawText.toLowerCase();\n                    } else if (parsed.value === \"uppercase\") {\n                        transformedText = rawText.toUpperCase();\n                    }\n                    object.parsedStyle.text = transformedText;\n                }\n                return parsed.value;\n            }\n        }\n    ]);\n}();\nvar definedProps = function definedProps(obj) {\n    return Object.fromEntries(Object.entries(obj).filter(function(_ref) {\n        var _ref2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_ref, 2), v = _ref2[1];\n        return v !== undefined;\n    }));\n};\nvar CANVAS_Map = new WeakMap();\n/**\n * destroy existed canvas with the same id\n */ function cleanExistedCanvas(container, canvas, cleanUp) {\n    if (container) {\n        var $dom = typeof container === \"string\" ? document.getElementById(container) : container;\n        if (CANVAS_Map.has($dom)) CANVAS_Map.get($dom).destroy(cleanUp);\n        CANVAS_Map.set($dom, canvas);\n    }\n}\nvar isBrowser =  false && 0;\nfunction isElement(target) {\n    return !!target.getAttribute;\n}\nfunction sortedIndex(array, value) {\n    var low = 0;\n    var high = array.length;\n    while(low < high){\n        var mid = low + high >>> 1;\n        if (sortByZIndex(array[mid], value) < 0) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction sortByZIndex(o1, o2) {\n    var zIndex1 = Number(o1.parsedStyle.zIndex || 0);\n    var zIndex2 = Number(o2.parsedStyle.zIndex || 0);\n    if (zIndex1 === zIndex2) {\n        var parent = o1.parentNode;\n        if (parent) {\n            var children = parent.childNodes || [];\n            return children.indexOf(o1) - children.indexOf(o2);\n        }\n    }\n    return zIndex1 - zIndex2;\n}\nfunction findClosestClipPathTarget(object) {\n    var el = object;\n    do {\n        var _el$parsedStyle;\n        var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;\n        if (clipPath) return el;\n        el = el.parentElement;\n    }while (el !== null);\n    return null;\n}\nvar PX_SUFFIX = \"px\";\nfunction setDOMSize($el, width, height) {\n    if (isBrowser && $el.style) {\n        $el.style.width = width + PX_SUFFIX;\n        $el.style.height = height + PX_SUFFIX;\n    }\n}\nfunction getStyle($el, property) {\n    if (isBrowser) {\n        return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);\n    }\n}\nfunction getWidth($el) {\n    var width = getStyle($el, \"width\");\n    if (width === \"auto\") {\n        return $el.offsetWidth;\n    }\n    return parseFloat(width);\n}\nfunction getHeight($el) {\n    var height = getStyle($el, \"height\");\n    if (height === \"auto\") {\n        return $el.offsetHeight;\n    }\n    return parseFloat(height);\n}\n// borrow from hammer.js\nvar MOUSE_POINTER_ID = 1;\nvar TOUCH_TO_POINTER = {\n    touchstart: \"pointerdown\",\n    touchend: \"pointerup\",\n    touchendoutside: \"pointerupoutside\",\n    touchmove: \"pointermove\",\n    touchcancel: \"pointercancel\"\n};\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nfunction isInFragment(node) {\n    if (node.nodeName === Shape.FRAGMENT) return true;\n    return node.getRootNode().nodeName === Shape.FRAGMENT;\n}\nfunction isFillOrStrokeAffected() {\n    var pointerEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"auto\";\n    var fill = arguments.length > 1 ? arguments[1] : undefined;\n    var stroke = arguments.length > 2 ? arguments[2] : undefined;\n    // account for pointerEvents\n    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n    var hasFill = false;\n    var hasStroke = false;\n    var isFillOtherThanNone = !!fill && !fill.isNone;\n    var isStrokeOtherThanNone = !!stroke && !stroke.isNone;\n    if (pointerEvents === \"visiblepainted\" || pointerEvents === \"painted\" || pointerEvents === \"auto\") {\n        hasFill = isFillOtherThanNone;\n        hasStroke = isStrokeOtherThanNone;\n    } else if (pointerEvents === \"visiblefill\" || pointerEvents === \"fill\") {\n        hasFill = true;\n    } else if (pointerEvents === \"visiblestroke\" || pointerEvents === \"stroke\") {\n        hasStroke = true;\n    } else if (pointerEvents === \"visible\" || pointerEvents === \"all\") {\n        // The values of the fill and stroke do not affect event processing.\n        hasFill = true;\n        hasStroke = true;\n    }\n    return [\n        hasFill,\n        hasStroke\n    ];\n}\n/**\n * Thanks for following contributor of codes\n * https://gist.github.com/1866474\n * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n * https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/requestAnimationFrame/polyfill.js\n * */ var uId = 1;\nvar uniqueId = function uniqueId() {\n    return uId++;\n};\n// We use `self` instead of `window` for `WebWorker` support.\nvar root = // eslint-disable-next-line no-nested-ternary\ntypeof self === \"object\" && self.self === self ? self : // @ts-ignore\ntypeof global === \"object\" && global.global === global ? // @ts-ignore\nglobal : {};\nvar nowOffset = Date.now();\n// use performance api if exist, otherwise use Date.now.\n// Date.now polyfill required.\nvar pnow = function pnow() {\n    if (root.performance && typeof root.performance.now === \"function\") {\n        return root.performance.now();\n    }\n    // fallback\n    return Date.now() - nowOffset;\n};\nvar reservedCBs = {};\nvar lastTime = Date.now();\nvar polyfillRaf = function polyfillRaf(callback) {\n    if (typeof callback !== \"function\") {\n        throw new TypeError(\"\".concat(callback, \" is not a function\"));\n    }\n    var currentTime = Date.now();\n    var gap = currentTime - lastTime;\n    var delay = gap > 16 ? 0 : 16 - gap;\n    var id = uniqueId();\n    reservedCBs[id] = callback;\n    // keys(reservedCBs).length > 1 의미는 이미 setTimeout 이 걸려있는 경우.\n    // 함께 callback 이 실행될 수 있게 reservedCBs 에만 추가해주고 return\n    if (Object.keys(reservedCBs).length > 1) return id;\n    setTimeout(function() {\n        lastTime = currentTime;\n        var copied = reservedCBs;\n        reservedCBs = {};\n        Object.keys(copied).forEach(function(key) {\n            return copied[key](pnow());\n        });\n    }, delay);\n    return id;\n};\nvar polyfillCaf = function polyfillCaf(id) {\n    delete reservedCBs[id];\n};\nvar vendorPrefixes = [\n    \"\",\n    \"webkit\",\n    \"moz\",\n    \"ms\",\n    \"o\"\n];\nvar getRequestAnimationFrame = function getRequestAnimationFrame(vp) {\n    if (typeof vp !== \"string\") return polyfillRaf;\n    if (vp === \"\") return root.requestAnimationFrame;\n    return root[\"\".concat(vp, \"RequestAnimationFrame\")];\n};\nvar getCancelAnimationFrame = function getCancelAnimationFrame(vp) {\n    if (typeof vp !== \"string\") return polyfillCaf;\n    if (vp === \"\") return root.cancelAnimationFrame;\n    return root[\"\".concat(vp, \"CancelAnimationFrame\")] || root[\"\".concat(vp, \"CancelRequestAnimationFrame\")];\n};\nvar find = function find(arr, predicate) {\n    var i = 0;\n    while(arr[i] !== undefined){\n        if (predicate(arr[i])) return arr[i];\n        i += 1;\n    }\n};\nvar vp = find(vendorPrefixes, function(vp) {\n    return !!getRequestAnimationFrame(vp);\n});\nvar raf = getRequestAnimationFrame(vp);\nvar caf = getCancelAnimationFrame(vp);\nroot.requestAnimationFrame = raf;\nroot.cancelAnimationFrame = caf;\nvar AsyncParallelHook = /*#__PURE__*/ function() {\n    function AsyncParallelHook() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AsyncParallelHook);\n        this.callbacks = [];\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AsyncParallelHook, [\n        {\n            key: \"getCallbacksNum\",\n            value: function getCallbacksNum() {\n                return this.callbacks.length;\n            }\n        },\n        {\n            key: \"tapPromise\",\n            value: function tapPromise(options, fn) {\n                this.callbacks.push(fn);\n            }\n        },\n        {\n            key: \"promise\",\n            value: function promise() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return Promise.all(this.callbacks.map(function(callback) {\n                    return callback.apply(void 0, args);\n                }));\n            }\n        }\n    ]);\n}();\nvar AsyncSeriesWaterfallHook = /*#__PURE__*/ function() {\n    function AsyncSeriesWaterfallHook() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AsyncSeriesWaterfallHook);\n        this.callbacks = [];\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(AsyncSeriesWaterfallHook, [\n        {\n            key: \"tapPromise\",\n            value: function tapPromise(options, fn) {\n                this.callbacks.push(fn);\n            }\n        },\n        {\n            key: \"promise\",\n            value: function() {\n                var _promise = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_13___default()(/*#__PURE__*/ _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default()().mark(function _callee() {\n                    var _this$callbacks, result, i, callback, _args = arguments;\n                    return _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default()().wrap(function _callee$(_context) {\n                        while(1)switch(_context.prev = _context.next){\n                            case 0:\n                                if (!this.callbacks.length) {\n                                    _context.next = 14;\n                                    break;\n                                }\n                                _context.next = 3;\n                                return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);\n                            case 3:\n                                result = _context.sent;\n                                i = 0;\n                            case 5:\n                                if (!(i < this.callbacks.length - 1)) {\n                                    _context.next = 13;\n                                    break;\n                                }\n                                callback = this.callbacks[i]; // @ts-ignore\n                                // eslint-disable-next-line no-await-in-loop\n                                _context.next = 9;\n                                return callback(result);\n                            case 9:\n                                result = _context.sent;\n                            case 10:\n                                i++;\n                                _context.next = 5;\n                                break;\n                            case 13:\n                                return _context.abrupt(\"return\", result);\n                            case 14:\n                                return _context.abrupt(\"return\", null);\n                            case 15:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }, _callee, this);\n                }));\n                function promise() {\n                    return _promise.apply(this, arguments);\n                }\n                return promise;\n            }()\n        }\n    ]);\n}();\nvar SyncHook = /*#__PURE__*/ function() {\n    function SyncHook() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, SyncHook);\n        this.callbacks = [];\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(SyncHook, [\n        {\n            key: \"tap\",\n            value: function tap(options, fn) {\n                this.callbacks.push(fn);\n            }\n        },\n        {\n            key: \"call\",\n            value: function call() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                /* eslint-disable-next-line prefer-rest-params */ var argsArr = arguments;\n                this.callbacks.forEach(function(callback) {\n                    /* eslint-disable-next-line prefer-spread */ callback.apply(undefined, argsArr);\n                });\n            }\n        }\n    ]);\n}();\nvar SyncWaterfallHook = /*#__PURE__*/ function() {\n    function SyncWaterfallHook() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, SyncWaterfallHook);\n        this.callbacks = [];\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(SyncWaterfallHook, [\n        {\n            key: \"tap\",\n            value: function tap(options, fn) {\n                this.callbacks.push(fn);\n            }\n        },\n        {\n            key: \"call\",\n            value: function call() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (this.callbacks.length) {\n                    /* eslint-disable-next-line prefer-rest-params */ var argsArr = arguments;\n                    /* eslint-disable-next-line prefer-spread */ var result = this.callbacks[0].apply(undefined, argsArr);\n                    for(var i = 0; i < this.callbacks.length - 1; i++){\n                        var callback = this.callbacks[i];\n                        // @ts-ignore\n                        result = callback(result);\n                    }\n                    return result;\n                }\n                return null;\n            }\n        }\n    ]);\n}();\nvar genericFontFamilies = [\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\"\n];\nvar stringRegExp = /([\\\"\\'])[^\\'\\\"]+\\1/;\nfunction toFontString(attributes) {\n    var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? \"sans-serif\" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? \"normal\" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? \"normal\" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? \"normal\" : _attributes$fontWeigh;\n    // build canvas api font setting from individual components. Convert a numeric this.fontSize to px\n    // const fontSizeString: string = isNumber(fontSize) ? `${fontSize}px` : fontSize.toString();\n    var fontSizeString = (0,_antv_util__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(fontSize) && \"\".concat(fontSize, \"px\") || \"16px\";\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    var fontFamilies = fontFamily.split(\",\");\n    for(var i = fontFamilies.length - 1; i >= 0; i--){\n        // Trim any extra white-space\n        var _fontFamily = fontFamilies[i].trim();\n        // Check if font already contains strings\n        if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {\n            _fontFamily = '\"'.concat(_fontFamily, '\"');\n        }\n        fontFamilies[i] = _fontFamily;\n    }\n    return \"\".concat(fontStyle, \" \").concat(fontVariant, \" \").concat(fontWeight, \" \").concat(fontSizeString, \" \").concat(fontFamilies.join(\",\"));\n}\nfunction createSkewMatrix(skewMatrix, skewX, skewY) {\n    // Create an identity matrix\n    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.identity(skewMatrix);\n    // Apply skew to the matrix\n    skewMatrix[4] = Math.tan(skewX); // Skew Y axis in X direction\n    skewMatrix[1] = Math.tan(skewY); // Skew X axis in Y direction\n    return skewMatrix;\n}\nvar $mat4_1 = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\nvar $mat4_2 = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\nvar parser = {\n    scale: function scale(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromScaling($mat4_1, [\n            d[0].value,\n            d[1].value,\n            1\n        ]);\n    },\n    scaleX: function scaleX(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromScaling($mat4_1, [\n            d[0].value,\n            1,\n            1\n        ]);\n    },\n    scaleY: function scaleY(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromScaling($mat4_1, [\n            1,\n            d[0].value,\n            1\n        ]);\n    },\n    scaleZ: function scaleZ(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromScaling($mat4_1, [\n            1,\n            1,\n            d[0].value\n        ]);\n    },\n    scale3d: function scale3d(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromScaling($mat4_1, [\n            d[0].value,\n            d[1].value,\n            d[2].value\n        ]);\n    },\n    translate: function translate(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation($mat4_1, [\n            d[0].value,\n            d[1].value,\n            0\n        ]);\n    },\n    translateX: function translateX(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation($mat4_1, [\n            d[0].value,\n            0,\n            0\n        ]);\n    },\n    translateY: function translateY(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation($mat4_1, [\n            0,\n            d[0].value,\n            0\n        ]);\n    },\n    translateZ: function translateZ(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation($mat4_1, [\n            0,\n            0,\n            d[0].value\n        ]);\n    },\n    translate3d: function translate3d(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation($mat4_1, [\n            d[0].value,\n            d[1].value,\n            d[2].value\n        ]);\n    },\n    rotate: function rotate(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d[0])));\n    },\n    rotateX: function rotateX(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromXRotation($mat4_1, deg2rad(convertAngleUnit(d[0])));\n    },\n    rotateY: function rotateY(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromYRotation($mat4_1, deg2rad(convertAngleUnit(d[0])));\n    },\n    rotateZ: function rotateZ(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d[0])));\n    },\n    rotate3d: function rotate3d(d) {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromRotation($mat4_1, deg2rad(convertAngleUnit(d[3])), [\n            d[0].value,\n            d[1].value,\n            d[2].value\n        ]);\n    },\n    skew: function skew(d) {\n        createSkewMatrix($mat4_1, deg2rad(d[0].value), deg2rad(d[1].value));\n    },\n    skewX: function skewX(d) {\n        createSkewMatrix($mat4_1, deg2rad(d[0].value), 0);\n    },\n    skewY: function skewY(d) {\n        createSkewMatrix($mat4_1, 0, deg2rad(d[0].value));\n    },\n    matrix: function matrix(d) {\n        // prettier-ignore\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.set($mat4_1, d[0].value, d[1].value, 0, 0, d[2].value, d[3].value, 0, 0, 0, 0, 1, 0, d[4].value, d[5].value, 0, 1);\n    },\n    matrix3d: function matrix3d(d) {\n        // @ts-ignore\n        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.set.apply(gl_matrix__WEBPACK_IMPORTED_MODULE_19__, [\n            $mat4_1\n        ].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(d.map(function(s) {\n            return s.value;\n        }))));\n    }\n};\nvar $vec3One$1 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(1, 1, 1);\nvar $vec3Zero$1 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nvar optimizer = {\n    translate: function translate(object, d) {\n        runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);\n        runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, undefined, undefined, false);\n        runtime.sceneGraphService.setLocalPosition(object, [\n            d[0].value,\n            d[1].value,\n            0\n        ], false);\n        runtime.sceneGraphService.dirtifyLocal(object, object.transformable);\n    }\n};\nfunction parsedTransformToMat4(transform, object) {\n    if (transform.length) {\n        if (transform.length === 1 && optimizer[transform[0].t]) {\n            optimizer[transform[0].t](object, transform[0].d);\n            return;\n        }\n        var m = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.identity($mat4_2);\n        for(var i = 0; i < transform.length; i++){\n            var _transform$i = transform[i], t = _transform$i.t, d = _transform$i.d;\n            var p = parser[t];\n            if (p) {\n                p(d);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_19__.mul(m, m, $mat4_1);\n            }\n        }\n        object.setLocalTransform(m);\n    } else {\n        object.resetLocalTransform();\n    }\n    return object.getLocalTransform();\n}\n/**\n * @see /zh/docs/api/animation#支持变换的属性\n *\n * support the following formats like CSS Transform:\n *\n * scale\n * * scale(x, y)\n * * scaleX(x)\n * * scaleY(x)\n * * scaleZ(z)\n * * scale3d(x, y, z)\n *\n * translate (unit: none, px, %(relative to its bounds))\n * * translate(x, y) eg. translate(0, 0) translate(0, 30px) translate(100%, 100%)\n * * translateX(0)\n * * translateY(0)\n * * translateZ(0)\n * * translate3d(0, 0, 0)\n *\n * rotate (unit: deg rad turn)\n * * rotate(0.5turn) rotate(30deg) rotate(1rad)\n *\n * none\n *\n * unsupported for now:\n * * calc() eg. translate(calc(100% + 10px))\n * * matrix/matrix3d()\n * * skew/skewX/skewY\n * * perspective\n */ var CSSPropertyTransform = /*#__PURE__*/ function() {\n    function CSSPropertyTransform() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyTransform);\n        this.parser = parseTransformUnmemoize;\n        this.mixer = mergeTransforms;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyTransform, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, parsed, object) {\n                // 'none'\n                if (parsed instanceof CSSKeywordValue) {\n                    return [];\n                }\n                return parsed;\n            }\n        },\n        {\n            key: \"postProcessor\",\n            value: function postProcessor(object) {\n                parsedTransformToMat4(object.parsedStyle.transform, object);\n            }\n        }\n    ]);\n}();\n/**\n * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin\n * @example\n * [10px, 10px] [10%, 10%]\n */ var CSSPropertyTransformOrigin = /*#__PURE__*/ function() {\n    function CSSPropertyTransformOrigin() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyTransformOrigin);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyTransformOrigin, [\n        {\n            key: \"postProcessor\",\n            value: function postProcessor(object) {\n                var transformOrigin = object.parsedStyle.transformOrigin;\n                if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {\n                    object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);\n                } else {\n                    // Relative to geometry bounds, calculate later.\n                    object.getGeometryBounds();\n                }\n            }\n        }\n    ]);\n}();\nvar CSSPropertyZIndex = /*#__PURE__*/ function() {\n    function CSSPropertyZIndex() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CSSPropertyZIndex);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CSSPropertyZIndex, [\n        {\n            key: \"calculator\",\n            value: function calculator(name, oldParsed, computed, object) {\n                return computed.value;\n            }\n        },\n        {\n            key: \"postProcessor\",\n            value: function postProcessor(object) {\n                if (object.parentNode) {\n                    var parentEntity = object.parentNode;\n                    var parentRenderable = parentEntity.renderable;\n                    var parentSortable = parentEntity.sortable;\n                    if (parentRenderable) {\n                        parentRenderable.dirty = true;\n                    }\n                    // need re-sort on parent\n                    if (parentSortable) {\n                        parentSortable.dirty = true;\n                        parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;\n                    }\n                }\n            }\n        }\n    ]);\n}();\nvar CircleUpdater = /*#__PURE__*/ function() {\n    function CircleUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CircleUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CircleUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle, object) {\n                var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;\n                return {\n                    cx: cx,\n                    cy: cy,\n                    hwidth: r,\n                    hheight: r\n                };\n            }\n        }\n    ]);\n}();\nvar EllipseUpdater = /*#__PURE__*/ function() {\n    function EllipseUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, EllipseUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(EllipseUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle, object) {\n                var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;\n                return {\n                    cx: cx,\n                    cy: cy,\n                    hwidth: rx,\n                    hheight: ry\n                };\n            }\n        }\n    ]);\n}();\nvar LineUpdater = /*#__PURE__*/ function() {\n    function LineUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, LineUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(LineUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle) {\n                var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2;\n                var minX = Math.min(x1, x2);\n                var maxX = Math.max(x1, x2);\n                var minY = Math.min(y1, y2);\n                var maxY = Math.max(y1, y2);\n                var width = maxX - minX;\n                var height = maxY - minY;\n                var hwidth = width / 2;\n                var hheight = height / 2;\n                return {\n                    cx: minX + hwidth,\n                    cy: minY + hheight,\n                    hwidth: hwidth,\n                    hheight: hheight\n                };\n            }\n        }\n    ]);\n}();\nvar PathUpdater = /*#__PURE__*/ function() {\n    function PathUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PathUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(PathUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle) {\n                var d = parsedStyle.d;\n                var _d$rect = d.rect, x = _d$rect.x, y = _d$rect.y, width = _d$rect.width, height = _d$rect.height;\n                var hwidth = width / 2;\n                var hheight = height / 2;\n                return {\n                    cx: x + hwidth,\n                    cy: y + hheight,\n                    hwidth: hwidth,\n                    hheight: hheight\n                };\n            }\n        }\n    ]);\n}();\nvar PolylineUpdater = /*#__PURE__*/ function() {\n    function PolylineUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PolylineUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(PolylineUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle) {\n                if (parsedStyle.points && (0,_antv_util__WEBPACK_IMPORTED_MODULE_39__[\"default\"])(parsedStyle.points.points)) {\n                    var points = parsedStyle.points.points;\n                    // FIXME: account for miter lineJoin\n                    var minX = Math.min.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(points.map(function(point) {\n                        return point[0];\n                    })));\n                    var maxX = Math.max.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(points.map(function(point) {\n                        return point[0];\n                    })));\n                    var minY = Math.min.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(points.map(function(point) {\n                        return point[1];\n                    })));\n                    var maxY = Math.max.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(points.map(function(point) {\n                        return point[1];\n                    })));\n                    var width = maxX - minX;\n                    var height = maxY - minY;\n                    var hwidth = width / 2;\n                    var hheight = height / 2;\n                    return {\n                        cx: minX + hwidth,\n                        cy: minY + hheight,\n                        hwidth: hwidth,\n                        hheight: hheight\n                    };\n                }\n                return {\n                    cx: 0,\n                    cy: 0,\n                    hwidth: 0,\n                    hheight: 0\n                };\n            }\n        }\n    ]);\n}();\nvar RectUpdater = /*#__PURE__*/ function() {\n    function RectUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, RectUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(RectUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle, object) {\n                var _parsedStyle$x = parsedStyle.x, x = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;\n                var contentWidth = width;\n                var contentHeight = height;\n                // resize with HTMLImageElement's size\n                if (src && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(src)) {\n                    if (!contentWidth) {\n                        contentWidth = src.width;\n                        parsedStyle.width = contentWidth;\n                    }\n                    if (!contentHeight) {\n                        contentHeight = src.height;\n                        parsedStyle.height = contentHeight;\n                    }\n                }\n                return {\n                    cx: x + contentWidth / 2,\n                    cy: y + contentHeight / 2,\n                    hwidth: contentWidth / 2,\n                    hheight: contentHeight / 2\n                };\n            }\n        }\n    ]);\n}();\nvar TextUpdater = /*#__PURE__*/ function() {\n    function TextUpdater(globalRuntime) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, TextUpdater);\n        this.globalRuntime = globalRuntime;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(TextUpdater, [\n        {\n            key: \"isReadyToMeasure\",\n            value: function isReadyToMeasure(parsedStyle, object) {\n                var text = parsedStyle.text;\n                return text;\n            }\n        },\n        {\n            key: \"update\",\n            value: function update(parsedStyle, object) {\n                var _object$ownerDocument;\n                var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? \"start\" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? \"alphabetic\" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;\n                if (!this.isReadyToMeasure(parsedStyle, object)) {\n                    parsedStyle.metrics = {\n                        font: \"\",\n                        width: 0,\n                        height: 0,\n                        lines: [],\n                        lineWidths: [],\n                        lineHeight: 0,\n                        maxLineWidth: 0,\n                        fontProperties: {\n                            ascent: 0,\n                            descent: 0,\n                            fontSize: 0\n                        },\n                        lineMetrics: []\n                    };\n                    return {\n                        hwidth: 0,\n                        hheight: 0,\n                        cx: 0,\n                        cy: 0\n                    };\n                }\n                var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;\n                var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);\n                parsedStyle.metrics = metrics;\n                var width = metrics.width, height = metrics.height;\n                var hwidth = width / 2;\n                var hheight = height / 2;\n                // default 'left'\n                var lineXOffset = x + hwidth;\n                if (textAlign === \"center\" || textAlign === \"middle\") {\n                    lineXOffset += lineWidth / 2 - hwidth;\n                } else if (textAlign === \"right\" || textAlign === \"end\") {\n                    lineXOffset += lineWidth - hwidth * 2;\n                }\n                var lineYOffset = y - hheight;\n                if (textBaseline === \"middle\") {\n                    lineYOffset += hheight;\n                } else if (textBaseline === \"top\" || textBaseline === \"hanging\") {\n                    lineYOffset += hheight * 2;\n                } else if (textBaseline === \"alphabetic\") ;\n                else if (textBaseline === \"bottom\" || textBaseline === \"ideographic\") {\n                    lineYOffset += 0;\n                }\n                // TODO: ideographic & bottom\n                if (dx) {\n                    lineXOffset += dx;\n                }\n                if (dy) {\n                    lineYOffset += dy;\n                }\n                return {\n                    cx: lineXOffset,\n                    cy: lineYOffset,\n                    hwidth: hwidth,\n                    hheight: hheight\n                };\n            }\n        }\n    ]);\n}();\nvar GroupUpdater = /*#__PURE__*/ function() {\n    function GroupUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, GroupUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(GroupUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle, object) {\n                return {\n                    cx: 0,\n                    cy: 0,\n                    hwidth: 0,\n                    hheight: 0\n                };\n            }\n        }\n    ]);\n}();\nvar HTMLUpdater = /*#__PURE__*/ function() {\n    function HTMLUpdater() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, HTMLUpdater);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(HTMLUpdater, [\n        {\n            key: \"update\",\n            value: function update(parsedStyle, object) {\n                var _parsedStyle$x = parsedStyle.x, x = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;\n                return {\n                    cx: x + width / 2,\n                    cy: y + height / 2,\n                    hwidth: width / 2,\n                    hheight: height / 2\n                };\n            }\n        }\n    ]);\n}();\nfunction isFederatedEvent(value) {\n    return !!value.type;\n}\n/**\n * An DOM-compatible synthetic event implementation that is \"forwarded\" on behalf of an original\n * FederatedEvent or native Event.\n */ var FederatedEvent = /*#__PURE__*/ function() {\n    /**\n   * The event boundary which manages this event. Propagation can only occur\n   *  within the boundary's jurisdiction.\n   */ function FederatedEvent(manager) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, FederatedEvent);\n        /**\n     * The propagation phase.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase\n     */ this.eventPhase = FederatedEvent.prototype.NONE;\n        /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/bubbles\n     */ this.bubbles = true;\n        /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/cancelBubble\n     */ this.cancelBubble = true;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelable\n     */ this.cancelable = false;\n        /** Flags whether the default response of the user agent was prevent through this event. */ this.defaultPrevented = false;\n        /** Flags whether propagation was stopped. */ this.propagationStopped = false;\n        /** Flags whether propagation was immediately stopped. */ this.propagationImmediatelyStopped = false;\n        /**\n     * The coordinates of the evnet relative to the nearest DOM layer.\n     * This is a non-standard property.\n     */ this.layer = new Point();\n        /**\n     * The coordinates of the event relative to the DOM document.\n     * This is a non-standard property.\n     * relative to the DOM document.\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX\n     */ this.page = new Point();\n        /**\n     * relative to Canvas, origin is left-top\n     */ this.canvas = new Point();\n        /**\n     * relative to Viewport, account for Camera\n     */ this.viewport = new Point();\n        this.composed = false;\n        this.NONE = 0;\n        this.CAPTURING_PHASE = 1;\n        this.AT_TARGET = 2;\n        this.BUBBLING_PHASE = 3;\n        this.manager = manager;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(FederatedEvent, [\n        {\n            key: \"name\",\n            get: /**\n     * The type of event, supports the following:\n     * * pointerdown\n     * * touchstart\n     * * mousedown\n     * * rightdown\n     * * ...\n     */ /**\n     * @deprecated\n     */ function get() {\n                return this.type;\n            }\n        },\n        {\n            key: \"layerX\",\n            get: function get() {\n                return this.layer.x;\n            }\n        },\n        {\n            key: \"layerY\",\n            get: function get() {\n                return this.layer.y;\n            }\n        },\n        {\n            key: \"pageX\",\n            get: function get() {\n                return this.page.x;\n            }\n        },\n        {\n            key: \"pageY\",\n            get: function get() {\n                return this.page.y;\n            }\n        },\n        {\n            key: \"x\",\n            get: function get() {\n                return this.canvas.x;\n            }\n        },\n        {\n            key: \"y\",\n            get: function get() {\n                return this.canvas.y;\n            }\n        },\n        {\n            key: \"canvasX\",\n            get: function get() {\n                return this.canvas.x;\n            }\n        },\n        {\n            key: \"canvasY\",\n            get: function get() {\n                return this.canvas.y;\n            }\n        },\n        {\n            key: \"viewportX\",\n            get: function get() {\n                return this.viewport.x;\n            }\n        },\n        {\n            key: \"viewportY\",\n            get: function get() {\n                return this.viewport.y;\n            }\n        },\n        {\n            key: \"composedPath\",\n            value: /**\n     * The propagation path for this event\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath\n     *\n     * So composedPath()[0] represents the original target.\n     * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting\n     */ function composedPath() {\n                if (this.manager && (!this.path || this.path[0] !== this.target)) {\n                    this.path = this.target ? this.manager.propagationPath(this.target) : [];\n                }\n                return this.path;\n            }\n        },\n        {\n            key: \"propagationPath\",\n            get: function get() {\n                return this.composedPath();\n            }\n        },\n        {\n            key: \"preventDefault\",\n            value: function preventDefault() {\n                if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n                    this.nativeEvent.preventDefault();\n                }\n                this.defaultPrevented = true;\n            }\n        },\n        {\n            key: \"stopImmediatePropagation\",\n            value: function stopImmediatePropagation() {\n                this.propagationImmediatelyStopped = true;\n            }\n        },\n        {\n            key: \"stopPropagation\",\n            value: function stopPropagation() {\n                this.propagationStopped = true;\n            }\n        },\n        {\n            key: \"initEvent\",\n            value: /**\n     * added for compatibility with DOM Event,\n     * deprecated props and methods\n     */ function initEvent() {}\n        },\n        {\n            key: \"initUIEvent\",\n            value: function initUIEvent() {}\n        },\n        {\n            key: \"clone\",\n            value: function clone() {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        }\n    ]);\n}();\nvar FederatedMouseEvent = /*#__PURE__*/ function(_ref) {\n    function FederatedMouseEvent() {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, FederatedMouseEvent);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, FederatedMouseEvent, [].concat(args));\n        /** Whether the \"alt\" key was pressed when this mouse event occurred. */ /** The specific button that was pressed in this mouse event. */ /** The button depressed when this event occurred. */ /** Whether the \"control\" key was pressed when this mouse event occurred. */ /** Whether the \"meta\" key was pressed when this mouse event occurred. */ /** This is currently not implemented in the Federated Events API. */ // @ts-ignore\n        /** Whether the \"shift\" key was pressed when this mouse event occurred. */ /**\n     * The coordinates of the mouse event relative to the canvas.\n     */ _this.client = new Point();\n        /**\n     * The movement in this pointer relative to the last `mousemove` event.\n     */ _this.movement = new Point();\n        /**\n     * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is\n     * not supported at the moment.\n     */ _this.offset = new Point();\n        /**\n     * The pointer coordinates in world space.\n     */ _this.global = new Point();\n        /**\n     * The pointer coordinates in sceen space.\n     */ _this.screen = new Point();\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(FederatedMouseEvent, _ref);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(FederatedMouseEvent, [\n        {\n            key: \"clientX\",\n            get: function get() {\n                return this.client.x;\n            }\n        },\n        {\n            key: \"clientY\",\n            get: function get() {\n                return this.client.y;\n            }\n        },\n        {\n            key: \"movementX\",\n            get: function get() {\n                return this.movement.x;\n            }\n        },\n        {\n            key: \"movementY\",\n            get: function get() {\n                return this.movement.y;\n            }\n        },\n        {\n            key: \"offsetX\",\n            get: function get() {\n                return this.offset.x;\n            }\n        },\n        {\n            key: \"offsetY\",\n            get: function get() {\n                return this.offset.y;\n            }\n        },\n        {\n            key: \"globalX\",\n            get: function get() {\n                return this.global.x;\n            }\n        },\n        {\n            key: \"globalY\",\n            get: function get() {\n                return this.global.y;\n            }\n        },\n        {\n            key: \"screenX\",\n            get: function get() {\n                return this.screen.x;\n            }\n        },\n        {\n            key: \"screenY\",\n            get: function get() {\n                return this.screen.y;\n            }\n        },\n        {\n            key: \"getModifierState\",\n            value: function getModifierState(key) {\n                return \"getModifierState\" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n            }\n        },\n        {\n            key: \"initMouseEvent\",\n            value: function initMouseEvent() {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        }\n    ]);\n}(FederatedEvent);\n// @ts-ignore\nvar FederatedPointerEvent = /*#__PURE__*/ function(_FederatedMouseEvent) {\n    function FederatedPointerEvent() {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, FederatedPointerEvent);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, FederatedPointerEvent, [].concat(args));\n        /**\n     * The unique identifier of the pointer.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n     */ /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */ _this.width = 0;\n        /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */ _this.height = 0;\n        /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */ _this.isPrimary = false;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(FederatedPointerEvent, _FederatedMouseEvent);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(FederatedPointerEvent, [\n        {\n            key: \"getCoalescedEvents\",\n            value: /**\n     * The type of pointer that triggered the event.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */ /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */ /**\n     * Barrel pressure on a stylus pointer.\n     *\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */ /**\n     * The angle, in degrees, between the pointer device and the screen.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */ /**\n     * The angle, in degrees, between the pointer device and the screen.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */ /**\n     * Twist of a stylus pointer.\n     *\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */ /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents\n     */ function getCoalescedEvents() {\n                if (this.type === \"pointermove\" || this.type === \"mousemove\" || this.type === \"touchmove\") {\n                    // @ts-ignore\n                    return [\n                        this\n                    ];\n                }\n                return [];\n            }\n        },\n        {\n            key: \"getPredictedEvents\",\n            value: function getPredictedEvents() {\n                throw new Error(\"getPredictedEvents is not supported!\");\n            }\n        },\n        {\n            key: \"clone\",\n            value: function clone() {\n                return this.manager.clonePointerEvent(this);\n            }\n        }\n    ]);\n}(FederatedMouseEvent);\n// @ts-ignore\nvar FederatedWheelEvent = /*#__PURE__*/ function(_FederatedMouseEvent) {\n    function FederatedWheelEvent() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, FederatedWheelEvent);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, FederatedWheelEvent, arguments);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(FederatedWheelEvent, _FederatedMouseEvent);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(FederatedWheelEvent, [\n        {\n            key: \"clone\",\n            value: /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */ /** Horizontal scroll amount */ /** Vertical scroll amount */ /** z-axis scroll amount. */ function clone() {\n                return this.manager.cloneWheelEvent(this);\n            }\n        }\n    ]);\n}(FederatedMouseEvent);\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events\n *\n * @example\n  const event = new CustomEvent('build', { detail: { prop1: 'xx' } });\n  circle.addEventListener('build', (e) => {\n    e.target; // circle\n    e.detail; // { prop1: 'xx' }\n  });\n\n  circle.dispatchEvent(event);\n */ var CustomEvent = /*#__PURE__*/ function(_FederatedEvent) {\n    function CustomEvent(eventName, object) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CustomEvent);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CustomEvent, [\n            null\n        ]);\n        _this.type = eventName;\n        _this.detail = object;\n        // compatible with G 3.0\n        Object.assign(_this, object);\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CustomEvent, _FederatedEvent);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CustomEvent);\n}(FederatedEvent);\nvar CANVAS_CACHE = new WeakMap();\n/**\n * Objects that can receive events and may have listeners for them.\n * eg. Element, Canvas, DisplayObject\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n */ var EventTarget = /*#__PURE__*/ function() {\n    function EventTarget() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, EventTarget);\n        /**\n     * event emitter\n     */ this.emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(EventTarget, [\n        {\n            key: \"on\",\n            value: /**\n     * @deprecated\n     * @alias addEventListener\n     */ function on(type, listener, options) {\n                this.addEventListener(type, listener, options);\n                return this;\n            }\n        },\n        {\n            key: \"addEventListener\",\n            value: function addEventListener(type, listener, options) {\n                var capture = false;\n                var once = false;\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_40__[\"default\"])(options)) capture = options;\n                else if (options) {\n                    var _options$capture = options.capture;\n                    capture = _options$capture === void 0 ? false : _options$capture;\n                    var _options$once = options.once;\n                    once = _options$once === void 0 ? false : _options$once;\n                }\n                if (capture) type += \"capture\";\n                // eslint-disable-next-line @typescript-eslint/unbound-method\n                listener = (0,_antv_util__WEBPACK_IMPORTED_MODULE_41__[\"default\"])(listener) ? listener : listener.handleEvent;\n                var context = (0,_antv_util__WEBPACK_IMPORTED_MODULE_41__[\"default\"])(listener) ? undefined : listener;\n                if (once) this.emitter.once(type, listener, context);\n                else this.emitter.on(type, listener, context);\n                return this;\n            }\n        },\n        {\n            key: \"off\",\n            value: function off(type, listener, options) {\n                if (type) {\n                    this.removeEventListener(type, listener, options);\n                } else {\n                    // remove all listeners\n                    this.removeAllEventListeners();\n                }\n                return this;\n            }\n        },\n        {\n            key: \"removeAllEventListeners\",\n            value: function removeAllEventListeners() {\n                var _this$emitter;\n                (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();\n            }\n        },\n        {\n            key: \"removeEventListener\",\n            value: function removeEventListener(type, listener, options) {\n                var _listener;\n                if (!this.emitter) return this;\n                var capture = (0,_antv_util__WEBPACK_IMPORTED_MODULE_40__[\"default\"])(options) ? options : options === null || options === void 0 ? void 0 : options.capture;\n                if (capture) type += \"capture\";\n                // eslint-disable-next-line @typescript-eslint/unbound-method\n                listener = (0,_antv_util__WEBPACK_IMPORTED_MODULE_41__[\"default\"])(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;\n                var context = (0,_antv_util__WEBPACK_IMPORTED_MODULE_41__[\"default\"])(listener) ? undefined : listener;\n                this.emitter.off(type, listener, context);\n                return this;\n            }\n        },\n        {\n            key: \"emit\",\n            value: function emit(eventName, object) {\n                this.dispatchEvent(new CustomEvent(eventName, object));\n            }\n        },\n        {\n            key: \"dispatchEvent\",\n            value: function dispatchEvent(e) {\n                var skipPropagate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var canvas = CANVAS_CACHE.get(this);\n                if (!canvas) {\n                    var _ownerDocument;\n                    // @ts-expect-error document may be defined in inherited class\n                    if (this.document) canvas = this;\n                    else if (this.defaultView) canvas = this.defaultView;\n                    else canvas = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;\n                    if (canvas) CANVAS_CACHE.set(this, canvas);\n                }\n                if (canvas) {\n                    e.manager = canvas.getEventService();\n                    if (!e.manager) return false;\n                    e.defaultPrevented = false;\n                    if (e.path) e.path.length = 0;\n                    else e.page = [];\n                    if (!skipPropagate) e.target = this;\n                    e.manager.dispatchEvent(e, e.type, skipPropagate);\n                } else {\n                    // HACK Fixed the issue that after an element leaves the DOM tree, there is no associated canvas,\n                    // which causes the removed and destroy events to not be triggered\n                    this.emitter.emit(e.type, e);\n                }\n                return !e.defaultPrevented;\n            }\n        }\n    ]);\n}();\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node\n */ var Node = /*#__PURE__*/ function(_EventTarget) {\n    function Node() {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Node);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Node, [].concat(args));\n        _this.shadow = false;\n        /**\n     * points to canvas.document\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/ownerDocument\n     */ _this.ownerDocument = null;\n        /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isConnected\n     * @example\n        circle.isConnected; // false\n        canvas.appendChild(circle);\n        circle.isConnected; // true\n     */ _this.isConnected = false;\n        /**\n     * Returns node's node document's document base URL.\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node\n     */ _this.baseURI = \"\";\n        /**\n     * Returns the children.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes\n     */ _this.childNodes = [];\n        /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType\n     */ _this.nodeType = 0;\n        /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName\n     */ _this.nodeName = \"\";\n        /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue\n     */ _this.nodeValue = null;\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode\n     */ _this.parentNode = null;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Node, _EventTarget);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Node, [\n        {\n            key: \"textContent\",\n            get: /**\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent\n     */ function get() {\n                var out = \"\";\n                if (this.nodeName === Shape.TEXT) {\n                    // @ts-ignore\n                    out += this.style.text;\n                }\n                var _iterator = _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default()(this.childNodes), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var _child = _step.value;\n                        if (_child.nodeName === Shape.TEXT) {\n                            out += _child.nodeValue;\n                        } else {\n                            out += _child.textContent;\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                return out;\n            },\n            set: function set(content) {\n                var _this2 = this;\n                // remove all children\n                this.childNodes.slice().forEach(function(child) {\n                    _this2.removeChild(child);\n                });\n                if (this.nodeName === Shape.TEXT) {\n                    // @ts-ignore\n                    this.style.text = \"\".concat(content);\n                }\n            }\n        },\n        {\n            key: \"getRootNode\",\n            value: function getRootNode() {\n                var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                if (this.parentNode) {\n                    return this.parentNode.getRootNode(opts);\n                }\n                if (opts.composed && this.host) {\n                    return this.host.getRootNode(opts);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"hasChildNodes\",\n            value: function hasChildNodes() {\n                return this.childNodes.length > 0;\n            }\n        },\n        {\n            key: \"isDefaultNamespace\",\n            value: function isDefaultNamespace(namespace) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"lookupNamespaceURI\",\n            value: function lookupNamespaceURI(prefix) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"lookupPrefix\",\n            value: function lookupPrefix(namespace) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"normalize\",\n            value: function normalize() {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"isEqualNode\",\n            value: function isEqualNode(otherNode) {\n                // TODO: compare 2 nodes, not sameness\n                return this === otherNode;\n            }\n        },\n        {\n            key: \"isSameNode\",\n            value: function isSameNode(otherNode) {\n                return this.isEqualNode(otherNode);\n            }\n        },\n        {\n            key: \"parent\",\n            get: /**\n     * @deprecated\n     * @alias parentNode\n     */ function get() {\n                return this.parentNode;\n            }\n        },\n        {\n            key: \"parentElement\",\n            get: function get() {\n                return null;\n            }\n        },\n        {\n            key: \"nextSibling\",\n            get: function get() {\n                return null;\n            }\n        },\n        {\n            key: \"previousSibling\",\n            get: function get() {\n                return null;\n            }\n        },\n        {\n            key: \"firstChild\",\n            get: function get() {\n                return this.childNodes.length > 0 ? this.childNodes[0] : null;\n            }\n        },\n        {\n            key: \"lastChild\",\n            get: function get() {\n                return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;\n            }\n        },\n        {\n            key: \"compareDocumentPosition\",\n            value: function compareDocumentPosition(other) {\n                if (other === this) {\n                    // same node\n                    return 0;\n                }\n                // if (!(other instanceof Node)) {\n                //   throw new TypeError(\n                //     'Node.compareDocumentPosition: Argument 1 does not implement interface Node.',\n                //   );\n                // }\n                var node1Root = other;\n                // eslint-disable-next-line @typescript-eslint/no-this-alias\n                var node2Root = this;\n                var node1Hierarchy = [\n                    node1Root\n                ];\n                var node2Hierarchy = [\n                    node2Root\n                ];\n                while((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode){\n                    var _node1Root$parentNode;\n                    node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;\n                    node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;\n                }\n                // Check if they don't share the same root node\n                if (node1Root !== node2Root) {\n                    return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING;\n                }\n                var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;\n                var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;\n                // Check if either is a container of the other\n                if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {\n                    return longerHierarchy === node1Hierarchy ? // other is a child of this\n                    Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING : // this is a child of other\n                    Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;\n                }\n                // Find their first common ancestor and see whether they\n                // are preceding or following\n                var longerStart = longerHierarchy.length - shorterHierarchy.length;\n                for(var i = shorterHierarchy.length - 1; i >= 0; i--){\n                    var shorterHierarchyNode = shorterHierarchy[i];\n                    var longerHierarchyNode = longerHierarchy[longerStart + i];\n                    // We found the first common ancestor\n                    if (longerHierarchyNode !== shorterHierarchyNode) {\n                        var siblings = shorterHierarchyNode.parentNode.childNodes;\n                        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {\n                            // Shorter is before longer\n                            if (shorterHierarchy === node1Hierarchy) {\n                                // Other is before this\n                                return Node.DOCUMENT_POSITION_PRECEDING;\n                            }\n                            // This is before other\n                            return Node.DOCUMENT_POSITION_FOLLOWING;\n                        }\n                        // Longer is before shorter\n                        if (longerHierarchy === node1Hierarchy) {\n                            // Other is before this\n                            return Node.DOCUMENT_POSITION_PRECEDING;\n                        }\n                        // Other is after this\n                        return Node.DOCUMENT_POSITION_FOLLOWING;\n                    }\n                }\n                return Node.DOCUMENT_POSITION_FOLLOWING;\n            }\n        },\n        {\n            key: \"contain\",\n            value: /**\n     * @deprecated\n     * @alias contains\n     */ function contain(other) {\n                return this.contains(other);\n            }\n        },\n        {\n            key: \"contains\",\n            value: function contains(other) {\n                // the node itself, one of its direct children\n                var tmp = other;\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n                while(tmp && this !== tmp){\n                    tmp = tmp.parentNode;\n                }\n                return !!tmp;\n            }\n        },\n        {\n            key: \"getAncestor\",\n            value: function getAncestor(n) {\n                // eslint-disable-next-line @typescript-eslint/no-this-alias\n                var temp = this;\n                while(n > 0 && temp){\n                    temp = temp.parentNode;\n                    n--;\n                }\n                return temp;\n            }\n        },\n        {\n            key: \"forEach\",\n            value: function forEach(callback) {\n                var stack = [\n                    this\n                ];\n                while(stack.length > 0){\n                    var node = stack.pop();\n                    var result = callback(node);\n                    if (result === false) {\n                        break;\n                    }\n                    for(var i = node.childNodes.length - 1; i >= 0; i--){\n                        stack.push(node.childNodes[i]);\n                    }\n                }\n            }\n        }\n    ], [\n        {\n            key: \"isNode\",\n            value: function isNode(target) {\n                return !!target.childNodes;\n            }\n        }\n    ]);\n}(EventTarget);\n/**\n * Both nodes are in different documents or different trees in the same document.\n */ Node.DOCUMENT_POSITION_DISCONNECTED = 1;\n/**\n * otherNode precedes the node in either a pre-order depth-first traversal\n * of a tree containing both (e.g., as an ancestor or previous sibling or a descendant of a previous sibling or previous sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.\n */ Node.DOCUMENT_POSITION_PRECEDING = 2;\n/**\n * otherNode follows the node in either a pre-order depth-first traversal of a tree containing both (e.g., as a descendant or following sibling or a descendant of a following sibling or following sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.\n */ Node.DOCUMENT_POSITION_FOLLOWING = 4;\n/**\n * otherNode is an ancestor of the node.\n */ Node.DOCUMENT_POSITION_CONTAINS = 8;\n/**\n * otherNode is a descendant of the node.\n */ Node.DOCUMENT_POSITION_CONTAINED_BY = 16;\n/**\n * The result relies upon arbitrary and/or implementation-specific behavior and is not guaranteed to be portable.\n */ Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;\nvar PROPAGATION_LIMIT = 2048;\nvar EventService = /*#__PURE__*/ function() {\n    function EventService(globalRuntime, context) {\n        var _this = this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, EventService);\n        /**\n     * Store HTML elements in current canvas.\n     */ this.nativeHTMLMap = new WeakMap();\n        this.cursor = \"default\";\n        this.mappingTable = {};\n        this.mappingState = {\n            trackingData: {}\n        };\n        this.eventPool = new Map();\n        this.tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n        this.tmpVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\n        this.onPointerDown = function(from) {\n            var e = _this.createPointerEvent(from);\n            _this.dispatchEvent(e, \"pointerdown\");\n            if (e.pointerType === \"touch\") {\n                _this.dispatchEvent(e, \"touchstart\");\n            } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n                var isRightButton = e.button === 2;\n                _this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n            }\n            var trackingData = _this.trackingData(from.pointerId);\n            trackingData.pressTargetsByButton[from.button] = e.composedPath();\n            _this.freeEvent(e);\n        };\n        this.onPointerUp = function(from) {\n            var now = clock.now();\n            var e = _this.createPointerEvent(from, undefined, undefined, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : undefined);\n            _this.dispatchEvent(e, \"pointerup\");\n            if (e.pointerType === \"touch\") {\n                _this.dispatchEvent(e, \"touchend\");\n            } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n                var isRightButton = e.button === 2;\n                _this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n            }\n            var trackingData = _this.trackingData(from.pointerId);\n            var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n            var clickTarget = pressTarget;\n            // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n            // the pointerup location.\n            if (pressTarget && !e.composedPath().includes(pressTarget)) {\n                var currentTarget = pressTarget;\n                while(currentTarget && !e.composedPath().includes(currentTarget)){\n                    e.currentTarget = currentTarget;\n                    _this.notifyTarget(e, \"pointerupoutside\");\n                    if (e.pointerType === \"touch\") {\n                        _this.notifyTarget(e, \"touchendoutside\");\n                    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n                        var _isRightButton = e.button === 2;\n                        _this.notifyTarget(e, _isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n                    }\n                    if (Node.isNode(currentTarget)) {\n                        currentTarget = currentTarget.parentNode;\n                    }\n                }\n                delete trackingData.pressTargetsByButton[from.button];\n                // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n                // targets. That is - it's our click target!\n                clickTarget = currentTarget;\n            }\n            if (clickTarget) {\n                var _e$detail;\n                var clickEvent = _this.clonePointerEvent(e, \"click\");\n                clickEvent.target = clickTarget;\n                clickEvent.path = [];\n                if (!trackingData.clicksByButton[from.button]) {\n                    trackingData.clicksByButton[from.button] = {\n                        clickCount: 0,\n                        target: clickEvent.target,\n                        timeStamp: now\n                    };\n                }\n                var canvas = _this.context.renderingContext.root.ownerDocument.defaultView;\n                var clickHistory = trackingData.clicksByButton[from.button];\n                if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < canvas.getConfig().dblClickSpeed) {\n                    ++clickHistory.clickCount;\n                } else {\n                    clickHistory.clickCount = 1;\n                }\n                clickHistory.target = clickEvent.target;\n                clickHistory.timeStamp = now;\n                clickEvent.detail = clickHistory.clickCount;\n                // @see https://github.com/antvis/G/issues/1091\n                if (!((_e$detail = e.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {\n                    if (!_this.context.config.useNativeClickEvent && (clickEvent.pointerType === \"mouse\" || clickEvent.pointerType === \"touch\")) {\n                        _this.dispatchEvent(clickEvent, \"click\");\n                    }\n                    _this.dispatchEvent(clickEvent, \"pointertap\");\n                }\n                _this.freeEvent(clickEvent);\n            }\n            _this.freeEvent(e);\n        };\n        this.onPointerMove = function(from) {\n            var e = _this.createPointerEvent(from, undefined, undefined, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : undefined);\n            var isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n            var trackingData = _this.trackingData(from.pointerId);\n            var outTarget = _this.findMountedTarget(trackingData.overTargets);\n            // First pointerout/pointerleave\n            if (trackingData.overTargets && outTarget !== e.target) {\n                // pointerout always occurs on the overTarget when the pointer hovers over another element.\n                var outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n                var outEvent = _this.createPointerEvent(from, outType, outTarget || undefined);\n                _this.dispatchEvent(outEvent, \"pointerout\");\n                if (isMouse) _this.dispatchEvent(outEvent, \"mouseout\");\n                // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n                // is dispatched to all ancestors that no longer capture the pointer.\n                if (!e.composedPath().includes(outTarget)) {\n                    var leaveEvent = _this.createPointerEvent(from, \"pointerleave\", outTarget || undefined);\n                    leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n                    while(leaveEvent.target && !e.composedPath().includes(leaveEvent.target)){\n                        leaveEvent.currentTarget = leaveEvent.target;\n                        _this.notifyTarget(leaveEvent);\n                        if (isMouse) {\n                            _this.notifyTarget(leaveEvent, \"mouseleave\");\n                        }\n                        if (Node.isNode(leaveEvent.target)) {\n                            leaveEvent.target = leaveEvent.target.parentNode;\n                        }\n                    }\n                    _this.freeEvent(leaveEvent);\n                }\n                _this.freeEvent(outEvent);\n            }\n            // Then pointerover\n            if (outTarget !== e.target) {\n                // pointerover always occurs on the new overTarget\n                var overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n                var overEvent = _this.clonePointerEvent(e, overType); // clone faster\n                _this.dispatchEvent(overEvent, \"pointerover\");\n                if (isMouse) _this.dispatchEvent(overEvent, \"mouseover\");\n                // Probe whether the newly hovered Node is an ancestor of the original overTarget.\n                var overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;\n                while(overTargetAncestor && overTargetAncestor !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)){\n                    if (overTargetAncestor === e.target) break;\n                    overTargetAncestor = overTargetAncestor.parentNode;\n                }\n                // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n                // event.\n                var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode);\n                if (didPointerEnter) {\n                    var enterEvent = _this.clonePointerEvent(e, \"pointerenter\");\n                    enterEvent.eventPhase = enterEvent.AT_TARGET;\n                    while(enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)){\n                        enterEvent.currentTarget = enterEvent.target;\n                        _this.notifyTarget(enterEvent);\n                        if (isMouse) _this.notifyTarget(enterEvent, \"mouseenter\");\n                        if (Node.isNode(enterEvent.target)) {\n                            enterEvent.target = enterEvent.target.parentNode;\n                        }\n                    }\n                    _this.freeEvent(enterEvent);\n                }\n                _this.freeEvent(overEvent);\n            }\n            // Then pointermove\n            _this.dispatchEvent(e, \"pointermove\");\n            if (e.pointerType === \"touch\") _this.dispatchEvent(e, \"touchmove\");\n            if (isMouse) {\n                _this.dispatchEvent(e, \"mousemove\");\n                _this.cursor = _this.getCursor(e.target);\n            }\n            trackingData.overTargets = e.composedPath();\n            _this.freeEvent(e);\n        };\n        this.onPointerOut = function(from) {\n            var trackingData = _this.trackingData(from.pointerId);\n            if (trackingData.overTargets) {\n                var isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n                var outTarget = _this.findMountedTarget(trackingData.overTargets);\n                // pointerout first\n                var outEvent = _this.createPointerEvent(from, \"pointerout\", outTarget || undefined);\n                _this.dispatchEvent(outEvent);\n                if (isMouse) _this.dispatchEvent(outEvent, \"mouseout\");\n                // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n                // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n                var leaveEvent = _this.createPointerEvent(from, \"pointerleave\", outTarget || undefined);\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n                while(leaveEvent.target && leaveEvent.target !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)){\n                    leaveEvent.currentTarget = leaveEvent.target;\n                    _this.notifyTarget(leaveEvent);\n                    if (isMouse) {\n                        _this.notifyTarget(leaveEvent, \"mouseleave\");\n                    }\n                    if (Node.isNode(leaveEvent.target)) {\n                        leaveEvent.target = leaveEvent.target.parentNode;\n                    }\n                }\n                trackingData.overTargets = null;\n                _this.freeEvent(outEvent);\n                _this.freeEvent(leaveEvent);\n            }\n            _this.cursor = null;\n        };\n        this.onPointerOver = function(from) {\n            var trackingData = _this.trackingData(from.pointerId);\n            var e = _this.createPointerEvent(from);\n            var isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n            _this.dispatchEvent(e, \"pointerover\");\n            if (isMouse) _this.dispatchEvent(e, \"mouseover\");\n            if (e.pointerType === \"mouse\") _this.cursor = _this.getCursor(e.target);\n            // pointerenter events must be fired since the pointer entered from upstream.\n            var enterEvent = _this.clonePointerEvent(e, \"pointerenter\");\n            enterEvent.eventPhase = enterEvent.AT_TARGET;\n            while(enterEvent.target && enterEvent.target !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)){\n                enterEvent.currentTarget = enterEvent.target;\n                _this.notifyTarget(enterEvent);\n                if (isMouse) {\n                    // mouseenter should not bubble\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event#usage_notes\n                    _this.notifyTarget(enterEvent, \"mouseenter\");\n                }\n                if (Node.isNode(enterEvent.target)) {\n                    enterEvent.target = enterEvent.target.parentNode;\n                }\n            }\n            trackingData.overTargets = e.composedPath();\n            _this.freeEvent(e);\n            _this.freeEvent(enterEvent);\n        };\n        this.onPointerUpOutside = function(from) {\n            var trackingData = _this.trackingData(from.pointerId);\n            var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n            var e = _this.createPointerEvent(from);\n            if (pressTarget) {\n                var currentTarget = pressTarget;\n                while(currentTarget){\n                    e.currentTarget = currentTarget;\n                    _this.notifyTarget(e, \"pointerupoutside\");\n                    if (e.pointerType === \"touch\") ;\n                    else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n                        _this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n                    }\n                    if (Node.isNode(currentTarget)) {\n                        currentTarget = currentTarget.parentNode;\n                    }\n                }\n                delete trackingData.pressTargetsByButton[from.button];\n            }\n            _this.freeEvent(e);\n        };\n        this.onWheel = function(from) {\n            var wheelEvent = _this.createWheelEvent(from);\n            _this.dispatchEvent(wheelEvent);\n            _this.freeEvent(wheelEvent);\n        };\n        this.onClick = function(from) {\n            if (_this.context.config.useNativeClickEvent) {\n                var e = _this.createPointerEvent(from);\n                _this.dispatchEvent(e);\n                _this.freeEvent(e);\n            }\n        };\n        this.onPointerCancel = function(from) {\n            var e = _this.createPointerEvent(from, undefined, undefined, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : undefined);\n            _this.dispatchEvent(e);\n            _this.freeEvent(e);\n        };\n        this.globalRuntime = globalRuntime;\n        this.context = context;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(EventService, [\n        {\n            key: \"init\",\n            value: function init() {\n                this.rootTarget = this.context.renderingContext.root.parentNode; // document\n                this.addEventMapping(\"pointerdown\", this.onPointerDown);\n                this.addEventMapping(\"pointerup\", this.onPointerUp);\n                this.addEventMapping(\"pointermove\", this.onPointerMove);\n                this.addEventMapping(\"pointerout\", this.onPointerOut);\n                this.addEventMapping(\"pointerleave\", this.onPointerOut);\n                this.addEventMapping(\"pointercancel\", this.onPointerCancel);\n                this.addEventMapping(\"pointerover\", this.onPointerOver);\n                this.addEventMapping(\"pointerupoutside\", this.onPointerUpOutside);\n                this.addEventMapping(\"wheel\", this.onWheel);\n                this.addEventMapping(\"click\", this.onClick);\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                this.mappingTable = {};\n                this.mappingState = {};\n                this.eventPool.clear();\n            }\n        },\n        {\n            key: \"getScale\",\n            value: function getScale() {\n                var bbox = this.context.contextService.getBoundingClientRect();\n                var scaleX = 1;\n                var scaleY = 1;\n                var $el = this.context.contextService.getDomElement();\n                if ($el && bbox) {\n                    var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;\n                    if (offsetWidth && offsetHeight) {\n                        scaleX = bbox.width / offsetWidth;\n                        scaleY = bbox.height / offsetHeight;\n                    }\n                }\n                return {\n                    scaleX: scaleX,\n                    scaleY: scaleY,\n                    bbox: bbox\n                };\n            }\n        },\n        {\n            key: \"client2Viewport\",\n            value: function client2Viewport(client) {\n                var _this$getScale = this.getScale(), scaleX = _this$getScale.scaleX, scaleY = _this$getScale.scaleY, bbox = _this$getScale.bbox;\n                return new Point((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY);\n            }\n        },\n        {\n            key: \"viewport2Client\",\n            value: function viewport2Client(canvas) {\n                var _this$getScale2 = this.getScale(), scaleX = _this$getScale2.scaleX, scaleY = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;\n                return new Point((canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX, (canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY);\n            }\n        },\n        {\n            key: \"viewport2Canvas\",\n            value: function viewport2Canvas(_ref) {\n                var x = _ref.x, y = _ref.y;\n                var canvas = this.rootTarget.defaultView;\n                var camera = canvas.getCamera();\n                var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;\n                var projectionMatrixInverse = camera.getPerspectiveInverse();\n                var worldMatrix = camera.getWorldTransform();\n                var vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);\n                var viewport = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.tmpVec3, x / width * 2 - 1, (1 - y / height) * 2 - 1, 0);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(viewport, viewport, vpMatrix);\n                return new Point(viewport[0], viewport[1]);\n            }\n        },\n        {\n            key: \"canvas2Viewport\",\n            value: function canvas2Viewport(canvasP) {\n                var canvas = this.rootTarget.defaultView;\n                var camera = canvas.getCamera();\n                // World -> Clip\n                var projectionMatrix = camera.getPerspective();\n                var viewMatrix = camera.getViewTransform();\n                var vpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);\n                var clip = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set(this.tmpVec3, canvasP.x, canvasP.y, 0);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);\n                // Clip -> NDC -> Viewport, flip Y\n                var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;\n                return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);\n            }\n        },\n        {\n            key: \"setPickHandler\",\n            value: function setPickHandler(pickHandler) {\n                this.pickHandler = pickHandler;\n            }\n        },\n        {\n            key: \"addEventMapping\",\n            value: function addEventMapping(type, fn) {\n                if (!this.mappingTable[type]) {\n                    this.mappingTable[type] = [];\n                }\n                this.mappingTable[type].push({\n                    fn: fn,\n                    priority: 0\n                });\n                this.mappingTable[type].sort(function(a, b) {\n                    return a.priority - b.priority;\n                });\n            }\n        },\n        {\n            key: \"mapEvent\",\n            value: function mapEvent(e) {\n                if (!this.rootTarget) {\n                    return;\n                }\n                var mappers = this.mappingTable[e.type];\n                if (mappers) {\n                    for(var i = 0, j = mappers.length; i < j; i++){\n                        mappers[i].fn(e);\n                    }\n                } else {\n                    console.warn(\"[EventService]: Event mapping not defined for \".concat(e.type));\n                }\n            }\n        },\n        {\n            key: \"dispatchEvent\",\n            value: function dispatchEvent(e, type, skipPropagate) {\n                // Canvas should skip\n                if (!skipPropagate) {\n                    e.propagationStopped = false;\n                    e.propagationImmediatelyStopped = false;\n                    this.propagate(e, type);\n                } else {\n                    // target phase\n                    e.eventPhase = e.AT_TARGET;\n                    var canvas = this.rootTarget.defaultView || null;\n                    e.currentTarget = canvas;\n                    this.notifyListeners(e, type);\n                }\n            }\n        },\n        {\n            key: \"propagate\",\n            value: function propagate(e, type) {\n                if (!e.target) {\n                    return;\n                }\n                // [target, parent, root, Canvas]\n                var composedPath = e.composedPath();\n                // event flow: capture -> target -> bubbling\n                // capture phase\n                e.eventPhase = e.CAPTURING_PHASE;\n                for(var i = composedPath.length - 1; i >= 1; i--){\n                    e.currentTarget = composedPath[i];\n                    this.notifyTarget(e, type);\n                    if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n                }\n                // target phase\n                e.eventPhase = e.AT_TARGET;\n                e.currentTarget = e.target;\n                this.notifyTarget(e, type);\n                if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n                // find current target in composed path\n                var index = composedPath.indexOf(e.currentTarget);\n                // bubbling phase\n                e.eventPhase = e.BUBBLING_PHASE;\n                for(var _i = index + 1; _i < composedPath.length; _i++){\n                    e.currentTarget = composedPath[_i];\n                    this.notifyTarget(e, type);\n                    if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n                }\n            }\n        },\n        {\n            key: \"propagationPath\",\n            value: function propagationPath(target) {\n                var propagationPath = [\n                    target\n                ];\n                var canvas = this.rootTarget.defaultView || null;\n                if (canvas && canvas === target) {\n                    propagationPath.unshift(canvas.document);\n                    return propagationPath;\n                }\n                for(var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++){\n                    // if (Node.isNode(target) && !target.parentNode) {\n                    //   throw new Error('Cannot find propagation path to disconnected target');\n                    // }\n                    if (Node.isNode(target) && target.parentNode) {\n                        // [target, parent, parent, root]\n                        propagationPath.push(target.parentNode);\n                        target = target.parentNode;\n                    }\n                }\n                if (canvas) {\n                    // @ts-ignore\n                    propagationPath.push(canvas);\n                }\n                return propagationPath;\n            }\n        },\n        {\n            key: \"hitTest\",\n            value: function hitTest(position) {\n                var viewportX = position.viewportX, viewportY = position.viewportY;\n                var _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;\n                // outside canvas\n                if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {\n                    return null;\n                }\n                return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document\n                null;\n            }\n        },\n        {\n            key: \"isNativeEventFromCanvas\",\n            value: function isNativeEventFromCanvas($el, nativeEvent) {\n                var _target;\n                var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;\n                // Get event target inside a web component.\n                // @see https://stackoverflow.com/questions/57963312/get-event-target-inside-a-web-component\n                if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {\n                    target = nativeEvent.composedPath()[0];\n                }\n                if (target) {\n                    // from <canvas>\n                    if (target === $el) {\n                        return true;\n                    }\n                    // from <svg>\n                    if ($el && $el.contains) {\n                        return $el.contains(target);\n                    }\n                }\n                if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {\n                    return nativeEvent.composedPath().indexOf($el) > -1;\n                }\n                // account for Touch\n                return false;\n            }\n        },\n        {\n            key: \"getExistedHTML\",\n            value: function getExistedHTML(event) {\n                if (event.nativeEvent.composedPath) {\n                    for(var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++){\n                        var eventTarget = _arr[_i2];\n                        var existed = this.nativeHTMLMap.get(eventTarget);\n                        if (existed) {\n                            return existed;\n                        }\n                    }\n                }\n                return null;\n            }\n        },\n        {\n            key: \"pickTarget\",\n            value: function pickTarget(event) {\n                return this.hitTest({\n                    clientX: event.clientX,\n                    clientY: event.clientY,\n                    viewportX: event.viewportX,\n                    viewportY: event.viewportY,\n                    x: event.canvasX,\n                    y: event.canvasY\n                });\n            }\n        },\n        {\n            key: \"createPointerEvent\",\n            value: function createPointerEvent(from, type, target, fallbackTarget) {\n                var event = this.allocateEvent(FederatedPointerEvent);\n                this.copyPointerData(from, event);\n                this.copyMouseData(from, event);\n                this.copyData(from, event);\n                event.nativeEvent = from.nativeEvent;\n                event.originalEvent = from;\n                var existedHTML = this.getExistedHTML(event);\n                var $el = this.context.contextService.getDomElement();\n                event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;\n                if (typeof type === \"string\") {\n                    event.type = type;\n                }\n                return event;\n            }\n        },\n        {\n            key: \"createWheelEvent\",\n            value: function createWheelEvent(from) {\n                var event = this.allocateEvent(FederatedWheelEvent);\n                this.copyWheelData(from, event);\n                this.copyMouseData(from, event);\n                this.copyData(from, event);\n                event.nativeEvent = from.nativeEvent;\n                event.originalEvent = from;\n                var existedHTML = this.getExistedHTML(event);\n                var $el = this.context.contextService.getDomElement();\n                event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);\n                return event;\n            }\n        },\n        {\n            key: \"trackingData\",\n            value: function trackingData(id) {\n                if (!this.mappingState.trackingData[id]) {\n                    this.mappingState.trackingData[id] = {\n                        pressTargetsByButton: {},\n                        clicksByButton: {},\n                        overTarget: null\n                    };\n                }\n                return this.mappingState.trackingData[id];\n            }\n        },\n        {\n            key: \"cloneWheelEvent\",\n            value: function cloneWheelEvent(from) {\n                var event = this.allocateEvent(FederatedWheelEvent);\n                event.nativeEvent = from.nativeEvent;\n                event.originalEvent = from.originalEvent;\n                this.copyWheelData(from, event);\n                this.copyMouseData(from, event);\n                this.copyData(from, event);\n                event.target = from.target;\n                event.path = from.composedPath().slice();\n                event.type = from.type;\n                return event;\n            }\n        },\n        {\n            key: \"clonePointerEvent\",\n            value: function clonePointerEvent(from, type) {\n                var event = this.allocateEvent(FederatedPointerEvent);\n                event.nativeEvent = from.nativeEvent;\n                event.originalEvent = from.originalEvent;\n                this.copyPointerData(from, event);\n                this.copyMouseData(from, event);\n                this.copyData(from, event);\n                event.target = from.target;\n                event.path = from.composedPath().slice();\n                event.type = type !== null && type !== void 0 ? type : event.type;\n                return event;\n            }\n        },\n        {\n            key: \"copyPointerData\",\n            value: function copyPointerData(from, to) {\n                // if (\n                //   !(\n                //     from instanceof FederatedPointerEvent &&\n                //     to instanceof FederatedPointerEvent\n                //   )\n                // )\n                //   return;\n                to.pointerId = from.pointerId;\n                to.width = from.width;\n                to.height = from.height;\n                to.isPrimary = from.isPrimary;\n                to.pointerType = from.pointerType;\n                to.pressure = from.pressure;\n                to.tangentialPressure = from.tangentialPressure;\n                to.tiltX = from.tiltX;\n                to.tiltY = from.tiltY;\n                to.twist = from.twist;\n            }\n        },\n        {\n            key: \"copyMouseData\",\n            value: function copyMouseData(from, to) {\n                // if (\n                //   !(\n                //     from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent\n                //   )\n                // )\n                //   return;\n                to.altKey = from.altKey;\n                to.button = from.button;\n                to.buttons = from.buttons;\n                to.ctrlKey = from.ctrlKey;\n                to.metaKey = from.metaKey;\n                to.shiftKey = from.shiftKey;\n                to.client.copyFrom(from.client);\n                to.movement.copyFrom(from.movement);\n                to.canvas.copyFrom(from.canvas);\n                to.screen.copyFrom(from.screen);\n                to.global.copyFrom(from.global);\n                to.offset.copyFrom(from.offset);\n            }\n        },\n        {\n            key: \"copyWheelData\",\n            value: function copyWheelData(from, to) {\n                to.deltaMode = from.deltaMode;\n                to.deltaX = from.deltaX;\n                to.deltaY = from.deltaY;\n                to.deltaZ = from.deltaZ;\n            }\n        },\n        {\n            key: \"copyData\",\n            value: function copyData(from, to) {\n                to.isTrusted = from.isTrusted;\n                to.timeStamp = clock.now();\n                to.type = from.type;\n                to.detail = from.detail;\n                to.view = from.view;\n                to.page.copyFrom(from.page);\n                to.viewport.copyFrom(from.viewport);\n            }\n        },\n        {\n            key: \"allocateEvent\",\n            value: function allocateEvent(constructor) {\n                if (!this.eventPool.has(constructor)) {\n                    this.eventPool.set(constructor, []);\n                }\n                // @ts-ignore\n                var event = this.eventPool.get(constructor).pop() || new constructor(this);\n                event.eventPhase = event.NONE;\n                event.currentTarget = null;\n                event.path = [];\n                event.target = null;\n                return event;\n            }\n        },\n        {\n            key: \"freeEvent\",\n            value: function freeEvent(event) {\n                if (event.manager !== this) throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n                var constructor = event.constructor;\n                if (!this.eventPool.has(constructor)) {\n                    this.eventPool.set(constructor, []);\n                }\n                // @ts-ignore\n                this.eventPool.get(constructor).push(event);\n            }\n        },\n        {\n            key: \"notifyTarget\",\n            value: function notifyTarget(e, type) {\n                type = type !== null && type !== void 0 ? type : e.type;\n                var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? \"\".concat(type, \"capture\") : type;\n                this.notifyListeners(e, key);\n                if (e.eventPhase === e.AT_TARGET) {\n                    this.notifyListeners(e, type);\n                }\n            }\n        },\n        {\n            key: \"notifyListeners\",\n            value: function notifyListeners(e, type) {\n                // hack EventEmitter, stops if the `propagationImmediatelyStopped` flag is set\n                var emitter = e.currentTarget.emitter;\n                // @ts-ignore\n                var listeners = emitter._events[type];\n                if (!listeners) return;\n                if (\"fn\" in listeners) {\n                    if (listeners.once) {\n                        emitter.removeListener(type, listeners.fn, undefined, true);\n                    }\n                    listeners.fn.call(e.currentTarget || listeners.context, e);\n                // listeners.fn.call(listeners.context, e);\n                } else {\n                    for(var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++){\n                        if (listeners[i].once) {\n                            emitter.removeListener(type, listeners[i].fn, undefined, true);\n                        }\n                        listeners[i].fn.call(e.currentTarget || listeners[i].context, e);\n                    // listeners[i].fn.call(listeners[i].context, e);\n                    }\n                }\n            }\n        },\n        {\n            key: \"findMountedTarget\",\n            value: function findMountedTarget(propagationPath) {\n                if (!propagationPath) {\n                    return null;\n                }\n                var currentTarget = propagationPath[propagationPath.length - 1];\n                for(var i = propagationPath.length - 2; i >= 0; i--){\n                    var target = propagationPath[i];\n                    if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {\n                        currentTarget = propagationPath[i];\n                    } else {\n                        break;\n                    }\n                }\n                return currentTarget;\n            }\n        },\n        {\n            key: \"getCursor\",\n            value: function getCursor(target) {\n                var tmp = target;\n                while(tmp){\n                    var cursor = isElement(tmp) && tmp.getAttribute(\"cursor\");\n                    if (cursor) {\n                        return cursor;\n                    }\n                    tmp = Node.isNode(tmp) && tmp.parentNode;\n                }\n            }\n        }\n    ]);\n}();\n/**\n * used in following scenes:\n * - g `ctx.measureText`\n * - g-plugin-canvas-picker `ctx.isPointInPath`\n * - g-plugin-device-renderer `ctx.createLinearGradient` and generate texture\n *\n * @see https://blog.scottlogic.com/2020/03/19/offscreen-canvas.html\n */ var OffscreenCanvasCreator = /*#__PURE__*/ function() {\n    function OffscreenCanvasCreator() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, OffscreenCanvasCreator);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(OffscreenCanvasCreator, [\n        {\n            key: \"getOrCreateCanvas\",\n            value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {\n                if (this.canvas) {\n                    return this.canvas;\n                }\n                // user-defined offscreen canvas\n                if (offscreenCanvas || runtime.offscreenCanvas) {\n                    this.canvas = offscreenCanvas || runtime.offscreenCanvas;\n                    this.context = this.canvas.getContext(\"2d\", _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        willReadFrequently: true\n                    }, contextAttributes));\n                } else {\n                    try {\n                        // OffscreenCanvas2D measureText can be up to 40% faster.\n                        this.canvas = new window.OffscreenCanvas(0, 0);\n                        this.context = this.canvas.getContext(\"2d\", _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                            willReadFrequently: true\n                        }, contextAttributes));\n                        if (!this.context || !this.context.measureText) {\n                            this.canvas = document.createElement(\"canvas\");\n                            this.context = this.canvas.getContext(\"2d\");\n                        }\n                    } catch (_unused) {\n                        this.canvas = document.createElement(\"canvas\");\n                        this.context = this.canvas.getContext(\"2d\", _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                            willReadFrequently: true\n                        }, contextAttributes));\n                    }\n                }\n                this.canvas.width = 10;\n                this.canvas.height = 10;\n                return this.canvas;\n            }\n        },\n        {\n            key: \"getOrCreateContext\",\n            value: function getOrCreateContext(offscreenCanvas, contextAttributes) {\n                if (this.context) {\n                    return this.context;\n                }\n                this.getOrCreateCanvas(offscreenCanvas, contextAttributes);\n                return this.context;\n            }\n        }\n    ], [\n        {\n            key: \"createCanvas\",\n            value: /**\n     * @returns new canvas instance\n     */ function createCanvas() {\n                try {\n                    return new window.OffscreenCanvas(0, 0);\n                } catch (_unused2) {\n                //\n                }\n                try {\n                    return document.createElement(\"canvas\");\n                } catch (_unused3) {\n                //\n                }\n                return null;\n            }\n        }\n    ]);\n}();\n/**\n * why we need re-render\n */ var RenderReason = /*#__PURE__*/ function(RenderReason) {\n    RenderReason[RenderReason[\"CAMERA_CHANGED\"] = 0] = \"CAMERA_CHANGED\";\n    RenderReason[RenderReason[\"DISPLAY_OBJECT_CHANGED\"] = 1] = \"DISPLAY_OBJECT_CHANGED\";\n    RenderReason[RenderReason[\"NONE\"] = 2] = \"NONE\";\n    return RenderReason;\n}({});\n/**\n * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:\n * * update & merge dirty rectangles\n * * begin frame\n * * filter by visible\n * * sort by z-index in scene graph\n * * culling with strategies registered in `g-canvas/webgl`\n * * end frame\n */ var RenderingService = /*#__PURE__*/ function() {\n    function RenderingService(globalRuntime, context) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, RenderingService);\n        this.inited = false;\n        this.stats = {\n            /**\n       * total display objects in scenegraph\n       */ total: 0,\n            /**\n       * number of display objects need to render in current frame\n       */ rendered: 0\n        };\n        this.zIndexCounter = 0;\n        this.hooks = {\n            /**\n       * called before any frame rendered\n       */ init: new SyncHook(),\n            initAsync: new AsyncParallelHook(),\n            /**\n       * only dirty object which has sth changed will be rendered\n       */ dirtycheck: new SyncWaterfallHook(),\n            /**\n       * do culling\n       */ cull: new SyncWaterfallHook(),\n            /**\n       * called at beginning of each frame, won't get called if nothing to re-render\n       */ beginFrame: new SyncHook(),\n            /**\n       * called before every dirty object get rendered\n       */ beforeRender: new SyncHook(),\n            /**\n       * called when every dirty object rendering even it's culled\n       */ render: new SyncHook(),\n            /**\n       * called after every dirty object get rendered\n       */ afterRender: new SyncHook(),\n            endFrame: new SyncHook(),\n            destroy: new SyncHook(),\n            /**\n       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`\n       */ pick: new AsyncSeriesWaterfallHook(),\n            /**\n       * Unsafe but sync version of pick.\n       */ pickSync: new SyncWaterfallHook(),\n            /**\n       * used in event system\n       */ pointerDown: new SyncHook(),\n            pointerUp: new SyncHook(),\n            pointerMove: new SyncHook(),\n            pointerOut: new SyncHook(),\n            pointerOver: new SyncHook(),\n            pointerWheel: new SyncHook(),\n            pointerCancel: new SyncHook(),\n            click: new SyncHook()\n        };\n        this.globalRuntime = globalRuntime;\n        this.context = context;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(RenderingService, [\n        {\n            key: \"init\",\n            value: function init(callback) {\n                var _this = this;\n                var context = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.globalRuntime), this.context);\n                // register rendering plugins\n                this.context.renderingPlugins.forEach(function(plugin) {\n                    plugin.apply(context, _this.globalRuntime);\n                });\n                this.hooks.init.call();\n                if (this.hooks.initAsync.getCallbacksNum() === 0) {\n                    this.inited = true;\n                    callback();\n                } else {\n                    this.hooks.initAsync.promise().then(function() {\n                        _this.inited = true;\n                        callback();\n                    })[\"catch\"](function(err) {});\n                }\n            }\n        },\n        {\n            key: \"getStats\",\n            value: function getStats() {\n                return this.stats;\n            }\n        },\n        {\n            key: \"disableDirtyRectangleRendering\",\n            value: function disableDirtyRectangleRendering() {\n                var renderer = this.context.config.renderer;\n                var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;\n                return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(canvasConfig, frame, rerenderCallback) {\n                var _this2 = this;\n                this.stats.total = 0;\n                this.stats.rendered = 0;\n                this.zIndexCounter = 0;\n                var renderingContext = this.context.renderingContext;\n                this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);\n                this.globalRuntime.sceneGraphService.triggerPendingEvents();\n                if (renderingContext.renderReasons.size && this.inited) {\n                    // @ts-ignore\n                    renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();\n                    var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);\n                    var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !(canvasConfig.disableRenderHooks && onlyCameraChanged);\n                    if (shouldTriggerRenderHooks) {\n                        this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);\n                    }\n                    this.hooks.beginFrame.call(frame);\n                    if (shouldTriggerRenderHooks) {\n                        renderingContext.renderListCurrentFrame.forEach(function(object) {\n                            _this2.hooks.beforeRender.call(object);\n                            _this2.hooks.render.call(object);\n                            _this2.hooks.afterRender.call(object);\n                        });\n                    }\n                    this.hooks.endFrame.call(frame);\n                    renderingContext.renderListCurrentFrame = [];\n                    renderingContext.renderReasons.clear();\n                    rerenderCallback();\n                }\n            // console.log('stats', this.stats);\n            }\n        },\n        {\n            key: \"renderDisplayObject\",\n            value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {\n                var self1 = this;\n                var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;\n                function internalRenderSingleDisplayObject(object) {\n                    // TODO: relayout\n                    // dirtycheck first\n                    var renderable = object.renderable, sortable = object.sortable;\n                    // eslint-disable-next-line no-nested-ternary\n                    var objectChanged = enableDirtyCheck ? // @ts-ignore\n                    renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null : object;\n                    if (objectChanged) {\n                        var objectToRender = enableCulling ? self1.hooks.cull.call(objectChanged, self1.context.camera) : objectChanged;\n                        if (objectToRender) {\n                            self1.stats.rendered += 1;\n                            renderingContext.renderListCurrentFrame.push(objectToRender);\n                        }\n                    }\n                    renderable.dirty = false;\n                    sortable.renderOrder = self1.zIndexCounter;\n                    self1.zIndexCounter += 1;\n                    self1.stats.total += 1;\n                    // sort is very expensive, use cached result if possible\n                    if (sortable.dirty) {\n                        self1.sort(object, sortable);\n                        sortable.dirty = false;\n                        sortable.dirtyChildren = [];\n                        sortable.dirtyReason = undefined;\n                    }\n                }\n                var stack = [\n                    displayObject\n                ];\n                while(stack.length > 0){\n                    var currentObject = stack.pop();\n                    internalRenderSingleDisplayObject(currentObject);\n                    // recursive rendering its children\n                    var objects = currentObject.sortable.sorted || currentObject.childNodes;\n                    for(var i = objects.length - 1; i >= 0; i--){\n                        stack.push(objects[i]);\n                    }\n                }\n            }\n        },\n        {\n            key: \"sort\",\n            value: function sort(displayObject, sortable) {\n                if (sortable.sorted && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {\n                    // avoid re-sorting the whole children list\n                    sortable.dirtyChildren.forEach(function(child) {\n                        var index = displayObject.childNodes.indexOf(child);\n                        if (index === -1) {\n                            // remove from sorted list\n                            var _index = sortable.sorted.indexOf(child);\n                            if (_index >= 0) {\n                                sortable.sorted.splice(_index, 1);\n                            }\n                        } else if (sortable.sorted.length === 0) {\n                            sortable.sorted.push(child);\n                        } else {\n                            var _index2 = sortedIndex(sortable.sorted, child);\n                            sortable.sorted.splice(_index2, 0, child);\n                        }\n                    });\n                } else {\n                    sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);\n                }\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                this.inited = false;\n                this.hooks.destroy.call();\n                this.globalRuntime.sceneGraphService.clearPendingEvents();\n            }\n        },\n        {\n            key: \"dirtify\",\n            value: function dirtify() {\n                // need re-render\n                this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);\n            }\n        }\n    ]);\n}();\nvar ATTRIBUTE_REGEXP = /\\[\\s*(.*)=(.*)\\s*\\]/;\n/**\n * support the following DOM API:\n * * getElementById\n * * getElementsByClassName\n * * getElementsByName\n * * getElementsByTag\n * * querySelector\n * * querySelectorAll\n */ var DefaultSceneGraphSelector = /*#__PURE__*/ function() {\n    function DefaultSceneGraphSelector() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DefaultSceneGraphSelector);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(DefaultSceneGraphSelector, [\n        {\n            key: \"selectOne\",\n            value: function selectOne(query, root) {\n                var _this = this;\n                if (query.startsWith(\".\")) {\n                    return root.find(function(node) {\n                        // return !node.shadow && node.id === query.substring(1);\n                        return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;\n                    });\n                }\n                if (query.startsWith(\"#\")) {\n                    // getElementById('id')\n                    return root.find(function(node) {\n                        // return !node.shadow && node.id === query.substring(1);\n                        return node.id === _this.getIdOrClassname(query);\n                    });\n                }\n                if (query.startsWith(\"[\")) {\n                    var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;\n                    if (name) {\n                        // getElementByName();\n                        return root.find(function(node) {\n                            return root !== node && (name === \"name\" ? node.name === value : _this.attributeToString(node, name) === value);\n                        });\n                    }\n                    return null;\n                }\n                // getElementsByTag('circle');\n                return root.find(function(node) {\n                    return root !== node && node.nodeName === query;\n                });\n            }\n        },\n        {\n            key: \"selectAll\",\n            value: function selectAll(query, root) {\n                var _this2 = this;\n                // only support `[name=\"${name}\"]` `.className` `#id`\n                if (query.startsWith(\".\")) {\n                    // getElementsByClassName('className');\n                    // should not include itself\n                    return root.findAll(function(node) {\n                        return root !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;\n                    });\n                }\n                if (query.startsWith(\"#\")) {\n                    return root.findAll(function(node) {\n                        return root !== node && node.id === _this2.getIdOrClassname(query);\n                    });\n                }\n                if (query.startsWith(\"[\")) {\n                    var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;\n                    if (name) {\n                        // getElementsByName();\n                        return root.findAll(function(node) {\n                            return root !== node && (name === \"name\" ? node.name === value : _this2.attributeToString(node, name) === value);\n                        });\n                    }\n                    return [];\n                }\n                // getElementsByTag('circle');\n                return root.findAll(function(node) {\n                    return root !== node && node.nodeName === query;\n                });\n            }\n        },\n        {\n            key: \"is\",\n            value: function is(query, node) {\n                // a simple `matches` implementation\n                if (query.startsWith(\".\")) {\n                    return node.className === this.getIdOrClassname(query);\n                }\n                if (query.startsWith(\"#\")) {\n                    return node.id === this.getIdOrClassname(query);\n                }\n                if (query.startsWith(\"[\")) {\n                    var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;\n                    return name === \"name\" ? node.name === value : this.attributeToString(node, name) === value;\n                }\n                return node.nodeName === query;\n            }\n        },\n        {\n            key: \"getIdOrClassname\",\n            value: function getIdOrClassname(query) {\n                return query.substring(1);\n            }\n        },\n        {\n            key: \"getAttribute\",\n            value: function getAttribute(query) {\n                var matches = query.match(ATTRIBUTE_REGEXP);\n                var name = \"\";\n                var value = \"\";\n                if (matches && matches.length > 2) {\n                    name = matches[1].replace(/\"/g, \"\");\n                    value = matches[2].replace(/\"/g, \"\");\n                }\n                return {\n                    name: name,\n                    value: value\n                };\n            }\n        },\n        {\n            key: \"attributeToString\",\n            value: function attributeToString(node, name) {\n                if (!node.getAttribute) {\n                    return \"\";\n                }\n                var value = node.getAttribute(name);\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(value)) {\n                    return \"\";\n                }\n                if (value.toString) {\n                    return value.toString();\n                }\n                return \"\";\n            }\n        }\n    ]);\n}();\n/**\n * built-in events for element\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent\n *\n * TODO: use MutationObserver instead\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n */ var ElementEvent = /*#__PURE__*/ function(ElementEvent) {\n    // --- @see https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent\n    /**\n   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMAttrModified\n   */ ElementEvent[\"ATTR_MODIFIED\"] = \"DOMAttrModified\";\n    /**\n   * it has been inserted\n   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeInserted\n   */ ElementEvent[\"INSERTED\"] = \"DOMNodeInserted\";\n    /**\n   * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnodeinsertedintodocument\n   */ ElementEvent[\"MOUNTED\"] = \"DOMNodeInsertedIntoDocument\";\n    /**\n   * it is being removed\n   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeRemoved\n   */ ElementEvent[\"REMOVED\"] = \"removed\";\n    /**\n   * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnoderemovedfromdocument\n   */ ElementEvent[\"UNMOUNTED\"] = \"DOMNodeRemovedFromDocument\";\n    // ---\n    ElementEvent[\"REPARENT\"] = \"reparent\";\n    ElementEvent[\"DESTROY\"] = \"destroy\";\n    ElementEvent[\"BOUNDS_CHANGED\"] = \"bounds-changed\";\n    ElementEvent[\"CULLED\"] = \"culled\";\n    return ElementEvent;\n}({});\n// #region EventTarget\n// #region Node\n// #region Element\n// #region AnimationTimeline\n// #region Document\n// #region CSSStyleDeclaration\n/**\n * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration\n */ // #region Canvas\nvar MutationEvent = /*#__PURE__*/ function(_FederatedEvent) {\n    function MutationEvent(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, MutationEvent);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, MutationEvent, [\n            null\n        ]);\n        _this.relatedNode = relatedNode;\n        _this.prevValue = prevValue;\n        _this.newValue = newValue;\n        _this.attrName = attrName;\n        _this.attrChange = attrChange;\n        _this.prevParsedValue = prevParsedValue;\n        _this.newParsedValue = newParsedValue;\n        _this.type = typeArg;\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(MutationEvent, _FederatedEvent);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(MutationEvent);\n}(FederatedEvent);\nMutationEvent.ADDITION = 2;\nMutationEvent.MODIFICATION = 1;\nMutationEvent.REMOVAL = 3;\nfunction markRenderableDirty(e) {\n    var renderable = e.renderable;\n    if (renderable) {\n        renderable.renderBoundsDirty = true;\n        renderable.boundsDirty = true;\n    }\n}\nvar reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, \"\", \"\", \"\", 0, \"\", \"\");\n// Object pooling\n/** do not modify this objects */ var $vec2Zero = gl_matrix__WEBPACK_IMPORTED_MODULE_42__.create();\n/** do not modify this objects */ var $vec3Zero = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\n/** do not modify this objects */ var $vec3One = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(1, 1, 1);\n/** do not modify this objects */ var $mat4Identity = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n/** shared objects */ var $vec2 = gl_matrix__WEBPACK_IMPORTED_MODULE_42__.create();\n/** shared objects */ var $vec3$1 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\n/** shared objects */ var $mat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\n/** shared objects */ var $quat$1 = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create();\nvar $setLocalTransform_1 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nvar $setLocalTransform_2 = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create();\nvar $setLocalTransform_3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nvar $setLocalPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nvar $setPosition_1 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nvar $setPosition_ParentInvertMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create();\nvar $setEulerAngles_InvParentRot = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create();\nvar $rotateLocal = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create();\nvar $rotate_ParentInvertRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create();\nvar $triggerPendingEvents_detail = {\n    affectChildren: true\n};\n/**\n * update transform in scene graph\n *\n * @see https://community.khronos.org/t/scene-graphs/50542/7\n */ var DefaultSceneGraphService = /*#__PURE__*/ function() {\n    function DefaultSceneGraphService(runtime) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DefaultSceneGraphService);\n        // target -> affectChildren\n        this.pendingEvents = new Map();\n        this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);\n        this.displayObjectDependencyMap = new WeakMap();\n        this.runtime = runtime;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(DefaultSceneGraphService, [\n        {\n            key: \"matches\",\n            value: function matches(query, root) {\n                return this.runtime.sceneGraphSelector.is(query, root);\n            }\n        },\n        {\n            key: \"querySelector\",\n            value: function querySelector(query, root) {\n                return this.runtime.sceneGraphSelector.selectOne(query, root);\n            }\n        },\n        {\n            key: \"querySelectorAll\",\n            value: function querySelectorAll(query, root) {\n                return this.runtime.sceneGraphSelector.selectAll(query, root);\n            // .filter((node) => !node.shadow);\n            }\n        },\n        {\n            key: \"attach\",\n            value: function attach(child, parent, index) {\n                var _sortable$sorted;\n                var detached = false;\n                if (child.parentNode) {\n                    detached = child.parentNode !== parent;\n                    this.detach(child);\n                }\n                var isChildFragment = child.nodeName === Shape.FRAGMENT;\n                var isAttachToFragment = isInFragment(parent);\n                child.parentNode = parent;\n                var nodes = isChildFragment ? child.childNodes : [\n                    child\n                ];\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(index)) {\n                    nodes.forEach(function(node) {\n                        parent.childNodes.splice(index, 0, node);\n                        node.parentNode = parent;\n                    });\n                } else {\n                    nodes.forEach(function(node) {\n                        parent.childNodes.push(node);\n                        node.parentNode = parent;\n                    });\n                }\n                // parent needs re-sort\n                var _ref = parent, sortable = _ref.sortable;\n                if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || child.parsedStyle.zIndex) {\n                    if (sortable.dirtyChildren.indexOf(child) === -1) {\n                        sortable.dirtyChildren.push(child);\n                    }\n                    // if (sortable) {\n                    // only child has z-Index\n                    sortable.dirty = true;\n                    sortable.dirtyReason = SortReason.ADDED;\n                }\n                if (isAttachToFragment) return;\n                if (isChildFragment) this.dirtifyFragment(child);\n                else {\n                    var transform = child.transformable;\n                    if (transform) {\n                        this.dirtifyWorld(child, transform);\n                    }\n                }\n                if (detached) {\n                    child.dispatchEvent(reparentEvent);\n                }\n            }\n        },\n        {\n            key: \"detach\",\n            value: function detach(child) {\n                if (child.parentNode) {\n                    var _sortable$sorted2, _style;\n                    var transform = child.transformable;\n                    // if (transform) {\n                    //   const worldTransform = this.getWorldTransform(child, transform);\n                    //   mat4.getScaling(transform.localScale, worldTransform);\n                    //   mat4.getTranslation(transform.localPosition, worldTransform);\n                    //   mat4.getRotation(transform.localRotation, worldTransform);\n                    //   transform.localDirtyFlag = true;\n                    // }\n                    // parent needs re-sort\n                    var _ref2 = child.parentNode, sortable = _ref2.sortable;\n                    // if (sortable) {\n                    if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {\n                        if (sortable.dirtyChildren.indexOf(child) === -1) {\n                            sortable.dirtyChildren.push(child);\n                        }\n                        sortable.dirty = true;\n                        sortable.dirtyReason = SortReason.REMOVED;\n                    }\n                    var index = child.parentNode.childNodes.indexOf(child);\n                    if (index > -1) {\n                        child.parentNode.childNodes.splice(index, 1);\n                    }\n                    if (transform) {\n                        this.dirtifyWorld(child, transform);\n                    }\n                    child.parentNode = null;\n                }\n            }\n        },\n        {\n            key: \"getOrigin\",\n            value: function getOrigin(element) {\n                element.getGeometryBounds();\n                return element.transformable.origin;\n            }\n        },\n        {\n            key: \"setOrigin\",\n            value: function setOrigin(element, origin) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                if (typeof origin === \"number\") {\n                    origin = [\n                        origin,\n                        y,\n                        z\n                    ];\n                }\n                var transform = element.transformable;\n                if (origin[0] === transform.origin[0] && origin[1] === transform.origin[1] && origin[2] === transform.origin[2]) {\n                    return;\n                }\n                var originVec = transform.origin;\n                // const delta = vec3.subtract(vec3.create(), origin, originVec);\n                // vec3.add(transform.localPosition, transform.localPosition, delta);\n                // update origin\n                originVec[0] = origin[0];\n                originVec[1] = origin[1];\n                originVec[2] = origin[2] || 0;\n                this.dirtifyLocal(element, transform);\n            }\n        },\n        {\n            key: \"rotate\",\n            value: function rotate(element, degrees) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                if (typeof degrees === \"number\") {\n                    degrees = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(degrees, y, z);\n                }\n                var transform = element.transformable;\n                if (element.parentNode === null || !element.parentNode.transformable) {\n                    this.rotateLocal(element, degrees);\n                } else {\n                    var rotation = $quat$1;\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);\n                    var rot = this.getRotation(element);\n                    var parentRot = this.getRotation(element.parentNode);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.copy($rotate_ParentInvertRotation, parentRot);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.multiply(rotation, $rotate_ParentInvertRotation, rotation);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.multiply(transform.localRotation, rotation, rot);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.normalize(transform.localRotation, transform.localRotation);\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"rotateLocal\",\n            value: function rotateLocal(element, degrees) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                if (typeof degrees === \"number\") {\n                    degrees = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(degrees, y, z);\n                }\n                var transform = element.transformable;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_21__.fromEuler($rotateLocal, degrees[0], degrees[1], degrees[2]);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_21__.mul(transform.localRotation, transform.localRotation, $rotateLocal);\n                this.dirtifyLocal(element, transform);\n            }\n        },\n        {\n            key: \"setEulerAngles\",\n            value: function setEulerAngles(element, degrees) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                if (typeof degrees === \"number\") {\n                    degrees = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(degrees, y, z);\n                }\n                var transform = element.transformable;\n                if (element.parentNode === null || !element.parentNode.transformable) {\n                    this.setLocalEulerAngles(element, degrees);\n                } else {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);\n                    var parentRotation = this.getRotation(element.parentNode);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.copy($setEulerAngles_InvParentRot, gl_matrix__WEBPACK_IMPORTED_MODULE_21__.invert($quat$1, parentRotation));\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.mul(transform.localRotation, transform.localRotation, $setEulerAngles_InvParentRot);\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"setLocalEulerAngles\",\n            value: function setLocalEulerAngles(element, degrees) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                var dirtify = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n                if (typeof degrees === \"number\") {\n                    degrees = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(degrees, y, z);\n                }\n                var transform = element.transformable;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_21__.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);\n                if (dirtify) {\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"translateLocal\",\n            value: function translateLocal(element, translation) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                if (typeof translation === \"number\") {\n                    translation = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(translation, y, z);\n                }\n                var transform = element.transformable;\n                if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.equals(translation, $vec3Zero)) return;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformQuat(translation, translation, transform.localRotation);\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.add(transform.localPosition, transform.localPosition, translation);\n                this.dirtifyLocal(element, transform);\n            }\n        },\n        {\n            key: \"setPosition\",\n            value: function setPosition(element, position) {\n                var _position$;\n                var transform = element.transformable;\n                $setPosition_1[0] = position[0];\n                $setPosition_1[1] = position[1];\n                $setPosition_1[2] = (_position$ = position[2]) !== null && _position$ !== void 0 ? _position$ : 0;\n                if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.equals(this.getPosition(element), $setPosition_1)) {\n                    return;\n                }\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(transform.position, $setPosition_1);\n                if (element.parentNode === null || !element.parentNode.transformable) {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(transform.localPosition, $setPosition_1);\n                } else {\n                    var parentTransform = element.parentNode.transformable;\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.copy($setPosition_ParentInvertMatrix, parentTransform.worldTransform);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(transform.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);\n                }\n                this.dirtifyLocal(element, transform);\n            }\n        },\n        {\n            key: \"setLocalPosition\",\n            value: function setLocalPosition(element, position) {\n                var _position$2;\n                var dirtify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n                var transform = element.transformable;\n                $setLocalPosition[0] = position[0];\n                $setLocalPosition[1] = position[1];\n                $setLocalPosition[2] = (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;\n                if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.equals(transform.localPosition, $setLocalPosition)) {\n                    return;\n                }\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(transform.localPosition, $setLocalPosition);\n                if (dirtify) {\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"scaleLocal\",\n            value: function scaleLocal(element, scaling) {\n                var _scaling$;\n                var transform = element.transformable;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.multiply(transform.localScale, transform.localScale, gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : 1));\n                this.dirtifyLocal(element, transform);\n            }\n        },\n        {\n            key: \"setLocalScale\",\n            value: function setLocalScale(element, scaling) {\n                var _scaling$2;\n                var dirtify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n                var transform = element.transformable;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : transform.localScale[2]);\n                if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.equals($vec3$1, transform.localScale)) {\n                    return;\n                }\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.copy(transform.localScale, $vec3$1);\n                if (dirtify) {\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"translate\",\n            value: function translate(element, translation) {\n                var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                var z = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                if (typeof translation === \"number\") {\n                    translation = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set($vec3$1, translation, y, z);\n                }\n                if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.equals(translation, $vec3Zero)) return;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_16__.add($vec3$1, this.getPosition(element), translation);\n                this.setPosition(element, $vec3$1);\n            }\n        },\n        {\n            key: \"setRotation\",\n            value: function setRotation(element, rotation, y, z, w) {\n                var transform = element.transformable;\n                if (typeof rotation === \"number\") {\n                    rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.fromValues(rotation, y, z, w);\n                }\n                if (element.parentNode === null || !element.parentNode.transformable) {\n                    this.setLocalRotation(element, rotation);\n                } else {\n                    var parentRot = this.getRotation(element.parentNode);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.copy($quat$1, parentRot);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.invert($quat$1, $quat$1);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.multiply(transform.localRotation, $quat$1, rotation);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_21__.normalize(transform.localRotation, transform.localRotation);\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"setLocalRotation\",\n            value: function setLocalRotation(element, rotation, y, z, w) {\n                var dirtify = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n                if (typeof rotation === \"number\") {\n                    rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.set($quat$1, rotation, y, z, w);\n                }\n                var transform = element.transformable;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_21__.copy(transform.localRotation, rotation);\n                if (dirtify) {\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"setLocalSkew\",\n            value: function setLocalSkew(element, skew, y) {\n                var dirtify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n                if (typeof skew === \"number\") {\n                    skew = gl_matrix__WEBPACK_IMPORTED_MODULE_42__.set($vec2, skew, y);\n                }\n                var transform = element.transformable;\n                gl_matrix__WEBPACK_IMPORTED_MODULE_42__.copy(transform.localSkew, skew);\n                if (dirtify) {\n                    this.dirtifyLocal(element, transform);\n                }\n            }\n        },\n        {\n            key: \"dirtifyLocal\",\n            value: function dirtifyLocal(element, transform) {\n                if (isInFragment(element)) return;\n                if (!transform.localDirtyFlag) {\n                    transform.localDirtyFlag = true;\n                    if (!transform.dirtyFlag) {\n                        this.dirtifyWorld(element, transform);\n                    }\n                }\n            }\n        },\n        {\n            key: \"dirtifyWorld\",\n            value: function dirtifyWorld(element, transform) {\n                if (!transform.dirtyFlag) {\n                    this.unfreezeParentToRoot(element);\n                }\n                this.dirtifyWorldInternal(element, transform);\n                this.dirtifyToRoot(element, true);\n            }\n        },\n        {\n            key: \"dirtifyFragment\",\n            value: function dirtifyFragment(element) {\n                var transform = element.transformable;\n                if (transform) {\n                    transform.frozen = false;\n                    transform.dirtyFlag = true;\n                    transform.localDirtyFlag = true;\n                }\n                var renderable = element.renderable;\n                if (renderable) {\n                    renderable.renderBoundsDirty = true;\n                    renderable.boundsDirty = true;\n                    renderable.dirty = true;\n                }\n                var length = element.childNodes.length;\n                for(var i = 0; i < length; i++){\n                    this.dirtifyFragment(element.childNodes[i]);\n                }\n                if (element.nodeName === Shape.FRAGMENT) {\n                    this.pendingEvents.set(element, false);\n                }\n            }\n        },\n        {\n            key: \"triggerPendingEvents\",\n            value: function triggerPendingEvents() {\n                var _this = this;\n                var triggered = new Set();\n                var trigger = function trigger(element, detail) {\n                    if (!element.isConnected || triggered.has(element) || element.nodeName === Shape.FRAGMENT) {\n                        return;\n                    }\n                    _this.boundsChangedEvent.detail = detail;\n                    _this.boundsChangedEvent.target = element;\n                    if (element.isMutationObserved) {\n                        element.dispatchEvent(_this.boundsChangedEvent);\n                    } else {\n                        element.ownerDocument.defaultView.dispatchEvent(_this.boundsChangedEvent, true);\n                    }\n                    triggered.add(element);\n                };\n                this.pendingEvents.forEach(function(affectChildren, element) {\n                    if (element.nodeName === Shape.FRAGMENT) {\n                        return;\n                    }\n                    $triggerPendingEvents_detail.affectChildren = affectChildren;\n                    if (affectChildren) {\n                        element.forEach(function(e) {\n                            trigger(e, $triggerPendingEvents_detail);\n                        });\n                    } else trigger(element, $triggerPendingEvents_detail);\n                });\n                triggered.clear();\n                this.clearPendingEvents();\n            }\n        },\n        {\n            key: \"clearPendingEvents\",\n            value: function clearPendingEvents() {\n                this.pendingEvents.clear();\n            }\n        },\n        {\n            key: \"dirtifyToRoot\",\n            value: function dirtifyToRoot(element) {\n                var affectChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var p = element;\n                // only need to re-render itself\n                if (p.renderable) {\n                    p.renderable.dirty = true;\n                }\n                while(p){\n                    markRenderableDirty(p);\n                    p = p.parentNode;\n                }\n                if (affectChildren) {\n                    element.forEach(function(e) {\n                        markRenderableDirty(e);\n                    });\n                }\n                this.informDependentDisplayObjects(element);\n                this.pendingEvents.set(element, affectChildren);\n            }\n        },\n        {\n            key: \"updateDisplayObjectDependency\",\n            value: function updateDisplayObjectDependency(name, oldPath, newPath, object) {\n                // clear ref to old clip path\n                if (oldPath && oldPath !== newPath) {\n                    var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);\n                    if (oldDependencyMap && oldDependencyMap[name]) {\n                        var index = oldDependencyMap[name].indexOf(object);\n                        oldDependencyMap[name].splice(index, 1);\n                    }\n                }\n                if (newPath) {\n                    var newDependencyMap = this.displayObjectDependencyMap.get(newPath);\n                    if (!newDependencyMap) {\n                        this.displayObjectDependencyMap.set(newPath, {});\n                        newDependencyMap = this.displayObjectDependencyMap.get(newPath);\n                    }\n                    if (!newDependencyMap[name]) {\n                        newDependencyMap[name] = [];\n                    }\n                    newDependencyMap[name].push(object);\n                }\n            }\n        },\n        {\n            key: \"informDependentDisplayObjects\",\n            value: function informDependentDisplayObjects(object) {\n                var _this2 = this;\n                var dependencyMap = this.displayObjectDependencyMap.get(object);\n                if (!dependencyMap) {\n                    return;\n                }\n                Object.keys(dependencyMap).forEach(function(name) {\n                    dependencyMap[name].forEach(function(target) {\n                        _this2.dirtifyToRoot(target, true);\n                        target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this2, _this2, name, MutationEvent.MODIFICATION, _this2, _this2));\n                        if (target.isCustomElement && target.isConnected) {\n                            if (target.attributeChangedCallback) {\n                                target.attributeChangedCallback(name, _this2, _this2);\n                            }\n                        }\n                    });\n                });\n            }\n        },\n        {\n            key: \"getPosition\",\n            value: function getPosition(element) {\n                var transform = element.transformable;\n                return gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getTranslation(transform.position, this.getWorldTransform(element, transform));\n            }\n        },\n        {\n            key: \"getRotation\",\n            value: function getRotation(element) {\n                var transform = element.transformable;\n                return gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getRotation(transform.rotation, this.getWorldTransform(element, transform));\n            }\n        },\n        {\n            key: \"getScale\",\n            value: function getScale(element) {\n                var transform = element.transformable;\n                return gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getScaling(transform.scaling, this.getWorldTransform(element, transform));\n            }\n        },\n        {\n            key: \"getWorldTransform\",\n            value: function getWorldTransform(element) {\n                var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element.transformable;\n                if (!transform.localDirtyFlag && !transform.dirtyFlag) {\n                    return transform.worldTransform;\n                }\n                if (element.parentNode && element.parentNode.transformable) {\n                    this.getWorldTransform(element.parentNode);\n                }\n                this.sync(element, transform);\n                return transform.worldTransform;\n            }\n        },\n        {\n            key: \"getLocalPosition\",\n            value: function getLocalPosition(element) {\n                return element.transformable.localPosition;\n            }\n        },\n        {\n            key: \"getLocalRotation\",\n            value: function getLocalRotation(element) {\n                return element.transformable.localRotation;\n            }\n        },\n        {\n            key: \"getLocalScale\",\n            value: function getLocalScale(element) {\n                return element.transformable.localScale;\n            }\n        },\n        {\n            key: \"getLocalSkew\",\n            value: function getLocalSkew(element) {\n                return element.transformable.localSkew;\n            }\n        },\n        {\n            key: \"calcLocalTransform\",\n            value: function calcLocalTransform(transform) {\n                var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;\n                if (hasSkew) {\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(1, 1, 1), transform.origin);\n                    // apply skew2D\n                    if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {\n                        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.identity($mat4);\n                        $mat4[4] = Math.tan(transform.localSkew[0]);\n                        $mat4[1] = Math.tan(transform.localSkew[1]);\n                        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(transform.localTransform, transform.localTransform, $mat4);\n                    }\n                    var scaling = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromRotationTranslationScaleOrigin($mat4, gl_matrix__WEBPACK_IMPORTED_MODULE_21__.set($quat$1, 0, 0, 0, 1), gl_matrix__WEBPACK_IMPORTED_MODULE_16__.set($vec3$1, 1, 1, 1), transform.localScale, transform.origin);\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(transform.localTransform, transform.localTransform, scaling);\n                } else {\n                    var localTransform = transform.localTransform, localPosition = transform.localPosition, localRotation = transform.localRotation, localScale = transform.localScale, origin = transform.origin;\n                    var hasPosition = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;\n                    var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;\n                    var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;\n                    var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;\n                    if (!hasRotation && !hasScale && !hasOrigin) {\n                        if (hasPosition) {\n                            gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromTranslation(localTransform, localPosition);\n                        } else {\n                            gl_matrix__WEBPACK_IMPORTED_MODULE_19__.identity(localTransform);\n                        }\n                    } else {\n                        // @see https://github.com/mattdesl/css-mat4/blob/master/index.js\n                        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);\n                    }\n                }\n            }\n        },\n        {\n            key: \"getLocalTransform\",\n            value: function getLocalTransform(element) {\n                var transform = element.transformable;\n                if (transform.localDirtyFlag) {\n                    this.calcLocalTransform(transform);\n                    transform.localDirtyFlag = false;\n                }\n                return transform.localTransform;\n            }\n        },\n        {\n            key: \"setLocalTransform\",\n            value: function setLocalTransform(element, transform) {\n                var t = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getTranslation($setLocalTransform_1, transform);\n                var r = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getRotation($setLocalTransform_2, transform);\n                var s = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getScaling($setLocalTransform_3, transform);\n                this.setLocalScale(element, s, false);\n                this.setLocalPosition(element, t, false);\n                this.setLocalRotation(element, r, undefined, undefined, undefined, false);\n                this.dirtifyLocal(element, element.transformable);\n            }\n        },\n        {\n            key: \"resetLocalTransform\",\n            value: function resetLocalTransform(element) {\n                this.setLocalScale(element, $vec3One, false);\n                this.setLocalPosition(element, $vec3Zero, false);\n                this.setLocalEulerAngles(element, $vec3Zero, undefined, undefined, false);\n                this.setLocalSkew(element, $vec2Zero, undefined, false);\n                this.dirtifyLocal(element, element.transformable);\n            }\n        },\n        {\n            key: \"getTransformedGeometryBounds\",\n            value: function getTransformedGeometryBounds(element) {\n                var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var existedAABB = arguments.length > 2 ? arguments[2] : undefined;\n                var bounds = this.getGeometryBounds(element, render);\n                if (!AABB.isEmpty(bounds)) {\n                    var aabb = existedAABB || new AABB();\n                    aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));\n                    return aabb;\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getGeometryBounds\",\n            value: function getGeometryBounds(element) {\n                var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var _ref3 = element, geometry = _ref3.geometry;\n                if (geometry.dirty) {\n                    runtime.styleValueRegistry.updateGeometry(element);\n                }\n                var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;\n                // return (bounds && new AABB(bounds.center, bounds.halfExtents)) || new AABB();\n                return bounds || new AABB();\n            }\n        },\n        {\n            key: \"getBounds\",\n            value: function getBounds(element) {\n                var _this3 = this;\n                var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var _ref4 = element, renderable = _ref4.renderable;\n                if (!renderable.boundsDirty && !render && renderable.bounds) {\n                    return renderable.bounds;\n                }\n                if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {\n                    return renderable.renderBounds;\n                }\n                // reuse existed if possible\n                var existedAABB = render ? renderable.renderBounds : renderable.bounds;\n                // reset with geometry's aabb\n                var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);\n                // merge children's aabbs\n                var children = element.childNodes;\n                children.forEach(function(child) {\n                    var childBounds = _this3.getBounds(child, render);\n                    if (childBounds) {\n                        if (!aabb) {\n                            aabb = existedAABB || new AABB();\n                            aabb.update(childBounds.center, childBounds.halfExtents);\n                        } else {\n                            aabb.add(childBounds);\n                        }\n                    }\n                });\n                if (!aabb) {\n                    aabb = new AABB();\n                }\n                if (render) {\n                    // FIXME: account for clip path\n                    var clipped = findClosestClipPathTarget(element);\n                    if (clipped) {\n                        // use bounds under world space\n                        var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);\n                        if (!aabb) {\n                            aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);\n                        } else if (clipPathBounds) {\n                            aabb = clipPathBounds.intersection(aabb);\n                        }\n                    }\n                }\n                if (render) {\n                    renderable.renderBounds = aabb;\n                    renderable.renderBoundsDirty = false;\n                } else {\n                    renderable.bounds = aabb;\n                    renderable.boundsDirty = false;\n                }\n                return aabb;\n            }\n        },\n        {\n            key: \"getLocalBounds\",\n            value: function getLocalBounds(element) {\n                if (element.parentNode) {\n                    var parentInvert = $mat4Identity;\n                    if (element.parentNode.transformable) {\n                        parentInvert = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert($mat4, this.getWorldTransform(element.parentNode));\n                    }\n                    var bounds = this.getBounds(element);\n                    if (!AABB.isEmpty(bounds)) {\n                        var localBounds = new AABB();\n                        localBounds.setFromTransformedAABB(bounds, parentInvert);\n                        return localBounds;\n                    }\n                }\n                return this.getBounds(element);\n            }\n        },\n        {\n            key: \"getBoundingClientRect\",\n            value: function getBoundingClientRect(element) {\n                var _element$ownerDocumen;\n                var aabb;\n                var bounds = this.getGeometryBounds(element);\n                if (!AABB.isEmpty(bounds)) {\n                    aabb = new AABB();\n                    // apply transformation to aabb\n                    aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));\n                }\n                // calc context's offset\n                var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();\n                if (aabb) {\n                    var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];\n                    var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];\n                    return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);\n                }\n                return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);\n            }\n        },\n        {\n            key: \"dirtifyWorldInternal\",\n            value: function dirtifyWorldInternal(element, transform) {\n                var _this4 = this;\n                if (!transform.dirtyFlag) {\n                    transform.dirtyFlag = true;\n                    transform.frozen = false;\n                    element.childNodes.forEach(function(child) {\n                        var childTransform = child.transformable;\n                        if (!childTransform.dirtyFlag) {\n                            _this4.dirtifyWorldInternal(child, childTransform);\n                        }\n                    });\n                    var _ref5 = element, renderable = _ref5.renderable;\n                    if (renderable) {\n                        renderable.renderBoundsDirty = true;\n                        renderable.boundsDirty = true;\n                        renderable.dirty = true;\n                    }\n                }\n            }\n        },\n        {\n            key: \"syncHierarchy\",\n            value: function syncHierarchy(element) {\n                var transform = element.transformable;\n                if (transform.frozen) {\n                    return;\n                }\n                transform.frozen = true;\n                if (transform.localDirtyFlag || transform.dirtyFlag) {\n                    this.sync(element, transform);\n                }\n                var children = element.childNodes;\n                for(var i = 0; i < children.length; i++){\n                    this.syncHierarchy(children[i]);\n                }\n            }\n        },\n        {\n            key: \"sync\",\n            value: function sync(element, transform) {\n                if (transform.localDirtyFlag) {\n                    this.calcLocalTransform(transform);\n                    transform.localDirtyFlag = false;\n                }\n                if (transform.dirtyFlag) {\n                    var parent = element.parentNode;\n                    var parentTransform = parent && parent.transformable;\n                    if (parent === null || !parentTransform) {\n                        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.copy(transform.worldTransform, transform.localTransform);\n                    } else {\n                        // TODO: should we support scale compensation?\n                        // @see https://github.com/playcanvas/engine/issues/1077#issuecomment-359765557\n                        gl_matrix__WEBPACK_IMPORTED_MODULE_19__.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);\n                    }\n                    transform.dirtyFlag = false;\n                }\n            }\n        },\n        {\n            key: \"unfreezeParentToRoot\",\n            value: function unfreezeParentToRoot(child) {\n                var p = child.parentNode;\n                while(p){\n                    var transform = p.transformable;\n                    if (transform) {\n                        transform.frozen = false;\n                    }\n                    p = p.parentNode;\n                }\n            }\n        }\n    ]);\n}();\nvar TEXT_METRICS = {\n    MetricsString: \"|\\xc9q\\xc5\",\n    BaselineSymbol: \"M\",\n    BaselineMultiplier: 1.4,\n    HeightMultiplier: 2,\n    Newlines: [\n        0x000a,\n        // line feed\n        0x000d // carriage return\n    ],\n    BreakingSpaces: [\n        0x0009,\n        // character tabulation\n        0x0020,\n        // space\n        0x2000,\n        // en quad\n        0x2001,\n        // em quad\n        0x2002,\n        // en space\n        0x2003,\n        // em space\n        0x2004,\n        // three-per-em space\n        0x2005,\n        // four-per-em space\n        0x2006,\n        // six-per-em space\n        0x2008,\n        // punctuation space\n        0x2009,\n        // thin space\n        0x200a,\n        // hair space\n        0x205f,\n        // medium mathematical space\n        0x3000 // ideographic space\n    ]\n};\nvar LATIN_REGEX = /[a-zA-Z0-9\\u00C0-\\u00D6\\u00D8-\\u00f6\\u00f8-\\u00ff!\"#$%&'()*+,-./:;]/;\n// Line breaking rules in CJK (Kinsoku Shori)\n// Refer from https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\nvar regexCannotStartZhCn = /[!%),.:;?\\]}¢°·'\"\"†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;\nvar regexCannotEndZhCn = /[$(£¥·'\"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;\nvar regexCannotStartZhTw = /[!),.:;?\\]}¢·–—'\"•\"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;\nvar regexCannotEndZhTw = /[([{£¥'\"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;\nvar regexCannotStartJaJp = /[)\\]｝〕〉》」』】〙〗〟'\"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;\nvar regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'\"｟«—...‥〳〴〵]/;\nvar regexCannotStartKoKr = /[!%),.:;?\\]}¢°'\"†‡℃〆〈《「『〕！％），．：；？］｝]/;\nvar regexCannotEndKoKr = /[$([{£¥'\"々〇〉》」〔＄（［｛｠￥￦#]/;\nvar regexCannotStart = new RegExp(\"\".concat(regexCannotStartZhCn.source, \"|\").concat(regexCannotStartZhTw.source, \"|\").concat(regexCannotStartJaJp.source, \"|\").concat(regexCannotStartKoKr.source));\nvar regexCannotEnd = new RegExp(\"\".concat(regexCannotEndZhCn.source, \"|\").concat(regexCannotEndZhTw.source, \"|\").concat(regexCannotEndJaJp.source, \"|\").concat(regexCannotEndKoKr.source));\n/**\n * Borrow from pixi/packages/text/src/TextMetrics.ts\n */ var TextService = /*#__PURE__*/ function() {\n    function TextService(runtime) {\n        var _this = this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, TextService);\n        /**\n     * font metrics cache\n     */ this.fontMetricsCache = {};\n        this.shouldBreakByKinsokuShorui = function(_char, nextChar) {\n            if (_this.isBreakingSpace(nextChar)) return false;\n            if (_char) {\n                // Line breaking rules in CJK (Kinsoku Shori)\n                if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        this.trimByKinsokuShorui = function(prev) {\n            var next = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(prev);\n            var prevLine = next[next.length - 2];\n            if (!prevLine) {\n                return prev;\n            }\n            var lastChar = prevLine[prevLine.length - 1];\n            next[next.length - 2] = prevLine.slice(0, -1);\n            next[next.length - 1] = lastChar + next[next.length - 1];\n            return next;\n        };\n        this.runtime = runtime;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(TextService, [\n        {\n            key: \"measureFont\",\n            value: /**\n     * Calculates the ascent, descent and fontSize of a given font-style.\n     */ function measureFont(font, offscreenCanvas) {\n                // as this method is used for preparing assets, don't recalculate things if we don't need to\n                if (this.fontMetricsCache[font]) {\n                    return this.fontMetricsCache[font];\n                }\n                var properties = {\n                    ascent: 0,\n                    descent: 0,\n                    fontSize: 0\n                };\n                var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n                var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {\n                    willReadFrequently: true\n                });\n                context.font = font;\n                var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;\n                var width = Math.ceil(context.measureText(metricsString).width);\n                var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);\n                var height = TEXT_METRICS.HeightMultiplier * baseline;\n                baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;\n                // @ts-ignore\n                canvas.width = width;\n                // @ts-ignore\n                canvas.height = height;\n                context.fillStyle = \"#f00\";\n                context.fillRect(0, 0, width, height);\n                context.font = font;\n                context.textBaseline = \"alphabetic\";\n                context.fillStyle = \"#000\";\n                context.fillText(metricsString, 0, baseline);\n                var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;\n                var pixels = imagedata.length;\n                var line = width * 4;\n                var i = 0;\n                var idx = 0;\n                var stop = false;\n                // ascent. scan from top to bottom until we find a non red pixel\n                for(i = 0; i < baseline; ++i){\n                    for(var j = 0; j < line; j += 4){\n                        if (imagedata[idx + j] !== 255) {\n                            stop = true;\n                            break;\n                        }\n                    }\n                    if (!stop) {\n                        idx += line;\n                    } else {\n                        break;\n                    }\n                }\n                properties.ascent = baseline - i;\n                idx = pixels - line;\n                stop = false;\n                // descent. scan from bottom to top until we find a non red pixel\n                for(i = height; i > baseline; --i){\n                    for(var _j = 0; _j < line; _j += 4){\n                        if (imagedata[idx + _j] !== 255) {\n                            stop = true;\n                            break;\n                        }\n                    }\n                    if (!stop) {\n                        idx -= line;\n                    } else {\n                        break;\n                    }\n                }\n                properties.descent = i - baseline;\n                properties.fontSize = properties.ascent + properties.descent;\n                this.fontMetricsCache[font] = properties;\n                return properties;\n            }\n        },\n        {\n            key: \"measureText\",\n            value: function measureText(text, parsedStyle, offscreenCanvas) {\n                var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? \"alphabetic\" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? \"start\" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;\n                parsedStyle.textPathSide;\n                parsedStyle.textPathStartOffset;\n                var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;\n                var font = toFontString(parsedStyle);\n                var fontProperties = this.measureFont(font, offscreenCanvas);\n                // fallback in case UA disallow canvas data extraction\n                if (fontProperties.fontSize === 0) {\n                    fontProperties.fontSize = fontSize;\n                    fontProperties.ascent = fontSize;\n                }\n                var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);\n                context.font = font;\n                // no overflowing by default\n                parsedStyle.isOverflowing = false;\n                var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;\n                var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n                var lineWidths = new Array(lines.length);\n                var maxLineWidth = 0;\n                // account for textPath\n                if (textPath) {\n                    textPath.getTotalLength();\n                    // const startingPoint = textPath.getPoint(0);\n                    for(var i = 0; i < lines.length; i++){\n                        context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;\n                    // for (\n                    //   let i = reverse ? lines[0].length - 1 : 0;\n                    //   reverse ? i >= 0 : i < lines[0].length;\n                    //   reverse ? i-- : i++\n                    // ) {\n                    //   graphemeInfo = lineBounds[i];\n                    //   if (positionInPath > totalPathLength) {\n                    //     positionInPath %= totalPathLength;\n                    //   } else if (positionInPath < 0) {\n                    //     positionInPath += totalPathLength;\n                    //   }\n                    //   // it would probably much faster to send all the grapheme position for a line\n                    //   // and calculate path position/angle at once.\n                    //   this.setGraphemeOnPath(\n                    //     positionInPath,\n                    //     graphemeInfo,\n                    //     startingPoint\n                    //   );\n                    //   positionInPath += graphemeInfo.kernedWidth;\n                    // }\n                    }\n                } else {\n                    for(var _i = 0; _i < lines.length; _i++){\n                        // char width + letterSpacing\n                        var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;\n                        lineWidths[_i] = _lineWidth;\n                        maxLineWidth = Math.max(maxLineWidth, _lineWidth);\n                    }\n                    var _width = maxLineWidth + lineWidth;\n                    // if (dropShadow) {\n                    //   width += dropShadowDistance;\n                    // }\n                    var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;\n                    var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);\n                    // if (dropShadow) {\n                    //   height += dropShadowDistance;\n                    // }\n                    lineHeight += leading;\n                    // handle vertical text baseline\n                    var offsetY = 0;\n                    if (textBaseline === \"middle\") {\n                        offsetY = -height / 2;\n                    } else if (textBaseline === \"bottom\" || textBaseline === \"alphabetic\" || textBaseline === \"ideographic\") {\n                        offsetY = -height;\n                    } else if (textBaseline === \"top\" || textBaseline === \"hanging\") {\n                        offsetY = 0;\n                    }\n                    return {\n                        font: font,\n                        width: _width,\n                        height: height,\n                        lines: lines,\n                        lineWidths: lineWidths,\n                        lineHeight: lineHeight,\n                        maxLineWidth: maxLineWidth,\n                        fontProperties: fontProperties,\n                        lineMetrics: lineWidths.map(function(width, i) {\n                            var offsetX = 0;\n                            // handle horizontal text align\n                            if (textAlign === \"center\" || textAlign === \"middle\") {\n                                offsetX -= width / 2;\n                            } else if (textAlign === \"right\" || textAlign === \"end\") {\n                                offsetX -= width;\n                            }\n                            return new Rectangle(offsetX - lineWidth / 2, offsetY + i * lineHeight, width + lineWidth, lineHeight);\n                        })\n                    };\n                }\n            }\n        },\n        {\n            key: \"wordWrap\",\n            value: function wordWrap(text, parsedStyle, offscreenCanvas) {\n                var _this2 = this;\n                var self1 = this;\n                var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;\n                var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);\n                var maxWidth = wordWrapWidth + letterSpacing;\n                var ellipsis = \"\";\n                if (textOverflow === \"ellipsis\") {\n                    ellipsis = \"...\";\n                } else if (textOverflow && textOverflow !== \"clip\") {\n                    ellipsis = textOverflow;\n                }\n                var chars = Array.from(text);\n                var lines = [];\n                var currentLineIndex = 0;\n                var currentLineWidth = 0;\n                var prevLineLastCharIndex = 0;\n                var cache = {};\n                var calcWidth = function calcWidth(txt) {\n                    return _this2.getFromCache(txt, letterSpacing, cache, context);\n                };\n                var ellipsisWidth = calcWidth(ellipsis);\n                /**\n       * Find text fragments that will take up as much of the given line width as possible when rendered.\n       *\n       * @see https://github.com/antvis/G/issues/1833\n       *\n       * @param lineTxt - Current line of text\n       * @param txtLastCharIndex - The index of the last character of the current line in the entire text\n       * @param txtStartCharIndex - The index of the start character of the current line in the entire text\n       */ function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {\n                    while(calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars.length - 1){\n                        if (self1.isNewline(chars[txtLastCharIndex + 1])) {\n                            break;\n                        }\n                        txtLastCharIndex += 1;\n                        lineTxt += chars[txtLastCharIndex];\n                    }\n                    while(calcWidth(lineTxt) > widthThreshold && txtLastCharIndex > txtStartCharIndex){\n                        txtLastCharIndex -= 1;\n                        lineTxt = lineTxt.slice(0, -1);\n                    }\n                    return {\n                        lineTxt: lineTxt,\n                        txtLastCharIndex: txtLastCharIndex\n                    };\n                }\n                function appendEllipsis(lineIndex, textCharIndex) {\n                    // If there is not enough space to display the string itself, it is clipped.\n                    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow#values\n                    if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {\n                        return;\n                    }\n                    if (!lines[lineIndex]) {\n                        lines[lineIndex] = ellipsis;\n                        return;\n                    }\n                    var result = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);\n                    lines[lineIndex] = result.lineTxt + ellipsis;\n                }\n                for(var i = 0; i < chars.length; i++){\n                    var _char2 = chars[i];\n                    var prevChar = chars[i - 1];\n                    var nextChar = chars[i + 1];\n                    var charWidth = calcWidth(_char2);\n                    if (this.isNewline(_char2)) {\n                        // exceed maxLines, break immediately\n                        if (currentLineIndex + 1 >= maxLines) {\n                            parsedStyle.isOverflowing = true;\n                            if (i < chars.length - 1) {\n                                appendEllipsis(currentLineIndex, i - 1);\n                            }\n                            break;\n                        }\n                        prevLineLastCharIndex = i - 1;\n                        currentLineIndex += 1;\n                        currentLineWidth = 0;\n                        lines[currentLineIndex] = \"\";\n                        continue;\n                    }\n                    if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {\n                        var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i - 1, prevLineLastCharIndex + 1, maxWidth);\n                        if (result.txtLastCharIndex !== i - 1) {\n                            lines[currentLineIndex] = result.lineTxt;\n                            if (result.txtLastCharIndex === chars.length - 1) {\n                                break;\n                            }\n                            i = result.txtLastCharIndex + 1;\n                            _char2 = chars[i];\n                            prevChar = chars[i - 1];\n                            nextChar = chars[i + 1];\n                            charWidth = calcWidth(_char2);\n                        }\n                        if (currentLineIndex + 1 >= maxLines) {\n                            parsedStyle.isOverflowing = true;\n                            appendEllipsis(currentLineIndex, i - 1);\n                            break;\n                        }\n                        prevLineLastCharIndex = i - 1;\n                        currentLineIndex += 1;\n                        currentLineWidth = 0;\n                        lines[currentLineIndex] = \"\";\n                        if (this.isBreakingSpace(_char2)) {\n                            continue;\n                        }\n                        if (!this.canBreakInLastChar(_char2)) {\n                            lines = this.trimToBreakable(lines);\n                            currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || \"\", calcWidth);\n                        }\n                        if (this.shouldBreakByKinsokuShorui(_char2, nextChar)) {\n                            lines = this.trimByKinsokuShorui(lines);\n                            currentLineWidth += calcWidth(prevChar || \"\");\n                        }\n                    }\n                    currentLineWidth += charWidth;\n                    lines[currentLineIndex] = (lines[currentLineIndex] || \"\") + _char2;\n                }\n                return lines.join(\"\\n\");\n            }\n        },\n        {\n            key: \"isBreakingSpace\",\n            value: function isBreakingSpace(_char3) {\n                if (typeof _char3 !== \"string\") {\n                    return false;\n                }\n                return TEXT_METRICS.BreakingSpaces.indexOf(_char3.charCodeAt(0)) >= 0;\n            }\n        },\n        {\n            key: \"isNewline\",\n            value: function isNewline(_char4) {\n                if (typeof _char4 !== \"string\") {\n                    return false;\n                }\n                return TEXT_METRICS.Newlines.indexOf(_char4.charCodeAt(0)) >= 0;\n            }\n        },\n        {\n            key: \"trimToBreakable\",\n            value: function trimToBreakable(prev) {\n                var next = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(prev);\n                var prevLine = next[next.length - 2];\n                var index = this.findBreakableIndex(prevLine);\n                if (index === -1 || !prevLine) return next;\n                var trimmedChar = prevLine.slice(index, index + 1);\n                var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);\n                var trimFrom = index + 1;\n                var trimTo = index + (isTrimmedWithSpace ? 0 : 1);\n                next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);\n                next[next.length - 2] = prevLine.slice(0, trimTo);\n                return next;\n            }\n        },\n        {\n            key: \"canBreakInLastChar\",\n            value: function canBreakInLastChar(_char5) {\n                if (_char5 && LATIN_REGEX.test(_char5)) return false;\n                return true;\n            }\n        },\n        {\n            key: \"sumTextWidthByCache\",\n            value: function sumTextWidthByCache(text, calcWidthWithCache) {\n                return text.split(\"\").reduce(function(sum, c) {\n                    return sum + calcWidthWithCache(c);\n                }, 0);\n            }\n        },\n        {\n            key: \"findBreakableIndex\",\n            value: function findBreakableIndex(line) {\n                for(var i = line.length - 1; i >= 0; i--){\n                    if (!LATIN_REGEX.test(line[i])) return i;\n                }\n                return -1;\n            }\n        },\n        {\n            key: \"getFromCache\",\n            value: function getFromCache(key, letterSpacing, cache, context) {\n                var width = cache[key];\n                if (typeof width !== \"number\") {\n                    var spacing = key.length * letterSpacing;\n                    var metrics = context.measureText(key);\n                    width = metrics.width + spacing;\n                    cache[key] = width;\n                }\n                return width;\n            }\n        }\n    ]);\n}();\nvar runtime = {};\n/**\n * Replace with IoC container\n */ var geometryUpdaterFactory = function(_ref) {\n    var rectUpdater = new RectUpdater();\n    var polylineUpdater = new PolylineUpdater();\n    return _ref = {}, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);\n}();\nvar CSSPropertySyntaxFactory = function(_ref2) {\n    var color = new CSSPropertyColor();\n    var length = new CSSPropertyLengthOrPercentage();\n    return _ref2 = {}, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color), PropertySyntax.COLOR, color), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length), PropertySyntax.LENGTH_PERCENTAGE, length), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());\n}();\nvar getGlobalThis = function getGlobalThis() {\n    if (typeof globalThis !== \"undefined\") return globalThis;\n    if (typeof self !== \"undefined\") return self;\n    if (false) {}\n    // @ts-ignore\n    if (typeof global !== \"undefined\") return global;\n    return {};\n// [!] Error: The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten\n// @see https://rollupjs.org/troubleshooting/#error-this-is-undefined\n// if (typeof this !== 'undefined') return this;\n};\n/**\n * Camera\n * `g-camera-api` will provide an advanced implementation\n */ runtime.CameraContribution = Camera;\n/**\n * `g-web-animations-api` will provide an AnimationTimeline\n */ runtime.AnimationTimeline = null;\nruntime.EasingFunction = null;\nruntime.offscreenCanvasCreator = new OffscreenCanvasCreator();\nruntime.sceneGraphSelector = new DefaultSceneGraphSelector();\nruntime.sceneGraphService = new DefaultSceneGraphService(runtime);\nruntime.textService = new TextService(runtime);\nruntime.geometryUpdaterFactory = geometryUpdaterFactory;\nruntime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;\nruntime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);\nruntime.layoutRegistry = null;\nruntime.globalThis = getGlobalThis();\nruntime.enableStyleSyntax = true;\nruntime.enableSizeAttenuation = false;\nvar entityCounter = 0;\nfunction resetEntityCounter() {\n    entityCounter = 0;\n}\nvar insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, \"\", \"\", \"\", 0, \"\", \"\");\nvar removedEvent = new MutationEvent(ElementEvent.REMOVED, null, \"\", \"\", \"\", 0, \"\", \"\");\nvar destroyEvent = new CustomEvent(ElementEvent.DESTROY);\n/**\n * Has following capabilities:\n * * Node insert/remove, eg. appendChild, removeChild, remove...\n * * Query eg. querySelector getElementById...\n * * Animation\n */ var Element = /*#__PURE__*/ function(_Node) {\n    function Element() {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Element);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Element, [].concat(args));\n        /**\n     * Unique id.\n     */ _this.entity = entityCounter++;\n        _this.renderable = {\n            bounds: undefined,\n            boundsDirty: true,\n            renderBounds: undefined,\n            renderBoundsDirty: true,\n            dirtyRenderBounds: undefined,\n            dirty: false\n        };\n        _this.cullable = {\n            strategy: Strategy.Standard,\n            visibilityPlaneMask: -1,\n            visible: true,\n            enable: true\n        };\n        _this.transformable = {\n            dirtyFlag: false,\n            localDirtyFlag: false,\n            frozen: false,\n            localPosition: [\n                0,\n                0,\n                0\n            ],\n            localRotation: [\n                0,\n                0,\n                0,\n                1\n            ],\n            localScale: [\n                1,\n                1,\n                1\n            ],\n            localTransform: [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ],\n            localSkew: [\n                0,\n                0\n            ],\n            position: [\n                0,\n                0,\n                0\n            ],\n            rotation: [\n                0,\n                0,\n                0,\n                1\n            ],\n            scaling: [\n                1,\n                1,\n                1\n            ],\n            worldTransform: [\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ],\n            origin: [\n                0,\n                0,\n                0\n            ]\n        };\n        _this.sortable = {\n            dirty: false,\n            sorted: undefined,\n            renderOrder: 0,\n            dirtyChildren: [],\n            dirtyReason: undefined\n        };\n        _this.geometry = {\n            contentBounds: undefined,\n            renderBounds: undefined,\n            dirty: true\n        };\n        _this.rBushNode = {\n            aabb: undefined\n        };\n        /**\n     * https://developer.mozilla.org/zh-CN/docs/Web/API/Element/namespaceURI\n     */ _this.namespaceURI = \"g\";\n        _this.scrollLeft = 0;\n        _this.scrollTop = 0;\n        /**\n     * We don't support border now\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientTop\n     */ _this.clientTop = 0;\n        _this.clientLeft = 0;\n        /**\n     * is destroyed or not\n     */ _this.destroyed = false;\n        /**\n     * compatible with `style`\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style\n     */ _this.style = {};\n        _this.computedStyle = {};\n        /**\n     * Renderers will use these used values.\n     */ _this.parsedStyle = {\n        };\n        /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes\n     */ _this.attributes = {};\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Element, _Node);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Element, [\n        {\n            key: \"className\",\n            get: /**\n     * used with `getElementById()`\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id\n     */ /**\n     * used in `getElementsByClassName`\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n     */ function get() {\n                // @ts-ignore\n                return this.getAttribute(\"class\") || \"\";\n            },\n            set: function set(className) {\n                this.setAttribute(\"class\", className);\n            }\n        },\n        {\n            key: \"classList\",\n            get: /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n     */ function get() {\n                return this.className.split(\" \").filter(function(c) {\n                    return c !== \"\";\n                });\n            }\n        },\n        {\n            key: \"tagName\",\n            get: function get() {\n                return this.nodeName;\n            }\n        },\n        {\n            key: \"children\",\n            get: function get() {\n                return this.childNodes;\n            }\n        },\n        {\n            key: \"childElementCount\",\n            get: function get() {\n                return this.childNodes.length;\n            }\n        },\n        {\n            key: \"firstElementChild\",\n            get: function get() {\n                return this.firstChild;\n            }\n        },\n        {\n            key: \"lastElementChild\",\n            get: function get() {\n                return this.lastChild;\n            }\n        },\n        {\n            key: \"parentElement\",\n            get: function get() {\n                return this.parentNode;\n            }\n        },\n        {\n            key: \"nextSibling\",\n            get: function get() {\n                if (this.parentNode) {\n                    var index = this.parentNode.childNodes.indexOf(this);\n                    return this.parentNode.childNodes[index + 1] || null;\n                }\n                return null;\n            }\n        },\n        {\n            key: \"previousSibling\",\n            get: function get() {\n                if (this.parentNode) {\n                    var index = this.parentNode.childNodes.indexOf(this);\n                    return this.parentNode.childNodes[index - 1] || null;\n                }\n                return null;\n            }\n        },\n        {\n            key: \"cloneNode\",\n            value: function cloneNode(deep) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"appendChild\",\n            value: function appendChild(child, index) {\n                var _this$ownerDocument;\n                if (child.destroyed) {\n                    throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);\n                }\n                runtime.sceneGraphService.attach(child, this, index);\n                if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {\n                    if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {\n                        this.ownerDocument.defaultView.mountFragment(child);\n                    } else {\n                        this.ownerDocument.defaultView.mountChildren(child);\n                    }\n                }\n                // @ts-ignore\n                if (this.isMutationObserved) {\n                    insertedEvent.relatedNode = this;\n                    child.dispatchEvent(insertedEvent);\n                }\n                return child;\n            }\n        },\n        {\n            key: \"insertBefore\",\n            value: function insertBefore(newChild, refChild) {\n                if (!refChild) {\n                    this.appendChild(newChild);\n                } else {\n                    if (newChild.parentElement) {\n                        newChild.parentElement.removeChild(newChild);\n                    }\n                    var index = this.childNodes.indexOf(refChild);\n                    if (index === -1) {\n                        this.appendChild(newChild);\n                    } else {\n                        this.appendChild(newChild, index);\n                    }\n                }\n                return newChild;\n            }\n        },\n        {\n            key: \"replaceChild\",\n            value: function replaceChild(newChild, oldChild) {\n                var index = this.childNodes.indexOf(oldChild);\n                this.removeChild(oldChild);\n                this.appendChild(newChild, index);\n                return oldChild;\n            }\n        },\n        {\n            key: \"removeChild\",\n            value: function removeChild(child) {\n                var _child$ownerDocument;\n                // should emit on itself before detach\n                removedEvent.relatedNode = this;\n                child.dispatchEvent(removedEvent);\n                if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {\n                    child.ownerDocument.defaultView.unmountChildren(child);\n                }\n                // remove from scene graph\n                runtime.sceneGraphService.detach(child);\n                return child;\n            }\n        },\n        {\n            key: \"removeChildren\",\n            value: function removeChildren() {\n                for(var i = this.childNodes.length - 1; i >= 0; i--){\n                    var child = this.childNodes[i];\n                    this.removeChild(child);\n                }\n            }\n        },\n        {\n            key: \"destroyChildren\",\n            value: function destroyChildren() {\n                for(var i = this.childNodes.length - 1; i >= 0; i--){\n                    var child = this.childNodes[i];\n                    if (child.childNodes.length > 0) {\n                        child.destroyChildren();\n                    }\n                    child.destroy();\n                }\n            }\n        },\n        {\n            key: \"matches\",\n            value: function matches(selector) {\n                return runtime.sceneGraphService.matches(selector, this);\n            }\n        },\n        {\n            key: \"getElementById\",\n            value: function getElementById(id) {\n                return runtime.sceneGraphService.querySelector(\"#\".concat(id), this);\n            }\n        },\n        {\n            key: \"getElementsByName\",\n            value: function getElementsByName(name) {\n                return runtime.sceneGraphService.querySelectorAll('[name=\"'.concat(name, '\"]'), this);\n            }\n        },\n        {\n            key: \"getElementsByClassName\",\n            value: function getElementsByClassName(className) {\n                return runtime.sceneGraphService.querySelectorAll(\".\".concat(className), this);\n            }\n        },\n        {\n            key: \"getElementsByTagName\",\n            value: function getElementsByTagName(tagName) {\n                return runtime.sceneGraphService.querySelectorAll(tagName, this);\n            }\n        },\n        {\n            key: \"querySelector\",\n            value: function querySelector(selectors) {\n                return runtime.sceneGraphService.querySelector(selectors, this);\n            }\n        },\n        {\n            key: \"querySelectorAll\",\n            value: function querySelectorAll(selectors) {\n                return runtime.sceneGraphService.querySelectorAll(selectors, this);\n            }\n        },\n        {\n            key: \"closest\",\n            value: function closest(selectors) {\n                var el = this;\n                do {\n                    if (runtime.sceneGraphService.matches(selectors, el)) return el;\n                    el = el.parentElement;\n                }while (el !== null);\n                return null;\n            }\n        },\n        {\n            key: \"find\",\n            value: function find(filter) {\n                var _this2 = this;\n                var target = null;\n                this.forEach(function(object) {\n                    if (object !== _this2 && filter(object)) {\n                        target = object;\n                        return false;\n                    }\n                    return true;\n                });\n                return target;\n            }\n        },\n        {\n            key: \"findAll\",\n            value: function findAll(filter) {\n                var _this3 = this;\n                var objects = [];\n                this.forEach(function(object) {\n                    if (object !== _this3 && filter(object)) {\n                        objects.push(object);\n                    }\n                });\n                return objects;\n            }\n        },\n        {\n            key: \"after\",\n            value: function after() {\n                var _this4 = this;\n                if (this.parentNode) {\n                    var index = this.parentNode.childNodes.indexOf(this);\n                    for(var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                        nodes[_key2] = arguments[_key2];\n                    }\n                    nodes.forEach(function(node, i) {\n                        var _this4$parentNode;\n                        return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index + i + 1);\n                    });\n                }\n            }\n        },\n        {\n            key: \"before\",\n            value: function before() {\n                if (this.parentNode) {\n                    var _ref;\n                    var index = this.parentNode.childNodes.indexOf(this);\n                    for(var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                        nodes[_key3] = arguments[_key3];\n                    }\n                    var first = nodes[0], rest = nodes.slice(1);\n                    this.parentNode.appendChild(first, index);\n                    (_ref = first).after.apply(_ref, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(rest));\n                }\n            }\n        },\n        {\n            key: \"replaceWith\",\n            value: function replaceWith() {\n                this.after.apply(this, arguments);\n                this.remove();\n            }\n        },\n        {\n            key: \"append\",\n            value: function append() {\n                var _this5 = this;\n                for(var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n                    nodes[_key4] = arguments[_key4];\n                }\n                nodes.forEach(function(node) {\n                    return _this5.appendChild(node);\n                });\n            }\n        },\n        {\n            key: \"prepend\",\n            value: function prepend() {\n                var _this6 = this;\n                for(var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n                    nodes[_key5] = arguments[_key5];\n                }\n                nodes.forEach(function(node, i) {\n                    return _this6.appendChild(node, i);\n                });\n            }\n        },\n        {\n            key: \"replaceChildren\",\n            value: function replaceChildren() {\n                while(this.childNodes.length && this.firstChild){\n                    this.removeChild(this.firstChild);\n                }\n                this.append.apply(this, arguments);\n            }\n        },\n        {\n            key: \"remove\",\n            value: function remove() {\n                if (this.parentNode) {\n                    return this.parentNode.removeChild(this);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                // fix https://github.com/antvis/G/issues/1813\n                this.destroyChildren();\n                // destroy itself before remove\n                this.dispatchEvent(destroyEvent);\n                // remove from scenegraph first\n                this.remove();\n                // remove event listeners\n                this.emitter.removeAllListeners();\n                this.destroyed = true;\n            }\n        },\n        {\n            key: \"getGeometryBounds\",\n            value: function getGeometryBounds() {\n                return runtime.sceneGraphService.getGeometryBounds(this);\n            }\n        },\n        {\n            key: \"getRenderBounds\",\n            value: function getRenderBounds() {\n                return runtime.sceneGraphService.getBounds(this, true);\n            }\n        },\n        {\n            key: \"getBounds\",\n            value: function getBounds() {\n                return runtime.sceneGraphService.getBounds(this);\n            }\n        },\n        {\n            key: \"getLocalBounds\",\n            value: function getLocalBounds() {\n                return runtime.sceneGraphService.getLocalBounds(this);\n            }\n        },\n        {\n            key: \"getBoundingClientRect\",\n            value: function getBoundingClientRect() {\n                return runtime.sceneGraphService.getBoundingClientRect(this);\n            }\n        },\n        {\n            key: \"getClientRects\",\n            value: function getClientRects() {\n                return [\n                    this.getBoundingClientRect()\n                ];\n            }\n        },\n        {\n            key: \"computedStyleMap\",\n            value: /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap\n     * eg. circle.computedStyleMap().get('fill');\n     */ function computedStyleMap() {\n                return new Map(Object.entries(this.computedStyle));\n            }\n        },\n        {\n            key: \"getAttributeNames\",\n            value: /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames\n     */ function getAttributeNames() {\n                return Object.keys(this.attributes);\n            }\n        },\n        {\n            key: \"getAttribute\",\n            value: function getAttribute(name) {\n                // @see https://github.com/antvis/G/issues/1267\n                if (typeof name === \"symbol\") {\n                    return undefined;\n                }\n                var value = this.attributes[name];\n                if (value === undefined) {\n                    // if the given attribute does not exist, the value returned will either be null or \"\"\n                    return value;\n                }\n                return value;\n            }\n        },\n        {\n            key: \"hasAttribute\",\n            value: function hasAttribute(qualifiedName) {\n                return this.getAttributeNames().includes(qualifiedName);\n            }\n        },\n        {\n            key: \"hasAttributes\",\n            value: function hasAttributes() {\n                return !!this.getAttributeNames().length;\n            }\n        },\n        {\n            key: \"removeAttribute\",\n            value: function removeAttribute(attributeName) {\n                this.setAttribute(attributeName, null);\n                delete this.attributes[attributeName];\n            }\n        },\n        {\n            key: \"setAttribute\",\n            value: function setAttribute(attributeName, value, force, memoize) {\n                this.attributes[attributeName] = value;\n            }\n        },\n        {\n            key: \"getAttributeNS\",\n            value: function getAttributeNS(namespace, localName) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"getAttributeNode\",\n            value: function getAttributeNode(qualifiedName) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"getAttributeNodeNS\",\n            value: function getAttributeNodeNS(namespace, localName) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"hasAttributeNS\",\n            value: function hasAttributeNS(namespace, localName) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"removeAttributeNS\",\n            value: function removeAttributeNS(namespace, localName) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"removeAttributeNode\",\n            value: function removeAttributeNode(attr) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"setAttributeNS\",\n            value: function setAttributeNS(namespace, qualifiedName, value) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"setAttributeNode\",\n            value: function setAttributeNode(attr) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"setAttributeNodeNS\",\n            value: function setAttributeNodeNS(attr) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"toggleAttribute\",\n            value: function toggleAttribute(qualifiedName, force) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        }\n    ]);\n}(Node);\nfunction isDisplayObject(value) {\n    return !!(value !== null && value !== void 0 && value.nodeName);\n}\nvar Proxy = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {};\nvar attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);\nvar $vec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create();\nvar $quat = gl_matrix__WEBPACK_IMPORTED_MODULE_21__.create();\n/**\n * prototype chains: DisplayObject -> Element -> Node -> EventTarget\n *\n * mixins: Animatable, Transformable, Visible\n * @see https://github.com/tannerntannern/ts-mixer/blob/master/README.md#mixing-generic-classes\n *\n * Provide abilities in scene graph, such as:\n * * transform `translate/rotate/scale`\n * * add/remove child\n * * visibility and z-index\n *\n * Those abilities are implemented with those components: `Transform/Sortable/Visible`.\n *\n * Emit following events:\n * * init\n * * destroy\n * * attributeChanged\n */ var DisplayObject = /*#__PURE__*/ function(_Element) {\n    function DisplayObject(config) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DisplayObject);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, DisplayObject);\n        // assign name, id to config\n        // eg. group.get('name')\n        _this.isCustomElement = false;\n        _this.isMutationObserved = false;\n        /**\n     * push to active animations after calling `animate()`\n     */ _this.activeAnimations = [];\n        _this.config = config;\n        // init scene graph node\n        _this.id = config.id || \"\";\n        _this.name = config.name || \"\";\n        if (config.className || config[\"class\"]) {\n            _this.className = config.className || config[\"class\"];\n        }\n        _this.nodeName = config.type || Shape.GROUP;\n        if (config.initialParsedStyle) {\n            Object.assign(_this.parsedStyle, config.initialParsedStyle);\n        }\n        // start to process attributes\n        _this.initAttributes(config.style);\n        if (runtime.enableStyleSyntax) {\n            _this.style = new Proxy(// @ts-ignore\n            {\n                // ...this.attributes,\n                setProperty: function setProperty(propertyName, value) {\n                    _this.setAttribute(propertyName, value);\n                },\n                getPropertyValue: function getPropertyValue(propertyName) {\n                    return _this.getAttribute(propertyName);\n                },\n                removeProperty: function removeProperty(propertyName) {\n                    _this.removeAttribute(propertyName);\n                },\n                item: function item() {\n                    return \"\";\n                }\n            }, {\n                get: function get(target, name) {\n                    if (target[name] !== undefined) {\n                        // if (name in target) {\n                        return target[name];\n                    }\n                    return _this.getAttribute(name);\n                },\n                set: function set(_, prop, value) {\n                    _this.setAttribute(prop, value);\n                    return true;\n                }\n            });\n        }\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(DisplayObject, _Element);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(DisplayObject, [\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                _babel_runtime_helpers_superPropGet__WEBPACK_IMPORTED_MODULE_10___default()(DisplayObject, \"destroy\", this, 3)([]);\n                // stop all active animations\n                this.getAnimations().forEach(function(animation) {\n                    animation.cancel();\n                });\n            }\n        },\n        {\n            key: \"cloneNode\",\n            value: function cloneNode(deep, customCloneFunc) {\n                var clonedStyle = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.attributes);\n                for(var attributeName in clonedStyle){\n                    var attribute = clonedStyle[attributeName];\n                    // @see https://github.com/antvis/G/issues/1095\n                    if (isDisplayObject(attribute) && // share the same clipPath if possible\n                    attributeName !== \"clipPath\" && attributeName !== \"offsetPath\" && attributeName !== \"textPath\") {\n                        clonedStyle[attributeName] = attribute.cloneNode(deep);\n                    }\n                    // TODO: clone other type\n                    if (customCloneFunc) {\n                        clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);\n                    }\n                }\n                var cloned = new this.constructor(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.config), {}, {\n                    style: clonedStyle\n                }));\n                // apply transform\n                cloned.setLocalTransform(this.getLocalTransform());\n                if (deep) {\n                    this.children.forEach(function(child) {\n                        // skip marker\n                        if (!child.style.isMarker) {\n                            var clonedChild = child.cloneNode(deep);\n                            cloned.appendChild(clonedChild);\n                        }\n                    });\n                }\n                return cloned;\n            }\n        },\n        {\n            key: \"initAttributes\",\n            value: function initAttributes() {\n                var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var options = {\n                    forceUpdateGeometry: true\n                };\n                runtime.styleValueRegistry.processProperties(this, attributes, options);\n                // redraw at next frame\n                this.renderable.dirty = true;\n            }\n        },\n        {\n            key: \"setAttribute\",\n            value: function setAttribute(name, value) {\n                var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var memoize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n                // ignore undefined value\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(value)) {\n                    return;\n                }\n                if (force || value !== this.attributes[name]) {\n                    this.internalSetAttribute(name, value, {\n                        memoize: memoize\n                    });\n                    _babel_runtime_helpers_superPropGet__WEBPACK_IMPORTED_MODULE_10___default()(DisplayObject, \"setAttribute\", this, 3)([\n                        name,\n                        value\n                    ]);\n                }\n            }\n        },\n        {\n            key: \"internalSetAttribute\",\n            value: function internalSetAttribute(name, value) {\n                var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var renderable = this.renderable;\n                var oldValue = this.attributes[name];\n                var oldParsedValue = this.parsedStyle[name];\n                runtime.styleValueRegistry.processProperties(this, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()({}, name, value), parseOptions);\n                // redraw at next frame\n                renderable.dirty = true;\n                var newParsedValue = this.parsedStyle[name];\n                if (this.isConnected) {\n                    attrModifiedEvent.relatedNode = this;\n                    attrModifiedEvent.prevValue = oldValue;\n                    attrModifiedEvent.newValue = value;\n                    attrModifiedEvent.attrName = name;\n                    attrModifiedEvent.prevParsedValue = oldParsedValue;\n                    attrModifiedEvent.newParsedValue = newParsedValue;\n                    if (this.isMutationObserved) {\n                        this.dispatchEvent(attrModifiedEvent);\n                    } else {\n                        attrModifiedEvent.target = this;\n                        this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true);\n                    }\n                }\n                if (this.isCustomElement && this.isConnected || !this.isCustomElement) {\n                    var _attributeChangedCall, _ref;\n                    (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name, oldValue, value, oldParsedValue, newParsedValue);\n                }\n            }\n        },\n        {\n            key: \"getBBox\",\n            value: function getBBox() {\n                var aabb = this.getBounds();\n                var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];\n                var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];\n                return new Rectangle(left, top, right - left, bottom - top);\n            }\n        },\n        {\n            key: \"setOrigin\",\n            value: function setOrigin(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                runtime.sceneGraphService.setOrigin(this, createVec3(position, y, z, false));\n                return this;\n            }\n        },\n        {\n            key: \"getOrigin\",\n            value: function getOrigin() {\n                return runtime.sceneGraphService.getOrigin(this);\n            }\n        },\n        {\n            key: \"setPosition\",\n            value: function setPosition(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                runtime.sceneGraphService.setPosition(this, createVec3(position, y, z, false));\n                return this;\n            }\n        },\n        {\n            key: \"setLocalPosition\",\n            value: function setLocalPosition(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y, z, false));\n                return this;\n            }\n        },\n        {\n            key: \"translate\",\n            value: function translate(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                runtime.sceneGraphService.translate(this, createVec3(position, y, z, false));\n                return this;\n            }\n        },\n        {\n            key: \"translateLocal\",\n            value: function translateLocal(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                runtime.sceneGraphService.translateLocal(this, createVec3(position, y, z, false));\n                return this;\n            }\n        },\n        {\n            key: \"getPosition\",\n            value: function getPosition() {\n                return runtime.sceneGraphService.getPosition(this);\n            }\n        },\n        {\n            key: \"getLocalPosition\",\n            value: function getLocalPosition() {\n                return runtime.sceneGraphService.getLocalPosition(this);\n            }\n        },\n        {\n            key: \"scale\",\n            value: function scale(scaling, y, z) {\n                return this.scaleLocal(scaling, y, z);\n            }\n        },\n        {\n            key: \"scaleLocal\",\n            value: function scaleLocal(scaling, y, z) {\n                if (typeof scaling === \"number\") {\n                    y = y || scaling;\n                    z = z || scaling;\n                    scaling = createVec3(scaling, y, z, false);\n                }\n                runtime.sceneGraphService.scaleLocal(this, scaling);\n                return this;\n            }\n        },\n        {\n            key: \"setLocalScale\",\n            value: function setLocalScale(scaling, y, z) {\n                if (typeof scaling === \"number\") {\n                    y = y || scaling;\n                    z = z || scaling;\n                    scaling = createVec3(scaling, y, z, false);\n                }\n                runtime.sceneGraphService.setLocalScale(this, scaling);\n                return this;\n            }\n        },\n        {\n            key: \"getLocalScale\",\n            value: function getLocalScale() {\n                return runtime.sceneGraphService.getLocalScale(this);\n            }\n        },\n        {\n            key: \"getScale\",\n            value: function getScale() {\n                return runtime.sceneGraphService.getScale(this);\n            }\n        },\n        {\n            key: \"getEulerAngles\",\n            value: function getEulerAngles() {\n                var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_getEuler, 3), ez = _getEuler2[2];\n                return rad2deg(ez);\n            }\n        },\n        {\n            key: \"getLocalEulerAngles\",\n            value: function getLocalEulerAngles() {\n                var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_getEuler3, 3), ez = _getEuler4[2];\n                return rad2deg(ez);\n            }\n        },\n        {\n            key: \"setEulerAngles\",\n            value: function setEulerAngles(z) {\n                runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);\n                return this;\n            }\n        },\n        {\n            key: \"setLocalEulerAngles\",\n            value: function setLocalEulerAngles(z) {\n                runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);\n                return this;\n            }\n        },\n        {\n            key: \"rotateLocal\",\n            value: function rotateLocal(x, y, z) {\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(y) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(z)) {\n                    runtime.sceneGraphService.rotateLocal(this, 0, 0, x);\n                } else {\n                    runtime.sceneGraphService.rotateLocal(this, x, y, z);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"rotate\",\n            value: function rotate(x, y, z) {\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(y) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(z)) {\n                    runtime.sceneGraphService.rotate(this, 0, 0, x);\n                } else {\n                    runtime.sceneGraphService.rotate(this, x, y, z);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setRotation\",\n            value: function setRotation(rotation, y, z, w) {\n                runtime.sceneGraphService.setRotation(this, rotation, y, z, w);\n                return this;\n            }\n        },\n        {\n            key: \"setLocalRotation\",\n            value: function setLocalRotation(rotation, y, z, w) {\n                runtime.sceneGraphService.setLocalRotation(this, rotation, y, z, w);\n                return this;\n            }\n        },\n        {\n            key: \"setLocalSkew\",\n            value: function setLocalSkew(skew, y) {\n                runtime.sceneGraphService.setLocalSkew(this, skew, y);\n                return this;\n            }\n        },\n        {\n            key: \"getRotation\",\n            value: function getRotation() {\n                return runtime.sceneGraphService.getRotation(this);\n            }\n        },\n        {\n            key: \"getLocalRotation\",\n            value: function getLocalRotation() {\n                return runtime.sceneGraphService.getLocalRotation(this);\n            }\n        },\n        {\n            key: \"getLocalSkew\",\n            value: function getLocalSkew() {\n                return runtime.sceneGraphService.getLocalSkew(this);\n            }\n        },\n        {\n            key: \"getLocalTransform\",\n            value: function getLocalTransform() {\n                return runtime.sceneGraphService.getLocalTransform(this);\n            }\n        },\n        {\n            key: \"getWorldTransform\",\n            value: function getWorldTransform() {\n                return runtime.sceneGraphService.getWorldTransform(this);\n            }\n        },\n        {\n            key: \"setLocalTransform\",\n            value: function setLocalTransform(transform) {\n                runtime.sceneGraphService.setLocalTransform(this, transform);\n                return this;\n            }\n        },\n        {\n            key: \"resetLocalTransform\",\n            value: function resetLocalTransform() {\n                runtime.sceneGraphService.resetLocalTransform(this);\n            }\n        },\n        {\n            key: \"getAnimations\",\n            value: function getAnimations() {\n                return this.activeAnimations;\n            }\n        },\n        {\n            key: \"animate\",\n            value: function animate(keyframes, options) {\n                var _this$ownerDocument;\n                var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;\n                if (timeline) {\n                    return timeline.play(this, keyframes, options);\n                }\n                return null;\n            }\n        },\n        {\n            key: \"isVisible\",\n            value: function isVisible() {\n                var _this$parsedStyle;\n                return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== \"hidden\";\n            }\n        },\n        {\n            key: \"interactive\",\n            get: function get() {\n                return this.isInteractive();\n            },\n            set: function set(b) {\n                this.style.pointerEvents = b ? \"auto\" : \"none\";\n            }\n        },\n        {\n            key: \"isInteractive\",\n            value: function isInteractive() {\n                var _this$parsedStyle2;\n                return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== \"none\";\n            }\n        },\n        {\n            key: \"isCulled\",\n            value: function isCulled() {\n                return !!(this.cullable && this.cullable.enable && !this.cullable.visible);\n            }\n        },\n        {\n            key: \"toFront\",\n            value: function toFront() {\n                if (this.parentNode) {\n                    this.style.zIndex = Math.max.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(this.parentNode.children.map(function(child) {\n                        return Number(child.style.zIndex);\n                    }))) + 1;\n                }\n                return this;\n            }\n        },\n        {\n            key: \"toBack\",\n            value: function toBack() {\n                if (this.parentNode) {\n                    this.style.zIndex = Math.min.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(this.parentNode.children.map(function(child) {\n                        return Number(child.style.zIndex);\n                    }))) - 1;\n                }\n                return this;\n            }\n        },\n        {\n            key: \"getConfig\",\n            value: function getConfig() {\n                return this.config;\n            }\n        },\n        {\n            key: \"attr\",\n            value: function attr() {\n                var _this2 = this;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                var name = args[0], value = args[1];\n                if (!name) {\n                    return this.attributes;\n                }\n                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_43__[\"default\"])(name)) {\n                    Object.keys(name).forEach(function(key) {\n                        _this2.setAttribute(key, name[key]);\n                    });\n                    return this;\n                }\n                if (args.length === 2) {\n                    this.setAttribute(name, value);\n                    return this;\n                }\n                return this.attributes[name];\n            }\n        },\n        {\n            key: \"getMatrix\",\n            value: function getMatrix(transformMat4) {\n                var transform = transformMat4 || this.getWorldTransform();\n                var _mat4$getTranslation = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getTranslation($vec3, transform), _mat4$getTranslation2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];\n                var _mat4$getScaling = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getScaling($vec3, transform), _mat4$getScaling2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];\n                var rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.getRotation($quat, transform);\n                var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];\n                // gimbal lock at 90 degrees\n                return fromRotationTranslationScale(eux || euz, tx, ty, sx, sy);\n            }\n        },\n        {\n            key: \"getLocalMatrix\",\n            value: function getLocalMatrix() {\n                return this.getMatrix(this.getLocalTransform());\n            }\n        },\n        {\n            key: \"setMatrix\",\n            value: function setMatrix(mat) {\n                var _decompose = decompose(mat), _decompose2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle = _decompose2[4];\n                this.setEulerAngles(angle).setPosition(tx, ty).setLocalScale(scalingX, scalingY);\n            }\n        },\n        {\n            key: \"setLocalMatrix\",\n            value: function setLocalMatrix(mat) {\n                var _decompose3 = decompose(mat), _decompose4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle = _decompose4[4];\n                this.setLocalEulerAngles(angle).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);\n            }\n        },\n        {\n            key: \"show\",\n            value: function show() {\n                this.forEach(function(object) {\n                    object.style.visibility = \"visible\";\n                });\n            }\n        },\n        {\n            key: \"hide\",\n            value: function hide() {\n                this.forEach(function(object) {\n                    object.style.visibility = \"hidden\";\n                });\n            }\n        },\n        {\n            key: \"getCount\",\n            value: function getCount() {\n                return this.childElementCount;\n            }\n        },\n        {\n            key: \"getParent\",\n            value: function getParent() {\n                return this.parentElement;\n            }\n        },\n        {\n            key: \"getChildren\",\n            value: function getChildren() {\n                return this.children;\n            }\n        },\n        {\n            key: \"getFirst\",\n            value: function getFirst() {\n                return this.firstElementChild;\n            }\n        },\n        {\n            key: \"getLast\",\n            value: function getLast() {\n                return this.lastElementChild;\n            }\n        },\n        {\n            key: \"getChildByIndex\",\n            value: function getChildByIndex(index) {\n                return this.children[index] || null;\n            }\n        },\n        {\n            key: \"add\",\n            value: function add(child, index) {\n                return this.appendChild(child, index);\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(name, value) {\n                // @ts-ignore\n                this.config[name] = value;\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(name) {\n                return this.config[name];\n            }\n        },\n        {\n            key: \"moveTo\",\n            value: function moveTo(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                this.setPosition(position, y, z);\n                return this;\n            }\n        },\n        {\n            key: \"move\",\n            value: function move(position) {\n                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                this.setPosition(position, y, z);\n                return this;\n            }\n        },\n        {\n            key: \"setZIndex\",\n            value: function setZIndex(zIndex) {\n                this.style.zIndex = zIndex;\n                return this;\n            }\n        }\n    ]);\n}(Element);\nDisplayObject.PARSED_STYLE_LIST = new Set([\n    \"class\",\n    \"className\",\n    \"clipPath\",\n    \"cursor\",\n    \"display\",\n    \"draggable\",\n    \"droppable\",\n    \"fill\",\n    \"fillOpacity\",\n    \"fillRule\",\n    \"filter\",\n    \"increasedLineWidthForHitTesting\",\n    \"lineCap\",\n    \"lineDash\",\n    \"lineDashOffset\",\n    \"lineJoin\",\n    \"lineWidth\",\n    \"miterLimit\",\n    \"hitArea\",\n    \"offsetDistance\",\n    \"offsetPath\",\n    \"offsetX\",\n    \"offsetY\",\n    \"opacity\",\n    \"pointerEvents\",\n    \"shadowColor\",\n    \"shadowType\",\n    \"shadowBlur\",\n    \"shadowOffsetX\",\n    \"shadowOffsetY\",\n    \"stroke\",\n    \"strokeOpacity\",\n    \"strokeWidth\",\n    \"strokeLinecap\",\n    \"strokeLineJoin\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"transform\",\n    \"transformOrigin\",\n    \"textTransform\",\n    \"visibility\",\n    \"zIndex\"\n]);\nvar Circle = /*#__PURE__*/ function(_DisplayObject) {\n    function Circle() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Circle);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Circle, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.CIRCLE\n            }, options)\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Circle, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Circle);\n}(DisplayObject);\nCircle.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"cx\",\n    \"cy\",\n    \"cz\",\n    \"r\",\n    \"isBillboard\",\n    \"isSizeAttenuation\"\n]));\nvar _excluded$6 = [\n    \"style\"\n];\n/**\n * shadow root\n * @see https://yuque.antfin-inc.com/antv/czqvg5/pgqipg\n */ var CustomElement = /*#__PURE__*/ function(_DisplayObject) {\n    // private shadowNodes: DisplayObject[] = [];\n    function CustomElement() {\n        var _this;\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded$6);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CustomElement);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, CustomElement, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                style: style\n            }, rest)\n        ]);\n        _this.isCustomElement = true;\n        return _this;\n    }\n    /**\n   * fired after element insert into DOM tree\n   */ _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CustomElement, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CustomElement);\n}(DisplayObject);\nCustomElement.PARSED_STYLE_LIST = new Set([\n    \"class\",\n    \"className\",\n    \"clipPath\",\n    \"cursor\",\n    \"draggable\",\n    \"droppable\",\n    \"opacity\",\n    \"pointerEvents\",\n    \"transform\",\n    \"transformOrigin\",\n    \"zIndex\",\n    \"visibility\"\n]);\nvar Ellipse = /*#__PURE__*/ function(_DisplayObject) {\n    function Ellipse() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Ellipse);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Ellipse, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.ELLIPSE\n            }, options)\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Ellipse, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Ellipse);\n}(DisplayObject);\nEllipse.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"cx\",\n    \"cy\",\n    \"cz\",\n    \"rx\",\n    \"ry\",\n    \"isBillboard\",\n    \"isSizeAttenuation\"\n]));\n/**\n * 节点片段，用于包裹多个节点并批量操作\n *\n *  向 Fragment 或者根节点为 Fragment 的节点添加子节点时，不会触发渲染和事件。\n *\n * 当 Fragment 被挂载到 Canvas 中的节点时，其子节点会一次性被渲染，并触发合并事件。\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment\n */ var Fragment = /*#__PURE__*/ function(_DisplayObject) {\n    function Fragment() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Fragment);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Fragment, [\n            {\n                type: Shape.FRAGMENT\n            }\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Fragment, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Fragment);\n}(DisplayObject);\nFragment.PARSED_STYLE_LIST = new Set([\n    \"class\",\n    \"className\"\n]);\n/**\n * its attributes are inherited by its children.\n * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/g\n * \n * @example\n * <g fill=\"white\" stroke=\"green\" stroke-width=\"5\">\n    <circle cx=\"40\" cy=\"40\" r=\"25\" />\n    <circle cx=\"60\" cy=\"60\" r=\"25\" />\n  </g>\n */ var Group = /*#__PURE__*/ function(_DisplayObject) {\n    function Group() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Group);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Group, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.GROUP\n            }, options)\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Group, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Group);\n}(DisplayObject);\nGroup.PARSED_STYLE_LIST = new Set([\n    \"class\",\n    \"className\",\n    \"clipPath\",\n    \"cursor\",\n    \"draggable\",\n    \"droppable\",\n    \"opacity\",\n    \"pointerEvents\",\n    \"transform\",\n    \"transformOrigin\",\n    \"zIndex\",\n    \"visibility\"\n]);\nvar _excluded$5 = [\n    \"style\"\n];\n/**\n * HTML container\n * @see https://github.com/pmndrs/drei#html\n */ var HTML = /*#__PURE__*/ function(_DisplayObject) {\n    function HTML() {\n        var _this;\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded$5);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, HTML);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, HTML, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.HTML,\n                style: style\n            }, rest)\n        ]);\n        _this.cullable.enable = false;\n        return _this;\n    }\n    /**\n   * return wrapper HTMLElement\n   * * <div> in g-webgl/canvas\n   * * <foreignObject> in g-svg\n   */ _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(HTML, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(HTML, [\n        {\n            key: \"getDomElement\",\n            value: function getDomElement() {\n                return this.parsedStyle.$el;\n            }\n        },\n        {\n            key: \"getClientRects\",\n            value: function getClientRects() {\n                return [\n                    this.getBoundingClientRect()\n                ];\n            }\n        },\n        {\n            key: \"getLocalBounds\",\n            value: function getLocalBounds() {\n                if (this.parentNode) {\n                    var parentInvert = gl_matrix__WEBPACK_IMPORTED_MODULE_19__.invert(gl_matrix__WEBPACK_IMPORTED_MODULE_19__.create(), this.parentNode.getWorldTransform());\n                    var bounds = this.getBounds();\n                    if (!AABB.isEmpty(bounds)) {\n                        var localBounds = new AABB();\n                        localBounds.setFromTransformedAABB(bounds, parentInvert);\n                        return localBounds;\n                    }\n                }\n                return this.getBounds();\n            }\n        }\n    ]);\n}(DisplayObject);\nHTML.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"x\",\n    \"y\",\n    \"$el\",\n    \"innerHTML\",\n    \"width\",\n    \"height\"\n]));\nvar Image = /*#__PURE__*/ function(_DisplayObject) {\n    function Image() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Image);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Image, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.IMAGE\n            }, options)\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Image, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Image);\n}(DisplayObject);\nImage.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"x\",\n    \"y\",\n    \"z\",\n    \"src\",\n    \"width\",\n    \"height\",\n    \"isBillboard\",\n    \"billboardRotation\",\n    \"isSizeAttenuation\",\n    \"keepAspectRatio\"\n]));\nvar _excluded$4 = [\n    \"style\"\n];\n/**\n * Create a line connecting two points.\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line\n *\n * Also support for using marker.\n */ var Line = /*#__PURE__*/ function(_DisplayObject) {\n    function Line() {\n        var _this;\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded$4);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Line);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Line, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.LINE,\n                style: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                    x1: 0,\n                    y1: 0,\n                    x2: 0,\n                    y2: 0,\n                    z1: 0,\n                    z2: 0\n                }, style)\n            }, rest)\n        ]);\n        _this.markerStartAngle = 0;\n        _this.markerEndAngle = 0;\n        var _this$parsedStyle = _this.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;\n        if (markerStart && isDisplayObject(markerStart)) {\n            _this.markerStartAngle = markerStart.getLocalEulerAngles();\n            _this.appendChild(markerStart);\n        }\n        if (markerEnd && isDisplayObject(markerEnd)) {\n            _this.markerEndAngle = markerEnd.getLocalEulerAngles();\n            _this.appendChild(markerEnd);\n        }\n        _this.transformMarker(true);\n        _this.transformMarker(false);\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Line, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Line, [\n        {\n            key: \"attributeChangedCallback\",\n            value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {\n                if (attrName === \"x1\" || attrName === \"y1\" || attrName === \"x2\" || attrName === \"y2\" || attrName === \"markerStartOffset\" || attrName === \"markerEndOffset\") {\n                    this.transformMarker(true);\n                    this.transformMarker(false);\n                } else if (attrName === \"markerStart\") {\n                    if (prevParsedValue && isDisplayObject(prevParsedValue)) {\n                        this.markerStartAngle = 0;\n                        prevParsedValue.remove();\n                    }\n                    // CSSKeyword 'unset'\n                    if (newParsedValue && isDisplayObject(newParsedValue)) {\n                        this.markerStartAngle = newParsedValue.getLocalEulerAngles();\n                        this.appendChild(newParsedValue);\n                        this.transformMarker(true);\n                    }\n                } else if (attrName === \"markerEnd\") {\n                    if (prevParsedValue && isDisplayObject(prevParsedValue)) {\n                        this.markerEndAngle = 0;\n                        prevParsedValue.remove();\n                    }\n                    if (newParsedValue && isDisplayObject(newParsedValue)) {\n                        this.markerEndAngle = newParsedValue.getLocalEulerAngles();\n                        this.appendChild(newParsedValue);\n                        this.transformMarker(false);\n                    }\n                }\n            }\n        },\n        {\n            key: \"transformMarker\",\n            value: function transformMarker(isStart) {\n                var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x2 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y2 = _this$parsedStyle2.y2;\n                var marker = isStart ? markerStart : markerEnd;\n                if (!marker || !isDisplayObject(marker)) {\n                    return;\n                }\n                var rad = 0;\n                var x;\n                var y;\n                var ox;\n                var oy;\n                var offset;\n                var originalAngle;\n                if (isStart) {\n                    ox = x1;\n                    oy = y1;\n                    x = x2 - x1;\n                    y = y2 - y1;\n                    offset = markerStartOffset || 0;\n                    originalAngle = this.markerStartAngle;\n                } else {\n                    ox = x2;\n                    oy = y2;\n                    x = x1 - x2;\n                    y = y1 - y2;\n                    offset = markerEndOffset || 0;\n                    originalAngle = this.markerEndAngle;\n                }\n                rad = Math.atan2(y, x);\n                // account for markerOffset\n                marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);\n                marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);\n            }\n        },\n        {\n            key: \"getPoint\",\n            value: function getPoint(ratio) {\n                var inWorldSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                // TODO: account for z1/z2 in 3D line\n                var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x2 = _this$parsedStyle3.x2, y2 = _this$parsedStyle3.y2;\n                var _linePointAt = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.linePointAt)(x1, y1, x2, y2, ratio), x = _linePointAt.x, y = _linePointAt.y;\n                var transformed = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(x, y, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());\n                // apply local transformation\n                return new Point(transformed[0], transformed[1]);\n            }\n        },\n        {\n            key: \"getPointAtLength\",\n            value: function getPointAtLength(distance) {\n                var inWorldSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                return this.getPoint(distance / this.getTotalLength(), inWorldSpace);\n            }\n        },\n        {\n            key: \"getTotalLength\",\n            value: function getTotalLength() {\n                // TODO: account for z1/z2 in 3D line\n                var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x2 = _this$parsedStyle4.x2, y2 = _this$parsedStyle4.y2;\n                return (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.lineLength)(x1, y1, x2, y2);\n            }\n        }\n    ]);\n}(DisplayObject);\nLine.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"x1\",\n    \"y1\",\n    \"x2\",\n    \"y2\",\n    \"z1\",\n    \"z2\",\n    \"isBillboard\",\n    \"isSizeAttenuation\",\n    \"markerStart\",\n    \"markerEnd\",\n    \"markerStartOffset\",\n    \"markerEndOffset\"\n]));\nvar _excluded$3 = [\n    \"style\"\n];\nvar Path = /*#__PURE__*/ function(_DisplayObject) {\n    function Path() {\n        var _this;\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded$3);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Path);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Path, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.PATH,\n                style: style,\n                initialParsedStyle: {\n                    miterLimit: 4,\n                    d: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, EMPTY_PARSED_PATH)\n                }\n            }, rest)\n        ]);\n        _this.markerStartAngle = 0;\n        _this.markerEndAngle = 0;\n        /**\n     * markers placed at the mid\n     */ _this.markerMidList = [];\n        var _this$parsedStyle = _this.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;\n        if (markerStart && isDisplayObject(markerStart)) {\n            _this.markerStartAngle = markerStart.getLocalEulerAngles();\n            _this.appendChild(markerStart);\n        }\n        if (markerMid && isDisplayObject(markerMid)) {\n            _this.placeMarkerMid(markerMid);\n        }\n        if (markerEnd && isDisplayObject(markerEnd)) {\n            _this.markerEndAngle = markerEnd.getLocalEulerAngles();\n            _this.appendChild(markerEnd);\n        }\n        _this.transformMarker(true);\n        _this.transformMarker(false);\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Path, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Path, [\n        {\n            key: \"attributeChangedCallback\",\n            value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {\n                if (attrName === \"d\") {\n                    // recalc markers\n                    this.transformMarker(true);\n                    this.transformMarker(false);\n                    this.placeMarkerMid(this.parsedStyle.markerMid);\n                } else if (attrName === \"markerStartOffset\" || attrName === \"markerEndOffset\") {\n                    this.transformMarker(true);\n                    this.transformMarker(false);\n                } else if (attrName === \"markerStart\") {\n                    if (prevParsedValue && isDisplayObject(prevParsedValue)) {\n                        this.markerStartAngle = 0;\n                        prevParsedValue.remove();\n                    }\n                    // CSSKeyword 'unset'\n                    if (newParsedValue && isDisplayObject(newParsedValue)) {\n                        this.markerStartAngle = newParsedValue.getLocalEulerAngles();\n                        this.appendChild(newParsedValue);\n                        this.transformMarker(true);\n                    }\n                } else if (attrName === \"markerEnd\") {\n                    if (prevParsedValue && isDisplayObject(prevParsedValue)) {\n                        this.markerEndAngle = 0;\n                        prevParsedValue.remove();\n                    }\n                    if (newParsedValue && isDisplayObject(newParsedValue)) {\n                        this.markerEndAngle = newParsedValue.getLocalEulerAngles();\n                        this.appendChild(newParsedValue);\n                        this.transformMarker(false);\n                    }\n                } else if (attrName === \"markerMid\") {\n                    this.placeMarkerMid(newParsedValue);\n                }\n            }\n        },\n        {\n            key: \"transformMarker\",\n            value: function transformMarker(isStart) {\n                var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;\n                var marker = isStart ? markerStart : markerEnd;\n                if (!marker || !isDisplayObject(marker)) {\n                    return;\n                }\n                var rad = 0;\n                var x;\n                var y;\n                var ox;\n                var oy;\n                var offset;\n                var originalAngle;\n                if (isStart) {\n                    var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];\n                    ox = p2[0];\n                    oy = p2[1];\n                    x = p1[0] - p2[0];\n                    y = p1[1] - p2[1];\n                    offset = markerStartOffset || 0;\n                    originalAngle = this.markerStartAngle;\n                } else {\n                    var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];\n                    ox = _p2[0];\n                    oy = _p2[1];\n                    x = _p[0] - _p2[0];\n                    y = _p[1] - _p2[1];\n                    offset = markerEndOffset || 0;\n                    originalAngle = this.markerEndAngle;\n                }\n                rad = Math.atan2(y, x);\n                // account for markerOffset\n                marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);\n                marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);\n            }\n        },\n        {\n            key: \"placeMarkerMid\",\n            value: function placeMarkerMid(marker) {\n                var segments = this.parsedStyle.d.segments;\n                // clear all existed markers\n                this.markerMidList.forEach(function(marker) {\n                    marker.remove();\n                });\n                if (marker && isDisplayObject(marker)) {\n                    for(var i = 1; i < segments.length - 1; i++){\n                        var _segments$i$currentPo = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(segments[i].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];\n                        var cloned = i === 1 ? marker : marker.cloneNode(true);\n                        this.markerMidList.push(cloned);\n                        this.appendChild(cloned);\n                        cloned.setLocalPosition(ox, oy);\n                    // TODO: orient of marker\n                    }\n                }\n            }\n        },\n        {\n            key: \"getTotalLength\",\n            value: function getTotalLength() {\n                return getOrCalculatePathTotalLength(this);\n            }\n        },\n        {\n            key: \"getPointAtLength\",\n            value: function getPointAtLength$1(distance) {\n                var inWorldSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var absolutePath = this.parsedStyle.d.absolutePath;\n                var _getPointAtLength2 = (0,_antv_util__WEBPACK_IMPORTED_MODULE_44__.getPointAtLength)(absolutePath, distance), x = _getPointAtLength2.x, y = _getPointAtLength2.y;\n                var transformed = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(x, y, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());\n                // apply local transformation\n                return new Point(transformed[0], transformed[1]);\n            }\n        },\n        {\n            key: \"getPoint\",\n            value: function getPoint(ratio) {\n                var inWorldSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);\n            }\n        },\n        {\n            key: \"getStartTangent\",\n            value: function getStartTangent() {\n                var segments = this.parsedStyle.d.segments;\n                var result = [];\n                if (segments.length > 1) {\n                    var startPoint = segments[0].currentPoint;\n                    var endPoint = segments[1].currentPoint;\n                    var tangent = segments[1].startTangent;\n                    result = [];\n                    if (tangent) {\n                        result.push([\n                            startPoint[0] - tangent[0],\n                            startPoint[1] - tangent[1]\n                        ]);\n                        result.push([\n                            startPoint[0],\n                            startPoint[1]\n                        ]);\n                    } else {\n                        result.push([\n                            endPoint[0],\n                            endPoint[1]\n                        ]);\n                        result.push([\n                            startPoint[0],\n                            startPoint[1]\n                        ]);\n                    }\n                }\n                return result;\n            }\n        },\n        {\n            key: \"getEndTangent\",\n            value: function getEndTangent() {\n                var segments = this.parsedStyle.d.segments;\n                var length = segments.length;\n                var result = [];\n                if (length > 1) {\n                    var startPoint = segments[length - 2].currentPoint;\n                    var endPoint = segments[length - 1].currentPoint;\n                    var tangent = segments[length - 1].endTangent;\n                    result = [];\n                    if (tangent) {\n                        result.push([\n                            endPoint[0] - tangent[0],\n                            endPoint[1] - tangent[1]\n                        ]);\n                        result.push([\n                            endPoint[0],\n                            endPoint[1]\n                        ]);\n                    } else {\n                        result.push([\n                            startPoint[0],\n                            startPoint[1]\n                        ]);\n                        result.push([\n                            endPoint[0],\n                            endPoint[1]\n                        ]);\n                    }\n                }\n                return result;\n            }\n        }\n    ]);\n}(DisplayObject);\nPath.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"d\",\n    \"markerStart\",\n    \"markerMid\",\n    \"markerEnd\",\n    \"markerStartOffset\",\n    \"markerEndOffset\",\n    \"isBillboard\",\n    \"isSizeAttenuation\"\n]));\nvar _excluded$2 = [\n    \"style\"\n];\nvar Polygon = /*#__PURE__*/ function(_DisplayObject) {\n    function Polygon() {\n        var _this;\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded$2);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Polygon);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Polygon, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.POLYGON,\n                style: style,\n                initialParsedStyle: {\n                    points: {\n                        points: [],\n                        totalLength: 0,\n                        segments: []\n                    },\n                    miterLimit: 4,\n                    isClosed: true\n                }\n            }, rest)\n        ]);\n        _this.markerStartAngle = 0;\n        _this.markerEndAngle = 0;\n        /**\n     * markers placed at the mid\n     */ _this.markerMidList = [];\n        var _this$parsedStyle = _this.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;\n        if (markerStart && isDisplayObject(markerStart)) {\n            _this.markerStartAngle = markerStart.getLocalEulerAngles();\n            _this.appendChild(markerStart);\n        }\n        if (markerMid && isDisplayObject(markerMid)) {\n            _this.placeMarkerMid(markerMid);\n        }\n        if (markerEnd && isDisplayObject(markerEnd)) {\n            _this.markerEndAngle = markerEnd.getLocalEulerAngles();\n            _this.appendChild(markerEnd);\n        }\n        _this.transformMarker(true);\n        _this.transformMarker(false);\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Polygon, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Polygon, [\n        {\n            key: \"attributeChangedCallback\",\n            value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {\n                if (attrName === \"points\") {\n                    // recalc markers\n                    this.transformMarker(true);\n                    this.transformMarker(false);\n                    this.placeMarkerMid(this.parsedStyle.markerMid);\n                } else if (attrName === \"markerStartOffset\" || attrName === \"markerEndOffset\") {\n                    this.transformMarker(true);\n                    this.transformMarker(false);\n                } else if (attrName === \"markerStart\") {\n                    if (prevParsedValue && isDisplayObject(prevParsedValue)) {\n                        this.markerStartAngle = 0;\n                        prevParsedValue.remove();\n                    }\n                    // CSSKeyword 'unset'\n                    if (newParsedValue && isDisplayObject(newParsedValue)) {\n                        this.markerStartAngle = newParsedValue.getLocalEulerAngles();\n                        this.appendChild(newParsedValue);\n                        this.transformMarker(true);\n                    }\n                } else if (attrName === \"markerEnd\") {\n                    if (prevParsedValue && isDisplayObject(prevParsedValue)) {\n                        this.markerEndAngle = 0;\n                        prevParsedValue.remove();\n                    }\n                    if (newParsedValue && isDisplayObject(newParsedValue)) {\n                        this.markerEndAngle = newParsedValue.getLocalEulerAngles();\n                        this.appendChild(newParsedValue);\n                        this.transformMarker(false);\n                    }\n                } else if (attrName === \"markerMid\") {\n                    this.placeMarkerMid(newParsedValue);\n                }\n            }\n        },\n        {\n            key: \"transformMarker\",\n            value: function transformMarker(isStart) {\n                var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;\n                var _ref2 = P || {}, points = _ref2.points;\n                var marker = isStart ? markerStart : markerEnd;\n                if (!marker || !isDisplayObject(marker) || !points) {\n                    return;\n                }\n                var rad = 0;\n                var x;\n                var y;\n                var ox;\n                var oy;\n                var offset;\n                var originalAngle;\n                ox = points[0][0];\n                oy = points[0][1];\n                if (isStart) {\n                    x = points[1][0] - points[0][0];\n                    y = points[1][1] - points[0][1];\n                    offset = markerStartOffset || 0;\n                    originalAngle = this.markerStartAngle;\n                } else {\n                    var length = points.length;\n                    if (!this.parsedStyle.isClosed) {\n                        ox = points[length - 1][0];\n                        oy = points[length - 1][1];\n                        x = points[length - 2][0] - points[length - 1][0];\n                        y = points[length - 2][1] - points[length - 1][1];\n                    } else {\n                        x = points[length - 1][0] - points[0][0];\n                        y = points[length - 1][1] - points[0][1];\n                    }\n                    offset = markerEndOffset || 0;\n                    originalAngle = this.markerEndAngle;\n                }\n                rad = Math.atan2(y, x);\n                // account for markerOffset\n                marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);\n                marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);\n            }\n        },\n        {\n            key: \"placeMarkerMid\",\n            value: function placeMarkerMid(marker) {\n                var P = this.parsedStyle.points;\n                var _ref3 = P || {}, points = _ref3.points;\n                // clear all existed markers\n                this.markerMidList.forEach(function(marker) {\n                    marker.remove();\n                });\n                this.markerMidList = [];\n                if (marker && isDisplayObject(marker) && points) {\n                    for(var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++){\n                        var ox = points[i][0];\n                        var oy = points[i][1];\n                        var cloned = i === 1 ? marker : marker.cloneNode(true);\n                        this.markerMidList.push(cloned);\n                        this.appendChild(cloned);\n                        cloned.setLocalPosition(ox, oy);\n                    // TODO: orient of marker\n                    }\n                }\n            }\n        }\n    ]);\n}(DisplayObject);\nPolygon.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"points\",\n    \"markerStart\",\n    \"markerMid\",\n    \"markerEnd\",\n    \"markerStartOffset\",\n    \"markerEndOffset\",\n    \"isClosed\",\n    \"isBillboard\",\n    \"isSizeAttenuation\"\n]));\nvar _excluded$1 = [\n    \"style\"\n];\n/**\n * Polyline inherits the marker-related capabilities of Polygon.\n */ var Polyline = /*#__PURE__*/ function(_Polygon) {\n    function Polyline() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded$1);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Polyline);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Polyline, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.POLYLINE,\n                style: style,\n                initialParsedStyle: {\n                    points: {\n                        points: [],\n                        totalLength: 0,\n                        segments: []\n                    },\n                    miterLimit: 4,\n                    isClosed: false\n                }\n            }, rest)\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Polyline, _Polygon);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Polyline, [\n        {\n            key: \"getTotalLength\",\n            value: function getTotalLength() {\n                return getOrCalculatePolylineTotalLength(this);\n            }\n        },\n        {\n            key: \"getPointAtLength\",\n            value: function getPointAtLength(distance) {\n                var inWorldSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                return this.getPoint(distance / this.getTotalLength(), inWorldSpace);\n            }\n        },\n        {\n            key: \"getPoint\",\n            value: function getPoint(ratio) {\n                var inWorldSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var points = this.parsedStyle.points.points;\n                if (this.parsedStyle.points.segments.length === 0) {\n                    var segments = [];\n                    var tempLength = 0;\n                    var segmentT;\n                    var segmentL;\n                    var totalLength = this.getTotalLength();\n                    points.forEach(function(p, i) {\n                        if (points[i + 1]) {\n                            segmentT = [\n                                0,\n                                0\n                            ];\n                            segmentT[0] = tempLength / totalLength;\n                            segmentL = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.lineLength)(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n                            tempLength += segmentL;\n                            segmentT[1] = tempLength / totalLength;\n                            segments.push(segmentT);\n                        }\n                    });\n                    this.parsedStyle.points.segments = segments;\n                }\n                var subt = 0;\n                var index = 0;\n                this.parsedStyle.points.segments.forEach(function(v, i) {\n                    if (ratio >= v[0] && ratio <= v[1]) {\n                        subt = (ratio - v[0]) / (v[1] - v[0]);\n                        index = i;\n                    }\n                });\n                var _linePointAt = (0,_antv_g_math__WEBPACK_IMPORTED_MODULE_11__.linePointAt)(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt), x = _linePointAt.x, y = _linePointAt.y;\n                var transformed = gl_matrix__WEBPACK_IMPORTED_MODULE_16__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_16__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_16__.fromValues(x, y, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());\n                // apply local transformation\n                return new Point(transformed[0], transformed[1]);\n            }\n        },\n        {\n            key: \"getStartTangent\",\n            value: function getStartTangent() {\n                var points = this.parsedStyle.points.points;\n                var result = [];\n                result.push([\n                    points[1][0],\n                    points[1][1]\n                ]);\n                result.push([\n                    points[0][0],\n                    points[0][1]\n                ]);\n                return result;\n            }\n        },\n        {\n            key: \"getEndTangent\",\n            value: function getEndTangent() {\n                var points = this.parsedStyle.points.points;\n                var l = points.length - 1;\n                var result = [];\n                result.push([\n                    points[l - 1][0],\n                    points[l - 1][1]\n                ]);\n                result.push([\n                    points[l][0],\n                    points[l][1]\n                ]);\n                return result;\n            }\n        }\n    ]);\n}(Polygon);\nPolyline.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(Polygon.PARSED_STYLE_LIST), [\n    \"points\",\n    \"markerStart\",\n    \"markerMid\",\n    \"markerEnd\",\n    \"markerStartOffset\",\n    \"markerEndOffset\",\n    \"isBillboard\"\n]));\nvar Rect = /*#__PURE__*/ function(_DisplayObject) {\n    function Rect() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Rect);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Rect, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.RECT\n            }, options)\n        ]);\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Rect, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Rect);\n}(DisplayObject);\nRect.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"x\",\n    \"y\",\n    \"z\",\n    \"width\",\n    \"height\",\n    \"isBillboard\",\n    \"isSizeAttenuation\",\n    \"radius\"\n]));\nvar _excluded = [\n    \"style\"\n];\n/**\n * <text> @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextElement\n */ var Text = /*#__PURE__*/ function(_DisplayObject) {\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement#constants\n   */ // LENGTHADJUST_SPACING: number = 1;\n    // LENGTHADJUST_SPACINGANDGLYPHS: number = 2;\n    // LENGTHADJUST_UNKNOWN: number = 0;\n    function Text() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, style = _ref.style, rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_15___default()(_ref, _excluded);\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Text);\n        return _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Text, [\n            _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                type: Shape.TEXT,\n                style: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                    fill: \"black\"\n                }, style)\n            }, rest)\n        ]);\n    }\n    /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement\n   */ _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Text, _DisplayObject);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Text, [\n        {\n            key: \"getComputedTextLength\",\n            value: function getComputedTextLength() {\n                var _this$parsedStyle$met;\n                this.getGeometryBounds();\n                return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;\n            }\n        },\n        {\n            key: \"getLineBoundingRects\",\n            value: function getLineBoundingRects() {\n                var _this$parsedStyle$met2;\n                this.getGeometryBounds();\n                return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];\n            }\n        },\n        {\n            key: \"isOverflowing\",\n            value: function isOverflowing() {\n                this.getGeometryBounds();\n                return !!this.parsedStyle.isOverflowing;\n            }\n        }\n    ]);\n}(DisplayObject);\nText.PARSED_STYLE_LIST = new Set([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(DisplayObject.PARSED_STYLE_LIST), [\n    \"x\",\n    \"y\",\n    \"z\",\n    \"isBillboard\",\n    \"billboardRotation\",\n    \"isSizeAttenuation\",\n    \"text\",\n    \"textAlign\",\n    \"textBaseline\",\n    \"fontStyle\",\n    \"fontSize\",\n    \"fontFamily\",\n    \"fontWeight\",\n    \"fontVariant\",\n    \"lineHeight\",\n    \"letterSpacing\",\n    \"leading\",\n    \"wordWrap\",\n    \"wordWrapWidth\",\n    \"maxLines\",\n    \"textOverflow\",\n    \"isOverflowing\",\n    \"textPath\",\n    \"textDecorationLine\",\n    \"textDecorationColor\",\n    \"textDecorationStyle\",\n    \"textPathSide\",\n    \"textPathStartOffset\",\n    \"metrics\",\n    \"dx\",\n    \"dy\"\n]));\n/**\n * canvas.customElements\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry\n */ var CustomElementRegistry = /*#__PURE__*/ function() {\n    function CustomElementRegistry() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CustomElementRegistry);\n        this.registry = {};\n        this.define(Shape.CIRCLE, Circle);\n        this.define(Shape.ELLIPSE, Ellipse);\n        this.define(Shape.RECT, Rect);\n        this.define(Shape.IMAGE, Image);\n        this.define(Shape.LINE, Line);\n        this.define(Shape.GROUP, Group);\n        this.define(Shape.PATH, Path);\n        this.define(Shape.POLYGON, Polygon);\n        this.define(Shape.POLYLINE, Polyline);\n        this.define(Shape.TEXT, Text);\n        this.define(Shape.HTML, HTML);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CustomElementRegistry, [\n        {\n            key: \"define\",\n            value: function define(name, constructor) {\n                this.registry[name] = constructor;\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(name) {\n                return this.registry[name];\n            }\n        }\n    ]);\n}();\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty#parameters\n */ /**\n * holds useful CSS-related methods.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS\n *\n * * CSS Typed OM @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/factory_functions\n * * register property @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty\n * * CSS Layout API\n */ var CSS = {\n    /**\n   * <number>\n   * @see https://drafts.csswg.org/css-values-4/#number-value\n   */ number: function number(n) {\n        return new CSSUnitValue(n);\n    },\n    /**\n   * <percentage>\n   * @see https://drafts.csswg.org/css-values-4/#percentage-value\n   */ percent: function percent(n) {\n        return new CSSUnitValue(n, \"%\");\n    },\n    /**\n   * <length>\n   */ px: function px(n) {\n        return new CSSUnitValue(n, \"px\");\n    },\n    /**\n   * <length>\n   */ em: function em(n) {\n        return new CSSUnitValue(n, \"em\");\n    },\n    rem: function rem(n) {\n        return new CSSUnitValue(n, \"rem\");\n    },\n    /**\n   * <angle>\n   */ deg: function deg(n) {\n        return new CSSUnitValue(n, \"deg\");\n    },\n    /**\n   * <angle>\n   */ grad: function grad(n) {\n        return new CSSUnitValue(n, \"grad\");\n    },\n    /**\n   * <angle>\n   */ rad: function rad(n) {\n        return new CSSUnitValue(n, \"rad\");\n    },\n    /**\n   * <angle>\n   */ turn: function turn(n) {\n        return new CSSUnitValue(n, \"turn\");\n    },\n    /**\n   * <time>\n   */ s: function s(n) {\n        return new CSSUnitValue(n, \"s\");\n    },\n    /**\n   * <time>\n   */ ms: function ms(n) {\n        return new CSSUnitValue(n, \"ms\");\n    },\n    /**\n   * CSS Properties & Values API\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API\n   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty\n   */ registerProperty: function registerProperty(definition) {\n        var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;\n        runtime.styleValueRegistry.registerMetadata({\n            n: name,\n            inh: inherits,\n            \"int\": interpolable,\n            d: initialValue,\n            syntax: syntax\n        });\n    },\n    /**\n   * CSS Layout API\n   * register layout\n   *\n   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md\n   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api\n   */ registerLayout: function registerLayout(name, clazz) {\n        runtime.layoutRegistry.registerLayout(name, clazz);\n    }\n};\n/**\n * the entry of DOM tree\n * Document -> Node -> EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document\n */ var Document = /*#__PURE__*/ function(_Node) {\n    function Document() {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Document);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Document);\n        /**\n     * only document has defaultView, points to canvas,\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView\n     */ _this.defaultView = null;\n        _this.ownerDocument = null;\n        _this.nodeName = \"document\";\n        // create timeline\n        try {\n            _this.timeline = new runtime.AnimationTimeline(_this);\n        } catch (_unused) {}\n        /**\n     * for inherited properties, the initial value is used on the root element only,\n     * as long as no specified value is supplied.\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial_value\n     */ var initialStyle = {};\n        BUILT_IN_PROPERTIES.forEach(function(_ref) {\n            var n = _ref.n, inh = _ref.inh, d = _ref.d;\n            if (inh && d) {\n                initialStyle[n] = (0,_antv_util__WEBPACK_IMPORTED_MODULE_41__[\"default\"])(d) ? d(Shape.GROUP) : d;\n            }\n        });\n        // like <html> in DOM tree\n        _this.documentElement = new Group({\n            id: \"g-root\",\n            style: initialStyle\n        });\n        _this.documentElement.ownerDocument = _this;\n        _this.documentElement.parentNode = _this;\n        _this.childNodes = [\n            _this.documentElement\n        ];\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Document, _Node);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Document, [\n        {\n            key: \"children\",\n            get: function get() {\n                return this.childNodes;\n            }\n        },\n        {\n            key: \"childElementCount\",\n            get: function get() {\n                return this.childNodes.length;\n            }\n        },\n        {\n            key: \"firstElementChild\",\n            get: function get() {\n                return this.firstChild;\n            }\n        },\n        {\n            key: \"lastElementChild\",\n            get: function get() {\n                return this.lastChild;\n            }\n        },\n        {\n            key: \"createElement\",\n            value: /**\n     * @example const circle = document.createElement('circle', { style: { r: 10 } });\n     */ function createElement(tagName, options) {\n                // @observablehq/plot will create <svg>\n                if (tagName === \"svg\") {\n                    return this.documentElement;\n                }\n                // d3 will use <tspan>\n                var clazz = this.defaultView.customElements.get(tagName);\n                if (!clazz) {\n                    console.warn(\"Unsupported tagName: \", tagName);\n                    clazz = tagName === \"tspan\" ? Text : Group;\n                }\n                var shape = new clazz(options);\n                shape.ownerDocument = this;\n                return shape;\n            }\n        },\n        {\n            key: \"createElementNS\",\n            value: function createElementNS(namespaceURI, tagName, options) {\n                return this.createElement(tagName, options);\n            }\n        },\n        {\n            key: \"cloneNode\",\n            value: function cloneNode(deep) {\n                throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                try {\n                    this.documentElement.destroyChildren();\n                    this.timeline.destroy();\n                } catch (_unused2) {}\n            }\n        },\n        {\n            key: \"elementsFromBBox\",\n            value: function elementsFromBBox(minX, minY, maxX, maxY) {\n                var rBush = this.defaultView.context.rBushRoot;\n                var rBushNodes = rBush.search({\n                    minX: minX,\n                    minY: minY,\n                    maxX: maxX,\n                    maxY: maxY\n                });\n                var hitTestList = [];\n                rBushNodes.forEach(function(_ref2) {\n                    var displayObject = _ref2.displayObject;\n                    var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? \"auto\" : _displayObject$parsed;\n                    // account for `visibility`\n                    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n                    var isVisibilityAffected = [\n                        \"auto\",\n                        \"visiblepainted\",\n                        \"visiblefill\",\n                        \"visiblestroke\",\n                        \"visible\"\n                    ].includes(pointerEvents);\n                    if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {\n                        hitTestList.push(displayObject);\n                    }\n                });\n                // find group with max z-index\n                hitTestList.sort(function(a, b) {\n                    return b.sortable.renderOrder - a.sortable.renderOrder;\n                });\n                return hitTestList;\n            }\n        },\n        {\n            key: \"elementFromPointSync\",\n            value: function elementFromPointSync(x, y) {\n                var _this$defaultView$can = this.defaultView.canvas2Viewport({\n                    x: x,\n                    y: y\n                }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;\n                var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;\n                // outside canvas' viewport\n                if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {\n                    return null;\n                }\n                var _this$defaultView$vie = this.defaultView.viewport2Client({\n                    x: viewportX,\n                    y: viewportY\n                }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;\n                var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({\n                    topmost: true,\n                    position: {\n                        x: x,\n                        y: y,\n                        viewportX: viewportX,\n                        viewportY: viewportY,\n                        clientX: clientX,\n                        clientY: clientY\n                    },\n                    picked: []\n                }), picked = _this$defaultView$get2.picked;\n                return picked && picked[0] || this.documentElement;\n            }\n        },\n        {\n            key: \"elementFromPoint\",\n            value: function() {\n                var _elementFromPoint = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_13___default()(/*#__PURE__*/ _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default()().mark(function _callee(x, y) {\n                    var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;\n                    return _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default()().wrap(function _callee$(_context) {\n                        while(1)switch(_context.prev = _context.next){\n                            case 0:\n                                _this$defaultView$can2 = this.defaultView.canvas2Viewport({\n                                    x: x,\n                                    y: y\n                                }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;\n                                _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height; // outside canvas' viewport\n                                if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {\n                                    _context.next = 4;\n                                    break;\n                                }\n                                return _context.abrupt(\"return\", null);\n                            case 4:\n                                _this$defaultView$vie2 = this.defaultView.viewport2Client({\n                                    x: viewportX,\n                                    y: viewportY\n                                }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;\n                                _context.next = 7;\n                                return this.defaultView.getRenderingService().hooks.pick.promise({\n                                    topmost: true,\n                                    position: {\n                                        x: x,\n                                        y: y,\n                                        viewportX: viewportX,\n                                        viewportY: viewportY,\n                                        clientX: clientX,\n                                        clientY: clientY\n                                    },\n                                    picked: []\n                                });\n                            case 7:\n                                _yield$this$defaultVi = _context.sent;\n                                picked = _yield$this$defaultVi.picked;\n                                return _context.abrupt(\"return\", picked && picked[0] || this.documentElement);\n                            case 10:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }, _callee, this);\n                }));\n                function elementFromPoint(_x, _x2) {\n                    return _elementFromPoint.apply(this, arguments);\n                }\n                return elementFromPoint;\n            }()\n        },\n        {\n            key: \"elementsFromPointSync\",\n            value: function elementsFromPointSync(x, y) {\n                var _this$defaultView$can3 = this.defaultView.canvas2Viewport({\n                    x: x,\n                    y: y\n                }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;\n                var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;\n                // outside canvas' viewport\n                if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {\n                    return [];\n                }\n                var _this$defaultView$vie3 = this.defaultView.viewport2Client({\n                    x: viewportX,\n                    y: viewportY\n                }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;\n                var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({\n                    topmost: false,\n                    position: {\n                        x: x,\n                        y: y,\n                        viewportX: viewportX,\n                        viewportY: viewportY,\n                        clientX: clientX,\n                        clientY: clientY\n                    },\n                    picked: []\n                }), picked = _this$defaultView$get5.picked;\n                if (picked[picked.length - 1] !== this.documentElement) {\n                    picked.push(this.documentElement);\n                }\n                return picked;\n            }\n        },\n        {\n            key: \"elementsFromPoint\",\n            value: function() {\n                var _elementsFromPoint = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_13___default()(/*#__PURE__*/ _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default()().mark(function _callee2(x, y) {\n                    var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;\n                    return _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_12___default()().wrap(function _callee2$(_context2) {\n                        while(1)switch(_context2.prev = _context2.next){\n                            case 0:\n                                _this$defaultView$can4 = this.defaultView.canvas2Viewport({\n                                    x: x,\n                                    y: y\n                                }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;\n                                _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height; // outside canvas' viewport\n                                if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {\n                                    _context2.next = 4;\n                                    break;\n                                }\n                                return _context2.abrupt(\"return\", []);\n                            case 4:\n                                _this$defaultView$vie4 = this.defaultView.viewport2Client({\n                                    x: viewportX,\n                                    y: viewportY\n                                }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;\n                                _context2.next = 7;\n                                return this.defaultView.getRenderingService().hooks.pick.promise({\n                                    topmost: false,\n                                    position: {\n                                        x: x,\n                                        y: y,\n                                        viewportX: viewportX,\n                                        viewportY: viewportY,\n                                        clientX: clientX,\n                                        clientY: clientY\n                                    },\n                                    picked: []\n                                });\n                            case 7:\n                                _yield$this$defaultVi2 = _context2.sent;\n                                picked = _yield$this$defaultVi2.picked;\n                                if (picked[picked.length - 1] !== this.documentElement) {\n                                    picked.push(this.documentElement);\n                                }\n                                return _context2.abrupt(\"return\", picked);\n                            case 11:\n                            case \"end\":\n                                return _context2.stop();\n                        }\n                    }, _callee2, this);\n                }));\n                function elementsFromPoint(_x3, _x4) {\n                    return _elementsFromPoint.apply(this, arguments);\n                }\n                return elementsFromPoint;\n            }()\n        },\n        {\n            key: \"appendChild\",\n            value: function appendChild(newChild, index) {\n                throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);\n            }\n        },\n        {\n            key: \"insertBefore\",\n            value: function insertBefore(newChild, refChild) {\n                throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);\n            }\n        },\n        {\n            key: \"removeChild\",\n            value: function removeChild(oldChild, destroy) {\n                throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);\n            }\n        },\n        {\n            key: \"replaceChild\",\n            value: function replaceChild(newChild, oldChild, destroy) {\n                throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);\n            }\n        },\n        {\n            key: \"append\",\n            value: function append() {\n                throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);\n            }\n        },\n        {\n            key: \"prepend\",\n            value: function prepend() {\n                throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);\n            }\n        },\n        {\n            key: \"getElementById\",\n            value: function getElementById(id) {\n                return this.documentElement.getElementById(id);\n            }\n        },\n        {\n            key: \"getElementsByName\",\n            value: function getElementsByName(name) {\n                return this.documentElement.getElementsByName(name);\n            }\n        },\n        {\n            key: \"getElementsByTagName\",\n            value: function getElementsByTagName(tagName) {\n                return this.documentElement.getElementsByTagName(tagName);\n            }\n        },\n        {\n            key: \"getElementsByClassName\",\n            value: function getElementsByClassName(className) {\n                return this.documentElement.getElementsByClassName(className);\n            }\n        },\n        {\n            key: \"querySelector\",\n            value: function querySelector(selectors) {\n                return this.documentElement.querySelector(selectors);\n            }\n        },\n        {\n            key: \"querySelectorAll\",\n            value: function querySelectorAll(selectors) {\n                return this.documentElement.querySelectorAll(selectors);\n            }\n        },\n        {\n            key: \"find\",\n            value: function find(filter) {\n                return this.documentElement.find(filter);\n            }\n        },\n        {\n            key: \"findAll\",\n            value: function findAll(filter) {\n                return this.documentElement.findAll(filter);\n            }\n        }\n    ]);\n}(Node);\n/**\n * apply following rules:\n * 1. `visibility` in scenegraph node\n * 2. other custom culling strategies, eg. frustum culling\n */ var CullingPlugin = /*#__PURE__*/ function() {\n    function CullingPlugin(strategies) {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CullingPlugin);\n        this.strategies = strategies;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CullingPlugin, [\n        {\n            key: \"apply\",\n            value: function apply(context) {\n                var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;\n                var strategies = this.strategies;\n                renderingService.hooks.cull.tap(CullingPlugin.tag, function(object) {\n                    if (object) {\n                        var cullable = object.cullable;\n                        // cullable.visible = true;\n                        // const renderBounds = object.getRenderBounds();\n                        // if (AABB.isEmpty(renderBounds)) {\n                        //   cullable.visible = false;\n                        // } else {\n                        //   const isShape2D = shape2D.indexOf(object.nodeName as Shape) > -1;\n                        //   const [p0, p1, p2, p3] = camera.getFrustum().planes;\n                        //   tmpAABB.setMinMax([-p1.distance, -p3.distance, 0], [p0.distance, p2.distance, 0]);\n                        //   cullable.visible = isShape2D ? renderBounds.intersects(tmpAABB) : true;\n                        // }\n                        if (strategies.length === 0) {\n                            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;\n                        } else {\n                            // eg. implemented by g-webgl(frustum culling)\n                            cullable.visible = strategies.every(function(strategy) {\n                                return strategy.isVisible(camera, object);\n                            });\n                        }\n                        if (!object.isCulled() && object.isVisible()) {\n                            return object;\n                        }\n                        // if (this.renderingContext.renderListLastFrame.indexOf(object) > -1) {\n                        object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));\n                        // }\n                        return null;\n                    }\n                    return object;\n                });\n                renderingService.hooks.afterRender.tap(CullingPlugin.tag, function(object) {\n                    object.cullable.visibilityPlaneMask = -1;\n                });\n            }\n        }\n    ]);\n}();\nCullingPlugin.tag = \"Culling\";\n/**\n * support mouse & touch events\n * @see https://github.com/pixijs/pixi.js/blob/dev/packages/interaction/README.md\n *\n * also provide some extra events such as `drag`\n */ var EventPlugin = /*#__PURE__*/ function() {\n    function EventPlugin() {\n        var _this = this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, EventPlugin);\n        this.autoPreventDefault = false;\n        this.rootPointerEvent = new FederatedPointerEvent(null);\n        this.rootWheelEvent = new FederatedWheelEvent(null);\n        this.onPointerMove = function(nativeEvent) {\n            var _this$context$renderi;\n            var canvas = (_this$context$renderi = _this.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;\n            if (canvas.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n            var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);\n            var _iterator = _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default()(normalizedEvents), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var normalizedEvent = _step.value;\n                    var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);\n                    _this.context.eventService.mapEvent(event);\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            _this.setCursor(_this.context.eventService.cursor);\n        };\n        this.onClick = function(nativeEvent) {\n            var _this$context$renderi2;\n            var canvas = (_this$context$renderi2 = _this.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;\n            var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);\n            var _iterator2 = _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default()(normalizedEvents), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var normalizedEvent = _step2.value;\n                    var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);\n                    _this.context.eventService.mapEvent(event);\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            _this.setCursor(_this.context.eventService.cursor);\n        };\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(EventPlugin, [\n        {\n            key: \"apply\",\n            value: function apply(context) {\n                var _this2 = this;\n                this.context = context;\n                var renderingService = context.renderingService;\n                var canvas = this.context.renderingContext.root.ownerDocument.defaultView;\n                this.context.eventService.setPickHandler(function(position) {\n                    var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({\n                        position: position,\n                        picked: [],\n                        topmost: true // we only concern the topmost element\n                    }), picked = _this2$context$render.picked;\n                    return picked[0] || null;\n                });\n                renderingService.hooks.pointerWheel.tap(EventPlugin.tag, function(nativeEvent) {\n                    var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);\n                    _this2.context.eventService.mapEvent(wheelEvent);\n                });\n                renderingService.hooks.pointerDown.tap(EventPlugin.tag, function(nativeEvent) {\n                    if (canvas.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n                    var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);\n                    if (_this2.autoPreventDefault && events[0].isNormalized) {\n                        var cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n                        if (cancelable) {\n                            nativeEvent.preventDefault();\n                        }\n                    }\n                    var _iterator3 = _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default()(events), _step3;\n                    try {\n                        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                            var event = _step3.value;\n                            var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas, nativeEvent);\n                            _this2.context.eventService.mapEvent(federatedEvent);\n                        }\n                    } catch (err) {\n                        _iterator3.e(err);\n                    } finally{\n                        _iterator3.f();\n                    }\n                    _this2.setCursor(_this2.context.eventService.cursor);\n                });\n                renderingService.hooks.pointerUp.tap(EventPlugin.tag, function(nativeEvent) {\n                    if (canvas.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n                    // account for element in SVG\n                    var $element = _this2.context.contextService.getDomElement();\n                    var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);\n                    var outside = !isNativeEventFromCanvas ? \"outside\" : \"\";\n                    var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);\n                    var _iterator4 = _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default()(normalizedEvents), _step4;\n                    try {\n                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                            var normalizedEvent = _step4.value;\n                            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);\n                            event.type += outside;\n                            _this2.context.eventService.mapEvent(event);\n                        }\n                    } catch (err) {\n                        _iterator4.e(err);\n                    } finally{\n                        _iterator4.f();\n                    }\n                    _this2.setCursor(_this2.context.eventService.cursor);\n                });\n                renderingService.hooks.pointerMove.tap(EventPlugin.tag, this.onPointerMove);\n                renderingService.hooks.pointerOver.tap(EventPlugin.tag, this.onPointerMove);\n                renderingService.hooks.pointerOut.tap(EventPlugin.tag, this.onPointerMove);\n                renderingService.hooks.click.tap(EventPlugin.tag, this.onClick);\n                renderingService.hooks.pointerCancel.tap(EventPlugin.tag, function(nativeEvent) {\n                    var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);\n                    var _iterator5 = _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_14___default()(normalizedEvents), _step5;\n                    try {\n                        for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                            var normalizedEvent = _step5.value;\n                            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);\n                            _this2.context.eventService.mapEvent(event);\n                        }\n                    } catch (err) {\n                        _iterator5.e(err);\n                    } finally{\n                        _iterator5.f();\n                    }\n                    _this2.setCursor(_this2.context.eventService.cursor);\n                });\n            }\n        },\n        {\n            key: \"bootstrapEvent\",\n            value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {\n                event.view = view;\n                event.originalEvent = null;\n                event.nativeEvent = nativeEvent;\n                event.pointerId = normalizedEvent.pointerId;\n                event.width = normalizedEvent.width;\n                event.height = normalizedEvent.height;\n                event.isPrimary = normalizedEvent.isPrimary;\n                event.pointerType = normalizedEvent.pointerType;\n                event.pressure = normalizedEvent.pressure;\n                event.tangentialPressure = normalizedEvent.tangentialPressure;\n                event.tiltX = normalizedEvent.tiltX;\n                event.tiltY = normalizedEvent.tiltY;\n                event.twist = normalizedEvent.twist;\n                this.transferMouseData(event, normalizedEvent);\n                var _this$context$eventSe = this.context.eventService.client2Viewport({\n                    x: normalizedEvent.clientX,\n                    y: normalizedEvent.clientY\n                }), x = _this$context$eventSe.x, y = _this$context$eventSe.y;\n                event.viewport.x = x;\n                event.viewport.y = y;\n                var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;\n                event.canvas.x = canvasX;\n                event.canvas.y = canvasY;\n                event.global.copyFrom(event.canvas);\n                event.offset.copyFrom(event.canvas);\n                event.isTrusted = nativeEvent.isTrusted;\n                if (event.type === \"pointerleave\") {\n                    event.type = \"pointerout\";\n                }\n                if (event.type.startsWith(\"mouse\")) {\n                    event.type = event.type.replace(\"mouse\", \"pointer\");\n                }\n                if (event.type.startsWith(\"touch\")) {\n                    event.type = TOUCH_TO_POINTER[event.type] || event.type;\n                }\n                return event;\n            }\n        },\n        {\n            key: \"normalizeWheelEvent\",\n            value: function normalizeWheelEvent(nativeEvent) {\n                var event = this.rootWheelEvent;\n                this.transferMouseData(event, nativeEvent);\n                event.deltaMode = nativeEvent.deltaMode;\n                event.deltaX = nativeEvent.deltaX;\n                event.deltaY = nativeEvent.deltaY;\n                event.deltaZ = nativeEvent.deltaZ;\n                var _this$context$eventSe3 = this.context.eventService.client2Viewport({\n                    x: nativeEvent.clientX,\n                    y: nativeEvent.clientY\n                }), x = _this$context$eventSe3.x, y = _this$context$eventSe3.y;\n                event.viewport.x = x;\n                event.viewport.y = y;\n                var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;\n                event.canvas.x = canvasX;\n                event.canvas.y = canvasY;\n                event.global.copyFrom(event.canvas);\n                event.offset.copyFrom(event.canvas);\n                event.nativeEvent = nativeEvent;\n                event.type = nativeEvent.type;\n                return event;\n            }\n        },\n        {\n            key: \"transferMouseData\",\n            value: function transferMouseData(event, nativeEvent) {\n                event.isTrusted = nativeEvent.isTrusted;\n                event.srcElement = nativeEvent.srcElement;\n                event.timeStamp = clock.now();\n                event.type = nativeEvent.type;\n                event.altKey = nativeEvent.altKey;\n                event.metaKey = nativeEvent.metaKey;\n                event.shiftKey = nativeEvent.shiftKey;\n                event.ctrlKey = nativeEvent.ctrlKey;\n                event.button = nativeEvent.button;\n                event.buttons = nativeEvent.buttons;\n                event.client.x = nativeEvent.clientX;\n                event.client.y = nativeEvent.clientY;\n                event.movement.x = nativeEvent.movementX;\n                event.movement.y = nativeEvent.movementY;\n                event.page.x = nativeEvent.pageX;\n                event.page.y = nativeEvent.pageY;\n                event.screen.x = nativeEvent.screenX;\n                event.screen.y = nativeEvent.screenY;\n                event.relatedTarget = null;\n            }\n        },\n        {\n            key: \"setCursor\",\n            value: function setCursor(cursor) {\n                this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || \"default\");\n            }\n        },\n        {\n            key: \"normalizeToPointerEvent\",\n            value: function normalizeToPointerEvent(event, canvas) {\n                var normalizedEvents = [];\n                if (canvas.isTouchEvent(event)) {\n                    for(var i = 0; i < event.changedTouches.length; i++){\n                        var touch = event.changedTouches[i];\n                        // use changedTouches instead of touches since touchend has no touches\n                        // @see https://stackoverflow.com/a/10079076\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.button)) touch.button = 0;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.buttons)) touch.buttons = 1;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.isPrimary)) {\n                            touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n                        }\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.width)) touch.width = touch.radiusX || 1;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.height)) touch.height = touch.radiusY || 1;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.tiltX)) touch.tiltX = 0;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.tiltY)) touch.tiltY = 0;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.pointerType)) touch.pointerType = \"touch\";\n                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.pointerId)) touch.pointerId = touch.identifier || 0;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.pressure)) touch.pressure = touch.force || 0.5;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.twist)) touch.twist = 0;\n                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(touch.tangentialPressure)) touch.tangentialPressure = 0;\n                        touch.isNormalized = true;\n                        touch.type = event.type;\n                        normalizedEvents.push(touch);\n                    }\n                } else if (canvas.isMouseEvent(event)) {\n                    var tempEvent = event;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.isPrimary)) tempEvent.isPrimary = true;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.width)) tempEvent.width = 1;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.height)) tempEvent.height = 1;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.tiltX)) tempEvent.tiltX = 0;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.tiltY)) tempEvent.tiltY = 0;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.pointerType)) tempEvent.pointerType = \"mouse\";\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.pressure)) tempEvent.pressure = 0.5;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.twist)) tempEvent.twist = 0;\n                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;\n                    tempEvent.isNormalized = true;\n                    normalizedEvents.push(tempEvent);\n                } else {\n                    normalizedEvents.push(event);\n                }\n                return normalizedEvents;\n            }\n        }\n    ]);\n}();\nEventPlugin.tag = \"Event\";\n// group is not a 2d shape\nvar shape2D = [\n    Shape.CIRCLE,\n    Shape.ELLIPSE,\n    Shape.IMAGE,\n    Shape.RECT,\n    Shape.LINE,\n    Shape.POLYLINE,\n    Shape.POLYGON,\n    Shape.TEXT,\n    Shape.PATH,\n    Shape.HTML\n];\nvar FrustumCullingStrategy = /*#__PURE__*/ function() {\n    function FrustumCullingStrategy() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, FrustumCullingStrategy);\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(FrustumCullingStrategy, [\n        {\n            key: \"isVisible\",\n            value: function isVisible(camera, object) {\n                var _object$parentNode;\n                // return true;\n                var cullable = object.cullable;\n                if (!cullable.enable) {\n                    return true;\n                }\n                var renderBounds = object.getRenderBounds();\n                if (AABB.isEmpty(renderBounds)) {\n                    return false;\n                }\n                // get VP matrix from camera\n                var frustum = camera.getFrustum();\n                var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;\n                cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);\n                cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;\n                return cullable.visible;\n            }\n        },\n        {\n            key: \"computeVisibilityWithPlaneMask\",\n            value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {\n                if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {\n                    // 父节点完全位于视锥内或者外部，直接返回\n                    return parentPlaneMask;\n                }\n                // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n                // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n                var mask = Mask.INSIDE;\n                var isShape2D = shape2D.indexOf(object.nodeName) > -1;\n                // Use viewport culling for 2D shapes\n                // @see https://github.com/antvis/g/issues/914\n                for(var k = 0, len = planes.length; k < len; ++k){\n                    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n                    var flag = 1 << k;\n                    if ((parentPlaneMask & flag) === 0) {\n                        continue;\n                    }\n                    // skip near & far planes when testing 2D shapes\n                    if (isShape2D && (k === 4 || k === 5)) {\n                        continue;\n                    }\n                    // p-vertex n-vertex <-|plane p-vertex n-vertex\n                    // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测\n                    var _planes$k = planes[k], normal = _planes$k.normal, distance = _planes$k.distance;\n                    if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance < 0) {\n                        return Mask.OUTSIDE;\n                    }\n                    if (gl_matrix__WEBPACK_IMPORTED_MODULE_16__.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance < 0) {\n                        // 和当前面相交，对应位置为1，继续检测下一个面\n                        mask |= flag;\n                    }\n                }\n                return mask;\n            }\n        }\n    ]);\n}();\nvar PrepareRendererPlugin = /*#__PURE__*/ function() {\n    function PrepareRendererPlugin() {\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PrepareRendererPlugin);\n        this.syncTasks = new Map();\n        this.isFirstTimeRendering = true;\n        this.syncing = false;\n        this.isFirstTimeRenderingFinished = false;\n    }\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(PrepareRendererPlugin, [\n        {\n            key: \"apply\",\n            value: function apply(context) {\n                var _this = this, _runtime$globalThis$r;\n                var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;\n                var canvas = renderingContext.root.ownerDocument.defaultView;\n                this.rBush = rBushRoot;\n                var handleAttributeChanged = function handleAttributeChanged(e) {\n                    var object = e.target;\n                    object.renderable.dirty = true;\n                    renderingService.dirtify();\n                };\n                var handleBoundsChanged = function handleBoundsChanged(e) {\n                    _this.syncTasks.set(e.target, e.detail.affectChildren);\n                    renderingService.dirtify();\n                };\n                var handleMounted = function handleMounted(e) {\n                    var object = e.target;\n                    if (runtime.enableSizeAttenuation) {\n                        runtime.styleValueRegistry.updateSizeAttenuation(object, canvas.getCamera().getZoom());\n                    }\n                };\n                var handleUnmounted = function handleUnmounted(e) {\n                    var object = e.target;\n                    var rBushNode = object.rBushNode;\n                    if (rBushNode.aabb) {\n                        _this.rBush.remove(rBushNode.aabb);\n                    }\n                    _this.syncTasks[\"delete\"](object);\n                    runtime.sceneGraphService.dirtifyToRoot(object);\n                    renderingService.dirtify();\n                };\n                renderingService.hooks.init.tap(PrepareRendererPlugin.tag, function() {\n                    canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);\n                    canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n                    canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);\n                    canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);\n                });\n                renderingService.hooks.destroy.tap(PrepareRendererPlugin.tag, function() {\n                    canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);\n                    canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n                    canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);\n                    canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);\n                    _this.syncTasks.clear();\n                });\n                var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);\n                renderingService.hooks.endFrame.tap(PrepareRendererPlugin.tag, function() {\n                    if (_this.isFirstTimeRendering) {\n                        _this.isFirstTimeRendering = false;\n                        _this.syncing = true;\n                        ric(function() {\n                            _this.syncRTree(true);\n                            _this.isFirstTimeRenderingFinished = true;\n                        });\n                    } else {\n                        _this.syncRTree();\n                    }\n                });\n            }\n        },\n        {\n            key: \"syncNode\",\n            value: function syncNode(node) {\n                var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                if (!node.isConnected) return;\n                var rBushNode = node.rBushNode;\n                // clear dirty node\n                if (rBushNode.aabb) this.rBush.remove(rBushNode.aabb);\n                var renderBounds = node.getRenderBounds();\n                if (renderBounds) {\n                    var renderable = node.renderable;\n                    if (force) {\n                        if (!renderable.dirtyRenderBounds) {\n                            renderable.dirtyRenderBounds = new AABB();\n                        }\n                        // save last dirty aabb\n                        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);\n                    }\n                    var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];\n                    var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_6___default()(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY = _renderBounds$getMax2[1];\n                    if (!rBushNode.aabb) {\n                        rBushNode.aabb = {};\n                    }\n                    rBushNode.aabb.displayObject = node;\n                    rBushNode.aabb.minX = minX;\n                    rBushNode.aabb.minY = minY;\n                    rBushNode.aabb.maxX = maxX;\n                    rBushNode.aabb.maxY = maxY;\n                }\n                if (rBushNode.aabb) {\n                    // TODO: NaN occurs when width/height of Rect is 0\n                    if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {\n                        return rBushNode.aabb;\n                    }\n                }\n            }\n        },\n        {\n            key: \"syncRTree\",\n            value: function syncRTree() {\n                var _this2 = this;\n                var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                if (!force && (this.syncing || this.syncTasks.size === 0)) {\n                    return;\n                }\n                this.syncing = true;\n                // bounds changed, need re-inserting its children\n                var bulk = [];\n                var synced = new Set();\n                var sync = function sync(node) {\n                    if (!synced.has(node) && node.renderable) {\n                        var aabb = _this2.syncNode(node, force);\n                        if (aabb) {\n                            bulk.push(aabb);\n                            synced.add(node);\n                        }\n                    }\n                };\n                this.syncTasks.forEach(function(affectChildren, node) {\n                    if (affectChildren) {\n                        node.forEach(sync);\n                    }\n                    var parent = node;\n                    while(parent){\n                        sync(parent);\n                        parent = parent.parentElement;\n                    }\n                });\n                // use bulk inserting, which is ~2-3 times faster\n                // @see https://github.com/mourner/rbush#bulk-inserting-data\n                this.rBush.load(bulk);\n                bulk.length = 0;\n                this.syncing = false;\n            }\n        }\n    ]);\n}();\nPrepareRendererPlugin.tag = \"Prepare\";\nfunction isCanvas(value) {\n    return !!value.document;\n}\nvar CanvasEvent = /*#__PURE__*/ function(CanvasEvent) {\n    CanvasEvent[\"READY\"] = \"ready\";\n    CanvasEvent[\"BEFORE_RENDER\"] = \"beforerender\";\n    CanvasEvent[\"RERENDER\"] = \"rerender\";\n    CanvasEvent[\"AFTER_RENDER\"] = \"afterrender\";\n    CanvasEvent[\"BEFORE_DESTROY\"] = \"beforedestroy\";\n    CanvasEvent[\"AFTER_DESTROY\"] = \"afterdestroy\";\n    CanvasEvent[\"RESIZE\"] = \"resize\";\n    CanvasEvent[\"DIRTY_RECTANGLE\"] = \"dirtyrectangle\";\n    CanvasEvent[\"RENDERER_CHANGED\"] = \"rendererchanged\";\n    return CanvasEvent;\n}({});\nvar DEFAULT_CAMERA_Z = 500;\nvar DEFAULT_CAMERA_NEAR = 0.1;\nvar DEFAULT_CAMERA_FAR = 1000;\n/**\n * reuse custom event preventing from re-create them in every frame\n */ var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);\nvar unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);\nvar beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);\nvar rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);\nvar afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);\n/**\n * can be treated like Window in DOM\n * provide some extra methods like `window`, such as:\n * * `window.requestAnimationFrame`\n * * `window.devicePixelRatio`\n *\n * prototype chains: Canvas(Window) -> EventTarget\n *\n * @docs https://g.antv.antgroup.com/api/canvas/intro\n */ var Canvas = /*#__PURE__*/ function(_EventTarget) {\n    function Canvas(config) {\n        var _this;\n        _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Canvas);\n        _this = _babel_runtime_helpers_callSuper__WEBPACK_IMPORTED_MODULE_4___default()(this, Canvas);\n        // #region environment\n        /**\n     * window.document\n     */ /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element\n     */ _this.Element = DisplayObject;\n        _this.inited = false;\n        _this.context = {};\n        var container = config.container, canvas = config.canvas, renderer = config.renderer, width = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame = config.requestAnimationFrame, cancelAnimationFrame = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;\n        var canvasWidth = width;\n        var canvasHeight = height;\n        var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;\n        dpr = dpr >= 1 ? Math.ceil(dpr) : 1;\n        // use user-defined <canvas> or OffscreenCanvas\n        if (canvas) {\n            // infer width & height with dpr\n            canvasWidth = width || getWidth(canvas) || canvas.width / dpr;\n            canvasHeight = height || getHeight(canvas) || canvas.height / dpr;\n        }\n        /**\n     * implements `Window` interface\n     */ _this.customElements = new CustomElementRegistry();\n        _this.devicePixelRatio = dpr;\n        _this.requestAnimationFrame = requestAnimationFrame !== null && requestAnimationFrame !== void 0 ? requestAnimationFrame : raf.bind(runtime.globalThis);\n        _this.cancelAnimationFrame = cancelAnimationFrame !== null && cancelAnimationFrame !== void 0 ? cancelAnimationFrame : caf.bind(runtime.globalThis);\n        // the following feature-detect from hammer.js\n        // @see https://github.com/hammerjs/hammer.js/blob/master/src/inputjs/input-consts.js#L5\n        _this.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : \"ontouchstart\" in runtime.globalThis;\n        _this.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;\n        _this.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {\n            return _this.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;\n        };\n        _this.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {\n            return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));\n        };\n        // override it in runtime\n        if (offscreenCanvas) {\n            runtime.offscreenCanvas = offscreenCanvas;\n        }\n        // create document\n        _this.document = new Document();\n        _this.document.defaultView = _this;\n        if (!supportsMutipleCanvasesInOneContainer) {\n            cleanExistedCanvas(container, _this, cleanUpOnDestroy);\n        }\n        _this.initRenderingContext(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, config), {}, {\n            width: canvasWidth,\n            height: canvasHeight,\n            background: background !== null && background !== void 0 ? background : \"transparent\",\n            cursor: cursor !== null && cursor !== void 0 ? cursor : \"default\",\n            cleanUpOnDestroy: cleanUpOnDestroy,\n            devicePixelRatio: dpr,\n            requestAnimationFrame: _this.requestAnimationFrame,\n            cancelAnimationFrame: _this.cancelAnimationFrame,\n            supportsTouchEvents: _this.supportsTouchEvents,\n            supportsPointerEvents: _this.supportsPointerEvents,\n            isTouchEvent: _this.isTouchEvent,\n            isMouseEvent: _this.isMouseEvent,\n            dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200,\n            createImage: createImage !== null && createImage !== void 0 ? createImage : function() {\n                return new window.Image();\n            }\n        }));\n        _this.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);\n        _this.initRenderer(renderer, true);\n        return _this;\n    }\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Canvas, _EventTarget);\n    return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Canvas, [\n        {\n            key: \"initRenderingContext\",\n            value: function initRenderingContext(mergedConfig) {\n                this.context.config = mergedConfig;\n                // bind rendering context, shared by all renderers\n                this.context.renderingContext = {\n                    /**\n         * the root node in scene graph\n         */ root: this.document.documentElement,\n                    renderListCurrentFrame: [],\n                    unculledEntities: [],\n                    renderReasons: new Set(),\n                    force: false,\n                    dirty: false\n                };\n            }\n        },\n        {\n            key: \"initDefaultCamera\",\n            value: function initDefaultCamera(width, height, clipSpaceNearZ) {\n                var _this2 = this;\n                // set a default ortho camera\n                var camera = new runtime.CameraContribution();\n                camera.clipSpaceNearZ = clipSpaceNearZ;\n                camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);\n                // keep ref since it will use raf in camera animation\n                camera.canvas = this;\n                // redraw when camera changed\n                camera.eventEmitter.on(CameraEvent.UPDATED, function() {\n                    _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);\n                    if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {\n                        _this2.updateSizeAttenuation();\n                    }\n                });\n                // bind camera\n                this.context.camera = camera;\n            }\n        },\n        {\n            key: \"updateSizeAttenuation\",\n            value: function updateSizeAttenuation() {\n                var zoom = this.getCamera().getZoom();\n                this.document.documentElement.forEach(function(node) {\n                    runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);\n                });\n            }\n        },\n        {\n            key: \"getConfig\",\n            value: function getConfig() {\n                return this.context.config;\n            }\n        },\n        {\n            key: \"getRoot\",\n            value: function getRoot() {\n                return this.document.documentElement;\n            }\n        },\n        {\n            key: \"getCamera\",\n            value: function getCamera() {\n                return this.context.camera;\n            }\n        },\n        {\n            key: \"getContextService\",\n            value: function getContextService() {\n                return this.context.contextService;\n            }\n        },\n        {\n            key: \"getEventService\",\n            value: function getEventService() {\n                return this.context.eventService;\n            }\n        },\n        {\n            key: \"getRenderingService\",\n            value: function getRenderingService() {\n                return this.context.renderingService;\n            }\n        },\n        {\n            key: \"getRenderingContext\",\n            value: function getRenderingContext() {\n                return this.context.renderingContext;\n            }\n        },\n        {\n            key: \"getStats\",\n            value: function getStats() {\n                return this.getRenderingService().getStats();\n            }\n        },\n        {\n            key: \"ready\",\n            get: function get() {\n                var _this3 = this;\n                if (!this.readyPromise) {\n                    this.readyPromise = new Promise(function(resolve) {\n                        _this3.resolveReadyPromise = function() {\n                            resolve(_this3);\n                        };\n                    });\n                    if (this.inited) {\n                        this.resolveReadyPromise();\n                    }\n                }\n                return this.readyPromise;\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                var cleanUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                var skipTriggerEvent = arguments.length > 1 ? arguments[1] : undefined;\n                memoize.clearCache();\n                if (!skipTriggerEvent) {\n                    this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));\n                }\n                if (this.frameId) {\n                    this.cancelAnimationFrame(this.frameId);\n                }\n                // unmount all children\n                var root = this.getRoot();\n                if (cleanUp) {\n                    this.unmountChildren(root);\n                    // destroy Document\n                    this.document.destroy();\n                    this.getEventService().destroy();\n                }\n                // destroy services\n                this.getRenderingService().destroy();\n                this.getContextService().destroy();\n                // clear root after render service destroyed\n                if (this.context.rBushRoot) {\n                    // clear rbush\n                    this.context.rBushRoot.clear();\n                }\n                if (!skipTriggerEvent) {\n                    this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));\n                }\n                var clearEventRetain = function clearEventRetain(event) {\n                    event.currentTarget = null;\n                    event.manager = null;\n                    event.target = null;\n                    event.relatedNode = null;\n                };\n                clearEventRetain(mountedEvent);\n                clearEventRetain(unmountedEvent);\n                clearEventRetain(beforeRenderEvent);\n                clearEventRetain(rerenderEvent);\n                clearEventRetain(afterRenderEvent);\n                clearEventRetain(attrModifiedEvent);\n                clearEventRetain(insertedEvent);\n                clearEventRetain(removedEvent);\n                clearEventRetain(destroyEvent);\n            }\n        },\n        {\n            key: \"changeSize\",\n            value: function changeSize(width, height) {\n                this.resize(width, height);\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize(width, height) {\n                // update canvas' config\n                var canvasConfig = this.context.config;\n                canvasConfig.width = width;\n                canvasConfig.height = height;\n                // resize context\n                this.getContextService().resize(width, height);\n                // resize camera\n                var camera = this.context.camera;\n                var projectionMode = camera.getProjectionMode();\n                camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);\n                if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {\n                    camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());\n                } else {\n                    camera.setAspect(width / height);\n                }\n                this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {\n                    width: width,\n                    height: height\n                }));\n            }\n        },\n        {\n            key: \"appendChild\",\n            value: function appendChild(child, index) {\n                return this.document.documentElement.appendChild(child, index);\n            }\n        },\n        {\n            key: \"insertBefore\",\n            value: function insertBefore(newChild, refChild) {\n                return this.document.documentElement.insertBefore(newChild, refChild);\n            }\n        },\n        {\n            key: \"removeChild\",\n            value: function removeChild(child) {\n                return this.document.documentElement.removeChild(child);\n            }\n        },\n        {\n            key: \"removeChildren\",\n            value: function removeChildren() {\n                this.document.documentElement.removeChildren();\n            }\n        },\n        {\n            key: \"destroyChildren\",\n            value: function destroyChildren() {\n                this.document.documentElement.destroyChildren();\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(frame) {\n                var _this4 = this;\n                // console.log('render ----------------------');\n                if (frame) {\n                    beforeRenderEvent.detail = frame;\n                    afterRenderEvent.detail = frame;\n                }\n                this.dispatchEvent(beforeRenderEvent);\n                var renderingService = this.getRenderingService();\n                renderingService.render(this.getConfig(), frame, function() {\n                    // trigger actual rerender event\n                    // @see https://github.com/antvis/G/issues/1268\n                    _this4.dispatchEvent(rerenderEvent);\n                });\n                this.dispatchEvent(afterRenderEvent);\n            }\n        },\n        {\n            key: \"run\",\n            value: function run() {\n                var _this5 = this;\n                var _tick = function tick(time, frame) {\n                    _this5.render(frame);\n                    _this5.frameId = _this5.requestAnimationFrame(_tick);\n                };\n                _tick();\n            }\n        },\n        {\n            key: \"initRenderer\",\n            value: function initRenderer(renderer) {\n                var _this6 = this;\n                var firstContentfullPaint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                if (!renderer) {\n                    throw new Error(\"Renderer is required.\");\n                }\n                // reset\n                this.inited = false;\n                this.readyPromise = undefined;\n                // FIXME: should re-create here?\n                this.context.rBushRoot = new RBush();\n                // reset rendering plugins\n                this.context.renderingPlugins = [];\n                this.context.renderingPlugins.push(new EventPlugin(), new PrepareRendererPlugin(), // new DirtyCheckPlugin(),\n                new CullingPlugin([\n                    new FrustumCullingStrategy()\n                ]));\n                //\n                this.loadRendererContainerModule(renderer);\n                // init context service\n                this.context.contextService = new this.context.ContextService(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, runtime), this.context));\n                // init rendering service\n                this.context.renderingService = new RenderingService(runtime, this.context);\n                // init event service\n                this.context.eventService = new EventService(runtime, this.context);\n                this.context.eventService.init();\n                if (this.context.contextService.init) {\n                    this.context.contextService.init();\n                    this.initRenderingService(renderer, firstContentfullPaint, true);\n                } else {\n                    this.context.contextService.initAsync().then(function() {\n                        _this6.initRenderingService(renderer, firstContentfullPaint);\n                    })[\"catch\"](function(err) {\n                        console.error(err);\n                    });\n                }\n            }\n        },\n        {\n            key: \"initRenderingService\",\n            value: function initRenderingService(renderer) {\n                var _this7 = this;\n                var firstContentfullPaint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                this.context.renderingService.init(function() {\n                    _this7.inited = true;\n                    if (firstContentfullPaint) {\n                        if (async) {\n                            _this7.requestAnimationFrame(function() {\n                                _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY));\n                            });\n                        } else {\n                            _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY));\n                        }\n                    } else {\n                        _this7.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED));\n                    }\n                    if (_this7.readyPromise) {\n                        _this7.resolveReadyPromise();\n                    }\n                    if (!firstContentfullPaint) {\n                        _this7.getRoot().forEach(function(node) {\n                            var _ref = node, renderable = _ref.renderable;\n                            if (renderable) {\n                                renderable.renderBoundsDirty = true;\n                                renderable.boundsDirty = true;\n                                renderable.dirty = true;\n                            }\n                        });\n                    }\n                    // keep current scenegraph unchanged, just trigger mounted event\n                    _this7.mountChildren(_this7.getRoot());\n                    if (renderer.getConfig().enableAutoRendering) {\n                        _this7.run();\n                    }\n                });\n            }\n        },\n        {\n            key: \"loadRendererContainerModule\",\n            value: function loadRendererContainerModule(renderer) {\n                var _this8 = this;\n                // load other container modules provided by g-canvas/g-svg/g-webgl\n                var plugins = renderer.getPlugins();\n                plugins.forEach(function(plugin) {\n                    plugin.context = _this8.context;\n                    plugin.init(runtime);\n                });\n            }\n        },\n        {\n            key: \"setRenderer\",\n            value: function setRenderer(renderer) {\n                // update canvas' config\n                var canvasConfig = this.getConfig();\n                if (canvasConfig.renderer === renderer) {\n                    return;\n                }\n                var oldRenderer = canvasConfig.renderer;\n                canvasConfig.renderer = renderer;\n                // keep all children undestroyed\n                this.destroy(false, true);\n                // destroy all plugins, reverse will mutate origin array\n                _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {\n                    plugin.destroy(runtime);\n                });\n                this.initRenderer(renderer);\n            }\n        },\n        {\n            key: \"setCursor\",\n            value: function setCursor(cursor) {\n                var canvasConfig = this.getConfig();\n                canvasConfig.cursor = cursor;\n                this.getContextService().applyCursorStyle(cursor);\n            }\n        },\n        {\n            key: \"unmountChildren\",\n            value: function unmountChildren(parent) {\n                var _this9 = this;\n                // unmountChildren recursively\n                parent.childNodes.forEach(function(child) {\n                    _this9.unmountChildren(child);\n                });\n                if (this.inited) {\n                    if (parent.isMutationObserved) {\n                        parent.dispatchEvent(unmountedEvent);\n                    } else {\n                        unmountedEvent.target = parent;\n                        this.dispatchEvent(unmountedEvent, true);\n                    }\n                    // skip document.documentElement\n                    if (parent !== this.document.documentElement) {\n                        parent.ownerDocument = null;\n                    }\n                    parent.isConnected = false;\n                }\n                // trigger after unmounted\n                if (parent.isCustomElement) {\n                    if (parent.disconnectedCallback) {\n                        parent.disconnectedCallback();\n                    }\n                }\n            }\n        },\n        {\n            key: \"mountChildren\",\n            value: function mountChildren(child) {\n                var _this10 = this;\n                var skipTriggerEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isInFragment(child);\n                if (this.inited) {\n                    if (!child.isConnected) {\n                        child.ownerDocument = this.document;\n                        child.isConnected = true;\n                        if (!skipTriggerEvent) {\n                            if (child.isMutationObserved) {\n                                child.dispatchEvent(mountedEvent);\n                            } else {\n                                mountedEvent.target = child;\n                                this.dispatchEvent(mountedEvent, true);\n                            }\n                        }\n                    }\n                } else {\n                    console.warn(\"[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.\", \"appended child: \", child.nodeName);\n                }\n                // recursively mount children\n                child.childNodes.forEach(function(c) {\n                    _this10.mountChildren(c, skipTriggerEvent);\n                });\n                // trigger after mounted\n                if (child.isCustomElement) {\n                    if (child.connectedCallback) {\n                        child.connectedCallback();\n                    }\n                }\n            }\n        },\n        {\n            key: \"mountFragment\",\n            value: function mountFragment(child) {\n                this.mountChildren(child, false);\n            }\n        },\n        {\n            key: \"client2Viewport\",\n            value: function client2Viewport(client) {\n                return this.getEventService().client2Viewport(client);\n            }\n        },\n        {\n            key: \"viewport2Client\",\n            value: function viewport2Client(canvas) {\n                return this.getEventService().viewport2Client(canvas);\n            }\n        },\n        {\n            key: \"viewport2Canvas\",\n            value: function viewport2Canvas(viewport) {\n                return this.getEventService().viewport2Canvas(viewport);\n            }\n        },\n        {\n            key: \"canvas2Viewport\",\n            value: function canvas2Viewport(canvas) {\n                return this.getEventService().canvas2Viewport(canvas);\n            }\n        },\n        {\n            key: \"getPointByClient\",\n            value: function getPointByClient(clientX, clientY) {\n                return this.client2Viewport({\n                    x: clientX,\n                    y: clientY\n                });\n            }\n        },\n        {\n            key: \"getClientByPoint\",\n            value: function getClientByPoint(x, y) {\n                return this.viewport2Client({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n    ]);\n}(EventTarget);\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhbnR2K2ctbGl0ZUAyLjIuMTYvbm9kZV9tb2R1bGVzL0BhbnR2L2ctbGl0ZS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ2dFO0FBQ0c7QUFDTjtBQUNZO0FBQ2hCO0FBQ0Y7QUFDVTtBQUN6QjtBQUNnQztBQUMzQjtBQUNvUTtBQUM5TztBQUNKO0FBQ2tDO0FBQ3RCO0FBQ0o7QUFDa0I7QUFDSjtBQUV0RixJQUFJa0QsaUJBQWlCLE9BQU9DLGVBQWUsY0FBY0EsYUFBYSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLE9BQU9DLFdBQVcsY0FBY0EsU0FBUyxPQUFPQyxTQUFTLGNBQWNBLE9BQU8sQ0FBQztBQUU5TCxJQUFJQyxRQUFRO0lBQUNDLFNBQVMsQ0FBQztBQUFDO0FBRXZCLFVBQVVDLE1BQU0sRUFBRUQsT0FBTztJQUN6QixVQUFVSCxPQUFNLEVBQUVLLE9BQU87UUFDMUJELE9BQU9ELE9BQU8sR0FBR0U7SUFDakIsR0FBRVIsZ0JBQWdCO1FBQ2xCLFNBQVNTLFlBQVlDLEdBQUcsRUFBRUMsQ0FBQyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTztZQUM3Q0MsZ0JBQWdCTCxLQUFLQyxHQUFHQyxRQUFRLEdBQUdDLFNBQVVILElBQUlNLE1BQU0sR0FBRyxHQUFJRixXQUFXRztRQUM3RTtRQUVBLFNBQVNGLGdCQUFnQkwsR0FBRyxFQUFFQyxDQUFDLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxPQUFPO1lBRWpELE1BQU9ELFFBQVFELEtB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R0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEVBQUU7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEdBQUcsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEdBQUc7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEdBQUcsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEdBQUc7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEdBQUcsR0FBR0QsQ0FBQyxDQUFDLEdBQUcsR0FBR0MsQ0FBQyxDQUFDLEdBQUc7UUFBRUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFD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bGVzLy5wbnBtL0BhbnR2K2ctbGl0ZUAyLjIuMTYvbm9kZV9tb2R1bGVzL0BhbnR2L2ctbGl0ZS9kaXN0L2luZGV4LmVzbS5qcz9lYmY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGFudHYvZy1saXRlXG4gKiBAZGVzY3JpcHRpb24gQSBjb3JlIG1vZHVsZSBmb3IgcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRzIERPTSBBUEkuXG4gKiBAdmVyc2lvbiAyLjIuMTZcbiAqIEBkYXRlIDEvMjMvMjAyNSwgODozMTo1MSBBTVxuICogQGF1dGhvciBBbnRWaXNcbiAqIEBkb2NzIGh0dHBzOi8vZy5hbnR2LmFudGdyb3VwLmNvbS9cbiAqL1xuaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayc7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5JztcbmltcG9ydCBfY2FsbFN1cGVyIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2FsbFN1cGVyJztcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cyc7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5JztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyB2ZWMzLCB2ZWM0LCBtYXQ0LCBtYXQzLCBxdWF0IGFzIHF1YXQkMSwgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcmVhZE9ubHlFcnJvcic7XG5pbXBvcnQgeyBpc051bWJlciwgZGlzdGFuY2VTcXVhcmVSb290LCBpc1N0cmluZywgaXNOaWwsIGNsYW1wLCBnZXRUb3RhbExlbmd0aCwgbWluLCBtYXgsIGlzTnVtYmVyRXF1YWwsIG1vZCwgbm9ybWFsaXplUGF0aCwgcGF0aDJDdXJ2ZSwgZXF1YWxpemVTZWdtZW50cywgZ2V0RHJhd0RpcmVjdGlvbiwgcmV2ZXJzZUN1cnZlLCBjbG9uZVBhdGgsIGdldFJvdGF0ZWRDdXJ2ZSwgaXNVbmRlZmluZWQsIGlzQXJyYXksIGlzQm9vbGVhbiwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGdldFBvaW50QXRMZW5ndGggfSBmcm9tICdAYW50di91dGlsJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgX3N1cGVyUHJvcEdldCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEdldCc7XG5pbXBvcnQgeyBwb2x5bGluZUxlbmd0aCwgYXJjQm94LCBjdWJpY0JveCwgcXVhZEJveCwgbGluZVBvaW50QXQsIGxpbmVMZW5ndGggfSBmcm9tICdAYW50di9nLW1hdGgnO1xuaW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUnO1xuaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcic7XG5pbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJztcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgcmJ1c2ggPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDtcbn0oY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uICgpIHtcbmZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0IHx8IDAsIHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSksIGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmUpO1xufVxuXG5mdW5jdGlvbiBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHsgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTsgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIHsgaSsrOyB9XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgeyBqLS07IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHsgc3dhcChhcnIsIGxlZnQsIGopOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIHsgbGVmdCA9IGogKyAxOyB9XG4gICAgICAgIGlmIChrIDw9IGopIHsgcmlnaHQgPSBqIC0gMTsgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5cbnZhciBSQnVzaCA9IGZ1bmN0aW9uIFJCdXNoKG1heEVudHJpZXMpIHtcbiAgICBpZiAoIG1heEVudHJpZXMgPT09IHZvaWQgMCApIG1heEVudHJpZXMgPSA5O1xuXG4gICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG4gICAgdGhpcy5jbGVhcigpO1xufTtcblxuUkJ1c2gucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uIGFsbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbn07XG5cblJCdXNoLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2ggKGJib3gpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94O1xuICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB2YXIgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyByZXN1bHQucHVzaChjaGlsZCk7IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB7IHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblJCdXNoLnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIGNvbGxpZGVzIChiYm94KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHZhciBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUkJ1c2gucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkIChkYXRhKSB7XG4gICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHsgcmV0dXJuIHRoaXM7IH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc2NyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUkJ1c2gucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7IHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7IH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJCdXNoLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJCdXNoLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFpdGVtKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pO1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICB2YXIgaSwgcGFyZW50LCBnb2luZ1VwO1xuXG4gICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblxuICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgeyBub2RlID0gbnVsbDsgfSAvLyBub3RoaW5nIGZvdW5kXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SQnVzaC5wcm90b3R5cGUudG9CQm94ID0gZnVuY3Rpb24gdG9CQm94IChpdGVtKSB7IHJldHVybiBpdGVtOyB9O1xuXG5SQnVzaC5wcm90b3R5cGUuY29tcGFyZU1pblggPSBmdW5jdGlvbiBjb21wYXJlTWluWCAoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9O1xuUkJ1c2gucHJvdG90eXBlLmNvbXBhcmVNaW5ZID0gZnVuY3Rpb24gY29tcGFyZU1pblkgKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfTtcblxuUkJ1c2gucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH07XG5cblJCdXNoLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJCdXNoLnByb3RvdHlwZS5fYWxsID0gZnVuY3Rpb24gX2FsbCAobm9kZSwgcmVzdWx0KSB7XG4gICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWFmKSB7IHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7IH1cbiAgICAgICAgZWxzZSB7IG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTsgfVxuXG4gICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuUkJ1c2gucHJvdG90eXBlLl9idWlsZCA9IGZ1bmN0aW9uIF9idWlsZCAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICB2YXIgTSA9IHRoaXMuX21heEVudHJpZXM7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgfVxuXG4gICAgbm9kZSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pO1xuICAgIHZhciBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSk7XG5cbiAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgdmFyIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgIHZhciByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblJCdXNoLnByb3RvdHlwZS5fY2hvb3NlU3VidHJlZSA9IGZ1bmN0aW9uIF9jaG9vc2VTdWJ0cmVlIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIHsgYnJlYWs7IH1cblxuICAgICAgICB2YXIgbWluQXJlYSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSAodm9pZCAwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB2YXIgYXJlYSA9IGJib3hBcmVhKGNoaWxkKTtcbiAgICAgICAgICAgIHZhciBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblJCdXNoLnByb3RvdHlwZS5faW5zZXJ0ID0gZnVuY3Rpb24gX2luc2VydCAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuICAgIHZhciBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRoaXMudG9CQm94KGl0ZW0pO1xuICAgIHZhciBpbnNlcnRQYXRoID0gW107XG5cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIH0gZWxzZSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xufTtcblxuLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG5SQnVzaC5wcm90b3R5cGUuX3NwbGl0ID0gZnVuY3Rpb24gX3NwbGl0IChpbnNlcnRQYXRoLCBsZXZlbCkge1xuICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF07XG4gICAgdmFyIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSk7XG4gICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgaWYgKGxldmVsKSB7IGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpOyB9XG4gICAgZWxzZSB7IHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTsgfVxufTtcblxuUkJ1c2gucHJvdG90eXBlLl9zcGxpdFJvb3QgPSBmdW5jdGlvbiBfc3BsaXRSb290IChub2RlLCBuZXdOb2RlKSB7XG4gICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgdGhpcy5kYXRhLmxlYWYgPSBmYWxzZTtcbiAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbn07XG5cblJCdXNoLnByb3RvdHlwZS5fY2hvb3NlU3BsaXRJbmRleCA9IGZ1bmN0aW9uIF9jaG9vc2VTcGxpdEluZGV4IChub2RlLCBtLCBNKSB7XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciBtaW5PdmVybGFwID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgdmFyIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB2YXIgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgdmFyIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgIHZhciBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4IHx8IE0gLSBtO1xufTtcblxuLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuUkJ1c2gucHJvdG90eXBlLl9jaG9vc2VTcGxpdEF4aXMgPSBmdW5jdGlvbiBfY2hvb3NlU3BsaXRBeGlzIChub2RlLCBtLCBNKSB7XG4gICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWDtcbiAgICB2YXIgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZO1xuICAgIHZhciB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCk7XG4gICAgdmFyIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSB7IG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7IH1cbn07XG5cbi8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG5SQnVzaC5wcm90b3R5cGUuX2FsbERpc3RNYXJnaW4gPSBmdW5jdGlvbiBfYWxsRGlzdE1hcmdpbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveDtcbiAgICB2YXIgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpO1xuICAgIHZhciByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KTtcbiAgICB2YXIgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG5cbiAgICBmb3IgKHZhciBpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQxID0gTSAtIG0gLSAxOyBpJDEgPj0gbTsgaSQxLS0pIHtcbiAgICAgICAgdmFyIGNoaWxkJDEgPSBub2RlLmNoaWxkcmVuW2kkMV07XG4gICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCQxKSA6IGNoaWxkJDEpO1xuICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJnaW47XG59O1xuXG5SQnVzaC5wcm90b3R5cGUuX2FkanVzdFBhcmVudEJCb3hlcyA9IGZ1bmN0aW9uIF9hZGp1c3RQYXJlbnRCQm94ZXMgKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgfVxufTtcblxuUkJ1c2gucHJvdG90eXBlLl9jb25kZW5zZSA9IGZ1bmN0aW9uIF9jb25kZW5zZSAocGF0aCkge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5ncyA9ICh2b2lkIDApOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICB9IGVsc2UgeyB0aGlzLmNsZWFyKCk7IH1cblxuICAgICAgICB9IGVsc2UgeyBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7IH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSXRlbShpdGVtLCBpdGVtcywgZXF1YWxzRm4pIHtcbiAgICBpZiAoIWVxdWFsc0ZuKSB7IHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSB7IGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTsgfVxuICAgIGRlc3ROb2RlLm1pblggPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5taW5ZID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WCA9IC1JbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IGs7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCk7XG4gICAgdmFyIG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSk7XG4gICAgdmFyIG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCk7XG4gICAgdmFyIG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluWCA8PSBiLm1pblggJiZcbiAgICAgICAgICAgYS5taW5ZIDw9IGIubWluWSAmJlxuICAgICAgICAgICBiLm1heFggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWF4WSA8PSBhLm1heFk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICAgIHJldHVybiBiLm1pblggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWluWSA8PSBhLm1heFkgJiZcbiAgICAgICAgICAgYi5tYXhYID49IGEubWluWCAmJlxuICAgICAgICAgICBiLm1heFkgPj0gYS5taW5ZO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcbiAgICB9O1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBtaWQsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuXG5yZXR1cm4gUkJ1c2g7XG5cbn0pKTtcbn0ocmJ1c2gpKTtcblxudmFyIFJCdXNoID0gcmJ1c2guZXhwb3J0cztcblxudmFyIFNoYXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChTaGFwZSkge1xuICBTaGFwZVtcIkdST1VQXCJdID0gXCJnXCI7XG4gIFNoYXBlW1wiRlJBR01FTlRcIl0gPSBcImZyYWdtZW50XCI7XG4gIFNoYXBlW1wiQ0lSQ0xFXCJdID0gXCJjaXJjbGVcIjtcbiAgU2hhcGVbXCJFTExJUFNFXCJdID0gXCJlbGxpcHNlXCI7XG4gIFNoYXBlW1wiSU1BR0VcIl0gPSBcImltYWdlXCI7XG4gIFNoYXBlW1wiUkVDVFwiXSA9IFwicmVjdFwiO1xuICBTaGFwZVtcIkxJTkVcIl0gPSBcImxpbmVcIjtcbiAgU2hhcGVbXCJQT0xZTElORVwiXSA9IFwicG9seWxpbmVcIjtcbiAgU2hhcGVbXCJQT0xZR09OXCJdID0gXCJwb2x5Z29uXCI7XG4gIFNoYXBlW1wiVEVYVFwiXSA9IFwidGV4dFwiO1xuICBTaGFwZVtcIlBBVEhcIl0gPSBcInBhdGhcIjtcbiAgU2hhcGVbXCJIVE1MXCJdID0gXCJodG1sXCI7XG4gIFNoYXBlW1wiTUVTSFwiXSA9IFwibWVzaFwiO1xuICByZXR1cm4gU2hhcGU7XG59KHt9KTtcblxuLy8gcHJldHRpZXItaWdub3JlXG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG4vLyBDdXJzb3Igc3R5bGVcbi8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2N1cnNvclxuXG52YXIgQ2xpcFNwYWNlTmVhclogPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKENsaXBTcGFjZU5lYXJaKSB7XG4gIENsaXBTcGFjZU5lYXJaW0NsaXBTcGFjZU5lYXJaW1wiWkVST1wiXSA9IDBdID0gXCJaRVJPXCI7XG4gIENsaXBTcGFjZU5lYXJaW0NsaXBTcGFjZU5lYXJaW1wiTkVHQVRJVkVfT05FXCJdID0gMV0gPSBcIk5FR0FUSVZFX09ORVwiO1xuICByZXR1cm4gQ2xpcFNwYWNlTmVhclo7XG59KHt9KTtcblxuLyoqXG4gKiBlZy4gTm9kZUNhbnZhcywgT2Zmc2NyZWVuQ2FudmFzLCBIVE1MQ2FudmFzRWxlbWVudFxuICovXG5cbi8qKlxuICogVGhlIGZvcm1hdCB0byB1c2Ugd2hlbiBkZWZpbmluZyBjdXN0b20gZWFzaW5nIGZ1bmN0aW9uc1xuICovXG5cbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3poYW5iYS9wYWlseWUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZmxleC9zcmMvdHlwZXMudHNcblxudmFyIEFic3RyYWN0UmVuZGVyZXJQbHVnaW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBYnN0cmFjdFJlbmRlcmVyUGx1Z2luKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdFJlbmRlcmVyUGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFic3RyYWN0UmVuZGVyZXJQbHVnaW4sIFt7XG4gICAga2V5OiBcImFkZFJlbmRlcmluZ1BsdWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZW5kZXJpbmdQbHVnaW4ocGx1Z2luKSB7XG4gICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgdGhpcy5jb250ZXh0LnJlbmRlcmluZ1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBbGxSZW5kZXJpbmdQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbFJlbmRlcmluZ1BsdWdpbnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5jb250ZXh0LnJlbmRlcmluZ1BsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIF90aGlzLmNvbnRleHQucmVuZGVyaW5nUGx1Z2lucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBBYnN0cmFjdFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RSZW5kZXJlcihjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RSZW5kZXJlcik7XG4gICAgdGhpcy5jbGlwU3BhY2VOZWFyWiA9IENsaXBTcGFjZU5lYXJaLk5FR0FUSVZFX09ORTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICB0aGlzLmNvbmZpZyA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgLyoqXG4gICAgICAgKiBvbmx5IGRpcnR5IG9iamVjdCB3aWxsIGNhdXNlIHJlLXJlbmRlclxuICAgICAgICovXG4gICAgICBlbmFibGVEaXJ0eUNoZWNrOiB0cnVlLFxuICAgICAgZW5hYmxlQ3VsbGluZzogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIGVuYWJsZSBhdXRvIHJlbmRlcmluZyBieSBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIGVuYWJsZUF1dG9SZW5kZXJpbmc6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIGVuYWJsZSBkaXJ0eSByZWN0YW5nbGUgcmVuZGVyaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgZW5hYmxlRGlydHlSZWN0YW5nbGVSZW5kZXJpbmc6IHRydWUsXG4gICAgICBlbmFibGVEaXJ0eVJlY3RhbmdsZVJlbmRlcmluZ0RlYnVnOiBmYWxzZSxcbiAgICAgIGVuYWJsZVNpemVBdHRlbnVhdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZVJlbmRlcmluZ09wdGltaXphdGlvbjogZmFsc2VcbiAgICB9LCBjb25maWcpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWJzdHJhY3RSZW5kZXJlciwgW3tcbiAgICBrZXk6IFwicmVnaXN0ZXJQbHVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnBsdWdpbnMuZmluZEluZGV4KGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwID09PSBwbHVnaW47XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5yZWdpc3RlclBsdWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5wbHVnaW5zLmZpbmRJbmRleChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcCA9PT0gcGx1Z2luO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnBsdWdpbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGx1Z2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbHVnaW5zKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGx1Z2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW5zLmZpbmQoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLm5hbWUgPT09IG5hbWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBhZGRWZWMzID0gdmVjMy5hZGQsXG4gIGNvcHlWZWMzID0gdmVjMy5jb3B5LFxuICBtYXhWZWMzID0gdmVjMy5tYXgsXG4gIG1pblZlYzMgPSB2ZWMzLm1pbixcbiAgc2NhbGVWZWMzID0gdmVjMy5zY2FsZSxcbiAgc3ViVmVjMyA9IHZlYzMuc3ViO1xuXG4vKipcbiAqIEF4aXMtQWxpZ25lZCBCb3VuZGluZyBCb3hcbiAqIOS4uuS6huS+v+S6juWQjue7rSBGcnVzdHVtIEN1bGxpbmfvvIzpgJrov4fmn6Xmib7ooajlrprkuYkgcC12ZXJ0ZXgg5ZKMIG4tdmVydGV4XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnR2aXMvR1dlYkdQVUVuZ2luZS9pc3N1ZXMvM1xuICovXG52YXIgQUFCQiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFBQkIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFBQkIpO1xuICAgIHRoaXMuY2VudGVyID0gWzAsIDAsIDBdO1xuICAgIHRoaXMuaGFsZkV4dGVudHMgPSBbMCwgMCwgMF07XG4gICAgdGhpcy5taW4gPSBbMCwgMCwgMF07XG4gICAgdGhpcy5tYXggPSBbMCwgMCwgMF07XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBQUJCLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGNlbnRlciwgaGFsZkV4dGVudHMpIHtcbiAgICAgIGNvcHlWZWMzKHRoaXMuY2VudGVyLCBjZW50ZXIpO1xuICAgICAgY29weVZlYzModGhpcy5oYWxmRXh0ZW50cywgaGFsZkV4dGVudHMpO1xuICAgICAgc3ViVmVjMyh0aGlzLm1pbiwgdGhpcy5jZW50ZXIsIHRoaXMuaGFsZkV4dGVudHMpO1xuICAgICAgYWRkVmVjMyh0aGlzLm1heCwgdGhpcy5jZW50ZXIsIHRoaXMuaGFsZkV4dGVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNaW5NYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWluTWF4KG1pbiwgbWF4KSB7XG4gICAgICBhZGRWZWMzKHRoaXMuY2VudGVyLCBtYXgsIG1pbik7XG4gICAgICBzY2FsZVZlYzModGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyLCAwLjUpO1xuICAgICAgc3ViVmVjMyh0aGlzLmhhbGZFeHRlbnRzLCBtYXgsIG1pbik7XG4gICAgICBzY2FsZVZlYzModGhpcy5oYWxmRXh0ZW50cywgdGhpcy5oYWxmRXh0ZW50cywgMC41KTtcbiAgICAgIGNvcHlWZWMzKHRoaXMubWluLCBtaW4pO1xuICAgICAgY29weVZlYzModGhpcy5tYXgsIG1heCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoYWFiYikge1xuICAgICAgaWYgKEFBQkIuaXNFbXB0eShhYWJiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoQUFCQi5pc0VtcHR5KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuc2V0TWluTWF4KGFhYmIuZ2V0TWluKCksIGFhYmIuZ2V0TWF4KCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGMgPSB0aGlzLmNlbnRlcjtcbiAgICAgIHZhciB0Y3ggPSB0Y1swXTtcbiAgICAgIHZhciB0Y3kgPSB0Y1sxXTtcbiAgICAgIHZhciB0Y3ogPSB0Y1syXTtcbiAgICAgIHZhciB0aCA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgICB2YXIgdGh4ID0gdGhbMF07XG4gICAgICB2YXIgdGh5ID0gdGhbMV07XG4gICAgICB2YXIgdGh6ID0gdGhbMl07XG4gICAgICB2YXIgdG1pbnggPSB0Y3ggLSB0aHg7XG4gICAgICB2YXIgdG1heHggPSB0Y3ggKyB0aHg7XG4gICAgICB2YXIgdG1pbnkgPSB0Y3kgLSB0aHk7XG4gICAgICB2YXIgdG1heHkgPSB0Y3kgKyB0aHk7XG4gICAgICB2YXIgdG1pbnogPSB0Y3ogLSB0aHo7XG4gICAgICB2YXIgdG1heHogPSB0Y3ogKyB0aHo7XG4gICAgICB2YXIgb2MgPSBhYWJiLmNlbnRlcjtcbiAgICAgIHZhciBvY3ggPSBvY1swXTtcbiAgICAgIHZhciBvY3kgPSBvY1sxXTtcbiAgICAgIHZhciBvY3ogPSBvY1syXTtcbiAgICAgIHZhciBvaCA9IGFhYmIuaGFsZkV4dGVudHM7XG4gICAgICB2YXIgb2h4ID0gb2hbMF07XG4gICAgICB2YXIgb2h5ID0gb2hbMV07XG4gICAgICB2YXIgb2h6ID0gb2hbMl07XG4gICAgICB2YXIgb21pbnggPSBvY3ggLSBvaHg7XG4gICAgICB2YXIgb21heHggPSBvY3ggKyBvaHg7XG4gICAgICB2YXIgb21pbnkgPSBvY3kgLSBvaHk7XG4gICAgICB2YXIgb21heHkgPSBvY3kgKyBvaHk7XG4gICAgICB2YXIgb21pbnogPSBvY3ogLSBvaHo7XG4gICAgICB2YXIgb21heHogPSBvY3ogKyBvaHo7XG4gICAgICBpZiAob21pbnggPCB0bWlueCkge1xuICAgICAgICB0bWlueCA9IG9taW54O1xuICAgICAgfVxuICAgICAgaWYgKG9tYXh4ID4gdG1heHgpIHtcbiAgICAgICAgdG1heHggPSBvbWF4eDtcbiAgICAgIH1cbiAgICAgIGlmIChvbWlueSA8IHRtaW55KSB7XG4gICAgICAgIHRtaW55ID0gb21pbnk7XG4gICAgICB9XG4gICAgICBpZiAob21heHkgPiB0bWF4eSkge1xuICAgICAgICB0bWF4eSA9IG9tYXh5O1xuICAgICAgfVxuICAgICAgaWYgKG9taW56IDwgdG1pbnopIHtcbiAgICAgICAgdG1pbnogPSBvbWluejtcbiAgICAgIH1cbiAgICAgIGlmIChvbWF4eiA+IHRtYXh6KSB7XG4gICAgICAgIHRtYXh6ID0gb21heHo7XG4gICAgICB9XG4gICAgICB0Y1swXSA9ICh0bWlueCArIHRtYXh4KSAqIDAuNTtcbiAgICAgIHRjWzFdID0gKHRtaW55ICsgdG1heHkpICogMC41O1xuICAgICAgdGNbMl0gPSAodG1pbnogKyB0bWF4eikgKiAwLjU7XG4gICAgICB0aFswXSA9ICh0bWF4eCAtIHRtaW54KSAqIDAuNTtcbiAgICAgIHRoWzFdID0gKHRtYXh5IC0gdG1pbnkpICogMC41O1xuICAgICAgdGhbMl0gPSAodG1heHogLSB0bWlueikgKiAwLjU7XG4gICAgICB0aGlzLm1pblswXSA9IHRtaW54O1xuICAgICAgdGhpcy5taW5bMV0gPSB0bWlueTtcbiAgICAgIHRoaXMubWluWzJdID0gdG1pbno7XG4gICAgICB0aGlzLm1heFswXSA9IHRtYXh4O1xuICAgICAgdGhpcy5tYXhbMV0gPSB0bWF4eTtcbiAgICAgIHRoaXMubWF4WzJdID0gdG1heHo7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21UcmFuc2Zvcm1lZEFBQkJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVRyYW5zZm9ybWVkQUFCQihhYWJiLCBtKSB7XG4gICAgICB2YXIgYmMgPSB0aGlzLmNlbnRlcjtcbiAgICAgIHZhciBiciA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgICB2YXIgYWMgPSBhYWJiLmNlbnRlcjtcbiAgICAgIHZhciBhciA9IGFhYmIuaGFsZkV4dGVudHM7XG4gICAgICB2YXIgbXgwID0gbVswXTtcbiAgICAgIHZhciBteDEgPSBtWzRdO1xuICAgICAgdmFyIG14MiA9IG1bOF07XG4gICAgICB2YXIgbXkwID0gbVsxXTtcbiAgICAgIHZhciBteTEgPSBtWzVdO1xuICAgICAgdmFyIG15MiA9IG1bOV07XG4gICAgICB2YXIgbXowID0gbVsyXTtcbiAgICAgIHZhciBtejEgPSBtWzZdO1xuICAgICAgdmFyIG16MiA9IG1bMTBdO1xuICAgICAgdmFyIG14MGEgPSBNYXRoLmFicyhteDApO1xuICAgICAgdmFyIG14MWEgPSBNYXRoLmFicyhteDEpO1xuICAgICAgdmFyIG14MmEgPSBNYXRoLmFicyhteDIpO1xuICAgICAgdmFyIG15MGEgPSBNYXRoLmFicyhteTApO1xuICAgICAgdmFyIG15MWEgPSBNYXRoLmFicyhteTEpO1xuICAgICAgdmFyIG15MmEgPSBNYXRoLmFicyhteTIpO1xuICAgICAgdmFyIG16MGEgPSBNYXRoLmFicyhtejApO1xuICAgICAgdmFyIG16MWEgPSBNYXRoLmFicyhtejEpO1xuICAgICAgdmFyIG16MmEgPSBNYXRoLmFicyhtejIpO1xuICAgICAgYmNbMF0gPSBtWzEyXSArIG14MCAqIGFjWzBdICsgbXgxICogYWNbMV0gKyBteDIgKiBhY1syXTtcbiAgICAgIGJjWzFdID0gbVsxM10gKyBteTAgKiBhY1swXSArIG15MSAqIGFjWzFdICsgbXkyICogYWNbMl07XG4gICAgICBiY1syXSA9IG1bMTRdICsgbXowICogYWNbMF0gKyBtejEgKiBhY1sxXSArIG16MiAqIGFjWzJdO1xuXG4gICAgICAvLyB2ZWMzLnNldChcbiAgICAgIC8vICAgYmMsXG4gICAgICAvLyAgIG1bMTJdICsgbXgwICogYWNbMF0gKyBteDEgKiBhY1sxXSArIG14MiAqIGFjWzJdLFxuICAgICAgLy8gICBtWzEzXSArIG15MCAqIGFjWzBdICsgbXkxICogYWNbMV0gKyBteTIgKiBhY1syXSxcbiAgICAgIC8vICAgbVsxNF0gKyBtejAgKiBhY1swXSArIG16MSAqIGFjWzFdICsgbXoyICogYWNbMl0sXG4gICAgICAvLyApO1xuXG4gICAgICBiclswXSA9IG14MGEgKiBhclswXSArIG14MWEgKiBhclsxXSArIG14MmEgKiBhclsyXTtcbiAgICAgIGJyWzFdID0gbXkwYSAqIGFyWzBdICsgbXkxYSAqIGFyWzFdICsgbXkyYSAqIGFyWzJdO1xuICAgICAgYnJbMl0gPSBtejBhICogYXJbMF0gKyBtejFhICogYXJbMV0gKyBtejJhICogYXJbMl07XG5cbiAgICAgIC8vIHZlYzMuc2V0KFxuICAgICAgLy8gICBicixcbiAgICAgIC8vICAgbXgwYSAqIGFyWzBdICsgbXgxYSAqIGFyWzFdICsgbXgyYSAqIGFyWzJdLFxuICAgICAgLy8gICBteTBhICogYXJbMF0gKyBteTFhICogYXJbMV0gKyBteTJhICogYXJbMl0sXG4gICAgICAvLyAgIG16MGEgKiBhclswXSArIG16MWEgKiBhclsxXSArIG16MmEgKiBhclsyXSxcbiAgICAgIC8vICk7XG5cbiAgICAgIC8vIHRoaXMubWluID0gdmVjMy5zdWIodGhpcy5taW4sIGJjLCBicik7XG4gICAgICAvLyB0aGlzLm1heCA9IHZlYzMuYWRkKHRoaXMubWF4LCBiYywgYnIpO1xuXG4gICAgICBzdWJWZWMzKHRoaXMubWluLCBiYywgYnIpO1xuICAgICAgYWRkVmVjMyh0aGlzLm1heCwgYmMsIGJyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzKGFhYmIpIHtcbiAgICAgIHZhciBhTWF4ID0gdGhpcy5nZXRNYXgoKTtcbiAgICAgIHZhciBhTWluID0gdGhpcy5nZXRNaW4oKTtcbiAgICAgIHZhciBiTWF4ID0gYWFiYi5nZXRNYXgoKTtcbiAgICAgIHZhciBiTWluID0gYWFiYi5nZXRNaW4oKTtcbiAgICAgIHJldHVybiBhTWluWzBdIDw9IGJNYXhbMF0gJiYgYU1heFswXSA+PSBiTWluWzBdICYmIGFNaW5bMV0gPD0gYk1heFsxXSAmJiBhTWF4WzFdID49IGJNaW5bMV0gJiYgYU1pblsyXSA8PSBiTWF4WzJdICYmIGFNYXhbMl0gPj0gYk1pblsyXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdGlvbihhYWJiKSB7XG4gICAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhhYWJiKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgQUFCQigpO1xuICAgICAgdmFyIG1pbiA9IG1heFZlYzMoWzAsIDAsIDBdLCB0aGlzLmdldE1pbigpLCBhYWJiLmdldE1pbigpKTtcbiAgICAgIHZhciBtYXggPSBtaW5WZWMzKFswLCAwLCAwXSwgdGhpcy5nZXRNYXgoKSwgYWFiYi5nZXRNYXgoKSk7XG4gICAgICBpbnRlcnNlY3Rpb24uc2V0TWluTWF4KG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IG4tdmVydGV4XG4gICAgICogQHBhcmFtIHBsYW5lIHBsYW5lIG9mIEN1bGxpbmdWb2x1bWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXROZWdhdGl2ZUZhclBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5lZ2F0aXZlRmFyUG9pbnQocGxhbmUpIHtcbiAgICAgIGlmIChwbGFuZS5wblZlcnRleEZsYWcgPT09IDB4MTExKSB7XG4gICAgICAgIHJldHVybiBjb3B5VmVjMyhbMCwgMCwgMF0sIHRoaXMubWluKTtcbiAgICAgICAgLy8gcmV0dXJuIHZlYzMuY29weSh2ZWMzLmNyZWF0ZSgpLCB0aGlzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAocGxhbmUucG5WZXJ0ZXhGbGFnID09PSAweDExMCkge1xuICAgICAgICByZXR1cm4gW3RoaXMubWluWzBdLCB0aGlzLm1pblsxXSwgdGhpcy5tYXhbMl1dO1xuICAgICAgICAvLyByZXR1cm4gdmVjMy5mcm9tVmFsdWVzKHRoaXMubWluWzBdLCB0aGlzLm1pblsxXSwgdGhpcy5tYXhbMl0pO1xuICAgICAgfVxuICAgICAgaWYgKHBsYW5lLnBuVmVydGV4RmxhZyA9PT0gMHgxMDEpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm1pblswXSwgdGhpcy5tYXhbMV0sIHRoaXMubWluWzJdXTtcbiAgICAgICAgLy8gcmV0dXJuIHZlYzMuZnJvbVZhbHVlcyh0aGlzLm1pblswXSwgdGhpcy5tYXhbMV0sIHRoaXMubWluWzJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFuZS5wblZlcnRleEZsYWcgPT09IDB4MTAwKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5taW5bMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1heFsyXV07XG4gICAgICAgIC8vIHJldHVybiB2ZWMzLmZyb21WYWx1ZXModGhpcy5taW5bMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1heFsyXSk7XG4gICAgICB9XG4gICAgICBpZiAocGxhbmUucG5WZXJ0ZXhGbGFnID09PSAweDAxMSkge1xuICAgICAgICByZXR1cm4gW3RoaXMubWF4WzBdLCB0aGlzLm1pblsxXSwgdGhpcy5taW5bMl1dO1xuICAgICAgICAvLyByZXR1cm4gdmVjMy5mcm9tVmFsdWVzKHRoaXMubWF4WzBdLCB0aGlzLm1pblsxXSwgdGhpcy5taW5bMl0pO1xuICAgICAgfVxuICAgICAgaWYgKHBsYW5lLnBuVmVydGV4RmxhZyA9PT0gMHgwMTApIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm1heFswXSwgdGhpcy5taW5bMV0sIHRoaXMubWF4WzJdXTtcbiAgICAgICAgLy8gcmV0dXJuIHZlYzMuZnJvbVZhbHVlcyh0aGlzLm1heFswXSwgdGhpcy5taW5bMV0sIHRoaXMubWF4WzJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFuZS5wblZlcnRleEZsYWcgPT09IDB4MDAxKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5tYXhbMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1pblsyXV07XG4gICAgICAgIC8vIHJldHVybiB2ZWMzLmZyb21WYWx1ZXModGhpcy5tYXhbMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1pblsyXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3RoaXMubWF4WzBdLCB0aGlzLm1heFsxXSwgdGhpcy5tYXhbMl1dO1xuICAgICAgLy8gcmV0dXJuIHZlYzMuZnJvbVZhbHVlcyh0aGlzLm1heFswXSwgdGhpcy5tYXhbMV0sIHRoaXMubWF4WzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgcC12ZXJ0ZXhcbiAgICAgKiBAcGFyYW0gcGxhbmUgcGxhbmUgb2YgQ3VsbGluZ1ZvbHVtZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aXZlRmFyUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpdmVGYXJQb2ludChwbGFuZSkge1xuICAgICAgaWYgKHBsYW5lLnBuVmVydGV4RmxhZyA9PT0gMHgxMTEpIHtcbiAgICAgICAgcmV0dXJuIGNvcHlWZWMzKFswLCAwLCAwXSwgdGhpcy5tYXgpO1xuICAgICAgICAvLyByZXR1cm4gdmVjMy5jb3B5KHZlYzMuY3JlYXRlKCksIHRoaXMubWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFuZS5wblZlcnRleEZsYWcgPT09IDB4MTEwKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5tYXhbMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1pblsyXV07XG4gICAgICAgIC8vIHJldHVybiB2ZWMzLmZyb21WYWx1ZXModGhpcy5tYXhbMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1pblsyXSk7XG4gICAgICB9XG4gICAgICBpZiAocGxhbmUucG5WZXJ0ZXhGbGFnID09PSAweDEwMSkge1xuICAgICAgICByZXR1cm4gW3RoaXMubWF4WzBdLCB0aGlzLm1pblsxXSwgdGhpcy5tYXhbMl1dO1xuICAgICAgICAvLyByZXR1cm4gdmVjMy5mcm9tVmFsdWVzKHRoaXMubWF4WzBdLCB0aGlzLm1pblsxXSwgdGhpcy5tYXhbMl0pO1xuICAgICAgfVxuICAgICAgaWYgKHBsYW5lLnBuVmVydGV4RmxhZyA9PT0gMHgxMDApIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm1heFswXSwgdGhpcy5taW5bMV0sIHRoaXMubWluWzJdXTtcbiAgICAgICAgLy8gcmV0dXJuIHZlYzMuZnJvbVZhbHVlcyh0aGlzLm1heFswXSwgdGhpcy5taW5bMV0sIHRoaXMubWluWzJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFuZS5wblZlcnRleEZsYWcgPT09IDB4MDExKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5taW5bMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1heFsyXV07XG4gICAgICAgIC8vIHJldHVybiB2ZWMzLmZyb21WYWx1ZXModGhpcy5taW5bMF0sIHRoaXMubWF4WzFdLCB0aGlzLm1heFsyXSk7XG4gICAgICB9XG4gICAgICBpZiAocGxhbmUucG5WZXJ0ZXhGbGFnID09PSAweDAxMCkge1xuICAgICAgICByZXR1cm4gW3RoaXMubWluWzBdLCB0aGlzLm1heFsxXSwgdGhpcy5taW5bMl1dO1xuICAgICAgICAvLyByZXR1cm4gdmVjMy5mcm9tVmFsdWVzKHRoaXMubWluWzBdLCB0aGlzLm1heFsxXSwgdGhpcy5taW5bMl0pO1xuICAgICAgfVxuICAgICAgaWYgKHBsYW5lLnBuVmVydGV4RmxhZyA9PT0gMHgwMDEpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm1pblswXSwgdGhpcy5taW5bMV0sIHRoaXMubWF4WzJdXTtcbiAgICAgICAgLy8gcmV0dXJuIHZlYzMuZnJvbVZhbHVlcyh0aGlzLm1pblswXSwgdGhpcy5taW5bMV0sIHRoaXMubWF4WzJdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdGhpcy5taW5bMF0sIHRoaXMubWluWzFdLCB0aGlzLm1pblsyXV07XG4gICAgICAvLyByZXR1cm4gdmVjMy5mcm9tVmFsdWVzKHRoaXMubWluWzBdLCB0aGlzLm1pblsxXSwgdGhpcy5taW5bMl0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eShhYWJiKSB7XG4gICAgICByZXR1cm4gIWFhYmIgfHwgYWFiYi5oYWxmRXh0ZW50c1swXSA9PT0gMCAmJiBhYWJiLmhhbGZFeHRlbnRzWzFdID09PSAwICYmIGFhYmIuaGFsZkV4dGVudHNbMl0gPT09IDA7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBQbGFuZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBsb29rdXAgdGFibGUgZm9yIHAtdmVydGV4ICYgbi12ZXJ0ZXggd2hlbiBkb2luZyBmcnVzdHVtIGN1bGxpbmdcbiAgICovXG5cbiAgZnVuY3Rpb24gUGxhbmUoZGlzdGFuY2UsIG5vcm1hbCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGFuZSk7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlIHx8IDA7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWwgfHwgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICAgIHRoaXMudXBkYXRlUE5WZXJ0ZXhGbGFnKCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQbGFuZSwgW3tcbiAgICBrZXk6IFwidXBkYXRlUE5WZXJ0ZXhGbGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBOVmVydGV4RmxhZygpIHtcbiAgICAgIHRoaXMucG5WZXJ0ZXhGbGFnID0gKE51bWJlcih0aGlzLm5vcm1hbFswXSA+PSAwKSA8PCA4KSArIChOdW1iZXIodGhpcy5ub3JtYWxbMV0gPj0gMCkgPDwgNCkgKyBOdW1iZXIodGhpcy5ub3JtYWxbMl0gPj0gMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHJldHVybiB2ZWMzLmRvdChwb2ludCwgdGhpcy5ub3JtYWwpIC0gdGhpcy5kaXN0YW5jZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgIHZhciBpbnZMZW4gPSAxIC8gdmVjMy5sZW4odGhpcy5ub3JtYWwpO1xuICAgICAgdmVjMy5zY2FsZSh0aGlzLm5vcm1hbCwgdGhpcy5ub3JtYWwsIGludkxlbik7XG4gICAgICB0aGlzLmRpc3RhbmNlICo9IGludkxlbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmUoc3RhcnQsIGVuZCwgcG9pbnQpIHtcbiAgICAgIHZhciBkMCA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KHN0YXJ0KTtcbiAgICAgIHZhciBkMSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGVuZCk7XG4gICAgICB2YXIgdCA9IGQwIC8gKGQwIC0gZDEpO1xuICAgICAgdmFyIGludGVyc2VjdHMgPSB0ID49IDAgJiYgdCA8PSAxO1xuICAgICAgaWYgKGludGVyc2VjdHMgJiYgcG9pbnQpIHtcbiAgICAgICAgdmVjMy5sZXJwKHBvaW50LCBzdGFydCwgZW5kLCB0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgTWFzayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoTWFzaykge1xuICBNYXNrW01hc2tbXCJPVVRTSURFXCJdID0gNDI5NDk2NzI5NV0gPSBcIk9VVFNJREVcIjtcbiAgTWFza1tNYXNrW1wiSU5TSURFXCJdID0gMF0gPSBcIklOU0lERVwiO1xuICBNYXNrW01hc2tbXCJJTkRFVEVSTUlOQVRFXCJdID0gMjE0NzQ4MzY0N10gPSBcIklOREVURVJNSU5BVEVcIjtcbiAgcmV0dXJuIE1hc2s7XG59KHt9KTtcbnZhciBGcnVzdHVtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJ1c3R1bShwbGFuZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJ1c3R1bSk7XG4gICAgdGhpcy5wbGFuZXMgPSBbXTtcbiAgICBpZiAocGxhbmVzKSB7XG4gICAgICB0aGlzLnBsYW5lcyA9IHBsYW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgdGhpcy5wbGFuZXMucHVzaChuZXcgUGxhbmUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGV4dHJhY3QgNiBwbGFuZXMgZnJvbSBwcm9qZWN0aW9uTWF0cml4XG4gICAqIEBzZWUgaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTEvSFQxMi9sYWIvcGxhbmVfZXh0cmFjdGlvbi5wZGZcbiAgICovXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRnJ1c3R1bSwgW3tcbiAgICBrZXk6IFwiZXh0cmFjdEZyb21WUE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0RnJvbVZQTWF0cml4KHByb2plY3Rpb25NYXRyaXgpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHZhciBfcHJvamVjdGlvbk1hdHJpeCA9IF9zbGljZWRUb0FycmF5KHByb2plY3Rpb25NYXRyaXgsIDE2KSxcbiAgICAgICAgbTAgPSBfcHJvamVjdGlvbk1hdHJpeFswXSxcbiAgICAgICAgbTEgPSBfcHJvamVjdGlvbk1hdHJpeFsxXSxcbiAgICAgICAgbTIgPSBfcHJvamVjdGlvbk1hdHJpeFsyXSxcbiAgICAgICAgbTMgPSBfcHJvamVjdGlvbk1hdHJpeFszXSxcbiAgICAgICAgbTQgPSBfcHJvamVjdGlvbk1hdHJpeFs0XSxcbiAgICAgICAgbTUgPSBfcHJvamVjdGlvbk1hdHJpeFs1XSxcbiAgICAgICAgbTYgPSBfcHJvamVjdGlvbk1hdHJpeFs2XSxcbiAgICAgICAgbTcgPSBfcHJvamVjdGlvbk1hdHJpeFs3XSxcbiAgICAgICAgbTggPSBfcHJvamVjdGlvbk1hdHJpeFs4XSxcbiAgICAgICAgbTkgPSBfcHJvamVjdGlvbk1hdHJpeFs5XSxcbiAgICAgICAgbTEwID0gX3Byb2plY3Rpb25NYXRyaXhbMTBdLFxuICAgICAgICBtMTEgPSBfcHJvamVjdGlvbk1hdHJpeFsxMV0sXG4gICAgICAgIG0xMiA9IF9wcm9qZWN0aW9uTWF0cml4WzEyXSxcbiAgICAgICAgbTEzID0gX3Byb2plY3Rpb25NYXRyaXhbMTNdLFxuICAgICAgICBtMTQgPSBfcHJvamVjdGlvbk1hdHJpeFsxNF0sXG4gICAgICAgIG0xNSA9IF9wcm9qZWN0aW9uTWF0cml4WzE1XTtcblxuICAgICAgLy8gcmlnaHRcbiAgICAgIHZlYzMuc2V0KHRoaXMucGxhbmVzWzBdLm5vcm1hbCwgbTMgLSBtMCwgbTcgLSBtNCwgbTExIC0gbTgpO1xuICAgICAgdGhpcy5wbGFuZXNbMF0uZGlzdGFuY2UgPSBtMTUgLSBtMTI7XG5cbiAgICAgIC8vIGxlZnRcbiAgICAgIHZlYzMuc2V0KHRoaXMucGxhbmVzWzFdLm5vcm1hbCwgbTMgKyBtMCwgbTcgKyBtNCwgbTExICsgbTgpO1xuICAgICAgdGhpcy5wbGFuZXNbMV0uZGlzdGFuY2UgPSBtMTUgKyBtMTI7XG5cbiAgICAgIC8vIGJvdHRvbVxuICAgICAgdmVjMy5zZXQodGhpcy5wbGFuZXNbMl0ubm9ybWFsLCBtMyArIG0xLCBtNyArIG01LCBtMTEgKyBtOSk7XG4gICAgICB0aGlzLnBsYW5lc1syXS5kaXN0YW5jZSA9IG0xNSArIG0xMztcblxuICAgICAgLy8gdG9wXG4gICAgICB2ZWMzLnNldCh0aGlzLnBsYW5lc1szXS5ub3JtYWwsIG0zIC0gbTEsIG03IC0gbTUsIG0xMSAtIG05KTtcbiAgICAgIHRoaXMucGxhbmVzWzNdLmRpc3RhbmNlID0gbTE1IC0gbTEzO1xuXG4gICAgICAvLyBmYXJcbiAgICAgIHZlYzMuc2V0KHRoaXMucGxhbmVzWzRdLm5vcm1hbCwgbTMgLSBtMiwgbTcgLSBtNiwgbTExIC0gbTEwKTtcbiAgICAgIHRoaXMucGxhbmVzWzRdLmRpc3RhbmNlID0gbTE1IC0gbTE0O1xuXG4gICAgICAvLyBuZWFyXG4gICAgICB2ZWMzLnNldCh0aGlzLnBsYW5lc1s1XS5ub3JtYWwsIG0zICsgbTIsIG03ICsgbTYsIG0xMSArIG0xMCk7XG4gICAgICB0aGlzLnBsYW5lc1s1XS5kaXN0YW5jZSA9IG0xNSArIG0xNDtcbiAgICAgIHRoaXMucGxhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBsYW5lKSB7XG4gICAgICAgIHBsYW5lLm5vcm1hbGl6ZSgpO1xuICAgICAgICBwbGFuZS51cGRhdGVQTlZlcnRleEZsYWcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgUG9pbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb2ludCgpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9pbnQpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQb2ludCwgW3tcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weUZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weUZyb20ocCkge1xuICAgICAgdGhpcy54ID0gcC54O1xuICAgICAgdGhpcy55ID0gcC55O1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgUmVjdGFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdGFuZ2xlKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubGVmdCA9IHg7XG4gICAgdGhpcy5yaWdodCA9IHggKyB3aWR0aDtcbiAgICB0aGlzLnRvcCA9IHk7XG4gICAgdGhpcy5ib3R0b20gPSB5ICsgaGVpZ2h0O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVjdGFuZ2xlLCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge31cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21SZWN0XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NUmVjdC9mcm9tUmVjdF9zdGF0aWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUmVjdChyZWN0KSB7XG4gICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdpbGwgcmV0dXJuIGEgbmV3IHJlY3QgaW5zdGFuY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShyZWN0LCBtYXRyaXgpIHtcbiAgICAgIHZhciB0b3BMZWZ0ID0gdmVjNC5mcm9tVmFsdWVzKHJlY3QueCwgcmVjdC55LCAwLCAxKTtcbiAgICAgIHZhciB0b3BSaWdodCA9IHZlYzQuZnJvbVZhbHVlcyhyZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIDAsIDEpO1xuICAgICAgdmFyIGJvdHRvbUxlZnQgPSB2ZWM0LmZyb21WYWx1ZXMocmVjdC54LCByZWN0LnkgKyByZWN0LmhlaWdodCwgMCwgMSk7XG4gICAgICB2YXIgYm90dG9tUmlnaHQgPSB2ZWM0LmZyb21WYWx1ZXMocmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55ICsgcmVjdC5oZWlnaHQsIDAsIDEpO1xuICAgICAgdmFyIHRyYW5zZm9ybWVkVG9wTGVmdCA9IHZlYzQuY3JlYXRlKCk7XG4gICAgICB2YXIgdHJhbnNmb3JtZWRUb3BSaWdodCA9IHZlYzQuY3JlYXRlKCk7XG4gICAgICB2YXIgdHJhbnNmb3JtZWRCb3R0b21MZWZ0ID0gdmVjNC5jcmVhdGUoKTtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZEJvdHRvbVJpZ2h0ID0gdmVjNC5jcmVhdGUoKTtcbiAgICAgIHZlYzQudHJhbnNmb3JtTWF0NCh0cmFuc2Zvcm1lZFRvcExlZnQsIHRvcExlZnQsIG1hdHJpeCk7XG4gICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodHJhbnNmb3JtZWRUb3BSaWdodCwgdG9wUmlnaHQsIG1hdHJpeCk7XG4gICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodHJhbnNmb3JtZWRCb3R0b21MZWZ0LCBib3R0b21MZWZ0LCBtYXRyaXgpO1xuICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KHRyYW5zZm9ybWVkQm90dG9tUmlnaHQsIGJvdHRvbVJpZ2h0LCBtYXRyaXgpO1xuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbih0cmFuc2Zvcm1lZFRvcExlZnRbMF0sIHRyYW5zZm9ybWVkVG9wUmlnaHRbMF0sIHRyYW5zZm9ybWVkQm90dG9tTGVmdFswXSwgdHJhbnNmb3JtZWRCb3R0b21SaWdodFswXSk7XG4gICAgICB2YXIgbWluWSA9IE1hdGgubWluKHRyYW5zZm9ybWVkVG9wTGVmdFsxXSwgdHJhbnNmb3JtZWRUb3BSaWdodFsxXSwgdHJhbnNmb3JtZWRCb3R0b21MZWZ0WzFdLCB0cmFuc2Zvcm1lZEJvdHRvbVJpZ2h0WzFdKTtcbiAgICAgIHZhciBtYXhYID0gTWF0aC5tYXgodHJhbnNmb3JtZWRUb3BMZWZ0WzBdLCB0cmFuc2Zvcm1lZFRvcFJpZ2h0WzBdLCB0cmFuc2Zvcm1lZEJvdHRvbUxlZnRbMF0sIHRyYW5zZm9ybWVkQm90dG9tUmlnaHRbMF0pO1xuICAgICAgdmFyIG1heFkgPSBNYXRoLm1heCh0cmFuc2Zvcm1lZFRvcExlZnRbMV0sIHRyYW5zZm9ybWVkVG9wUmlnaHRbMV0sIHRyYW5zZm9ybWVkQm90dG9tTGVmdFsxXSwgdHJhbnNmb3JtZWRCb3R0b21SaWdodFsxXSk7XG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLmZyb21SZWN0KHtcbiAgICAgICAgeDogbWluWCxcbiAgICAgICAgeTogbWluWSxcbiAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJztcbnZhciBFUlJPUl9NU0dfVVNFX0RPQ1VNRU5UX0VMRU1FTlQgPSAnVXNlIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCBpbnN0ZWFkLic7XG52YXIgRVJST1JfTVNHX0FQUEVORF9ERVNUUk9ZRURfRUxFTUVOVCA9ICdDYW5ub3QgYXBwZW5kIGEgZGVzdHJveWVkIGVsZW1lbnQuJztcblxuZnVuY3Rpb24gZ2V0QW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoYW5nbGUgPiAzNjAgfHwgYW5nbGUgPCAtMzYwKSB7XG4gICAgcmV0dXJuIGFuZ2xlICUgMzYwO1xuICB9XG4gIHJldHVybiBhbmdsZTtcbn1cbnZhciAkdmVjMyQyID0gdmVjMy5jcmVhdGUoKTtcbmZ1bmN0aW9uIGNyZWF0ZVZlYzMoeCkge1xuICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIHZhciBjbG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gY2xvbmUgPyB2ZWMzLmNsb25lKHgpIDogdmVjMy5jb3B5KCR2ZWMzJDIsIHgpO1xuICB9XG4gIGlmIChpc051bWJlcih4KSkge1xuICAgIHJldHVybiBjbG9uZSA/IHZlYzMuZnJvbVZhbHVlcyh4LCB5LCB6KSA6IHZlYzMuc2V0KCR2ZWMzJDIsIHgsIHksIHopO1xuICB9XG4gIHJldHVybiBjbG9uZSA/IHZlYzMuZnJvbVZhbHVlcyh4WzBdLCB4WzFdIHx8IHksIHhbMl0gfHwgeikgOiB2ZWMzLnNldCgkdmVjMyQyLCB4WzBdLCB4WzFdIHx8IHksIHhbMl0gfHwgeik7XG59XG52YXIgREVHX1JBRCA9IE1hdGguUEkgLyAxODA7XG5mdW5jdGlvbiBkZWcycmFkKGRlZykge1xuICByZXR1cm4gZGVnICogREVHX1JBRDtcbn1cbnZhciBSQURfREVHID0gMTgwIC8gTWF0aC5QSTtcbmZ1bmN0aW9uIHJhZDJkZWcocmFkKSB7XG4gIHJldHVybiByYWQgKiBSQURfREVHO1xufVxudmFyIEdSQURfREVHID0gMC45OyAvLyAzNjAgLyA0MDA7XG5mdW5jdGlvbiBncmFkMmRlZyhncmFkcykge1xuICBncmFkcyAlPSA0MDA7XG4gIGlmIChncmFkcyA8IDApIHtcbiAgICBncmFkcyArPSA0MDA7XG4gIH1cbiAgcmV0dXJuIGdyYWRzICogR1JBRF9ERUc7XG59XG5mdW5jdGlvbiBkZWcydHVybihkZWcpIHtcbiAgcmV0dXJuIGRlZyAvIDM2MDtcbn1cbmZ1bmN0aW9uIHR1cm4yZGVnKHR1cm4pIHtcbiAgcmV0dXJuIDM2MCAqIHR1cm47XG59XG52YXIgSEFMRl9QSSA9IE1hdGguUEkgLyAyO1xuZnVuY3Rpb24gZ2V0RXVsZXJGcm9tUXVhdChvdXQsIHF1YXQpIHtcbiAgdmFyIHggPSBxdWF0WzBdO1xuICB2YXIgeSA9IHF1YXRbMV07XG4gIHZhciB6ID0gcXVhdFsyXTtcbiAgdmFyIHcgPSBxdWF0WzNdO1xuICB2YXIgeDIgPSB4ICogeDtcbiAgdmFyIHkyID0geSAqIHk7XG4gIHZhciB6MiA9IHogKiB6O1xuICB2YXIgdzIgPSB3ICogdztcbiAgdmFyIHVuaXQgPSB4MiArIHkyICsgejIgKyB3MjtcbiAgdmFyIHRlc3QgPSB4ICogdyAtIHkgKiB6O1xuICBpZiAodGVzdCA+IDAuNDk5OTk1ICogdW5pdCkge1xuICAgIC8vIFRPRE86IFVzZSBnbG1hdHJpeC5FUFNJTE9OXG4gICAgLy8gc2luZ3VsYXJpdHkgYXQgdGhlIG5vcnRoIHBvbGVcbiAgICBvdXRbMF0gPSBIQUxGX1BJO1xuICAgIG91dFsxXSA9IDIgKiBNYXRoLmF0YW4yKHksIHgpO1xuICAgIG91dFsyXSA9IDA7XG4gIH0gZWxzZSBpZiAodGVzdCA8IC0wLjQ5OTk5NSAqIHVuaXQpIHtcbiAgICAvLyBUT0RPOiBVc2UgZ2xtYXRyaXguRVBTSUxPTlxuICAgIC8vIHNpbmd1bGFyaXR5IGF0IHRoZSBzb3V0aCBwb2xlXG4gICAgb3V0WzBdID0gLUhBTEZfUEk7XG4gICAgb3V0WzFdID0gMiAqIE1hdGguYXRhbjIoeSwgeCk7XG4gICAgb3V0WzJdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBNYXRoLmFzaW4oMiAqICh4ICogeiAtIHcgKiB5KSk7XG4gICAgb3V0WzFdID0gTWF0aC5hdGFuMigyICogKHggKiB3ICsgeSAqIHopLCAxIC0gMiAqICh6MiArIHcyKSk7XG4gICAgb3V0WzJdID0gTWF0aC5hdGFuMigyICogKHggKiB5ICsgeiAqIHcpLCAxIC0gMiAqICh5MiArIHoyKSk7XG4gIH1cbiAgLy8gVE9ETzogUmV0dXJuIHRoZW0gYXMgZGVncmVlcyBhbmQgbm90IGFzIHJhZGlhbnNcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGdldEV1bGVyRnJvbU1hdDQob3V0LCBtKSB7XG4gIHZhciB4O1xuICB2YXIgejtcbiAgdmFyIF9tYXQ0JGdldFNjYWxpbmcgPSBtYXQ0LmdldFNjYWxpbmcodmVjMy5jcmVhdGUoKSwgbSksXG4gICAgX21hdDQkZ2V0U2NhbGluZzIgPSBfc2xpY2VkVG9BcnJheShfbWF0NCRnZXRTY2FsaW5nLCAzKSxcbiAgICBzeCA9IF9tYXQ0JGdldFNjYWxpbmcyWzBdLFxuICAgIHN5ID0gX21hdDQkZ2V0U2NhbGluZzJbMV0sXG4gICAgc3ogPSBfbWF0NCRnZXRTY2FsaW5nMlsyXTtcbiAgdmFyIHkgPSBNYXRoLmFzaW4oLW1bMl0gLyBzeCk7XG4gIGlmICh5IDwgSEFMRl9QSSkge1xuICAgIGlmICh5ID4gLUhBTEZfUEkpIHtcbiAgICAgIHggPSBNYXRoLmF0YW4yKG1bNl0gLyBzeSwgbVsxMF0gLyBzeik7XG4gICAgICB6ID0gTWF0aC5hdGFuMihtWzFdIC8gc3gsIG1bMF0gLyBzeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdCBhIHVuaXF1ZSBzb2x1dGlvblxuICAgICAgeiA9IDA7XG4gICAgICB4ID0gLU1hdGguYXRhbjIobVs0XSAvIHN5LCBtWzVdIC8gc3kpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBOb3QgYSB1bmlxdWUgc29sdXRpb25cbiAgICB6ID0gMDtcbiAgICB4ID0gTWF0aC5hdGFuMihtWzRdIC8gc3ksIG1bNV0gLyBzeSk7XG4gIH1cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9pc3N1ZXMvMzI5XG4gKiBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZGl2aW5nRGVlcGVyL21lc2gvdHJhbnNmb3Jtcy9jZW50ZXJfb3JpZ2luL3JvdGF0aW9uX2NvbnZlbnRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEV1bGVyKG91dCwgcXVhdCkge1xuICBpZiAocXVhdC5sZW5ndGggPT09IDE2KSB7XG4gICAgcmV0dXJuIGdldEV1bGVyRnJvbU1hdDQob3V0LCBxdWF0KTtcbiAgfVxuICByZXR1cm4gZ2V0RXVsZXJGcm9tUXVhdChvdXQsIHF1YXQpO1xufVxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZShyb3RhdGlvbiwgeCwgeSwgc2NhbGVYLCBzY2FsZVkpIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgcmV0dXJuIG1hdDMuZnJvbVZhbHVlcyhzY2FsZVggKiBjb3MsIHNjYWxlWSAqIHNpbiwgMCwgLXNjYWxlWCAqIHNpbiwgc2NhbGVZICogY29zLCAwLCB4LCB5LCAxKTtcbn1cbmZ1bmN0aW9uIG1ha2VQZXJzcGVjdGl2ZShvdXQsIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKSB7XG4gIHZhciB6ZXJvID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBmYWxzZTtcbiAgdmFyIHR3b05lYXIgPSAyICogbmVhcjtcbiAgdmFyIHJpZ2h0TWludXNMZWZ0ID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgdG9wTWludXNCb3R0b20gPSB0b3AgLSBib3R0b207XG4gIHZhciB4ID0gdHdvTmVhciAvIHJpZ2h0TWludXNMZWZ0O1xuICB2YXIgeSA9IHR3b05lYXIgLyB0b3BNaW51c0JvdHRvbTtcbiAgdmFyIGEgPSAocmlnaHQgKyBsZWZ0KSAvIHJpZ2h0TWludXNMZWZ0O1xuICB2YXIgYiA9ICh0b3AgKyBib3R0b20pIC8gdG9wTWludXNCb3R0b207XG4gIHZhciBjO1xuICB2YXIgZDtcbiAgdmFyIGZhck1pbnVzTmVhciA9IGZhciAtIG5lYXI7XG4gIHZhciBmYXJNdWxOZWFyID0gZmFyICogbmVhcjtcbiAgaWYgKHplcm8pIHtcbiAgICBjID0gLWZhciAvIGZhck1pbnVzTmVhcjtcbiAgICBkID0gLWZhck11bE5lYXIgLyBmYXJNaW51c05lYXI7XG4gIH0gZWxzZSB7XG4gICAgYyA9IC0oZmFyICsgbmVhcikgLyBmYXJNaW51c05lYXI7XG4gICAgZCA9IC0yICogZmFyTXVsTmVhciAvIGZhck1pbnVzTmVhcjtcbiAgfVxuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB5O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBhO1xuICBvdXRbOV0gPSBiO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSBkO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGRlY29tcG9zZShtYXQpIHtcbiAgdmFyIHJvdzB4ID0gbWF0WzBdO1xuICB2YXIgcm93MHkgPSBtYXRbMV07XG4gIHZhciByb3cxeCA9IG1hdFszXTtcbiAgdmFyIHJvdzF5ID0gbWF0WzRdO1xuICAvLyBkZWNvbXBvc2UgM3gzIG1hdHJpeFxuICAvLyBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdHJhbnNmb3Jtcy0xLyNkZWNvbXBvc2luZy1hLTJkLW1hdHJpeFxuICB2YXIgc2NhbGluZ1ggPSBNYXRoLnNxcnQocm93MHggKiByb3cweCArIHJvdzB5ICogcm93MHkpO1xuICB2YXIgc2NhbGluZ1kgPSBNYXRoLnNxcnQocm93MXggKiByb3cxeCArIHJvdzF5ICogcm93MXkpO1xuXG4gIC8vIElmIGRldGVybWluYW50IGlzIG5lZ2F0aXZlLCBvbmUgYXhpcyB3YXMgZmxpcHBlZC5cbiAgdmFyIGRldGVybWluYW50ID0gcm93MHggKiByb3cxeSAtIHJvdzB5ICogcm93MXg7XG4gIGlmIChkZXRlcm1pbmFudCA8IDApIHtcbiAgICAvLyBGbGlwIGF4aXMgd2l0aCBtaW5pbXVtIHVuaXQgdmVjdG9yIGRvdCBwcm9kdWN0LlxuICAgIGlmIChyb3cweCA8IHJvdzF5KSB7XG4gICAgICBzY2FsaW5nWCA9IC1zY2FsaW5nWDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGluZ1kgPSAtc2NhbGluZ1k7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVub3JtYWxpemUgbWF0cml4IHRvIHJlbW92ZSBzY2FsZS5cbiAgaWYgKHNjYWxpbmdYKSB7XG4gICAgdmFyIGludlNjYWxpbmdYID0gMSAvIHNjYWxpbmdYO1xuICAgIHJvdzB4ICo9IGludlNjYWxpbmdYO1xuICAgIHJvdzB5ICo9IGludlNjYWxpbmdYO1xuICB9XG4gIGlmIChzY2FsaW5nWSkge1xuICAgIHZhciBpbnZTY2FsaW5nWSA9IDEgLyBzY2FsaW5nWTtcbiAgICByb3cxeCAqPSBpbnZTY2FsaW5nWTtcbiAgICByb3cxeSAqPSBpbnZTY2FsaW5nWTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgcm90YXRpb24gYW5kIHJlbm9ybWFsaXplIG1hdHJpeC5cbiAgdmFyIHJvdGF0aW9uID0gTWF0aC5hdGFuMihyb3cweSwgcm93MHgpO1xuICB2YXIgYW5nbGUgPSByYWQyZGVnKHJvdGF0aW9uKTtcbiAgcmV0dXJuIFttYXRbNl0sIG1hdFs3XSwgc2NhbGluZ1gsIHNjYWxpbmdZLCBhbmdsZV07XG59XG52YXIgdG1wID0gbWF0NC5jcmVhdGUoKTtcbnZhciBwZXJzcGVjdGl2ZU1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG52YXIgdG1wVmVjNCA9IHZlYzQuY3JlYXRlKCk7XG52YXIgcm93ID0gW3ZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCldO1xudmFyIHBkdW0zID0gdmVjMy5jcmVhdGUoKTtcblxuLypcbklucHV0OiAgbWF0cml4ICAgICAgOyBhIDR4NCBtYXRyaXhcbk91dHB1dDogdHJhbnNsYXRpb24gOyBhIDMgY29tcG9uZW50IHZlY3RvclxuICAgICAgICBzY2FsZSAgICAgICA7IGEgMyBjb21wb25lbnQgdmVjdG9yXG4gICAgICAgIHNrZXcgICAgICAgIDsgc2tldyBmYWN0b3JzIFhZLFhaLFlaIHJlcHJlc2VudGVkIGFzIGEgMyBjb21wb25lbnQgdmVjdG9yXG4gICAgICAgIHBlcnNwZWN0aXZlIDsgYSA0IGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgcXVhdGVybmlvbiAgOyBhIDQgY29tcG9uZW50IHZlY3RvclxuUmV0dXJucyBmYWxzZSBpZiB0aGUgbWF0cml4IGNhbm5vdCBiZSBkZWNvbXBvc2VkLCB0cnVlIGlmIGl0IGNhblxuXG5cblJlZmVyZW5jZXM6XG5odHRwczovL2dpdGh1Yi5jb20va2FtaWNhbmUvbWF0cml4M2QvYmxvYi9tYXN0ZXIvbGliL01hdHJpeDNkLmpzXG5odHRwczovL2dpdGh1Yi5jb20vQ2hyb21pdW1XZWJBcHBzL2Nocm9taXVtL2Jsb2IvbWFzdGVyL3VpL2dmeC90cmFuc2Zvcm1fdXRpbC5jY1xuaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy10cmFuc2Zvcm1zLyNkZWNvbXBvc2luZy1hLTNkLW1hdHJpeFxuKi9cbmZ1bmN0aW9uIGRlY29tcG9zZU1hdDQobWF0cml4LCB0cmFuc2xhdGlvbiwgc2NhbGUsIHNrZXcsIHBlcnNwZWN0aXZlLCBxdWF0ZXJuaW9uKSB7XG4gIC8vIG5vcm1hbGl6ZSwgaWYgbm90IHBvc3NpYmxlIHRoZW4gYmFpbCBvdXQgZWFybHlcbiAgaWYgKCFub3JtYWxpemUodG1wLCBtYXRyaXgpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gcGVyc3BlY3RpdmVNYXRyaXggaXMgdXNlZCB0byBzb2x2ZSBmb3IgcGVyc3BlY3RpdmUsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzXG4gIC8vIGFuIGVhc3kgd2F5IHRvIHRlc3QgZm9yIHNpbmd1bGFyaXR5IG9mIHRoZSB1cHBlciAzeDMgY29tcG9uZW50LlxuICBtYXQ0LmNvcHkocGVyc3BlY3RpdmVNYXRyaXgsIHRtcCk7XG4gIHBlcnNwZWN0aXZlTWF0cml4WzNdID0gMDtcbiAgcGVyc3BlY3RpdmVNYXRyaXhbN10gPSAwO1xuICBwZXJzcGVjdGl2ZU1hdHJpeFsxMV0gPSAwO1xuICBwZXJzcGVjdGl2ZU1hdHJpeFsxNV0gPSAxO1xuXG4gIC8vIElmIHRoZSBwZXJzcGVjdGl2ZU1hdHJpeCBpcyBub3QgaW52ZXJ0aWJsZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvXG4gIC8vIGRlY29tcG9zZSwgc28gd2UnbGwgYmFpbCBlYXJseS4gQ29uc3RhbnQgdGFrZW4gZnJvbSBTa01hdHJpeDQ0OjppbnZlcnQuXG4gIGlmIChNYXRoLmFicyhtYXQ0LmRldGVybWluYW50KHBlcnNwZWN0aXZlTWF0cml4KSkgPCAxZS04KSByZXR1cm4gZmFsc2U7XG4gIHZhciBhMDMgPSB0bXBbM107XG4gIHZhciBhMTMgPSB0bXBbN107XG4gIHZhciBhMjMgPSB0bXBbMTFdO1xuICB2YXIgYTMwID0gdG1wWzEyXTtcbiAgdmFyIGEzMSA9IHRtcFsxM107XG4gIHZhciBhMzIgPSB0bXBbMTRdO1xuICB2YXIgYTMzID0gdG1wWzE1XTtcblxuICAvLyBGaXJzdCwgaXNvbGF0ZSBwZXJzcGVjdGl2ZS5cbiAgaWYgKGEwMyAhPT0gMCB8fCBhMTMgIT09IDAgfHwgYTIzICE9PSAwKSB7XG4gICAgdG1wVmVjNFswXSA9IGEwMztcbiAgICB0bXBWZWM0WzFdID0gYTEzO1xuICAgIHRtcFZlYzRbMl0gPSBhMjM7XG4gICAgdG1wVmVjNFszXSA9IGEzMztcblxuICAgIC8vIFNvbHZlIHRoZSBlcXVhdGlvbiBieSBpbnZlcnRpbmcgcGVyc3BlY3RpdmVNYXRyaXggYW5kIG11bHRpcGx5aW5nXG4gICAgLy8gcmlnaHRIYW5kU2lkZSBieSB0aGUgaW52ZXJzZS5cbiAgICAvLyByZXN1aW5nIHRoZSBwZXJzcGVjdGl2ZU1hdHJpeCBoZXJlIHNpbmNlIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZFxuICAgIHZhciByZXQgPSBtYXQ0LmludmVydChwZXJzcGVjdGl2ZU1hdHJpeCwgcGVyc3BlY3RpdmVNYXRyaXgpO1xuICAgIGlmICghcmV0KSByZXR1cm4gZmFsc2U7XG4gICAgbWF0NC50cmFuc3Bvc2UocGVyc3BlY3RpdmVNYXRyaXgsIHBlcnNwZWN0aXZlTWF0cml4KTtcblxuICAgIC8vIG11bHRpcGx5IGJ5IHRyYW5zcG9zZWQgaW52ZXJzZSBwZXJzcGVjdGl2ZSBtYXRyaXgsIGludG8gcGVyc3BlY3RpdmUgdmVjNFxuICAgIHZlYzQudHJhbnNmb3JtTWF0NChwZXJzcGVjdGl2ZSwgdG1wVmVjNCwgcGVyc3BlY3RpdmVNYXRyaXgpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vIHBlcnNwZWN0aXZlXG4gICAgcGVyc3BlY3RpdmVbMF0gPSBwZXJzcGVjdGl2ZVsxXSA9IHBlcnNwZWN0aXZlWzJdID0gMDtcbiAgICBwZXJzcGVjdGl2ZVszXSA9IDE7XG4gIH1cblxuICAvLyBOZXh0IHRha2UgY2FyZSBvZiB0cmFuc2xhdGlvblxuICB0cmFuc2xhdGlvblswXSA9IGEzMDtcbiAgdHJhbnNsYXRpb25bMV0gPSBhMzE7XG4gIHRyYW5zbGF0aW9uWzJdID0gYTMyO1xuXG4gIC8vIE5vdyBnZXQgc2NhbGUgYW5kIHNoZWFyLiAncm93JyBpcyBhIDMgZWxlbWVudCBhcnJheSBvZiAzIGNvbXBvbmVudCB2ZWN0b3JzXG4gIG1hdDNmcm9tNChyb3csIHRtcCk7XG5cbiAgLy8gQ29tcHV0ZSBYIHNjYWxlIGZhY3RvciBhbmQgbm9ybWFsaXplIGZpcnN0IHJvdy5cbiAgc2NhbGVbMF0gPSB2ZWMzLmxlbmd0aChyb3dbMF0pO1xuICB2ZWMzLm5vcm1hbGl6ZShyb3dbMF0sIHJvd1swXSk7XG5cbiAgLy8gQ29tcHV0ZSBYWSBzaGVhciBmYWN0b3IgYW5kIG1ha2UgMm5kIHJvdyBvcnRob2dvbmFsIHRvIDFzdC5cbiAgc2tld1swXSA9IHZlYzMuZG90KHJvd1swXSwgcm93WzFdKTtcbiAgY29tYmluZShyb3dbMV0sIHJvd1sxXSwgcm93WzBdLCAxLjAsIC1za2V3WzBdKTtcblxuICAvLyBOb3csIGNvbXB1dGUgWSBzY2FsZSBhbmQgbm9ybWFsaXplIDJuZCByb3cuXG4gIHNjYWxlWzFdID0gdmVjMy5sZW5ndGgocm93WzFdKTtcbiAgdmVjMy5ub3JtYWxpemUocm93WzFdLCByb3dbMV0pO1xuICBza2V3WzBdIC89IHNjYWxlWzFdO1xuXG4gIC8vIENvbXB1dGUgWFogYW5kIFlaIHNoZWFycywgb3J0aG9nb25hbGl6ZSAzcmQgcm93XG4gIHNrZXdbMV0gPSB2ZWMzLmRvdChyb3dbMF0sIHJvd1syXSk7XG4gIGNvbWJpbmUocm93WzJdLCByb3dbMl0sIHJvd1swXSwgMS4wLCAtc2tld1sxXSk7XG4gIHNrZXdbMl0gPSB2ZWMzLmRvdChyb3dbMV0sIHJvd1syXSk7XG4gIGNvbWJpbmUocm93WzJdLCByb3dbMl0sIHJvd1sxXSwgMS4wLCAtc2tld1syXSk7XG5cbiAgLy8gTmV4dCwgZ2V0IFogc2NhbGUgYW5kIG5vcm1hbGl6ZSAzcmQgcm93LlxuICBzY2FsZVsyXSA9IHZlYzMubGVuZ3RoKHJvd1syXSk7XG4gIHZlYzMubm9ybWFsaXplKHJvd1syXSwgcm93WzJdKTtcbiAgc2tld1sxXSAvPSBzY2FsZVsyXTtcbiAgc2tld1syXSAvPSBzY2FsZVsyXTtcblxuICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgbWF0cml4IChpbiByb3dzKSBpcyBvcnRob25vcm1hbC5cbiAgLy8gQ2hlY2sgZm9yIGEgY29vcmRpbmF0ZSBzeXN0ZW0gZmxpcC4gIElmIHRoZSBkZXRlcm1pbmFudFxuICAvLyBpcyAtMSwgdGhlbiBuZWdhdGUgdGhlIG1hdHJpeCBhbmQgdGhlIHNjYWxpbmcgZmFjdG9ycy5cbiAgdmVjMy5jcm9zcyhwZHVtMywgcm93WzFdLCByb3dbMl0pO1xuICBpZiAodmVjMy5kb3Qocm93WzBdLCBwZHVtMykgPCAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIHNjYWxlW2ldICo9IC0xO1xuICAgICAgcm93W2ldWzBdICo9IC0xO1xuICAgICAgcm93W2ldWzFdICo9IC0xO1xuICAgICAgcm93W2ldWzJdICo9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5vdywgZ2V0IHRoZSByb3RhdGlvbnMgb3V0XG4gIHF1YXRlcm5pb25bMF0gPSAwLjUgKiBNYXRoLnNxcnQoTWF0aC5tYXgoMSArIHJvd1swXVswXSAtIHJvd1sxXVsxXSAtIHJvd1syXVsyXSwgMCkpO1xuICBxdWF0ZXJuaW9uWzFdID0gMC41ICogTWF0aC5zcXJ0KE1hdGgubWF4KDEgLSByb3dbMF1bMF0gKyByb3dbMV1bMV0gLSByb3dbMl1bMl0sIDApKTtcbiAgcXVhdGVybmlvblsyXSA9IDAuNSAqIE1hdGguc3FydChNYXRoLm1heCgxIC0gcm93WzBdWzBdIC0gcm93WzFdWzFdICsgcm93WzJdWzJdLCAwKSk7XG4gIHF1YXRlcm5pb25bM10gPSAwLjUgKiBNYXRoLnNxcnQoTWF0aC5tYXgoMSArIHJvd1swXVswXSArIHJvd1sxXVsxXSArIHJvd1syXVsyXSwgMCkpO1xuICBpZiAocm93WzJdWzFdID4gcm93WzFdWzJdKSBxdWF0ZXJuaW9uWzBdID0gLXF1YXRlcm5pb25bMF07XG4gIGlmIChyb3dbMF1bMl0gPiByb3dbMl1bMF0pIHF1YXRlcm5pb25bMV0gPSAtcXVhdGVybmlvblsxXTtcbiAgaWYgKHJvd1sxXVswXSA+IHJvd1swXVsxXSkgcXVhdGVybmlvblsyXSA9IC1xdWF0ZXJuaW9uWzJdO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIG1hdCkge1xuICB2YXIgbTQ0ID0gbWF0WzE1XTtcbiAgLy8gQ2Fubm90IG5vcm1hbGl6ZS5cbiAgaWYgKG00NCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2NhbGUgPSAxIC8gbTQ0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG91dFtpXSA9IG1hdFtpXSAqIHNjYWxlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ2V0cyB1cHBlci1sZWZ0IG9mIGEgNHg0IG1hdHJpeCBpbnRvIGEgM3gzIG9mIHZlY3RvcnNcbmZ1bmN0aW9uIG1hdDNmcm9tNChvdXQsIG1hdDR4NCkge1xuICBvdXRbMF1bMF0gPSBtYXQ0eDRbMF07XG4gIG91dFswXVsxXSA9IG1hdDR4NFsxXTtcbiAgb3V0WzBdWzJdID0gbWF0NHg0WzJdO1xuICBvdXRbMV1bMF0gPSBtYXQ0eDRbNF07XG4gIG91dFsxXVsxXSA9IG1hdDR4NFs1XTtcbiAgb3V0WzFdWzJdID0gbWF0NHg0WzZdO1xuICBvdXRbMl1bMF0gPSBtYXQ0eDRbOF07XG4gIG91dFsyXVsxXSA9IG1hdDR4NFs5XTtcbiAgb3V0WzJdWzJdID0gbWF0NHg0WzEwXTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmUob3V0LCBhLCBiLCBzY2FsZTEsIHNjYWxlMikge1xuICBvdXRbMF0gPSBhWzBdICogc2NhbGUxICsgYlswXSAqIHNjYWxlMjtcbiAgb3V0WzFdID0gYVsxXSAqIHNjYWxlMSArIGJbMV0gKiBzY2FsZTI7XG4gIG91dFsyXSA9IGFbMl0gKiBzY2FsZTEgKyBiWzJdICogc2NhbGUyO1xufVxuXG4vKipcbiAqIERpZmZlcmVudCB0eXBlIG9mIGNhbWVyYXMsIGVnLiBzaW1wbGUgY2FtZXJhIHVzZWQgaW4gMkQgc2NlbmUgb3JcbiAqIGFkdmFuY2VkIGNhbWVyYSB3aGljaCBjYW4gZG8gYWN0aW9ucyAmIHN3aXRjaCBiZXR3ZWVuIGxhbmRtYXJrcy5cbiAqL1xuXG52YXIgQ2FtZXJhVHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQ2FtZXJhVHlwZSkge1xuICAvKipcbiAgICogUGVyZm9ybXMgYWxsIHRoZSByb3RhdGlvbmFsIG9wZXJhdGlvbnMgd2l0aCB0aGUgZm9jYWwgcG9pbnQgaW5zdGVhZCBvZiB0aGUgY2FtZXJhIHBvc2l0aW9uLlxuICAgKiBUaGlzIHR5cGUgb2YgY2FtZXJhIGlzIHVzZWZ1bCBpbiBhcHBsaWNhdGlvbnMobGlrZSBDQUQpIHdoZXJlIDNEIG9iamVjdHMgYXJlIGJlaW5nIGRlc2lnbmVkIG9yIGV4cGxvcmVkLlxuICAgKiBDYW1lcmEgY2Fubm90IG9yYml0cyBvdmVyIHRoZSBub3J0aCAmIHNvdXRoIHBvbGVzLlxuICAgKiBAc2VlIGh0dHA6Ly92b3hlbGVudC5jb20vdHV0b3JpYWwtY2FtZXJhcy9cbiAgICpcbiAgICogSW4gVGhyZWUuanMgaXQncyB1c2VkIGluIE9yYml0Q29udHJvbHMuXG4gICAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNleGFtcGxlcy96aC9jb250cm9scy9PcmJpdENvbnRyb2xzXG4gICAqL1xuICBDYW1lcmFUeXBlW0NhbWVyYVR5cGVbXCJPUkJJVElOR1wiXSA9IDBdID0gXCJPUkJJVElOR1wiO1xuICAvKipcbiAgICogSXQncyBzaW1pbGFyIHRvIHRoZSBPUkJJVElORyBjYW1lcmEsIGJ1dCBpdCBhbGxvd3MgdGhlIGNhbWVyYSB0byBvcmJpdCBvdmVyIHRoZSBub3J0aCBvciBzb3V0aCBwb2xlcy5cbiAgICpcbiAgICogSW4gVGhyZWUuanMgaXQncyB1c2VkIGluIE9yYml0Q29udHJvbHMuXG4gICAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNleGFtcGxlcy9lbi9jb250cm9scy9UcmFja2JhbGxDb250cm9sc1xuICAgKi9cbiAgQ2FtZXJhVHlwZVtDYW1lcmFUeXBlW1wiRVhQTE9SSU5HXCJdID0gMV0gPSBcIkVYUExPUklOR1wiO1xuICAvKipcbiAgICogUGVyZm9ybXMgYWxsIHRoZSByb3RhdGlvbmFsIG9wZXJhdGlvbnMgd2l0aCB0aGUgY2FtZXJhIHBvc2l0aW9uLlxuICAgKiBJdCdzIHVzZWZ1bCBpbiBmaXJzdCBwZXJzb24gc2hvb3RpbmcgZ2FtZXMuXG4gICAqIENhbWVyYSBjYW5ub3Qgb3JiaXRzIG92ZXIgdGhlIG5vcnRoICYgc291dGggcG9sZXMuXG4gICAqXG4gICAqIEluIFRocmVlLmpzIGl0J3MgdXNlZCBpbiBGaXJzdFBlcnNvbkNvbnRyb2xzLlxuICAgKiBAc2VlIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jZXhhbXBsZXMvZW4vY29udHJvbHMvRmlyc3RQZXJzb25Db250cm9sc1xuICAgKi9cbiAgQ2FtZXJhVHlwZVtDYW1lcmFUeXBlW1wiVFJBQ0tJTkdcIl0gPSAyXSA9IFwiVFJBQ0tJTkdcIjtcbiAgcmV0dXJuIENhbWVyYVR5cGU7XG59KHt9KTtcblxuLyoqXG4gKiBDYW1lcmFUeXBlIG11c3QgYmUgVFJBQ0tJTkdcbiAqL1xudmFyIENhbWVyYVRyYWNraW5nTW9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQ2FtZXJhVHJhY2tpbmdNb2RlKSB7XG4gIENhbWVyYVRyYWNraW5nTW9kZVtDYW1lcmFUcmFja2luZ01vZGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgQ2FtZXJhVHJhY2tpbmdNb2RlW0NhbWVyYVRyYWNraW5nTW9kZVtcIlJPVEFUSU9OQUxcIl0gPSAxXSA9IFwiUk9UQVRJT05BTFwiO1xuICBDYW1lcmFUcmFja2luZ01vZGVbQ2FtZXJhVHJhY2tpbmdNb2RlW1wiVFJBTlNMQVRJT05BTFwiXSA9IDJdID0gXCJUUkFOU0xBVElPTkFMXCI7XG4gIENhbWVyYVRyYWNraW5nTW9kZVtDYW1lcmFUcmFja2luZ01vZGVbXCJDSU5FTUFUSUNcIl0gPSAzXSA9IFwiQ0lORU1BVElDXCI7XG4gIHJldHVybiBDYW1lcmFUcmFja2luZ01vZGU7XG59KHt9KTtcbnZhciBDYW1lcmFQcm9qZWN0aW9uTW9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQ2FtZXJhUHJvamVjdGlvbk1vZGUpIHtcbiAgQ2FtZXJhUHJvamVjdGlvbk1vZGVbQ2FtZXJhUHJvamVjdGlvbk1vZGVbXCJPUlRIT0dSQVBISUNcIl0gPSAwXSA9IFwiT1JUSE9HUkFQSElDXCI7XG4gIENhbWVyYVByb2plY3Rpb25Nb2RlW0NhbWVyYVByb2plY3Rpb25Nb2RlW1wiUEVSU1BFQ1RJVkVcIl0gPSAxXSA9IFwiUEVSU1BFQ1RJVkVcIjtcbiAgcmV0dXJuIENhbWVyYVByb2plY3Rpb25Nb2RlO1xufSh7fSk7XG52YXIgQ2FtZXJhRXZlbnQgPSB7XG4gIFVQREFURUQ6ICd1cGRhdGVkJ1xufTtcblxudmFyIE1JTl9ESVNUQU5DRSA9IDAuMDAwMjtcblxuLyoqXG4gKiDlj4LogIPjgIxXZWJHTCBJbnNpZ2h0cyAtIDIzLkRlc2lnbmluZyBDYW1lcmFzIGZvciBXZWJHTCBBcHBsaWNhdGlvbnPjgI3vvIzln7rkuo4gUmVzcG9uc2libGUgQ2FtZXJhIOaAnei3r+iuvuiuoVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDEzZzAvbnVjbGVvLmpzL2Jsb2IvbWFzdGVyL3NvdXJjZS9jYW1lcmEvQ2FtZXJhLmpzXG4gKlxuICog5L+d5a2Y55u45py65Y+C5pWw77yM5a6a5LmJ55u45py65Yqo5L2c77yaXG4gKiAxLiBkb2xseSDmsr8gbiDovbTnp7vliqhcbiAqIDIuIHBhbiDmsr8gdSB2IOi9tOenu+WKqFxuICogMy4gcm90YXRlIOS7peaWueS9jeinkuaXi+i9rFxuICogNC4g56e75Yqo5YiwIExhbmRtYXJr77yM5YW35pyJ5bmz5ruR55qE5Yqo55S75pWI5p6c77yM5YW26Ze056aB5q2i5YW25LuW55So5oi35Lqk5LqSXG4gKi9cblxudmFyIENhbWVyYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbWVyYSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FtZXJhKTtcbiAgICAvKipcbiAgICAgKiBDbGlwIHNwYWNlIG5lYXIgWiwgZGVmYXVsdCB0byByYW5nZSBgWy0xLCAxXWBcbiAgICAgKi9cbiAgICB0aGlzLmNsaXBTcGFjZU5lYXJaID0gQ2xpcFNwYWNlTmVhclouTkVHQVRJVkVfT05FO1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIE1hdHJpeCBvZiBjYW1lcmFcbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogdSBheGlzICtYIGlzIHJpZ2h0XG4gICAgICogQHNlZSBodHRwOi8vbGVhcm53ZWJnbC5icm93bjM3Lm5ldC8wN19jYW1lcmFzL2NhbWVyYV9pbnRyb2R1Y3Rpb24uaHRtbCNhLWNhbWVyYS1kZWZpbml0aW9uXG4gICAgICovXG4gICAgdGhpcy5yaWdodCA9IHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbiAgICAvKipcbiAgICAgKiB2IGF4aXMgK1kgaXMgdXBcbiAgICAgKi9cbiAgICB0aGlzLnVwID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICAgIC8qKlxuICAgICAqIG4gYXhpcyArWiBpcyBpbnNpZGVcbiAgICAgKi9cbiAgICB0aGlzLmZvcndhcmQgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gb2YgY2FtZXJhLlxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gb2YgZm9jYWwgcG9pbnQuXG4gICAgICovXG4gICAgdGhpcy5mb2NhbFBvaW50ID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApO1xuICAgIC8qKlxuICAgICAqIHZlY3RvciBmcm9tIGZvY2FsUG9pbnQgdG8gcG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlVmVjdG9yID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC0xKTtcbiAgICAvKipcbiAgICAgKiBsZW5ndGgoZm9jYWxQb2ludCAtIHBvc2l0aW9uKVxuICAgICAqL1xuICAgIHRoaXMuZGlzdGFuY2UgPSAxO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXppbXV0aFxuICAgICAqL1xuICAgIHRoaXMuYXppbXV0aCA9IDA7XG4gICAgdGhpcy5lbGV2YXRpb24gPSAwO1xuICAgIHRoaXMucm9sbCA9IDA7XG4gICAgdGhpcy5yZWxBemltdXRoID0gMDtcbiAgICB0aGlzLnJlbEVsZXZhdGlvbiA9IDA7XG4gICAgdGhpcy5yZWxSb2xsID0gMDtcbiAgICAvKipcbiAgICAgKiDmsr8gbiDovbTnp7vliqjml7bvvIzkv53or4Hnp7vliqjpgJ/luqbku47lv6vliLDmhaJcbiAgICAgKi9cbiAgICB0aGlzLmRvbGx5aW5nU3RlcCA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIHRoaXMubWluRGlzdGFuY2UgPSAtSW5maW5pdHk7XG4gICAgLyoqXG4gICAgICogem9vbSBmYWN0b3Igb2YgdGhlIGNhbWVyYSwgZGVmYXVsdCBpcyAxXG4gICAgICogZWcuIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLnpvb21cbiAgICAgKi9cbiAgICB0aGlzLnpvb20gPSAxO1xuICAgIC8qKlxuICAgICAqIGludmVydCB0aGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHN5c3RlbSBIQ1NcbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0ZVdvcmxkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICog5oqV5b2x55+p6Zi15Y+C5pWwXG4gICAgICovXG4gICAgLyoqXG4gICAgICogZmllbGQgb2YgdmlldyBbMC0zNjBdXG4gICAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FuZ2xlX29mX3ZpZXdcbiAgICAgKi9cbiAgICB0aGlzLmZvdiA9IDMwO1xuICAgIHRoaXMubmVhciA9IDAuMTtcbiAgICB0aGlzLmZhciA9IDEwMDA7XG4gICAgdGhpcy5hc3BlY3QgPSAxO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSA9IG1hdDQuY3JlYXRlKCk7XG4gICAgdGhpcy5qaXR0ZXJlZFByb2plY3Rpb25NYXRyaXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVVcGRhdGUgPSB0cnVlO1xuICAgIC8vIHByb3RlY3RlZCBmb2xsb3dpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50eXBlID0gQ2FtZXJhVHlwZS5FWFBMT1JJTkc7XG4gICAgdGhpcy50cmFja2luZ01vZGUgPSBDYW1lcmFUcmFja2luZ01vZGUuREVGQVVMVDtcbiAgICB0aGlzLnByb2plY3Rpb25Nb2RlID0gQ2FtZXJhUHJvamVjdGlvbk1vZGUuUEVSU1BFQ1RJVkU7XG4gICAgLyoqXG4gICAgICogZm9yIGN1bGxpbmcgdXNlXG4gICAgICovXG4gICAgdGhpcy5mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcbiAgICAvKipcbiAgICAgKiBvcnRobyBtYXRyaXggZm9yIENhbnZhczJEICYgU1ZHXG4gICAgICovXG4gICAgdGhpcy5vcnRob01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDYW1lcmEsIFt7XG4gICAga2V5OiBcImlzT3J0aG9cIixcbiAgICB2YWx1ZTpcbiAgICAvLyBjb25zdHJ1Y3Rvcih0eXBlID0gQ2FtZXJhVHlwZS5FWFBMT1JJTkcsIHRyYWNraW5nTW9kZSA9IENhbWVyYVRyYWNraW5nTW9kZS5ERUZBVUxUKSB7XG4gICAgLy8gICB0aGlzLnNldFR5cGUodHlwZSwgdHJhY2tpbmdNb2RlKTtcbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBpc09ydGhvKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbk1vZGUgPT09IENhbWVyYVByb2plY3Rpb25Nb2RlLk9SVEhPR1JBUEhJQztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvamVjdGlvbk1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvamVjdGlvbk1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uTW9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGVyc3BlY3RpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGVyc3BlY3RpdmUoKSB7XG4gICAgICAvLyBhY2NvdW50IGZvciBUQUFcbiAgICAgIHJldHVybiB0aGlzLmppdHRlcmVkUHJvamVjdGlvbk1hdHJpeCB8fCB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBlcnNwZWN0aXZlSW52ZXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQZXJzcGVjdGl2ZUludmVyc2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnJ1c3R1bVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGcnVzdHVtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJ1c3R1bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9jYWxQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb2NhbFBvaW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9jYWxQb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RG9sbHlpbmdTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERvbGx5aW5nU3RlcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvbGx5aW5nU3RlcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZWFyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmVhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZhcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Wm9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRab29tKCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9vbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3J0aG9NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3J0aG9NYXRyaXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcnRob01hdHJpeDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3KCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlldztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RW5hYmxlVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVuYWJsZVVwZGF0ZShlbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZVVwZGF0ZSA9IGVuYWJsZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHlwZSh0eXBlLCB0cmFja2luZ01vZGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBDYW1lcmFUeXBlLkVYUExPUklORykge1xuICAgICAgICB0aGlzLnNldFdvcmxkUm90YXRpb24odHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFdvcmxkUm90YXRpb24oZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZ2V0QW5nbGVzKCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBDYW1lcmFUeXBlLlRSQUNLSU5HICYmIHRyYWNraW5nTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0VHJhY2tpbmdNb2RlKHRyYWNraW5nTW9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvamVjdGlvbk1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvamVjdGlvbk1vZGUocHJvamVjdGlvbk1vZGUpIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1vZGUgPSBwcm9qZWN0aW9uTW9kZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFja2luZ01vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhY2tpbmdNb2RlKHRyYWNraW5nTW9kZSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gQ2FtZXJhVHlwZS5UUkFDS0lORykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcG9zc2libGUgdG8gc2V0IGEgdHJhY2tpbmcgbW9kZSBpZiB0aGUgY2FtZXJhIGlzIG5vdCBvZiB0cmFja2luZyB0eXBlJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNraW5nTW9kZSA9IHRyYWNraW5nTW9kZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGZsYWcgaXMgdHJ1ZSwgaXQgcmV2ZXJzZXMgdGhlIGF6aW11dGggYW5kIGVsZXZhdGlvbiBhbmdsZXMuXG4gICAgICogU3Vic2VxdWVudCBjYWxscyB0byByb3RhdGUsIHNldEF6aW11dGgsIHNldEVsZXZhdGlvbixcbiAgICAgKiBjaGFuZ2VBemltdXRoIG9yIGNoYW5nZUVsZXZhdGlvbiB3aWxsIGNhdXNlIHRoZSBpbnZlcnRlZCBlZmZlY3QuXG4gICAgICogc2V0Um9sbCBvciBjaGFuZ2VSb2xsIGlzIG5vdCBhZmZlY3RlZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaW52ZXJzaW9uIGlzIHVzZWZ1bCB3aGVuIG9uZSB3YW50cyB0byBzaW11bGF0ZSB0aGF0IHRoZSB3b3JsZFxuICAgICAqIGlzIG1vdmluZywgaW5zdGVhZCBvZiB0aGUgY2FtZXJhLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCB0aGUgY2FtZXJhIGFuZ2xlcyBhcmUgbm90IHJldmVyc2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmxhZyB0aGUgYm9vbGVhbiBmbGFnIHRvIHJldmVyc2UgdGhlIGFuZ2xlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRXb3JsZFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdvcmxkUm90YXRpb24oZmxhZykge1xuICAgICAgdGhpcy5yb3RhdGVXb3JsZCA9IGZsYWc7XG4gICAgICB0aGlzLl9nZXRBbmdsZXMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeulyBNViDnn6npmLXvvIzkuLrnm7jmnLrnn6npmLXnmoTpgIbnn6npmLVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdUcmFuc2Zvcm0oKSB7XG4gICAgICAvLyBtYXQ0LnNjYWxlKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKDEsIC0xLCAxKSk7XG5cbiAgICAgIHJldHVybiBtYXQ0LmludmVydChtYXQ0LmNyZWF0ZSgpLCB0aGlzLm1hdHJpeCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdvcmxkVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmxkVHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqaXR0ZXJQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGppdHRlclByb2plY3Rpb25NYXRyaXgoeCwgeSkge1xuICAgICAgdmFyIHRyYW5zbGF0aW9uID0gbWF0NC5mcm9tVHJhbnNsYXRpb24obWF0NC5jcmVhdGUoKSwgW3gsIHksIDBdKTtcbiAgICAgIHRoaXMuaml0dGVyZWRQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShtYXQ0LmNyZWF0ZSgpLCB0cmFuc2xhdGlvbiwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJKaXR0ZXJQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFySml0dGVyUHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICAgIHRoaXMuaml0dGVyZWRQcm9qZWN0aW9uTWF0cml4ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9ruebuOacuuefqemYtVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNYXRyaXgobWF0cml4KSB7XG4gICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHByb2plY3Rpb24gbWF0cml4IG1hbnVhbGx5LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFByb2plY3Rpb25NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvamVjdGlvbk1hdHJpeChtYXRyaXgpIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Rm92XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvdihmb3YpIHtcbiAgICAgIHRoaXMuc2V0UGVyc3BlY3RpdmUodGhpcy5uZWFyLCB0aGlzLmZhciwgZm92LCB0aGlzLmFzcGVjdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXNwZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFzcGVjdChhc3BlY3QpIHtcbiAgICAgIHRoaXMuc2V0UGVyc3BlY3RpdmUodGhpcy5uZWFyLCB0aGlzLmZhciwgdGhpcy5mb3YsIGFzcGVjdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TmVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROZWFyKG5lYXIpIHtcbiAgICAgIGlmICh0aGlzLnByb2plY3Rpb25Nb2RlID09PSBDYW1lcmFQcm9qZWN0aW9uTW9kZS5QRVJTUEVDVElWRSkge1xuICAgICAgICB0aGlzLnNldFBlcnNwZWN0aXZlKG5lYXIsIHRoaXMuZmFyLCB0aGlzLmZvdiwgdGhpcy5hc3BlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRPcnRob2dyYXBoaWModGhpcy5sZWZ0LCB0aGlzLnJyaWdodCwgdGhpcy50b3AsIHRoaXMuYm90dG9tLCBuZWFyLCB0aGlzLmZhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZhcihmYXIpIHtcbiAgICAgIGlmICh0aGlzLnByb2plY3Rpb25Nb2RlID09PSBDYW1lcmFQcm9qZWN0aW9uTW9kZS5QRVJTUEVDVElWRSkge1xuICAgICAgICB0aGlzLnNldFBlcnNwZWN0aXZlKHRoaXMubmVhciwgZmFyLCB0aGlzLmZvdiwgdGhpcy5hc3BlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRPcnRob2dyYXBoaWModGhpcy5sZWZ0LCB0aGlzLnJyaWdodCwgdGhpcy50b3AsIHRoaXMuYm90dG9tLCB0aGlzLm5lYXIsIGZhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLCB1c2VkIGluIFBpeGVsUGlja2luZ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFZpZXdPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vmlld09mZnNldChmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuYXNwZWN0ID0gZnVsbFdpZHRoIC8gZnVsbEhlaWdodDtcbiAgICAgIGlmICh0aGlzLnZpZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBmdWxsV2lkdGg6IDEsXG4gICAgICAgICAgZnVsbEhlaWdodDogMSxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuICAgICAgdGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuICAgICAgdGhpcy52aWV3Lm9mZnNldFggPSB4O1xuICAgICAgdGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKHRoaXMucHJvamVjdGlvbk1vZGUgPT09IENhbWVyYVByb2plY3Rpb25Nb2RlLlBFUlNQRUNUSVZFKSB7XG4gICAgICAgIHRoaXMuc2V0UGVyc3BlY3RpdmUodGhpcy5uZWFyLCB0aGlzLmZhciwgdGhpcy5mb3YsIHRoaXMuYXNwZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0T3J0aG9ncmFwaGljKHRoaXMubGVmdCwgdGhpcy5ycmlnaHQsIHRoaXMudG9wLCB0aGlzLmJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJWaWV3T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVmlld09mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvamVjdGlvbk1vZGUgPT09IENhbWVyYVByb2plY3Rpb25Nb2RlLlBFUlNQRUNUSVZFKSB7XG4gICAgICAgIHRoaXMuc2V0UGVyc3BlY3RpdmUodGhpcy5uZWFyLCB0aGlzLmZhciwgdGhpcy5mb3YsIHRoaXMuYXNwZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0T3J0aG9ncmFwaGljKHRoaXMubGVmdCwgdGhpcy5ycmlnaHQsIHRoaXMudG9wLCB0aGlzLmJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Wm9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRab29tKHpvb20pIHtcbiAgICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgICBpZiAodGhpcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ2FtZXJhUHJvamVjdGlvbk1vZGUuT1JUSE9HUkFQSElDKSB7XG4gICAgICAgIHRoaXMuc2V0T3J0aG9ncmFwaGljKHRoaXMubGVmdCwgdGhpcy5ycmlnaHQsIHRoaXMudG9wLCB0aGlzLmJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvamVjdGlvbk1vZGUgPT09IENhbWVyYVByb2plY3Rpb25Nb2RlLlBFUlNQRUNUSVZFKSB7XG4gICAgICAgIHRoaXMuc2V0UGVyc3BlY3RpdmUodGhpcy5uZWFyLCB0aGlzLmZhciwgdGhpcy5mb3YsIHRoaXMuYXNwZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20gYnkgc3BlY2lmaWVkIHBvaW50IGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFpvb21CeVZpZXdwb3J0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Wm9vbUJ5Vmlld3BvcnRQb2ludCh6b29tLCB2aWV3cG9ydFBvaW50KSB7XG4gICAgICB2YXIgX3RoaXMkY2FudmFzJHZpZXdwb3J0ID0gdGhpcy5jYW52YXMudmlld3BvcnQyQ2FudmFzKHtcbiAgICAgICAgICB4OiB2aWV3cG9ydFBvaW50WzBdLFxuICAgICAgICAgIHk6IHZpZXdwb3J0UG9pbnRbMV1cbiAgICAgICAgfSksXG4gICAgICAgIG94ID0gX3RoaXMkY2FudmFzJHZpZXdwb3J0LngsXG4gICAgICAgIG95ID0gX3RoaXMkY2FudmFzJHZpZXdwb3J0Lnk7XG4gICAgICB2YXIgcm9sbCA9IHRoaXMucm9sbDtcbiAgICAgIHRoaXMucm90YXRlKDAsIDAsIC1yb2xsKTtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ob3gsIG95KTtcbiAgICAgIHRoaXMuc2V0Rm9jYWxQb2ludChveCwgb3kpO1xuICAgICAgdGhpcy5zZXRab29tKHpvb20pO1xuICAgICAgdGhpcy5yb3RhdGUoMCwgMCwgcm9sbCk7XG4gICAgICB2YXIgX3RoaXMkY2FudmFzJHZpZXdwb3J0MiA9IHRoaXMuY2FudmFzLnZpZXdwb3J0MkNhbnZhcyh7XG4gICAgICAgICAgeDogdmlld3BvcnRQb2ludFswXSxcbiAgICAgICAgICB5OiB2aWV3cG9ydFBvaW50WzFdXG4gICAgICAgIH0pLFxuICAgICAgICBjeCA9IF90aGlzJGNhbnZhcyR2aWV3cG9ydDIueCxcbiAgICAgICAgY3kgPSBfdGhpcyRjYW52YXMkdmlld3BvcnQyLnk7XG5cbiAgICAgIC8vIHByb2plY3QgdG8gcm90YXRlZCBheGlzXG4gICAgICB2YXIgZHZlYyA9IHZlYzMuZnJvbVZhbHVlcyhjeCAtIG94LCBjeSAtIG95LCAwKTtcbiAgICAgIHZhciBkeCA9IHZlYzMuZG90KGR2ZWMsIHRoaXMucmlnaHQpIC8gdmVjMy5sZW5ndGgodGhpcy5yaWdodCk7XG4gICAgICB2YXIgZHkgPSB2ZWMzLmRvdChkdmVjLCB0aGlzLnVwKSAvIHZlYzMubGVuZ3RoKHRoaXMudXApO1xuICAgICAgdmFyIF90aGlzJGdldFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbigpLFxuICAgICAgICBfdGhpcyRnZXRQb3NpdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRQb3NpdGlvbiwgMiksXG4gICAgICAgIHB4ID0gX3RoaXMkZ2V0UG9zaXRpb24yWzBdLFxuICAgICAgICBweSA9IF90aGlzJGdldFBvc2l0aW9uMlsxXTtcbiAgICAgIHZhciBfdGhpcyRnZXRGb2NhbFBvaW50ID0gdGhpcy5nZXRGb2NhbFBvaW50KCksXG4gICAgICAgIF90aGlzJGdldEZvY2FsUG9pbnQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZ2V0Rm9jYWxQb2ludCwgMiksXG4gICAgICAgIGZ4ID0gX3RoaXMkZ2V0Rm9jYWxQb2ludDJbMF0sXG4gICAgICAgIGZ5ID0gX3RoaXMkZ2V0Rm9jYWxQb2ludDJbMV07XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKHB4IC0gZHgsIHB5IC0gZHkpO1xuICAgICAgdGhpcy5zZXRGb2NhbFBvaW50KGZ4IC0gZHgsIGZ5IC0gZHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBlcnNwZWN0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBlcnNwZWN0aXZlKG5lYXIsIGZhciwgZm92LCBhc3BlY3QpIHtcbiAgICAgIHZhciBfdGhpcyR2aWV3O1xuICAgICAgdGhpcy5wcm9qZWN0aW9uTW9kZSA9IENhbWVyYVByb2plY3Rpb25Nb2RlLlBFUlNQRUNUSVZFO1xuICAgICAgdGhpcy5mb3YgPSBmb3Y7XG4gICAgICB0aGlzLm5lYXIgPSBuZWFyO1xuICAgICAgdGhpcy5mYXIgPSBmYXI7XG4gICAgICB0aGlzLmFzcGVjdCA9IGFzcGVjdDtcbiAgICAgIHZhciB0b3AgPSB0aGlzLm5lYXIgKiBNYXRoLnRhbihkZWcycmFkKDAuNSAqIHRoaXMuZm92KSkgLyB0aGlzLnpvb207XG4gICAgICB2YXIgaGVpZ2h0ID0gMiAqIHRvcDtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0O1xuICAgICAgdmFyIGxlZnQgPSAtMC41ICogd2lkdGg7XG4gICAgICBpZiAoKF90aGlzJHZpZXcgPSB0aGlzLnZpZXcpICE9PSBudWxsICYmIF90aGlzJHZpZXcgIT09IHZvaWQgMCAmJiBfdGhpcyR2aWV3LmVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGZ1bGxXaWR0aCA9IHRoaXMudmlldy5mdWxsV2lkdGg7XG4gICAgICAgIHZhciBmdWxsSGVpZ2h0ID0gdGhpcy52aWV3LmZ1bGxIZWlnaHQ7XG4gICAgICAgIGxlZnQgKz0gdGhpcy52aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcbiAgICAgICAgdG9wIC09IHRoaXMudmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcbiAgICAgICAgd2lkdGggKj0gdGhpcy52aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuICAgICAgICBoZWlnaHQgKj0gdGhpcy52aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XG4gICAgICB9XG4gICAgICBtYWtlUGVyc3BlY3RpdmUodGhpcy5wcm9qZWN0aW9uTWF0cml4LCBsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCAtIGhlaWdodCwgdG9wLCBuZWFyLCB0aGlzLmZhciwgdGhpcy5jbGlwU3BhY2VOZWFyWiA9PT0gQ2xpcFNwYWNlTmVhclouWkVSTyk7XG4gICAgICBtYXQ0LmludmVydCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgdGhpcy50cmlnZ2VyVXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3J0aG9ncmFwaGljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9ydGhvZ3JhcGhpYyhsLCByLCB0LCBiLCBuZWFyLCBmYXIpIHtcbiAgICAgIHZhciBfdGhpcyR2aWV3MjtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1vZGUgPSBDYW1lcmFQcm9qZWN0aW9uTW9kZS5PUlRIT0dSQVBISUM7XG4gICAgICB0aGlzLnJyaWdodCA9IHI7XG4gICAgICB0aGlzLmxlZnQgPSBsO1xuICAgICAgdGhpcy50b3AgPSB0O1xuICAgICAgdGhpcy5ib3R0b20gPSBiO1xuICAgICAgdGhpcy5uZWFyID0gbmVhcjtcbiAgICAgIHRoaXMuZmFyID0gZmFyO1xuICAgICAgdmFyIGR4ID0gKHRoaXMucnJpZ2h0IC0gdGhpcy5sZWZ0KSAvICgyICogdGhpcy56b29tKTtcbiAgICAgIHZhciBkeSA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAvICgyICogdGhpcy56b29tKTtcbiAgICAgIHZhciBjeCA9ICh0aGlzLnJyaWdodCArIHRoaXMubGVmdCkgLyAyO1xuICAgICAgdmFyIGN5ID0gKHRoaXMudG9wICsgdGhpcy5ib3R0b20pIC8gMjtcbiAgICAgIHZhciBsZWZ0ID0gY3ggLSBkeDtcbiAgICAgIHZhciByaWdodCA9IGN4ICsgZHg7XG4gICAgICB2YXIgdG9wID0gY3kgKyBkeTtcbiAgICAgIHZhciBib3R0b20gPSBjeSAtIGR5O1xuICAgICAgaWYgKChfdGhpcyR2aWV3MiA9IHRoaXMudmlldykgIT09IG51bGwgJiYgX3RoaXMkdmlldzIgIT09IHZvaWQgMCAmJiBfdGhpcyR2aWV3Mi5lbmFibGVkKSB7XG4gICAgICAgIHZhciBzY2FsZVcgPSAodGhpcy5ycmlnaHQgLSB0aGlzLmxlZnQpIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCAvIHRoaXMuem9vbTtcbiAgICAgICAgdmFyIHNjYWxlSCA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAvIHRoaXMudmlldy5mdWxsSGVpZ2h0IC8gdGhpcy56b29tO1xuICAgICAgICBsZWZ0ICs9IHNjYWxlVyAqIHRoaXMudmlldy5vZmZzZXRYO1xuICAgICAgICByaWdodCA9IGxlZnQgKyBzY2FsZVcgKiB0aGlzLnZpZXcud2lkdGg7XG4gICAgICAgIHRvcCAtPSBzY2FsZUggKiB0aGlzLnZpZXcub2Zmc2V0WTtcbiAgICAgICAgYm90dG9tID0gdG9wIC0gc2NhbGVIICogdGhpcy52aWV3LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBTcGFjZU5lYXJaID09PSBDbGlwU3BhY2VOZWFyWi5ORUdBVElWRV9PTkUpIHtcbiAgICAgICAgLy8gRmxpcFkgd2l0aCBzd2l0Y2hpbmcgYm90dG9tICYgdG9wLlxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODg2NjU2XG4gICAgICAgIG1hdDQub3J0aG8odGhpcy5wcm9qZWN0aW9uTWF0cml4LCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXQ0Lm9ydGhvWk8odGhpcy5wcm9qZWN0aW9uTWF0cml4LCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG4gICAgICB9XG4gICAgICBtYXQ0LmludmVydCh0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgdGhpcy5fZ2V0T3J0aG9NYXRyaXgoKTtcbiAgICAgIHRoaXMudHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY2FtZXJhIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAqIEl0IHdpbGwga2VlcCBsb29raW5nIGF0IHRoZSBjdXJyZW50IGZvY2FsIHBvaW50LlxuICAgICAqXG4gICAgICogc3VwcG9ydCBzY2FsYXJzIG9yIHZlY3RvcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzZXRQb3NpdGlvbigxLCAyLCAzKTtcbiAgICAgKiBzZXRQb3NpdGlvbihbMSwgMiwgM10pO1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKHgpIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnBvc2l0aW9uWzFdO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMucG9zaXRpb25bMl07XG4gICAgICB2YXIgcG9zaXRpb24gPSBjcmVhdGVWZWMzKHgsIHksIHopO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgdGhpcy5zZXRGb2NhbFBvaW50KHRoaXMuZm9jYWxQb2ludCk7XG4gICAgICB0aGlzLnRyaWdnZXJVcGRhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZvY2FsIHBvaW50IG9mIHRoaXMgY2FtZXJhIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogc3VwcG9ydCBzY2FsYXJzIG9yIHZlY3RvcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzZXRGb2NhbFBvaW50KDEsIDIsIDMpO1xuICAgICAqIHNldEZvY2FsUG9pbnQoWzEsIDIsIDNdKTtcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRGb2NhbFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvY2FsUG9pbnQoeCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZm9jYWxQb2ludFsxXTtcbiAgICAgIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmZvY2FsUG9pbnRbMl07XG4gICAgICB2YXIgdXAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG4gICAgICB0aGlzLmZvY2FsUG9pbnQgPSBjcmVhdGVWZWMzKHgsIHksIHopO1xuICAgICAgaWYgKHRoaXMudHJhY2tpbmdNb2RlID09PSBDYW1lcmFUcmFja2luZ01vZGUuQ0lORU1BVElDKSB7XG4gICAgICAgIHZhciBkID0gdmVjMy5zdWJ0cmFjdCh2ZWMzLmNyZWF0ZSgpLCB0aGlzLmZvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB4ID0gZFswXTtcbiAgICAgICAgeSA9IGRbMV07XG4gICAgICAgIHogPSBkWzJdO1xuICAgICAgICB2YXIgciA9IHZlYzMubGVuZ3RoKGQpO1xuICAgICAgICB2YXIgZWwgPSByYWQyZGVnKE1hdGguYXNpbih5IC8gcikpO1xuICAgICAgICB2YXIgYXogPSA5MCArIHJhZDJkZWcoTWF0aC5hdGFuMih6LCB4KSk7XG4gICAgICAgIHZhciBtID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgbWF0NC5yb3RhdGVZKG0sIG0sIGRlZzJyYWQoYXopKTtcbiAgICAgICAgbWF0NC5yb3RhdGVYKG0sIG0sIGRlZzJyYWQoZWwpKTtcbiAgICAgICAgdXAgPSB2ZWMzLnRyYW5zZm9ybU1hdDQodmVjMy5jcmVhdGUoKSwgWzAsIDEsIDBdLCBtKTtcbiAgICAgIH1cbiAgICAgIG1hdDQuaW52ZXJ0KHRoaXMubWF0cml4LCBtYXQ0Lmxvb2tBdChtYXQ0LmNyZWF0ZSgpLCB0aGlzLnBvc2l0aW9uLCB0aGlzLmZvY2FsUG9pbnQsIHVwKSk7XG4gICAgICB0aGlzLl9nZXRBeGVzKCk7XG4gICAgICB0aGlzLl9nZXREaXN0YW5jZSgpO1xuICAgICAgdGhpcy5fZ2V0QW5nbGVzKCk7XG4gICAgICB0aGlzLnRyaWdnZXJVcGRhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREaXN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREaXN0YW5jZVZlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZVZlY3RvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVmVjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBjYW1lcmEgdG93YXJkcy9mcm9tIHRoZSBmb2NhbCBwb2ludC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREaXN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXN0YW5jZShkKSB7XG4gICAgICBpZiAodGhpcy5kaXN0YW5jZSA9PT0gZCB8fCBkIDwgMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzdGFuY2UgPSBkO1xuICAgICAgaWYgKHRoaXMuZGlzdGFuY2UgPCBNSU5fRElTVEFOQ0UpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IE1JTl9ESVNUQU5DRTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9sbHlpbmdTdGVwID0gdGhpcy5kaXN0YW5jZSAvIDEwMDtcbiAgICAgIHZhciBwb3MgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgZCA9IHRoaXMuZGlzdGFuY2U7XG4gICAgICB2YXIgbiA9IHRoaXMuZm9yd2FyZDtcbiAgICAgIHZhciBmID0gdGhpcy5mb2NhbFBvaW50O1xuICAgICAgcG9zWzBdID0gZCAqIG5bMF0gKyBmWzBdO1xuICAgICAgcG9zWzFdID0gZCAqIG5bMV0gKyBmWzFdO1xuICAgICAgcG9zWzJdID0gZCAqIG5bMl0gKyBmWzJdO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgICAgIHRoaXMudHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1heERpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1heERpc3RhbmNlKGQpIHtcbiAgICAgIHRoaXMubWF4RGlzdGFuY2UgPSBkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1pbkRpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1pbkRpc3RhbmNlKGQpIHtcbiAgICAgIHRoaXMubWluRGlzdGFuY2UgPSBkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u55u45py65pa55L2N6KeS77yM5LiN5ZCM55u45py65qih5byP5LiL6ZyA6KaB6YeN5paw6K6h566X55u45py65L2N572u5oiW6ICF5piv6KeG54K55L2N572uXG4gICAgICogdGhlIGF6aW11dGggaW4gZGVncmVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEF6aW11dGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXppbXV0aChheikge1xuICAgICAgdGhpcy5hemltdXRoID0gZ2V0QW5nbGUoYXopO1xuICAgICAgdGhpcy5jb21wdXRlTWF0cml4KCk7XG4gICAgICB0aGlzLl9nZXRBeGVzKCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBDYW1lcmFUeXBlLk9SQklUSU5HIHx8IHRoaXMudHlwZSA9PT0gQ2FtZXJhVHlwZS5FWFBMT1JJTkcpIHtcbiAgICAgICAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBDYW1lcmFUeXBlLlRSQUNLSU5HKSB7XG4gICAgICAgIHRoaXMuX2dldEZvY2FsUG9pbnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF6aW11dGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXppbXV0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF6aW11dGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u55u45py65pa55L2N6KeS77yM5LiN5ZCM55u45py65qih5byP5LiL6ZyA6KaB6YeN5paw6K6h566X55u45py65L2N572u5oiW6ICF5piv6KeG54K55L2N572uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RWxldmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVsZXZhdGlvbihlbCkge1xuICAgICAgdGhpcy5lbGV2YXRpb24gPSBnZXRBbmdsZShlbCk7XG4gICAgICB0aGlzLmNvbXB1dGVNYXRyaXgoKTtcbiAgICAgIHRoaXMuX2dldEF4ZXMoKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IENhbWVyYVR5cGUuT1JCSVRJTkcgfHwgdGhpcy50eXBlID09PSBDYW1lcmFUeXBlLkVYUExPUklORykge1xuICAgICAgICB0aGlzLl9nZXRQb3NpdGlvbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IENhbWVyYVR5cGUuVFJBQ0tJTkcpIHtcbiAgICAgICAgdGhpcy5fZ2V0Rm9jYWxQb2ludCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyVXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxldmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZXZhdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZXZhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7nm7jmnLrmlrnkvY3op5LvvIzkuI3lkIznm7jmnLrmqKHlvI/kuIvpnIDopoHph43mlrDorqHnrpfnm7jmnLrkvY3nva7miJbogIXmmK/op4bngrnkvY3nva5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRSb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJvbGwoYW5nbGUpIHtcbiAgICAgIHRoaXMucm9sbCA9IGdldEFuZ2xlKGFuZ2xlKTtcbiAgICAgIHRoaXMuY29tcHV0ZU1hdHJpeCgpO1xuICAgICAgdGhpcy5fZ2V0QXhlcygpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQ2FtZXJhVHlwZS5PUkJJVElORyB8fCB0aGlzLnR5cGUgPT09IENhbWVyYVR5cGUuRVhQTE9SSU5HKSB7XG4gICAgICAgIHRoaXMuX2dldFBvc2l0aW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gQ2FtZXJhVHlwZS5UUkFDS0lORykge1xuICAgICAgICB0aGlzLl9nZXRGb2NhbFBvaW50KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXJVcGRhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvbGwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb2xsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOagueaNruebuOacuuefqemYtemHjeaWsOiuoeeul+WQhOenjeebuOacuuWPguaVsFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2dldEF4ZXMoKTtcbiAgICAgIHRoaXMuX2dldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLl9nZXREaXN0YW5jZSgpO1xuICAgICAgdGhpcy5fZ2V0QW5nbGVzKCk7XG4gICAgICB0aGlzLl9nZXRPcnRob01hdHJpeCgpO1xuICAgICAgdGhpcy50cmlnZ2VyVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X55u45py655+p6Zi1XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZU1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlTWF0cml4KCkge1xuICAgICAgLy8g5L2/55So5Zub5YWD5pWw5o+P6L+wIDNEIOaXi+i9rFxuICAgICAgLy8gQHNlZSBodHRwczovL3hpYW9pdmVyLmdpdGh1Yi5pby9jb2RpbmcvMjAxOC8xMi8yOC9DYW1lcmEtJUU4JUFFJUJFJUU4JUFFJUExLSVFNCVCOCU4MC5odG1sXG4gICAgICB2YXIgcm90WiA9IHF1YXQkMS5zZXRBeGlzQW5nbGUocXVhdCQxLmNyZWF0ZSgpLCBbMCwgMCwgMV0sIGRlZzJyYWQodGhpcy5yb2xsKSk7XG4gICAgICBtYXQ0LmlkZW50aXR5KHRoaXMubWF0cml4KTtcblxuICAgICAgLy8gb25seSBjb25zaWRlciBIQ1MgZm9yIEVYUExPUklORyBhbmQgT1JCSVRJTkcgY2FtZXJhc1xuICAgICAgdmFyIHJvdFggPSBxdWF0JDEuc2V0QXhpc0FuZ2xlKHF1YXQkMS5jcmVhdGUoKSwgWzEsIDAsIDBdLCBkZWcycmFkKCh0aGlzLnJvdGF0ZVdvcmxkICYmIHRoaXMudHlwZSAhPT0gQ2FtZXJhVHlwZS5UUkFDS0lORyB8fCB0aGlzLnR5cGUgPT09IENhbWVyYVR5cGUuVFJBQ0tJTkcgPyAxIDogLTEpICogdGhpcy5lbGV2YXRpb24pKTtcbiAgICAgIHZhciByb3RZID0gcXVhdCQxLnNldEF4aXNBbmdsZShxdWF0JDEuY3JlYXRlKCksIFswLCAxLCAwXSwgZGVnMnJhZCgodGhpcy5yb3RhdGVXb3JsZCAmJiB0aGlzLnR5cGUgIT09IENhbWVyYVR5cGUuVFJBQ0tJTkcgfHwgdGhpcy50eXBlID09PSBDYW1lcmFUeXBlLlRSQUNLSU5HID8gMSA6IC0xKSAqIHRoaXMuYXppbXV0aCkpO1xuICAgICAgdmFyIHJvdFEgPSBxdWF0JDEubXVsdGlwbHkocXVhdCQxLmNyZWF0ZSgpLCByb3RZLCByb3RYKTtcbiAgICAgIHJvdFEgPSBxdWF0JDEubXVsdGlwbHkocXVhdCQxLmNyZWF0ZSgpLCByb3RRLCByb3RaKTtcbiAgICAgIHZhciByb3RNYXRyaXggPSBtYXQ0LmZyb21RdWF0KG1hdDQuY3JlYXRlKCksIHJvdFEpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQ2FtZXJhVHlwZS5PUkJJVElORyB8fCB0aGlzLnR5cGUgPT09IENhbWVyYVR5cGUuRVhQTE9SSU5HKSB7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdGhpcy5mb2NhbFBvaW50KTtcbiAgICAgICAgbWF0NC5tdWx0aXBseSh0aGlzLm1hdHJpeCwgdGhpcy5tYXRyaXgsIHJvdE1hdHJpeCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgWzAsIDAsIHRoaXMuZGlzdGFuY2VdKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBDYW1lcmFUeXBlLlRSQUNLSU5HKSB7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIG1hdDQubXVsdGlwbHkodGhpcy5tYXRyaXgsIHRoaXMubWF0cml4LCByb3RNYXRyaXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbWVyYSBwb3NpdGlvbiBpbiB0aGUgY2FtZXJhIG1hdHJpeFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UG9zaXRpb24oeCwgeSwgeikge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IGNyZWF0ZVZlYzMoeCwgeSwgeik7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0cml4O1xuICAgICAgbVsxMl0gPSB0aGlzLnBvc2l0aW9uWzBdO1xuICAgICAgbVsxM10gPSB0aGlzLnBvc2l0aW9uWzFdO1xuICAgICAgbVsxNF0gPSB0aGlzLnBvc2l0aW9uWzJdO1xuICAgICAgbVsxNV0gPSAxO1xuICAgICAgdGhpcy5fZ2V0T3J0aG9NYXRyaXgoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgYXhlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QXhlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXhlcygpIHtcbiAgICAgIHZlYzMuY29weSh0aGlzLnJpZ2h0LCBjcmVhdGVWZWMzKHZlYzQudHJhbnNmb3JtTWF0NCh2ZWM0LmNyZWF0ZSgpLCBbMSwgMCwgMCwgMF0sIHRoaXMubWF0cml4KSkpO1xuICAgICAgdmVjMy5jb3B5KHRoaXMudXAsIGNyZWF0ZVZlYzModmVjNC50cmFuc2Zvcm1NYXQ0KHZlYzQuY3JlYXRlKCksIFswLCAxLCAwLCAwXSwgdGhpcy5tYXRyaXgpKSk7XG4gICAgICB2ZWMzLmNvcHkodGhpcy5mb3J3YXJkLCBjcmVhdGVWZWMzKHZlYzQudHJhbnNmb3JtTWF0NCh2ZWM0LmNyZWF0ZSgpLCBbMCwgMCwgMSwgMF0sIHRoaXMubWF0cml4KSkpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodGhpcy5yaWdodCwgdGhpcy5yaWdodCk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0aGlzLnVwLCB0aGlzLnVwKTtcbiAgICAgIHZlYzMubm9ybWFsaXplKHRoaXMuZm9yd2FyZCwgdGhpcy5mb3J3YXJkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgZXVsZXIgYW5nbGVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFuZ2xlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QW5nbGVzKCkge1xuICAgICAgLy8gUmVjYWxjdWxhdGVzIGFuZ2xlc1xuICAgICAgdmFyIHggPSB0aGlzLmRpc3RhbmNlVmVjdG9yWzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLmRpc3RhbmNlVmVjdG9yWzFdO1xuICAgICAgdmFyIHogPSB0aGlzLmRpc3RhbmNlVmVjdG9yWzJdO1xuICAgICAgdmFyIHIgPSB2ZWMzLmxlbmd0aCh0aGlzLmRpc3RhbmNlVmVjdG9yKTtcblxuICAgICAgLy8gRkFTVCBGQUlMOiBJZiB0aGVyZSBpcyBubyBkaXN0YW5jZSB3ZSBjYW5ub3QgY29tcHV0ZSBhbmdsZXNcbiAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgIHRoaXMuZWxldmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5hemltdXRoID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQ2FtZXJhVHlwZS5UUkFDS0lORykge1xuICAgICAgICB0aGlzLmVsZXZhdGlvbiA9IHJhZDJkZWcoTWF0aC5hc2luKHkgLyByKSk7XG4gICAgICAgIHRoaXMuYXppbXV0aCA9IHJhZDJkZWcoTWF0aC5hdGFuMigteCwgLXopKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yb3RhdGVXb3JsZCkge1xuICAgICAgICB0aGlzLmVsZXZhdGlvbiA9IHJhZDJkZWcoTWF0aC5hc2luKHkgLyByKSk7XG4gICAgICAgIHRoaXMuYXppbXV0aCA9IHJhZDJkZWcoTWF0aC5hdGFuMigteCwgLXopKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxldmF0aW9uID0gLXJhZDJkZWcoTWF0aC5hc2luKHkgLyByKSk7XG4gICAgICAgIHRoaXMuYXppbXV0aCA9IC1yYWQyZGVnKE1hdGguYXRhbjIoLXgsIC16KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6YeN5paw6K6h566X55u45py65L2N572u77yM5Y+q5pyJIE9SQklUSU5HIOaooeW8j+ebuOacuuS9jee9ruaJjeS8muWPkeeUn+WPmOWMllxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UG9zaXRpb24oKSB7XG4gICAgICB2ZWMzLmNvcHkodGhpcy5wb3NpdGlvbiwgY3JlYXRlVmVjMyh2ZWM0LnRyYW5zZm9ybU1hdDQodmVjNC5jcmVhdGUoKSwgWzAsIDAsIDAsIDFdLCB0aGlzLm1hdHJpeCkpKTtcblxuICAgICAgLy8g55u45py65L2N572u5Y+Y5YyW77yM6ZyA6KaB6YeN5paw6K6h566X6KeG6LedXG4gICAgICB0aGlzLl9nZXREaXN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmHjeaWsOiuoeeul+inhueCue+8jOWPquaciSBUUkFDS0lORyDmqKHlvI/op4bngrnmiY3kvJrlj5HnlJ/lj5jljJZcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Rm9jYWxQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9jYWxQb2ludCgpIHtcbiAgICAgIHZlYzMudHJhbnNmb3JtTWF0Myh0aGlzLmRpc3RhbmNlVmVjdG9yLCBbMCwgMCwgLXRoaXMuZGlzdGFuY2VdLCBtYXQzLmZyb21NYXQ0KG1hdDMuY3JlYXRlKCksIHRoaXMubWF0cml4KSk7XG4gICAgICB2ZWMzLmFkZCh0aGlzLmZvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuZGlzdGFuY2VWZWN0b3IpO1xuXG4gICAgICAvLyDop4bngrnlj5jljJbvvIzpnIDopoHph43mlrDorqHnrpfop4bot51cbiAgICAgIHRoaXMuX2dldERpc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6YeN5paw6K6h566X6KeG6LedXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZSgpIHtcbiAgICAgIHRoaXMuZGlzdGFuY2VWZWN0b3IgPSB2ZWMzLnN1YnRyYWN0KHZlYzMuY3JlYXRlKCksIHRoaXMuZm9jYWxQb2ludCwgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLmRpc3RhbmNlID0gdmVjMy5sZW5ndGgodGhpcy5kaXN0YW5jZVZlY3Rvcik7XG4gICAgICB0aGlzLmRvbGx5aW5nU3RlcCA9IHRoaXMuZGlzdGFuY2UgLyAxMDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRPcnRob01hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T3J0aG9NYXRyaXgoKSB7XG4gICAgICBpZiAodGhpcy5wcm9qZWN0aW9uTW9kZSAhPT0gQ2FtZXJhUHJvamVjdGlvbk1vZGUuT1JUSE9HUkFQSElDKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB2YXIgcm90WiA9IHF1YXQkMS5zZXRBeGlzQW5nbGUocXVhdCQxLmNyZWF0ZSgpLCBbMCwgMCwgMV0sIC10aGlzLnJvbGwgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbih0aGlzLm9ydGhvTWF0cml4LCByb3RaLCB2ZWMzLmZyb21WYWx1ZXMoKHRoaXMucnJpZ2h0IC0gdGhpcy5sZWZ0KSAvIDIgLSBwb3NpdGlvblswXSwgKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pIC8gMiAtIHBvc2l0aW9uWzFdLCAwKSwgdmVjMy5mcm9tVmFsdWVzKHRoaXMuem9vbSwgdGhpcy56b29tLCAxKSwgcG9zaXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmlnZ2VyVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXJVcGRhdGUoKSB7XG4gICAgICBpZiAodGhpcy5lbmFibGVVcGRhdGUpIHtcbiAgICAgICAgLy8gdXBkYXRlIGZydXN0dW1cbiAgICAgICAgdmFyIHZpZXdNYXRyaXggPSB0aGlzLmdldFZpZXdUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIHZwTWF0cml4ID0gbWF0NC5tdWx0aXBseShtYXQ0LmNyZWF0ZSgpLCB0aGlzLmdldFBlcnNwZWN0aXZlKCksIHZpZXdNYXRyaXgpO1xuICAgICAgICB0aGlzLmdldEZydXN0dW0oKS5leHRyYWN0RnJvbVZQTWF0cml4KHZwTWF0cml4KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChDYW1lcmFFdmVudC5VUERBVEVEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZShhemltdXRoLCBlbGV2YXRpb24sIHJvbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW4odHgsIHR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb2xseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb2xseSh2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlTGFuZG1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTGFuZG1hcmsobmFtZSwgcGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnb3RvTGFuZG1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ290b0xhbmRtYXJrKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbExhbmRtYXJrQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbExhbmRtYXJrQW5pbWF0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vaG93X3RvL29wdGltaXppbmdfeW91cl9zY2VuZSNjaGFuZ2luZy1tZXNoLWN1bGxpbmctc3RyYXRlZ3lcbiAqL1xudmFyIFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChTdHJhdGVneSkge1xuICBTdHJhdGVneVtTdHJhdGVneVtcIlN0YW5kYXJkXCJdID0gMF0gPSBcIlN0YW5kYXJkXCI7XG4gIHJldHVybiBTdHJhdGVneTtcbn0oe30pO1xuXG52YXIgU29ydFJlYXNvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoU29ydFJlYXNvbikge1xuICBTb3J0UmVhc29uW1NvcnRSZWFzb25bXCJBRERFRFwiXSA9IDBdID0gXCJBRERFRFwiO1xuICBTb3J0UmVhc29uW1NvcnRSZWFzb25bXCJSRU1PVkVEXCJdID0gMV0gPSBcIlJFTU9WRURcIjtcbiAgU29ydFJlYXNvbltTb3J0UmVhc29uW1wiWl9JTkRFWF9DSEFOR0VEXCJdID0gMl0gPSBcIlpfSU5ERVhfQ0hBTkdFRFwiO1xuICByZXR1cm4gU29ydFJlYXNvbjtcbn0oe30pO1xuXG52YXIgRU1QVFlfUEFSU0VEX1BBVEggPSB7XG4gIGFic29sdXRlUGF0aDogW10sXG4gIGhhc0FyYzogZmFsc2UsXG4gIHNlZ21lbnRzOiBbXSxcbiAgcG9seWdvbnM6IFtdLFxuICBwb2x5bGluZXM6IFtdLFxuICBjdXJ2ZTogbnVsbCxcbiAgdG90YWxMZW5ndGg6IDAsXG4gIHJlY3Q6IG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMClcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQ29udGVudF90eXBlXG4gKi9cbnZhciBQcm9wZXJ0eVN5bnRheCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoUHJvcGVydHlTeW50YXgpIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0NvbnRlbnRfdHlwZSNjb29yZGluYXRlXG4gICAqL1xuICBQcm9wZXJ0eVN5bnRheFtcIkNPT1JESU5BVEVcIl0gPSBcIjxjb29yZGluYXRlPlwiO1xuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQ29udGVudF90eXBlI2NvbG9yXG4gICAqL1xuICBQcm9wZXJ0eVN5bnRheFtcIkNPTE9SXCJdID0gXCI8Y29sb3I+XCI7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9Db250ZW50X3R5cGUjcGFpbnRcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiUEFJTlRcIl0gPSBcIjxwYWludD5cIjtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0NvbnRlbnRfdHlwZSNudW1iZXJcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiTlVNQkVSXCJdID0gXCI8bnVtYmVyPlwiO1xuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9DU1MvYW5nbGVcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiQU5HTEVcIl0gPSBcIjxhbmdsZT5cIjtcbiAgLyoqXG4gICAqIDxudW1iZXI+IHdpdGggcmFuZ2UgMC4uMVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9Db250ZW50X3R5cGUjb3BhY2l0eV92YWx1ZVxuICAgKi9cbiAgUHJvcGVydHlTeW50YXhbXCJPUEFDSVRZX1ZBTFVFXCJdID0gXCI8b3BhY2l0eS12YWx1ZT5cIjtcbiAgLyoqXG4gICAqIDxudW1iZXI+IHdpdGggcmFuZ2UgMC4uSW5maW5pdHlcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiU0hBRE9XX0JMVVJcIl0gPSBcIjxzaGFkb3ctYmx1cj5cIjtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0NvbnRlbnRfdHlwZSNsZW5ndGhcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiTEVOR1RIXCJdID0gXCI8bGVuZ3RoPlwiO1xuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQ29udGVudF90eXBlI3BlcmNlbnRhZ2VcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiUEVSQ0VOVEFHRVwiXSA9IFwiPHBlcmNlbnRhZ2U+XCI7XG4gIFByb3BlcnR5U3ludGF4W1wiTEVOR1RIX1BFUkNFTlRBR0VcIl0gPSBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+XCI7XG4gIFByb3BlcnR5U3ludGF4W1wiTEVOR1RIX1BFUkNFTlRBR0VfMTJcIl0gPSBcIls8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPl17MSwyfVwiO1xuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbWFyZ2luI2Zvcm1hbF9zeW50YXhcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiTEVOR1RIX1BFUkNFTlRBR0VfMTRcIl0gPSBcIls8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPl17MSw0fVwiO1xuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQ29udGVudF90eXBlI2xpc3Qtb2YtdHNcbiAgICovXG4gIFByb3BlcnR5U3ludGF4W1wiTElTVF9PRl9QT0lOVFNcIl0gPSBcIjxsaXN0LW9mLXBvaW50cz5cIjtcbiAgUHJvcGVydHlTeW50YXhbXCJQQVRIXCJdID0gXCI8cGF0aD5cIjtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZpbHRlciNmb3JtYWxfc3ludGF4XG4gICAqL1xuICBQcm9wZXJ0eVN5bnRheFtcIkZJTFRFUlwiXSA9IFwiPGZpbHRlcj5cIjtcbiAgUHJvcGVydHlTeW50YXhbXCJaX0lOREVYXCJdID0gXCI8ei1pbmRleD5cIjtcbiAgUHJvcGVydHlTeW50YXhbXCJPRkZTRVRfRElTVEFOQ0VcIl0gPSBcIjxvZmZzZXQtZGlzdGFuY2U+XCI7XG4gIFByb3BlcnR5U3ludGF4W1wiREVGSU5FRF9QQVRIXCJdID0gXCI8ZGVmaW5lZC1wYXRoPlwiO1xuICBQcm9wZXJ0eVN5bnRheFtcIk1BUktFUlwiXSA9IFwiPG1hcmtlcj5cIjtcbiAgUHJvcGVydHlTeW50YXhbXCJUUkFOU0ZPUk1cIl0gPSBcIjx0cmFuc2Zvcm0+XCI7XG4gIFByb3BlcnR5U3ludGF4W1wiVFJBTlNGT1JNX09SSUdJTlwiXSA9IFwiPHRyYW5zZm9ybS1vcmlnaW4+XCI7XG4gIFByb3BlcnR5U3ludGF4W1wiVEVYVFwiXSA9IFwiPHRleHQ+XCI7XG4gIFByb3BlcnR5U3ludGF4W1wiVEVYVF9UUkFOU0ZPUk1cIl0gPSBcIjx0ZXh0LXRyYW5zZm9ybT5cIjtcbiAgcmV0dXJuIFByb3BlcnR5U3ludGF4O1xufSh7fSk7XG5cbmZ1bmN0aW9uIGRlZmluZShjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBDb2xvcigpIHt9XG5cbnZhciBkYXJrZXIgPSAwLjc7XG52YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4ID0gL14jKFswLTlhLWZdezMsOH0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHtyZUl9LCR7cmVJfSwke3JlSX1cXFxcKSRgKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke3JlUH0sJHtyZVB9LCR7cmVQfVxcXFwpJGApLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtyZUl9LCR7cmVJfSwke3JlSX0sJHtyZU59XFxcXCkkYCksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5yZ2JhXFxcXCgke3JlUH0sJHtyZVB9LCR7cmVQfSwke3JlTn1cXFxcKSRgKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKGBeaHNsXFxcXCgke3JlTn0sJHtyZVB9LCR7cmVQfVxcXFwpJGApLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKGBeaHNsYVxcXFwoJHtyZU59LCR7cmVQfSwke3JlUH0sJHtyZU59XFxcXCkkYCk7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGNvcHkoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhleDg6IGNvbG9yX2Zvcm1hdEhleDgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleDgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleDgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SHNsKCkge1xuICByZXR1cm4gaHNsQ29udmVydCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0UmdiKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cblxuZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtLCBsO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4LmV4ZWMoZm9ybWF0KSkgPyAobCA9IG1bMV0ubGVuZ3RoLCBtID0gcGFyc2VJbnQobVsxXSwgMTYpLCBsID09PSA2ID8gcmdibihtKSAvLyAjZmYwMDAwXG4gICAgICA6IGwgPT09IDMgPyBuZXcgUmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpIC8vICNmMDBcbiAgICAgIDogbCA9PT0gOCA/IHJnYmEobSA+PiAyNCAmIDB4ZmYsIG0gPj4gMTYgJiAweGZmLCBtID4+IDggJiAweGZmLCAobSAmIDB4ZmYpIC8gMHhmZikgLy8gI2ZmMDAwMDAwXG4gICAgICA6IGwgPT09IDQgPyByZ2JhKChtID4+IDEyICYgMHhmKSB8IChtID4+IDggJiAweGYwKSwgKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKCgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpIC8gMHhmZikgLy8gI2YwMDBcbiAgICAgIDogbnVsbCkgLy8gaW52YWxpZCBoZXhcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgMSkgLy8gcmdiKDEwMCUsIDAlLCAwJSlcbiAgICAgIDogKG0gPSByZVJnYmFJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pIC8vIHJnYmEoMjU1LCAwLCAwLCAxKVxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgMSkgLy8gaHNsKDEyMCwgNTAlLCA1MCUpXG4gICAgICA6IChtID0gcmVIc2xhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCBtWzRdKSAvLyBoc2xhKDEyMCwgNTAlLCA1MCUsIDEpXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICA6IGZvcm1hdCA9PT0gXCJ0cmFuc3BhcmVudFwiID8gbmV3IFJnYihOYU4sIE5hTiwgTmFOLCAwKVxuICAgICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiByZ2JuKG4pIHtcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcbn1cblxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XG4gIGlmIChhIDw9IDApIHIgPSBnID0gYiA9IE5hTjtcbiAgcmV0dXJuIG5ldyBSZ2IociwgZywgYiwgYSk7XG59XG5cbmZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gUmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5yID0gK3I7XG4gIHRoaXMuZyA9ICtnO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShSZ2IsIHJnYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgUmdiKGNsYW1waSh0aGlzLnIpLCBjbGFtcGkodGhpcy5nKSwgY2xhbXBpKHRoaXMuYiksIGNsYW1wYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRIZXg4OiByZ2JfZm9ybWF0SGV4OCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gYCMke2hleCh0aGlzLnIpfSR7aGV4KHRoaXMuZyl9JHtoZXgodGhpcy5iKX1gO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4OCgpIHtcbiAgcmV0dXJuIGAjJHtoZXgodGhpcy5yKX0ke2hleCh0aGlzLmcpfSR7aGV4KHRoaXMuYil9JHtoZXgoKGlzTmFOKHRoaXMub3BhY2l0eSkgPyAxIDogdGhpcy5vcGFjaXR5KSAqIDI1NSl9YDtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgY29uc3QgYSA9IGNsYW1wYSh0aGlzLm9wYWNpdHkpO1xuICByZXR1cm4gYCR7YSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwifSR7Y2xhbXBpKHRoaXMucil9LCAke2NsYW1waSh0aGlzLmcpfSwgJHtjbGFtcGkodGhpcy5iKX0ke2EgPT09IDEgPyBcIilcIiA6IGAsICR7YX0pYH1gO1xufVxuXG5mdW5jdGlvbiBjbGFtcGEob3BhY2l0eSkge1xuICByZXR1cm4gaXNOYU4ob3BhY2l0eSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgb3BhY2l0eSkpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGkodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xufVxuXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgdmFsdWUgPSBjbGFtcGkodmFsdWUpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBIc2woY2xhbXBoKHRoaXMuaCksIGNsYW1wdCh0aGlzLnMpLCBjbGFtcHQodGhpcy5sKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsKCkge1xuICAgIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgICByZXR1cm4gYCR7YSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwifSR7Y2xhbXBoKHRoaXMuaCl9LCAke2NsYW1wdCh0aGlzLnMpICogMTAwfSUsICR7Y2xhbXB0KHRoaXMubCkgKiAxMDB9JSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gY2xhbXBoKHZhbHVlKSB7XG4gIHZhbHVlID0gKHZhbHVlIHx8IDApICUgMzYwO1xuICByZXR1cm4gdmFsdWUgPCAwID8gdmFsdWUgKyAzNjAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xhbXB0KHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSB8fCAwKSk7XG59XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicgfHwgcmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIF9tZW1vaXplZCA9IGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdmFyIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdO1xuICAgIHZhciBjYWNoZSA9IF9tZW1vaXplZC5jYWNoZTtcbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgX21lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBfbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwKSgpO1xuICBtZW1vaXplLmNhY2hlTGlzdC5wdXNoKF9tZW1vaXplZC5jYWNoZSk7XG4gIHJldHVybiBfbWVtb2l6ZWQ7XG59XG5tZW1vaXplLkNhY2hlID0gTWFwO1xubWVtb2l6ZS5jYWNoZUxpc3QgPSBbXTtcbm1lbW9pemUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgbWVtb2l6ZS5jYWNoZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGUuY2xlYXIoKTtcbiAgfSk7XG59O1xuXG4vLyBUaGVzZSB1bml0cyBhcmUgaXRlcmF0ZWQgdGhyb3VnaCwgc28gYmUgY2FyZWZ1bCB3aGVuIGFkZGluZyBvciBjaGFuZ2luZyB0aGVcbi8vIG9yZGVyLlxudmFyIFVuaXRUeXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChVbml0VHlwZSkge1xuICBVbml0VHlwZVtVbml0VHlwZVtcImtVbmtub3duXCJdID0gMF0gPSBcImtVbmtub3duXCI7XG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia051bWJlclwiXSA9IDFdID0gXCJrTnVtYmVyXCI7XG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia1BlcmNlbnRhZ2VcIl0gPSAyXSA9IFwia1BlcmNlbnRhZ2VcIjtcbiAgLy8gTGVuZ3RoIHVuaXRzXG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia0Vtc1wiXSA9IDNdID0gXCJrRW1zXCI7XG4gIC8vIGtFeHMsXG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia1BpeGVsc1wiXSA9IDRdID0gXCJrUGl4ZWxzXCI7XG4gIC8vIGtDZW50aW1ldGVycyxcbiAgLy8ga01pbGxpbWV0ZXJzLFxuICAvLyBrSW5jaGVzLFxuICAvLyBrUG9pbnRzLFxuICAvLyBrUGljYXMsXG4gIC8vIGtRdWFydGVyTWlsbGltZXRlcnMsXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTQvI3ZpZXdwb3J0LXJlbGF0aXZlLWxlbmd0aHNcbiAgLy9cbiAgLy8gU2VlIGFsc28gSXNWaWV3cG9ydFBlcmNlbnRhZ2VMZW5ndGguXG4gIC8vIGtWaWV3cG9ydFdpZHRoLFxuICAvLyBrVmlld3BvcnRIZWlnaHQsXG4gIC8vIGtWaWV3cG9ydElubGluZVNpemUsXG4gIC8vIGtWaWV3cG9ydEJsb2NrU2l6ZSxcbiAgLy8ga1ZpZXdwb3J0TWluLFxuICAvLyBrVmlld3BvcnRNYXgsXG4gIC8vIGtTbWFsbFZpZXdwb3J0V2lkdGgsXG4gIC8vIGtTbWFsbFZpZXdwb3J0SGVpZ2h0LFxuICAvLyBrU21hbGxWaWV3cG9ydElubGluZVNpemUsXG4gIC8vIGtTbWFsbFZpZXdwb3J0QmxvY2tTaXplLFxuICAvLyBrU21hbGxWaWV3cG9ydE1pbixcbiAgLy8ga1NtYWxsVmlld3BvcnRNYXgsXG4gIC8vIGtMYXJnZVZpZXdwb3J0V2lkdGgsXG4gIC8vIGtMYXJnZVZpZXdwb3J0SGVpZ2h0LFxuICAvLyBrTGFyZ2VWaWV3cG9ydElubGluZVNpemUsXG4gIC8vIGtMYXJnZVZpZXdwb3J0QmxvY2tTaXplLFxuICAvLyBrTGFyZ2VWaWV3cG9ydE1pbixcbiAgLy8ga0xhcmdlVmlld3BvcnRNYXgsXG4gIC8vIGtEeW5hbWljVmlld3BvcnRXaWR0aCxcbiAgLy8ga0R5bmFtaWNWaWV3cG9ydEhlaWdodCxcbiAgLy8ga0R5bmFtaWNWaWV3cG9ydElubGluZVNpemUsXG4gIC8vIGtEeW5hbWljVmlld3BvcnRCbG9ja1NpemUsXG4gIC8vIGtEeW5hbWljVmlld3BvcnRNaW4sXG4gIC8vIGtEeW5hbWljVmlld3BvcnRNYXgsXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtY29udGFpbi0zLyNjb250YWluZXItbGVuZ3Roc1xuICAvL1xuICAvLyBTZWUgYWxzbyBJc0NvbnRhaW5lclBlcmNlbnRhZ2VMZW5ndGguXG4gIC8vIGtDb250YWluZXJXaWR0aCxcbiAgLy8ga0NvbnRhaW5lckhlaWdodCxcbiAgLy8ga0NvbnRhaW5lcklubGluZVNpemUsXG4gIC8vIGtDb250YWluZXJCbG9ja1NpemUsXG4gIC8vIGtDb250YWluZXJNaW4sXG4gIC8vIGtDb250YWluZXJNYXgsXG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia1JlbXNcIl0gPSA1XSA9IFwia1JlbXNcIjtcbiAgLy8ga0NocyxcbiAgLy8ga1VzZXJVbml0cywgLy8gVGhlIFNWRyB0ZXJtIGZvciB1bml0bGVzcyBsZW5ndGhzXG4gIC8vIEFuZ2xlIHVuaXRzXG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia0RlZ3JlZXNcIl0gPSA2XSA9IFwia0RlZ3JlZXNcIjtcbiAgVW5pdFR5cGVbVW5pdFR5cGVbXCJrUmFkaWFuc1wiXSA9IDddID0gXCJrUmFkaWFuc1wiO1xuICBVbml0VHlwZVtVbml0VHlwZVtcImtHcmFkaWFuc1wiXSA9IDhdID0gXCJrR3JhZGlhbnNcIjtcbiAgVW5pdFR5cGVbVW5pdFR5cGVbXCJrVHVybnNcIl0gPSA5XSA9IFwia1R1cm5zXCI7XG4gIC8vIFRpbWUgdW5pdHNcbiAgVW5pdFR5cGVbVW5pdFR5cGVbXCJrTWlsbGlzZWNvbmRzXCJdID0gMTBdID0gXCJrTWlsbGlzZWNvbmRzXCI7XG4gIFVuaXRUeXBlW1VuaXRUeXBlW1wia1NlY29uZHNcIl0gPSAxMV0gPSBcImtTZWNvbmRzXCI7XG4gIC8vIGtIZXJ0eixcbiAgLy8ga0tpbG9oZXJ0eixcbiAgLy8gUmVzb2x1dGlvblxuICAvLyBrRG90c1BlclBpeGVsLFxuICAvLyBrRG90c1BlckluY2gsXG4gIC8vIGtEb3RzUGVyQ2VudGltZXRlcixcbiAgLy8gT3RoZXIgdW5pdHNcbiAgLy8ga0ZyYWN0aW9uLFxuICBVbml0VHlwZVtVbml0VHlwZVtcImtJbnRlZ2VyXCJdID0gMTJdID0gXCJrSW50ZWdlclwiOyAvLyBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gaGFuZGxlIHF1aXJreSBtYXJnaW5zIGluIHJlZmxvdyByb290cyAoYm9keSwgdGQsXG4gIC8vIGFuZCB0aCkgbGlrZSBXaW5JRS4gVGhlIGJhc2ljIGlkZWEgaXMgdGhhdCBhIHN0eWxlc2hlZXQgY2FuIHVzZSB0aGUgdmFsdWVcbiAgLy8gX19xZW0gKGZvciBxdWlya3kgZW0pIGluc3RlYWQgb2YgZW0uIFdoZW4gdGhlIHF1aXJreSB2YWx1ZSBpcyB1c2VkLCBpZlxuICAvLyB5b3UncmUgaW4gcXVpcmtzIG1vZGUsIHRoZSBtYXJnaW4gd2lsbCBjb2xsYXBzZSBhd2F5IGluc2lkZSBhIHRhYmxlIGNlbGwuXG4gIC8vIFRoaXMgcXVpcmsgaXMgc3BlY2lmaWVkIGluIHRoZSBIVE1MIHNwZWMgYnV0IG91ciBpbXBsIGlzIGRpZmZlcmVudC5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMuIGNyYnVnLmNvbS80NDM5NTJcbiAgLy8ga1F1aXJreUVtcyxcbiAgcmV0dXJuIFVuaXRUeXBlO1xufSh7fSk7XG52YXIgVW5pdENhdGVnb3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChVbml0Q2F0ZWdvcnkpIHtcbiAgVW5pdENhdGVnb3J5W1VuaXRDYXRlZ29yeVtcImtVTnVtYmVyXCJdID0gMF0gPSBcImtVTnVtYmVyXCI7XG4gIFVuaXRDYXRlZ29yeVtVbml0Q2F0ZWdvcnlbXCJrVVBlcmNlbnRcIl0gPSAxXSA9IFwia1VQZXJjZW50XCI7XG4gIFVuaXRDYXRlZ29yeVtVbml0Q2F0ZWdvcnlbXCJrVUxlbmd0aFwiXSA9IDJdID0gXCJrVUxlbmd0aFwiO1xuICBVbml0Q2F0ZWdvcnlbVW5pdENhdGVnb3J5W1wia1VBbmdsZVwiXSA9IDNdID0gXCJrVUFuZ2xlXCI7XG4gIFVuaXRDYXRlZ29yeVtVbml0Q2F0ZWdvcnlbXCJrVVRpbWVcIl0gPSA0XSA9IFwia1VUaW1lXCI7XG4gIC8vIGtVRnJlcXVlbmN5LFxuICAvLyBrVVJlc29sdXRpb24sXG4gIFVuaXRDYXRlZ29yeVtVbml0Q2F0ZWdvcnlbXCJrVU90aGVyXCJdID0gNV0gPSBcImtVT3RoZXJcIjtcbiAgcmV0dXJuIFVuaXRDYXRlZ29yeTtcbn0oe30pO1xudmFyIE5lc3RlZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoTmVzdGVkKSB7XG4gIE5lc3RlZFtOZXN0ZWRbXCJrWWVzXCJdID0gMF0gPSBcImtZZXNcIjtcbiAgTmVzdGVkW05lc3RlZFtcImtOb1wiXSA9IDFdID0gXCJrTm9cIjtcbiAgcmV0dXJuIE5lc3RlZDtcbn0oe30pO1xudmFyIFBhcmVuTGVzcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoUGFyZW5MZXNzKSB7XG4gIFBhcmVuTGVzc1tQYXJlbkxlc3NbXCJrWWVzXCJdID0gMF0gPSBcImtZZXNcIjtcbiAgUGFyZW5MZXNzW1BhcmVuTGVzc1tcImtOb1wiXSA9IDFdID0gXCJrTm9cIjtcbiAgcmV0dXJuIFBhcmVuTGVzcztcbn0oe30pO1xuXG4vLyBUaGlzIGZpbGUgc3BlY2lmaWVzIHRoZSB1bml0IHN0cmluZ3MgdXNlZCBpbiBDU1NQcmltaXRpdmVWYWx1ZXMuXG52YXIgZGF0YSA9IFt7XG4gIG5hbWU6ICdlbScsXG4gIHVuaXRfdHlwZTogVW5pdFR5cGUua0Vtc1xufSxcbi8vIHtcbi8vICAgbmFtZTogJ2V4Jyxcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rRXhzLFxuLy8gfSxcbntcbiAgbmFtZTogJ3B4JyxcbiAgdW5pdF90eXBlOiBVbml0VHlwZS5rUGl4ZWxzXG59LFxuLy8ge1xuLy8gICBuYW1lOiBcImNtXCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0NlbnRpbWV0ZXJzLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJtbVwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtNaWxsaW1ldGVycyxcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwicVwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtRdWFydGVyTWlsbGltZXRlcnMsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImluXCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0luY2hlcyxcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwicHRcIixcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rUG9pbnRzLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJwY1wiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtQaWNhcyxcbi8vIH0sXG57XG4gIG5hbWU6ICdkZWcnLFxuICB1bml0X3R5cGU6IFVuaXRUeXBlLmtEZWdyZWVzXG59LCB7XG4gIG5hbWU6ICdyYWQnLFxuICB1bml0X3R5cGU6IFVuaXRUeXBlLmtSYWRpYW5zXG59LCB7XG4gIG5hbWU6ICdncmFkJyxcbiAgdW5pdF90eXBlOiBVbml0VHlwZS5rR3JhZGlhbnNcbn0sIHtcbiAgbmFtZTogJ21zJyxcbiAgdW5pdF90eXBlOiBVbml0VHlwZS5rTWlsbGlzZWNvbmRzXG59LCB7XG4gIG5hbWU6ICdzJyxcbiAgdW5pdF90eXBlOiBVbml0VHlwZS5rU2Vjb25kc1xufSxcbi8vIHtcbi8vICAgbmFtZTogXCJoelwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtIZXJ0eixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwia2h6XCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0tpbG9oZXJ0eixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwiZHBpXCIsXG4vLyAgIHVuaXRfdHlwZTogXCJrRG90c1BlckluY2hcIixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwiZHBjbVwiLFxuLy8gICB1bml0X3R5cGU6IFwia0RvdHNQZXJDZW50aW1ldGVyXCIsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImRwcHhcIixcbi8vICAgdW5pdF90eXBlOiBcImtEb3RzUGVyUGl4ZWxcIixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwieFwiLFxuLy8gICB1bml0X3R5cGU6IFwia0RvdHNQZXJQaXhlbFwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJ2d1wiLFxuLy8gICB1bml0X3R5cGU6IFwia1ZpZXdwb3J0V2lkdGhcIixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwidmhcIixcbi8vICAgdW5pdF90eXBlOiBcImtWaWV3cG9ydEhlaWdodFwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJ2aVwiLFxuLy8gICB1bml0X3R5cGU6IFwia1ZpZXdwb3J0SW5saW5lU2l6ZVwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJ2YlwiLFxuLy8gICB1bml0X3R5cGU6IFwia1ZpZXdwb3J0QmxvY2tTaXplXCIsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcInZtaW5cIixcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rVmlld3BvcnRNaW4sXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcInZtYXhcIixcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rVmlld3BvcnRNYXgsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcInN2d1wiLFxuLy8gICB1bml0X3R5cGU6IFwia1NtYWxsVmlld3BvcnRXaWR0aFwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJzdmhcIixcbi8vICAgdW5pdF90eXBlOiBcImtTbWFsbFZpZXdwb3J0SGVpZ2h0XCIsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcInN2aVwiLFxuLy8gICB1bml0X3R5cGU6IFwia1NtYWxsVmlld3BvcnRJbmxpbmVTaXplXCIsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcInN2YlwiLFxuLy8gICB1bml0X3R5cGU6IFwia1NtYWxsVmlld3BvcnRCbG9ja1NpemVcIixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwic3ZtaW5cIixcbi8vICAgdW5pdF90eXBlOiBcImtTbWFsbFZpZXdwb3J0TWluXCIsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcInN2bWF4XCIsXG4vLyAgIHVuaXRfdHlwZTogXCJrU21hbGxWaWV3cG9ydE1heFwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJsdndcIixcbi8vICAgdW5pdF90eXBlOiBcImtMYXJnZVZpZXdwb3J0V2lkdGhcIixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwibHZoXCIsXG4vLyAgIHVuaXRfdHlwZTogXCJrTGFyZ2VWaWV3cG9ydEhlaWdodFwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJsdmlcIixcbi8vICAgdW5pdF90eXBlOiBcImtMYXJnZVZpZXdwb3J0SW5saW5lU2l6ZVwiLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJsdmJcIixcbi8vICAgdW5pdF90eXBlOiBcImtMYXJnZVZpZXdwb3J0QmxvY2tTaXplXCIsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImx2bWluXCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0xhcmdlVmlld3BvcnRNaW4sXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImx2bWF4XCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0xhcmdlVmlld3BvcnRNYXgsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImR2d1wiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtEeW5hbWljVmlld3BvcnRXaWR0aCxcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwiZHZoXCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0R5bmFtaWNWaWV3cG9ydEhlaWdodCxcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwiZHZpXCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0R5bmFtaWNWaWV3cG9ydElubGluZVNpemUsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImR2YlwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtEeW5hbWljVmlld3BvcnRCbG9ja1NpemUsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImR2bWluXCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0R5bmFtaWNWaWV3cG9ydE1pbixcbi8vIH0sXG4vLyB7XG4vLyAgIG5hbWU6IFwiZHZtYXhcIixcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rRHluYW1pY1ZpZXdwb3J0TWF4LFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJjcXdcIixcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rQ29udGFpbmVyV2lkdGgsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImNxaFwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtDb250YWluZXJIZWlnaHQsXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImNxaVwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtDb250YWluZXJJbmxpbmVTaXplLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJjcWJcIixcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rQ29udGFpbmVyQmxvY2tTaXplLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogXCJjcW1pblwiLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtDb250YWluZXJNaW4sXG4vLyB9LFxuLy8ge1xuLy8gICBuYW1lOiBcImNxbWF4XCIsXG4vLyAgIHVuaXRfdHlwZTogVW5pdFR5cGUua0NvbnRhaW5lck1heCxcbi8vIH0sXG57XG4gIG5hbWU6ICdyZW0nLFxuICB1bml0X3R5cGU6IFVuaXRUeXBlLmtSZW1zXG59LFxuLy8ge1xuLy8gICBuYW1lOiAnZnInLFxuLy8gICB1bml0X3R5cGU6IFVuaXRUeXBlLmtGcmFjdGlvbixcbi8vIH0sXG57XG4gIG5hbWU6ICd0dXJuJyxcbiAgdW5pdF90eXBlOiBVbml0VHlwZS5rVHVybnNcbn1cbi8vIHtcbi8vICAgbmFtZTogJ2NoJyxcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rQ2hzLFxuLy8gfSxcbi8vIHtcbi8vICAgbmFtZTogJ19fcWVtJyxcbi8vICAgdW5pdF90eXBlOiBVbml0VHlwZS5rUXVpcmt5RW1zLFxuLy8gfSxcbl07XG52YXIgQ1NTU3R5bGVWYWx1ZVR5cGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKENTU1N0eWxlVmFsdWVUeXBlKSB7XG4gIENTU1N0eWxlVmFsdWVUeXBlW0NTU1N0eWxlVmFsdWVUeXBlW1wia1Vua25vd25UeXBlXCJdID0gMF0gPSBcImtVbmtub3duVHlwZVwiO1xuICBDU1NTdHlsZVZhbHVlVHlwZVtDU1NTdHlsZVZhbHVlVHlwZVtcImtVbnBhcnNlZFR5cGVcIl0gPSAxXSA9IFwia1VucGFyc2VkVHlwZVwiO1xuICBDU1NTdHlsZVZhbHVlVHlwZVtDU1NTdHlsZVZhbHVlVHlwZVtcImtLZXl3b3JkVHlwZVwiXSA9IDJdID0gXCJrS2V5d29yZFR5cGVcIjtcbiAgLy8gU3RhcnQgb2YgQ1NTTnVtZXJpY1ZhbHVlIHN1YmNsYXNzZXNcbiAgQ1NTU3R5bGVWYWx1ZVR5cGVbQ1NTU3R5bGVWYWx1ZVR5cGVbXCJrVW5pdFR5cGVcIl0gPSAzXSA9IFwia1VuaXRUeXBlXCI7XG4gIENTU1N0eWxlVmFsdWVUeXBlW0NTU1N0eWxlVmFsdWVUeXBlW1wia1N1bVR5cGVcIl0gPSA0XSA9IFwia1N1bVR5cGVcIjtcbiAgQ1NTU3R5bGVWYWx1ZVR5cGVbQ1NTU3R5bGVWYWx1ZVR5cGVbXCJrUHJvZHVjdFR5cGVcIl0gPSA1XSA9IFwia1Byb2R1Y3RUeXBlXCI7XG4gIENTU1N0eWxlVmFsdWVUeXBlW0NTU1N0eWxlVmFsdWVUeXBlW1wia05lZ2F0ZVR5cGVcIl0gPSA2XSA9IFwia05lZ2F0ZVR5cGVcIjtcbiAgQ1NTU3R5bGVWYWx1ZVR5cGVbQ1NTU3R5bGVWYWx1ZVR5cGVbXCJrSW52ZXJ0VHlwZVwiXSA9IDddID0gXCJrSW52ZXJ0VHlwZVwiO1xuICBDU1NTdHlsZVZhbHVlVHlwZVtDU1NTdHlsZVZhbHVlVHlwZVtcImtNaW5UeXBlXCJdID0gOF0gPSBcImtNaW5UeXBlXCI7XG4gIENTU1N0eWxlVmFsdWVUeXBlW0NTU1N0eWxlVmFsdWVUeXBlW1wia01heFR5cGVcIl0gPSA5XSA9IFwia01heFR5cGVcIjtcbiAgQ1NTU3R5bGVWYWx1ZVR5cGVbQ1NTU3R5bGVWYWx1ZVR5cGVbXCJrQ2xhbXBUeXBlXCJdID0gMTBdID0gXCJrQ2xhbXBUeXBlXCI7XG4gIC8vIEVuZCBvZiBDU1NOdW1lcmljVmFsdWUgc3ViY2xhc3Nlc1xuICBDU1NTdHlsZVZhbHVlVHlwZVtDU1NTdHlsZVZhbHVlVHlwZVtcImtUcmFuc2Zvcm1UeXBlXCJdID0gMTFdID0gXCJrVHJhbnNmb3JtVHlwZVwiO1xuICBDU1NTdHlsZVZhbHVlVHlwZVtDU1NTdHlsZVZhbHVlVHlwZVtcImtQb3NpdGlvblR5cGVcIl0gPSAxMl0gPSBcImtQb3NpdGlvblR5cGVcIjtcbiAgQ1NTU3R5bGVWYWx1ZVR5cGVbQ1NTU3R5bGVWYWx1ZVR5cGVbXCJrVVJMSW1hZ2VUeXBlXCJdID0gMTNdID0gXCJrVVJMSW1hZ2VUeXBlXCI7XG4gIENTU1N0eWxlVmFsdWVUeXBlW0NTU1N0eWxlVmFsdWVUeXBlW1wia0NvbG9yVHlwZVwiXSA9IDE0XSA9IFwia0NvbG9yVHlwZVwiO1xuICBDU1NTdHlsZVZhbHVlVHlwZVtDU1NTdHlsZVZhbHVlVHlwZVtcImtVbnN1cHBvcnRlZENvbG9yVHlwZVwiXSA9IDE1XSA9IFwia1Vuc3VwcG9ydGVkQ29sb3JUeXBlXCI7XG4gIHJldHVybiBDU1NTdHlsZVZhbHVlVHlwZTtcbn0oe30pO1xuXG4vLyBmdW5jdGlvbiBwYXJzZUNTU1N0eWxlVmFsdWUocHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBDU1NTdHlsZVZhbHVlW10ge1xuLy8gICAvLyBjb25zdCBwcm9wZXJ0eUlkID0gY3NzUHJvcGVydHlJRChwcm9wZXJ0eU5hbWUpO1xuXG4vLyAgIC8vIGlmIChwcm9wZXJ0eUlkID09PSBDU1NQcm9wZXJ0eUlELmtJbnZhbGlkKSB7XG4vLyAgIC8vICAgcmV0dXJuIFtdO1xuLy8gICAvLyB9XG5cbi8vICAgLy8gY29uc3QgY3VzdG9tUHJvcGVydHlOYW1lID0gcHJvcGVydHlJZCA9PT0gQ1NTUHJvcGVydHlJRC5rVmFyaWFibGUgPyBwcm9wZXJ0eU5hbWUgOiBudWxsO1xuLy8gICAvLyByZXR1cm4gZnJvbVN0cmluZyhwcm9wZXJ0eUlkLCBjdXN0b21Qcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbi8vICAgcmV0dXJuIFtdO1xuLy8gfVxuXG52YXIgc3RyaW5nVG9Vbml0VHlwZSA9IGZ1bmN0aW9uIHN0cmluZ1RvVW5pdFR5cGUobmFtZSkge1xuICByZXR1cm4gZGF0YS5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgfSkudW5pdF90eXBlO1xufTtcbnZhciB1bml0RnJvbU5hbWUgPSBmdW5jdGlvbiB1bml0RnJvbU5hbWUobmFtZSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gVW5pdFR5cGUua1Vua25vd247XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFVuaXRUeXBlLmtOdW1iZXI7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdwZXJjZW50JyB8fCBuYW1lID09PSAnJScpIHtcbiAgICByZXR1cm4gVW5pdFR5cGUua1BlcmNlbnRhZ2U7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvVW5pdFR5cGUobmFtZSk7XG59O1xudmFyIHVuaXRUeXBlVG9Vbml0Q2F0ZWdvcnkgPSBmdW5jdGlvbiB1bml0VHlwZVRvVW5pdENhdGVnb3J5KHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBVbml0VHlwZS5rTnVtYmVyOlxuICAgIGNhc2UgVW5pdFR5cGUua0ludGVnZXI6XG4gICAgICByZXR1cm4gVW5pdENhdGVnb3J5LmtVTnVtYmVyO1xuICAgIGNhc2UgVW5pdFR5cGUua1BlcmNlbnRhZ2U6XG4gICAgICByZXR1cm4gVW5pdENhdGVnb3J5LmtVUGVyY2VudDtcbiAgICBjYXNlIFVuaXRUeXBlLmtQaXhlbHM6XG4gICAgICAvLyBjYXNlIFVuaXRUeXBlLmtDZW50aW1ldGVyczpcbiAgICAgIC8vIGNhc2UgVW5pdFR5cGUua01pbGxpbWV0ZXJzOlxuICAgICAgLy8gY2FzZSBVbml0VHlwZS5rUXVhcnRlck1pbGxpbWV0ZXJzOlxuICAgICAgLy8gY2FzZSBVbml0VHlwZS5rSW5jaGVzOlxuICAgICAgLy8gY2FzZSBVbml0VHlwZS5rUG9pbnRzOlxuICAgICAgLy8gY2FzZSBVbml0VHlwZS5rUGljYXM6XG4gICAgICAvLyBjYXNlIFVuaXRUeXBlLmtVc2VyVW5pdHM6XG4gICAgICByZXR1cm4gVW5pdENhdGVnb3J5LmtVTGVuZ3RoO1xuICAgIGNhc2UgVW5pdFR5cGUua01pbGxpc2Vjb25kczpcbiAgICBjYXNlIFVuaXRUeXBlLmtTZWNvbmRzOlxuICAgICAgcmV0dXJuIFVuaXRDYXRlZ29yeS5rVVRpbWU7XG4gICAgY2FzZSBVbml0VHlwZS5rRGVncmVlczpcbiAgICBjYXNlIFVuaXRUeXBlLmtSYWRpYW5zOlxuICAgIGNhc2UgVW5pdFR5cGUua0dyYWRpYW5zOlxuICAgIGNhc2UgVW5pdFR5cGUua1R1cm5zOlxuICAgICAgcmV0dXJuIFVuaXRDYXRlZ29yeS5rVUFuZ2xlO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua0hlcnR6OlxuICAgIC8vIGNhc2UgVW5pdFR5cGUua0tpbG9oZXJ0ejpcbiAgICAvLyAgIHJldHVybiBVbml0Q2F0ZWdvcnkua1VGcmVxdWVuY3k7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rRG90c1BlclBpeGVsOlxuICAgIC8vIGNhc2UgVW5pdFR5cGUua0RvdHNQZXJJbmNoOlxuICAgIC8vIGNhc2UgVW5pdFR5cGUua0RvdHNQZXJDZW50aW1ldGVyOlxuICAgIC8vICAgcmV0dXJuIFVuaXRDYXRlZ29yeS5rVVJlc29sdXRpb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBVbml0Q2F0ZWdvcnkua1VPdGhlcjtcbiAgfVxufTtcbnZhciBjYW5vbmljYWxVbml0VHlwZUZvckNhdGVnb3J5ID0gZnVuY3Rpb24gY2Fub25pY2FsVW5pdFR5cGVGb3JDYXRlZ29yeShjYXRlZ29yeSkge1xuICAvLyBUaGUgY2Fub25pY2FsIHVuaXQgdHlwZSBpcyBjaG9zZW4gYWNjb3JkaW5nIHRvIHRoZSB3YXlcbiAgLy8gQ1NTUHJvcGVydHlQYXJzZXIuVmFsaWRVbml0KCkgY2hvb3NlcyB0aGUgZGVmYXVsdCB1bml0IGluIGVhY2ggY2F0ZWdvcnlcbiAgLy8gKGJhc2VkIG9uIHVuaXRmbGFncykuXG4gIHN3aXRjaCAoY2F0ZWdvcnkpIHtcbiAgICBjYXNlIFVuaXRDYXRlZ29yeS5rVU51bWJlcjpcbiAgICAgIHJldHVybiBVbml0VHlwZS5rTnVtYmVyO1xuICAgIGNhc2UgVW5pdENhdGVnb3J5LmtVTGVuZ3RoOlxuICAgICAgcmV0dXJuIFVuaXRUeXBlLmtQaXhlbHM7XG4gICAgY2FzZSBVbml0Q2F0ZWdvcnkua1VQZXJjZW50OlxuICAgICAgcmV0dXJuIFVuaXRUeXBlLmtQZXJjZW50YWdlO1xuICAgIC8vIHJldHVybiBVbml0VHlwZS5rVW5rbm93bjsgLy8gQ2Fubm90IGNvbnZlcnQgYmV0d2VlbiBudW1iZXJzIGFuZCBwZXJjZW50LlxuICAgIGNhc2UgVW5pdENhdGVnb3J5LmtVVGltZTpcbiAgICAgIHJldHVybiBVbml0VHlwZS5rU2Vjb25kcztcbiAgICBjYXNlIFVuaXRDYXRlZ29yeS5rVUFuZ2xlOlxuICAgICAgcmV0dXJuIFVuaXRUeXBlLmtEZWdyZWVzO1xuICAgIC8vIGNhc2UgVW5pdENhdGVnb3J5LmtVRnJlcXVlbmN5OlxuICAgIC8vICAgcmV0dXJuIFVuaXRUeXBlLmtIZXJ0ejtcbiAgICAvLyBjYXNlIFVuaXRDYXRlZ29yeS5rVVJlc29sdXRpb246XG4gICAgLy8gICByZXR1cm4gVW5pdFR5cGUua0RvdHNQZXJQaXhlbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFVuaXRUeXBlLmtVbmtub3duO1xuICB9XG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rL3JlZnMvaGVhZHMvbWFpbi90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2Nzcy9jc3NfcHJpbWl0aXZlX3ZhbHVlLmNjIzM1M1xuICovXG52YXIgY29udmVyc2lvblRvQ2Fub25pY2FsVW5pdHNTY2FsZUZhY3RvciA9IGZ1bmN0aW9uIGNvbnZlcnNpb25Ub0Nhbm9uaWNhbFVuaXRzU2NhbGVGYWN0b3IodW5pdF90eXBlKSB7XG4gIHZhciBmYWN0b3IgPSAxLjA7XG4gIC8vIEZJWE1FOiB0aGUgc3dpdGNoIGNhbiBiZSByZXBsYWNlZCBieSBhbiBhcnJheSBvZiBzY2FsZSBmYWN0b3JzLlxuICBzd2l0Y2ggKHVuaXRfdHlwZSkge1xuICAgIC8vIFRoZXNlIGFyZSBcImNhbm9uaWNhbFwiIHVuaXRzIGluIHRoZWlyIHJlc3BlY3RpdmUgY2F0ZWdvcmllcy5cbiAgICBjYXNlIFVuaXRUeXBlLmtQaXhlbHM6XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rVXNlclVuaXRzOlxuICAgIGNhc2UgVW5pdFR5cGUua0RlZ3JlZXM6XG4gICAgY2FzZSBVbml0VHlwZS5rU2Vjb25kczpcbiAgICAgIC8vIGNhc2UgVW5pdFR5cGUua0hlcnR6OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVbml0VHlwZS5rTWlsbGlzZWNvbmRzOlxuICAgICAgZmFjdG9yID0gMC4wMDE7XG4gICAgICBicmVhaztcbiAgICAvLyBjYXNlIFVuaXRUeXBlLmtDZW50aW1ldGVyczpcbiAgICAvLyAgIC8vIGZhY3RvciA9IGtDc3NQaXhlbHNQZXJDZW50aW1ldGVyO1xuICAgIC8vICAgYnJlYWs7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rRG90c1BlckNlbnRpbWV0ZXI6XG4gICAgLy8gICAvLyBmYWN0b3IgPSAxIC8ga0Nzc1BpeGVsc1BlckNlbnRpbWV0ZXI7XG4gICAgLy8gICBicmVhaztcbiAgICAvLyBjYXNlIFVuaXRUeXBlLmtNaWxsaW1ldGVyczpcbiAgICAvLyAgIC8vIGZhY3RvciA9IGtDc3NQaXhlbHNQZXJNaWxsaW1ldGVyO1xuICAgIC8vICAgYnJlYWs7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rUXVhcnRlck1pbGxpbWV0ZXJzOlxuICAgIC8vICAgLy8gZmFjdG9yID0ga0Nzc1BpeGVsc1BlclF1YXJ0ZXJNaWxsaW1ldGVyO1xuICAgIC8vICAgYnJlYWs7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rSW5jaGVzOlxuICAgIC8vICAgLy8gZmFjdG9yID0ga0Nzc1BpeGVsc1BlckluY2g7XG4gICAgLy8gICBicmVhaztcbiAgICAvLyBjYXNlIFVuaXRUeXBlLmtEb3RzUGVySW5jaDpcbiAgICAvLyAgIC8vIGZhY3RvciA9IDEgLyBrQ3NzUGl4ZWxzUGVySW5jaDtcbiAgICAvLyAgIGJyZWFrO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua1BvaW50czpcbiAgICAvLyAgIC8vIGZhY3RvciA9IGtDc3NQaXhlbHNQZXJQb2ludDtcbiAgICAvLyAgIGJyZWFrO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua1BpY2FzOlxuICAgIC8vICAgLy8gZmFjdG9yID0ga0Nzc1BpeGVsc1BlclBpY2E7XG4gICAgLy8gICBicmVhaztcbiAgICBjYXNlIFVuaXRUeXBlLmtSYWRpYW5zOlxuICAgICAgZmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVW5pdFR5cGUua0dyYWRpYW5zOlxuICAgICAgZmFjdG9yID0gMC45O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVbml0VHlwZS5rVHVybnM6XG4gICAgICBmYWN0b3IgPSAzNjA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZmFjdG9yO1xufTtcbnZhciB1bml0VHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gdW5pdFR5cGVUb1N0cmluZyh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgVW5pdFR5cGUua051bWJlcjpcbiAgICBjYXNlIFVuaXRUeXBlLmtJbnRlZ2VyOlxuICAgICAgLy8gY2FzZSBVbml0VHlwZS5rVXNlclVuaXRzOlxuICAgICAgcmV0dXJuICcnO1xuICAgIGNhc2UgVW5pdFR5cGUua1BlcmNlbnRhZ2U6XG4gICAgICByZXR1cm4gJyUnO1xuICAgIGNhc2UgVW5pdFR5cGUua0VtczpcbiAgICAgIC8vIGNhc2UgVW5pdFR5cGUua1F1aXJreUVtczpcbiAgICAgIHJldHVybiAnZW0nO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua0V4czpcbiAgICAvLyAgIHJldHVybiAnZXgnO1xuICAgIGNhc2UgVW5pdFR5cGUua1JlbXM6XG4gICAgICByZXR1cm4gJ3JlbSc7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rQ2hzOlxuICAgIC8vICAgcmV0dXJuICdjaCc7XG4gICAgY2FzZSBVbml0VHlwZS5rUGl4ZWxzOlxuICAgICAgcmV0dXJuICdweCc7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rQ2VudGltZXRlcnM6XG4gICAgLy8gICByZXR1cm4gJ2NtJztcbiAgICAvLyBjYXNlIFVuaXRUeXBlLmtEb3RzUGVyUGl4ZWw6XG4gICAgLy8gICByZXR1cm4gJ2RwcHgnO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua0RvdHNQZXJJbmNoOlxuICAgIC8vICAgcmV0dXJuICdkcGknO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua0RvdHNQZXJDZW50aW1ldGVyOlxuICAgIC8vICAgcmV0dXJuICdkcGNtJztcbiAgICAvLyBjYXNlIFVuaXRUeXBlLmtNaWxsaW1ldGVyczpcbiAgICAvLyAgIHJldHVybiAnbW0nO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua1F1YXJ0ZXJNaWxsaW1ldGVyczpcbiAgICAvLyAgIHJldHVybiAncSc7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rSW5jaGVzOlxuICAgIC8vICAgcmV0dXJuICdpbic7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rUG9pbnRzOlxuICAgIC8vICAgcmV0dXJuICdwdCc7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rUGljYXM6XG4gICAgLy8gICByZXR1cm4gJ3BjJztcbiAgICBjYXNlIFVuaXRUeXBlLmtEZWdyZWVzOlxuICAgICAgcmV0dXJuICdkZWcnO1xuICAgIGNhc2UgVW5pdFR5cGUua1JhZGlhbnM6XG4gICAgICByZXR1cm4gJ3JhZCc7XG4gICAgY2FzZSBVbml0VHlwZS5rR3JhZGlhbnM6XG4gICAgICByZXR1cm4gJ2dyYWQnO1xuICAgIGNhc2UgVW5pdFR5cGUua01pbGxpc2Vjb25kczpcbiAgICAgIHJldHVybiAnbXMnO1xuICAgIGNhc2UgVW5pdFR5cGUua1NlY29uZHM6XG4gICAgICByZXR1cm4gJ3MnO1xuICAgIC8vIGNhc2UgVW5pdFR5cGUua0hlcnR6OlxuICAgIC8vICAgcmV0dXJuICdoeic7XG4gICAgLy8gY2FzZSBVbml0VHlwZS5rS2lsb2hlcnR6OlxuICAgIC8vICAgcmV0dXJuICdraHonO1xuICAgIGNhc2UgVW5pdFR5cGUua1R1cm5zOlxuICAgICAgcmV0dXJuICd0dXJuJztcbiAgfVxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIENTU1N0eWxlVmFsdWUgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBDU1MgdmFsdWVzIGFjY2Vzc2libGUgZnJvbSBUeXBlZCBPTS5cbiAqIFZhbHVlcyB0aGF0IGFyZSBub3QgeWV0IHN1cHBvcnRlZCBhcyBzcGVjaWZpYyB0eXBlcyBhcmUgYWxzbyByZXR1cm5lZCBhcyBiYXNlIENTU1N0eWxlVmFsdWVzLlxuICpcbiAqIFNwZWMgQHNlZSBodHRwczovL2RyYWZ0cy5jc3MtaG91ZGluaS5vcmcvY3NzLXR5cGVkLW9tLyNzdHlsZXZhbHVlLW9iamVjdHNcbiAqIERvY3MgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ1NTU3R5bGVWYWx1ZVxuICovXG52YXIgQ1NTU3R5bGVWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1N0eWxlVmFsdWUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1N0eWxlVmFsdWUpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTU3R5bGVWYWx1ZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBwcm90ZWN0ZWQgYWJzdHJhY3QgdG9DU1NWYWx1ZSgpOiBDU1NWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDU1NUZXh0KE5lc3RlZC5rTm8sIFBhcmVuTGVzcy5rTm8sICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNOdW1lcmljVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOdW1lcmljVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkgPj0gQ1NTU3R5bGVWYWx1ZVR5cGUua1VuaXRUeXBlICYmIHRoaXMuZ2V0VHlwZSgpIDw9IENTU1N0eWxlVmFsdWVUeXBlLmtDbGFtcFR5cGU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNBbmdsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8vIHN0YXRpYyBwYXJzZShwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IENTU1N0eWxlVmFsdWUge1xuICAgIC8vICAgcmV0dXJuIHBhcnNlQ1NTU3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUsIHZhbHVlKVswXTtcbiAgICAvLyB9XG5cbiAgICAvLyBzdGF0aWMgcGFyc2VBbGwocHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBDU1NTdHlsZVZhbHVlW10ge1xuICAgIC8vICAgcmV0dXJuIHBhcnNlQ1NTU3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBpc0FuZ2xlKHVuaXQpIHtcbiAgICAgIHJldHVybiB1bml0ID09PSBVbml0VHlwZS5rRGVncmVlcyB8fCB1bml0ID09PSBVbml0VHlwZS5rUmFkaWFucyB8fCB1bml0ID09PSBVbml0VHlwZS5rR3JhZGlhbnMgfHwgdW5pdCA9PT0gVW5pdFR5cGUua1R1cm5zO1xuICAgIH1cblxuICAgIC8vIHN0YXRpYyBpc1ZpZXdwb3J0UGVyY2VudGFnZUxlbmd0aCh0eXBlOiBVbml0VHlwZSkge1xuICAgIC8vICAgcmV0dXJuIHR5cGUgPj0gVW5pdFR5cGUua1ZpZXdwb3J0V2lkdGggJiYgdHlwZSA8PSBVbml0VHlwZS5rRHluYW1pY1ZpZXdwb3J0TWF4O1xuICAgIC8vIH1cblxuICAgIC8vIHN0YXRpYyBpc0NvbnRhaW5lclBlcmNlbnRhZ2VMZW5ndGgodHlwZTogVW5pdFR5cGUpIHtcbiAgICAvLyAgIHJldHVybiB0eXBlID49IFVuaXRUeXBlLmtDb250YWluZXJXaWR0aCAmJiB0eXBlIDw9IFVuaXRUeXBlLmtDb250YWluZXJNYXg7XG4gICAgLy8gfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGVuZ3RoKHR5cGUpIHtcbiAgICAgIC8vIHJldHVybiAodHlwZSA+PSBVbml0VHlwZS5rRW1zICYmIHR5cGUgPD0gVW5pdFR5cGUua1VzZXJVbml0cykgfHwgdHlwZSA9PSBVbml0VHlwZS5rUXVpcmt5RW1zO1xuICAgICAgcmV0dXJuIHR5cGUgPj0gVW5pdFR5cGUua0VtcyAmJiB0eXBlIDwgVW5pdFR5cGUua0RlZ3JlZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmVsYXRpdmVVbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVsYXRpdmVVbml0KHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlID09PSBVbml0VHlwZS5rUGVyY2VudGFnZSB8fCB0eXBlID09PSBVbml0VHlwZS5rRW1zIHx8XG4gICAgICAvLyB0eXBlID09PSBVbml0VHlwZS5rRXhzIHx8XG4gICAgICB0eXBlID09PSBVbml0VHlwZS5rUmVtc1xuICAgICAgLy8gdHlwZSA9PT0gVW5pdFR5cGUua0NocyB8fFxuICAgICAgLy8gdGhpcy5pc1ZpZXdwb3J0UGVyY2VudGFnZUxlbmd0aCh0eXBlKSB8fFxuICAgICAgLy8gdGhpcy5pc0NvbnRhaW5lclBlcmNlbnRhZ2VMZW5ndGgodHlwZSlcbiAgICAgIDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGltZSh1bml0KSB7XG4gICAgICByZXR1cm4gdW5pdCA9PT0gVW5pdFR5cGUua1NlY29uZHMgfHwgdW5pdCA9PT0gVW5pdFR5cGUua01pbGxpc2Vjb25kcztcbiAgICB9XG5cbiAgICAvLyBzdGF0aWMgaXNGcmVxdWVuY3kodW5pdDogVW5pdFR5cGUpIHtcbiAgICAvLyAgIHJldHVybiB1bml0ID09IFVuaXRUeXBlLmtIZXJ0eiB8fCB1bml0ID09IFVuaXRUeXBlLmtLaWxvaGVydHo7XG4gICAgLy8gfVxuXG4gICAgLy8gc3RhdGljIGlzUmVzb2x1dGlvbih0eXBlOiBVbml0VHlwZSkge1xuICAgIC8vICAgcmV0dXJuIHR5cGUgPj0gVW5pdFR5cGUua0RvdHNQZXJQaXhlbCAmJiB0eXBlIDw9IFVuaXRUeXBlLmtEb3RzUGVyQ2VudGltZXRlcjtcbiAgICAvLyB9XG5cbiAgICAvLyBzdGF0aWMgaXNGbGV4KHVuaXQ6IFVuaXRUeXBlKSB7XG4gICAgLy8gICByZXR1cm4gdW5pdCA9PT0gVW5pdFR5cGUua0ZyYWN0aW9uO1xuICAgIC8vIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kcmFmdHMuY3NzLWhvdWRpbmkub3JnL2Nzcy10eXBlZC1vbS0xLyNkb20tY3NzY29sb3J2YWx1ZS1jb2xvcnNwYWNlXG4gKi9cblxuLyoqXG4gKiBDU1NDb2xvclZhbHVlIGlzIHRoZSBiYXNlIGNsYXNzIHVzZWQgZm9yIHRoZSB2YXJpb3VzIENTUyBjb2xvciBpbnRlcmZhY2VzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kcmFmdHMuY3NzLWhvdWRpbmkub3JnL2Nzcy10eXBlZC1vbS0xLyNjb2xvcnZhbHVlLW9iamVjdHNcbiAqL1xudmFyIENTU0NvbG9yVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DU1NTdHlsZVZhbHVlKSB7XG4gIGZ1bmN0aW9uIENTU0NvbG9yVmFsdWUoY29sb3JTcGFjZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTQ29sb3JWYWx1ZSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENTU0NvbG9yVmFsdWUpO1xuICAgIF90aGlzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQ1NTQ29sb3JWYWx1ZSwgX0NTU1N0eWxlVmFsdWUpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU0NvbG9yVmFsdWUsIFt7XG4gICAga2V5OiBcImdldFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiBDU1NTdHlsZVZhbHVlVHlwZS5rQ29sb3JUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kcmFmdHMuY3NzLWhvdWRpbmkub3JnL2Nzcy10eXBlZC1vbS0xLyNkb20tY3NzY29sb3J2YWx1ZS10b1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvKGNvbG9yU3BhY2UpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xufShDU1NTdHlsZVZhbHVlKTtcblxudmFyIEdyYWRpZW50VHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoR3JhZGllbnRUeXBlKSB7XG4gIEdyYWRpZW50VHlwZVtHcmFkaWVudFR5cGVbXCJDb25zdGFudFwiXSA9IDBdID0gXCJDb25zdGFudFwiO1xuICBHcmFkaWVudFR5cGVbR3JhZGllbnRUeXBlW1wiTGluZWFyR3JhZGllbnRcIl0gPSAxXSA9IFwiTGluZWFyR3JhZGllbnRcIjtcbiAgR3JhZGllbnRUeXBlW0dyYWRpZW50VHlwZVtcIlJhZGlhbEdyYWRpZW50XCJdID0gMl0gPSBcIlJhZGlhbEdyYWRpZW50XCI7XG4gIHJldHVybiBHcmFkaWVudFR5cGU7XG59KHt9KTtcbnZhciBDU1NHcmFkaWVudFZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ1NTU3R5bGVWYWx1ZSkge1xuICBmdW5jdGlvbiBDU1NHcmFkaWVudFZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDU1NHcmFkaWVudFZhbHVlKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ1NTR3JhZGllbnRWYWx1ZSk7XG4gICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKENTU0dyYWRpZW50VmFsdWUsIF9DU1NTdHlsZVZhbHVlKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NHcmFkaWVudFZhbHVlLCBbe1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgQ1NTR3JhZGllbnRWYWx1ZSh0aGlzLnR5cGUsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZENTU1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRDU1NUZXh0KG4sIHAsIHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgICAgcmV0dXJuIENTU1N0eWxlVmFsdWVUeXBlLmtDb2xvclR5cGU7XG4gICAgfVxuICB9XSk7XG59KENTU1N0eWxlVmFsdWUpO1xuXG4vKipcbiAqIENTU0tleXdvcmRWYWx1ZSByZXByZXNlbnRzIENTUyBWYWx1ZXMgdGhhdCBhcmUgc3BlY2lmaWVkIGFzIGtleXdvcmRzXG4gKiBlZy4gJ2luaXRpYWwnXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DU1NLZXl3b3JkVmFsdWVcbiAqIEBzZWUgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rL3JlZnMvaGVhZHMvbWFpbi90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2Nzcy9jc3NvbS9jc3Nfa2V5d29yZF92YWx1ZS5pZGxcbiAqL1xudmFyIENTU0tleXdvcmRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NTU1N0eWxlVmFsdWUpIHtcbiAgZnVuY3Rpb24gQ1NTS2V5d29yZFZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDU1NLZXl3b3JkVmFsdWUpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDU1NLZXl3b3JkVmFsdWUpO1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhDU1NLZXl3b3JkVmFsdWUsIF9DU1NTdHlsZVZhbHVlKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NLZXl3b3JkVmFsdWUsIFt7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBDU1NLZXl3b3JkVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiBDU1NTdHlsZVZhbHVlVHlwZS5rS2V5d29yZFR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkQ1NTVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZENTU1RleHQobiwgcCwgcmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgdGhpcy52YWx1ZTtcbiAgICB9XG4gIH1dKTtcbn0oQ1NTU3R5bGVWYWx1ZSk7XG5cbnZhciBmb3JtYXRJbmZpbml0eU9yTmFOID0gZnVuY3Rpb24gZm9ybWF0SW5maW5pdHlPck5hTihudW1iZXIpIHtcbiAgdmFyIHN1ZmZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobnVtYmVyKSkge1xuICAgIGlmIChudW1iZXIgPiAwKSByZXN1bHQgPSAnaW5maW5pdHknO2Vsc2UgcmVzdWx0ID0gJy1pbmZpbml0eSc7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gJ05hTic7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCArPSBzdWZmaXg7XG59O1xudmFyIHRvQ2Fub25pY2FsVW5pdCA9IGZ1bmN0aW9uIHRvQ2Fub25pY2FsVW5pdCh1bml0KSB7XG4gIHJldHVybiBjYW5vbmljYWxVbml0VHlwZUZvckNhdGVnb3J5KHVuaXRUeXBlVG9Vbml0Q2F0ZWdvcnkodW5pdCkpO1xufTtcblxuLyoqXG4gKiBDU1NOdW1lcmljVmFsdWUgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIG51bWVyaWMgYW5kIGxlbmd0aCB0eXBlZCBDU1MgVmFsdWVzLlxuICogQHNlZSBodHRwczovL2RyYWZ0cy5jc3MtaG91ZGluaS5vcmcvY3NzLXR5cGVkLW9tLyNudW1lcmljLW9iamVjdHNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTU051bWVyaWNWYWx1ZVxuICogQHNlZSBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvcmVmcy9oZWFkcy9tYWluL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvY3NzL2Nzc29tL2Nzc19udW1lcmljX3ZhbHVlLmlkbFxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBudW1lcmljIHZhbHVlcyB0aGF0IGNhbiBiZSBleHByZXNzZWQgYXMgYSBzaW5nbGUgbnVtYmVyIHBsdXMgYVxuICogdW5pdCAob3IgYSBuYWtlZCBudW1iZXIgb3IgcGVyY2VudGFnZSkuXG4gKiBAc2VlIGh0dHBzOi8vZHJhZnRzLmNzcy1ob3VkaW5pLm9yZy9jc3MtdHlwZWQtb20vI2Nzc3VuaXR2YWx1ZVxuICovXG52YXIgQ1NTVW5pdFZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ1NTU3R5bGVWYWx1ZSkge1xuICBmdW5jdGlvbiBDU1NVbml0VmFsdWUodmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIHVuaXRPck5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFVuaXRUeXBlLmtOdW1iZXI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1VuaXRWYWx1ZSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENTU1VuaXRWYWx1ZSk7XG4gICAgdmFyIHVuaXQ7XG4gICAgaWYgKHR5cGVvZiB1bml0T3JOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdW5pdCA9IHVuaXRGcm9tTmFtZSh1bml0T3JOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IHVuaXRPck5hbWU7XG4gICAgfVxuICAgIF90aGlzLnVuaXQgPSB1bml0O1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhDU1NVbml0VmFsdWUsIF9DU1NTdHlsZVZhbHVlKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NVbml0VmFsdWUsIFt7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBDU1NVbml0VmFsdWUodGhpcy52YWx1ZSwgdGhpcy51bml0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgdmFyIG90aGVyX3VuaXRfdmFsdWUgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlcl91bml0X3ZhbHVlLnZhbHVlICYmIHRoaXMudW5pdCA9PT0gb3RoZXJfdW5pdF92YWx1ZS51bml0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFR5cGUoKSB7XG4gICAgICByZXR1cm4gQ1NTU3R5bGVWYWx1ZVR5cGUua1VuaXRUeXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb252ZXJ0VG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydFRvKHRhcmdldF91bml0KSB7XG4gICAgICBpZiAodGhpcy51bml0ID09PSB0YXJnZXRfdW5pdCkge1xuICAgICAgICByZXR1cm4gbmV3IENTU1VuaXRWYWx1ZSh0aGlzLnZhbHVlLCB0aGlzLnVuaXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnN0ZWFkIG9mIGRlZmluaW5nIHRoZSBzY2FsZSBmYWN0b3JzIGZvciBldmVyeSB1bml0IHRvIGV2ZXJ5IG90aGVyIHVuaXQsXG4gICAgICAvLyB3ZSBzaW1wbHkgY29udmVydCB0byB0aGUgY2Fub25pY2FsIHVuaXQgYW5kIGJhY2sgc2luY2Ugd2UgYWxyZWFkeSBoYXZlXG4gICAgICAvLyB0aGUgc2NhbGUgZmFjdG9ycyBmb3IgY2Fub25pY2FsIHVuaXRzLlxuICAgICAgdmFyIGNhbm9uaWNhbF91bml0ID0gdG9DYW5vbmljYWxVbml0KHRoaXMudW5pdCk7XG4gICAgICBpZiAoY2Fub25pY2FsX3VuaXQgIT09IHRvQ2Fub25pY2FsVW5pdCh0YXJnZXRfdW5pdCkgfHwgY2Fub25pY2FsX3VuaXQgPT09IFVuaXRUeXBlLmtVbmtub3duKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlX2ZhY3RvciA9IGNvbnZlcnNpb25Ub0Nhbm9uaWNhbFVuaXRzU2NhbGVGYWN0b3IodGhpcy51bml0KSAvIGNvbnZlcnNpb25Ub0Nhbm9uaWNhbFVuaXRzU2NhbGVGYWN0b3IodGFyZ2V0X3VuaXQpO1xuICAgICAgcmV0dXJuIG5ldyBDU1NVbml0VmFsdWUodGhpcy52YWx1ZSAqIHNjYWxlX2ZhY3RvciwgdGFyZ2V0X3VuaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZENTU1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRDU1NUZXh0KG4sIHAsIHJlc3VsdCkge1xuICAgICAgdmFyIHRleHQ7XG4gICAgICBzd2l0Y2ggKHRoaXMudW5pdCkge1xuICAgICAgICBjYXNlIFVuaXRUeXBlLmtVbmtub3duOlxuICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVW5pdFR5cGUua0ludGVnZXI6XG4gICAgICAgICAgdGV4dCA9IE51bWJlcih0aGlzLnZhbHVlKS50b0ZpeGVkKDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVuaXRUeXBlLmtOdW1iZXI6XG4gICAgICAgIGNhc2UgVW5pdFR5cGUua1BlcmNlbnRhZ2U6XG4gICAgICAgIGNhc2UgVW5pdFR5cGUua0VtczpcbiAgICAgICAgLy8gY2FzZSBVbml0VHlwZS5rUXVpcmt5RW1zOlxuICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtFeHM6XG4gICAgICAgIGNhc2UgVW5pdFR5cGUua1JlbXM6XG4gICAgICAgIC8vIGNhc2UgVW5pdFR5cGUua0NoczpcbiAgICAgICAgY2FzZSBVbml0VHlwZS5rUGl4ZWxzOlxuICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtDZW50aW1ldGVyczpcbiAgICAgICAgLy8gY2FzZSBVbml0VHlwZS5rRG90c1BlclBpeGVsOlxuICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtEb3RzUGVySW5jaDpcbiAgICAgICAgLy8gY2FzZSBVbml0VHlwZS5rRG90c1BlckNlbnRpbWV0ZXI6XG4gICAgICAgIC8vIGNhc2UgVW5pdFR5cGUua01pbGxpbWV0ZXJzOlxuICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtRdWFydGVyTWlsbGltZXRlcnM6XG4gICAgICAgIC8vIGNhc2UgVW5pdFR5cGUua0luY2hlczpcbiAgICAgICAgLy8gY2FzZSBVbml0VHlwZS5rUG9pbnRzOlxuICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtQaWNhczpcbiAgICAgICAgLy8gY2FzZSBVbml0VHlwZS5rVXNlclVuaXRzOlxuICAgICAgICBjYXNlIFVuaXRUeXBlLmtEZWdyZWVzOlxuICAgICAgICBjYXNlIFVuaXRUeXBlLmtSYWRpYW5zOlxuICAgICAgICBjYXNlIFVuaXRUeXBlLmtHcmFkaWFuczpcbiAgICAgICAgY2FzZSBVbml0VHlwZS5rTWlsbGlzZWNvbmRzOlxuICAgICAgICBjYXNlIFVuaXRUeXBlLmtTZWNvbmRzOlxuICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtIZXJ0ejpcbiAgICAgICAgLy8gY2FzZSBVbml0VHlwZS5rS2lsb2hlcnR6OlxuICAgICAgICBjYXNlIFVuaXRUeXBlLmtUdXJuczpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBjYXNlIFVuaXRUeXBlLmtDb250YWluZXJNYXg6IHsgLy8gY2FzZSBVbml0VHlwZS5rQ29udGFpbmVyTWluOiAvLyBjYXNlIFVuaXRUeXBlLmtDb250YWluZXJCbG9ja1NpemU6IC8vIGNhc2UgVW5pdFR5cGUua0NvbnRhaW5lcklubGluZVNpemU6IC8vIGNhc2UgVW5pdFR5cGUua0NvbnRhaW5lckhlaWdodDogLy8gY2FzZSBVbml0VHlwZS5rQ29udGFpbmVyV2lkdGg6IC8vIGNhc2UgVW5pdFR5cGUua0R5bmFtaWNWaWV3cG9ydE1heDogLy8gY2FzZSBVbml0VHlwZS5rRHluYW1pY1ZpZXdwb3J0TWluOiAvLyBjYXNlIFVuaXRUeXBlLmtEeW5hbWljVmlld3BvcnRCbG9ja1NpemU6IC8vIGNhc2UgVW5pdFR5cGUua0R5bmFtaWNWaWV3cG9ydElubGluZVNpemU6IC8vIGNhc2UgVW5pdFR5cGUua0R5bmFtaWNWaWV3cG9ydEhlaWdodDogLy8gY2FzZSBVbml0VHlwZS5rRHluYW1pY1ZpZXdwb3J0V2lkdGg6IC8vIGNhc2UgVW5pdFR5cGUua0xhcmdlVmlld3BvcnRNYXg6IC8vIGNhc2UgVW5pdFR5cGUua0xhcmdlVmlld3BvcnRNaW46IC8vIGNhc2UgVW5pdFR5cGUua0xhcmdlVmlld3BvcnRCbG9ja1NpemU6IC8vIGNhc2UgVW5pdFR5cGUua0xhcmdlVmlld3BvcnRJbmxpbmVTaXplOiAvLyBjYXNlIFVuaXRUeXBlLmtMYXJnZVZpZXdwb3J0SGVpZ2h0OiAvLyBjYXNlIFVuaXRUeXBlLmtMYXJnZVZpZXdwb3J0V2lkdGg6IC8vIGNhc2UgVW5pdFR5cGUua1NtYWxsVmlld3BvcnRNYXg6IC8vIGNhc2UgVW5pdFR5cGUua1NtYWxsVmlld3BvcnRNaW46IC8vIGNhc2UgVW5pdFR5cGUua1NtYWxsVmlld3BvcnRCbG9ja1NpemU6IC8vIGNhc2UgVW5pdFR5cGUua1NtYWxsVmlld3BvcnRJbmxpbmVTaXplOiAvLyBjYXNlIFVuaXRUeXBlLmtTbWFsbFZpZXdwb3J0SGVpZ2h0OiAvLyBjYXNlIFVuaXRUeXBlLmtTbWFsbFZpZXdwb3J0V2lkdGg6IC8vIGNhc2UgVW5pdFR5cGUua1ZpZXdwb3J0TWF4OiAvLyBjYXNlIFVuaXRUeXBlLmtWaWV3cG9ydE1pbjogLy8gY2FzZSBVbml0VHlwZS5rVmlld3BvcnRCbG9ja1NpemU6IC8vIGNhc2UgVW5pdFR5cGUua1ZpZXdwb3J0SW5saW5lU2l6ZTogLy8gY2FzZSBVbml0VHlwZS5rVmlld3BvcnRIZWlnaHQ6IC8vIGNhc2UgVW5pdFR5cGUua1ZpZXdwb3J0V2lkdGg6IC8vIGNhc2UgVW5pdFR5cGUua0ZyYWN0aW9uOlxuICAgICAgICAgICAgdmFyIGtNaW5JbnRlZ2VyID0gLTk5OTk5OTtcbiAgICAgICAgICAgIHZhciBrTWF4SW50ZWdlciA9IDk5OTk5OTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IHVuaXRUeXBlVG9TdHJpbmcodGhpcy51bml0KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IGtNaW5JbnRlZ2VyIHx8IHZhbHVlID4ga01heEludGVnZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF91bml0ID0gdW5pdFR5cGVUb1N0cmluZyh0aGlzLnVuaXQpO1xuICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXRJbmZpbml0eU9yTmFOKHZhbHVlLCBfdW5pdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHZhbHVlICsgKF91bml0IHx8ICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGV4dCA9IFwiXCIuY29uY2F0KHZhbHVlKS5jb25jYXQodW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHRleHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xufShDU1NTdHlsZVZhbHVlKTtcbnZhciBPcHggPSBuZXcgQ1NTVW5pdFZhbHVlKDAsICdweCcpO1xubmV3IENTU1VuaXRWYWx1ZSgxLCAncHgnKTtcbnZhciBPZGVnID0gbmV3IENTU1VuaXRWYWx1ZSgwLCAnZGVnJyk7XG5cbi8qKlxuICogVGhlIENTU1JHQiBjbGFzcyByZXByZXNlbnRzIHRoZSBDU1MgcmdiKCkvcmdiYSgpIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZHJhZnRzLmNzcy1ob3VkaW5pLm9yZy9jc3MtdHlwZWQtb20tMS8jY3NzcmdiXG4gKi9cbnZhciBDU1NSR0IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DU1NDb2xvclZhbHVlKSB7XG4gIGZ1bmN0aW9uIENTU1JHQihyLCBnLCBiKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBhbHBoYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgICB2YXIgaXNOb25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUkdCKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ1NTUkdCLCBbJ3JnYiddKTtcbiAgICBfdGhpcy5yID0gcjtcbiAgICBfdGhpcy5nID0gZztcbiAgICBfdGhpcy5iID0gYjtcbiAgICBfdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgIF90aGlzLmlzTm9uZSA9IGlzTm9uZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKENTU1JHQiwgX0NTU0NvbG9yVmFsdWUpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU1JHQiwgW3tcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IENTU1JHQih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFscGhhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRDU1NUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkQ1NTVGV4dChuLCBwLCByZXN1bHQpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZXN1bHQsIFwicmdiYShcIikuY29uY2F0KHRoaXMuciwgXCIsXCIpLmNvbmNhdCh0aGlzLmcsIFwiLFwiKS5jb25jYXQodGhpcy5iLCBcIixcIikuY29uY2F0KHRoaXMuYWxwaGEsIFwiKVwiKTtcbiAgICB9XG4gIH1dKTtcbn0oQ1NTQ29sb3JWYWx1ZSk7XG5cbi8qKlxuICogQ1NTS2V5d29yZFZhbHVlXG4gKi9cbnZhciB1bnNldEtleXdvcmRWYWx1ZSA9IG5ldyBDU1NLZXl3b3JkVmFsdWUoJ3Vuc2V0Jyk7XG52YXIgaW5pdGlhbEtleXdvcmRWYWx1ZSA9IG5ldyBDU1NLZXl3b3JkVmFsdWUoJ2luaXRpYWwnKTtcbnZhciBpbmhlcml0S2V5d29yZFZhbHVlID0gbmV3IENTU0tleXdvcmRWYWx1ZSgnaW5oZXJpdCcpO1xudmFyIGtleXdvcmRDYWNoZSA9IHtcbiAgJyc6IHVuc2V0S2V5d29yZFZhbHVlLFxuICB1bnNldDogdW5zZXRLZXl3b3JkVmFsdWUsXG4gIGluaXRpYWw6IGluaXRpYWxLZXl3b3JkVmFsdWUsXG4gIGluaGVyaXQ6IGluaGVyaXRLZXl3b3JkVmFsdWVcbn07XG52YXIgZ2V0T3JDcmVhdGVLZXl3b3JkID0gZnVuY3Rpb24gZ2V0T3JDcmVhdGVLZXl3b3JkKG5hbWUpIHtcbiAgaWYgKCFrZXl3b3JkQ2FjaGVbbmFtZV0pIHtcbiAgICBrZXl3b3JkQ2FjaGVbbmFtZV0gPSBuZXcgQ1NTS2V5d29yZFZhbHVlKG5hbWUpO1xuICB9XG4gIHJldHVybiBrZXl3b3JkQ2FjaGVbbmFtZV07XG59O1xuXG4vKipcbiAqIENTU0NvbG9yXG4gKi9cbnZhciBub25lQ29sb3IgPSBuZXcgQ1NTUkdCKDAsIDAsIDAsIDAsIHRydWUpO1xudmFyIHRyYW5zcGFyZW50Q29sb3IgPSBuZXcgQ1NTUkdCKDAsIDAsIDAsIDApO1xudmFyIGdldE9yQ3JlYXRlUkdCQSA9IG1lbW9pemUoZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgcmV0dXJuIG5ldyBDU1NSR0IociwgZywgYiwgYSk7XG59LCBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICByZXR1cm4gXCJyZ2JhKFwiLmNvbmNhdChyLCBcIixcIikuY29uY2F0KGcsIFwiLFwiKS5jb25jYXQoYiwgXCIsXCIpLmNvbmNhdChhLCBcIilcIik7XG59KTtcblxuLy8gZXhwb3J0IGNvbnN0IGdldE9yQ3JlYXRlVW5pdFZhbHVlID0gbWVtb2l6ZShcbi8vICAgKHZhbHVlOiBudW1iZXIsIHVuaXRPck5hbWU6IFVuaXRUeXBlIHwgc3RyaW5nID0gVW5pdFR5cGUua051bWJlcikgPT4ge1xuLy8gICAgIHJldHVybiBuZXcgQ1NTVW5pdFZhbHVlKHZhbHVlLCB1bml0T3JOYW1lKTtcbi8vICAgfSxcbi8vICAgKHZhbHVlOiBudW1iZXIsIHVuaXRPck5hbWU6IFVuaXRUeXBlIHwgc3RyaW5nID0gVW5pdFR5cGUua051bWJlcikgPT4ge1xuLy8gICAgIHJldHVybiBgJHt2YWx1ZX0ke3VuaXRPck5hbWV9YDtcbi8vICAgfSxcbi8vICk7XG5cbnZhciBnZXRPckNyZWF0ZVVuaXRWYWx1ZSA9IGZ1bmN0aW9uIGdldE9yQ3JlYXRlVW5pdFZhbHVlKHZhbHVlKSB7XG4gIHZhciB1bml0T3JOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBVbml0VHlwZS5rTnVtYmVyO1xuICByZXR1cm4gbmV3IENTU1VuaXRWYWx1ZSh2YWx1ZSwgdW5pdE9yTmFtZSk7XG59O1xubmV3IENTU1VuaXRWYWx1ZSg1MCwgJyUnKTtcblxuLyoqXG4gKiBib3Jyb3cgZnJvbSBncmFkaWVudC1wYXJzZXIsIGJ1dCB3ZSBkZWxldGUgc29tZSBicm93c2VyIGNvbXBhdGlibGUgcHJlZml4IHN1Y2ggYXMgYC13ZWJraXQtYFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFmYWVsY2FyaWNpby9ncmFkaWVudC1wYXJzZXJcbiAqL1xuXG5mdW5jdGlvbiBjb2xvclN0b3BUb1N0cmluZyhjb2xvclN0b3ApIHtcbiAgdmFyIHR5cGUgPSBjb2xvclN0b3AudHlwZSxcbiAgICB2YWx1ZSA9IGNvbG9yU3RvcC52YWx1ZTtcbiAgaWYgKHR5cGUgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIFwiI1wiLmNvbmNhdCh2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdsaXRlcmFsJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3JnYicpIHtcbiAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KHZhbHVlLmpvaW4oJywnKSwgXCIpXCIpO1xuICB9XG4gIHJldHVybiBcInJnYmEoXCIuY29uY2F0KHZhbHVlLmpvaW4oJywnKSwgXCIpXCIpO1xufVxudmFyIHBhcnNlR3JhZGllbnQkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VucyA9IHtcbiAgICBsaW5lYXJHcmFkaWVudDogL14obGluZWFyXFwtZ3JhZGllbnQpL2ksXG4gICAgcmVwZWF0aW5nTGluZWFyR3JhZGllbnQ6IC9eKHJlcGVhdGluZ1xcLWxpbmVhclxcLWdyYWRpZW50KS9pLFxuICAgIHJhZGlhbEdyYWRpZW50OiAvXihyYWRpYWxcXC1ncmFkaWVudCkvaSxcbiAgICByZXBlYXRpbmdSYWRpYWxHcmFkaWVudDogL14ocmVwZWF0aW5nXFwtcmFkaWFsXFwtZ3JhZGllbnQpL2ksXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL3Byb2plY3RzLnZlcm91Lm1lL2NvbmljLWdyYWRpZW50L1xuICAgICAqL1xuICAgIGNvbmljR3JhZGllbnQ6IC9eKGNvbmljXFwtZ3JhZGllbnQpL2ksXG4gICAgc2lkZU9yQ29ybmVyOiAvXnRvIChsZWZ0ICh0b3B8Ym90dG9tKXxyaWdodCAodG9wfGJvdHRvbSl8dG9wIChsZWZ0fHJpZ2h0KXxib3R0b20gKGxlZnR8cmlnaHQpfGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkvaSxcbiAgICBleHRlbnRLZXl3b3JkczogL14oY2xvc2VzdFxcLXNpZGV8Y2xvc2VzdFxcLWNvcm5lcnxmYXJ0aGVzdFxcLXNpZGV8ZmFydGhlc3RcXC1jb3JuZXJ8Y29udGFpbnxjb3ZlcikvLFxuICAgIHBvc2l0aW9uS2V5d29yZHM6IC9eKGxlZnR8Y2VudGVyfHJpZ2h0fHRvcHxib3R0b20pL2ksXG4gICAgcGl4ZWxWYWx1ZTogL14oLT8oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKSlweC8sXG4gICAgcGVyY2VudGFnZVZhbHVlOiAvXigtPygoWzAtOV0qXFwuWzAtOV0rKXwoWzAtOV0rXFwuPykpKVxcJS8sXG4gICAgZW1WYWx1ZTogL14oLT8oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKSllbS8sXG4gICAgYW5nbGVWYWx1ZTogL14oLT8oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKSlkZWcvLFxuICAgIHN0YXJ0Q2FsbDogL15cXCgvLFxuICAgIGVuZENhbGw6IC9eXFwpLyxcbiAgICBjb21tYTogL14sLyxcbiAgICBoZXhDb2xvcjogL15cXCMoWzAtOWEtZkEtRl0rKS8sXG4gICAgbGl0ZXJhbENvbG9yOiAvXihbYS16QS1aXSspLyxcbiAgICByZ2JDb2xvcjogL15yZ2IvaSxcbiAgICByZ2JhQ29sb3I6IC9ecmdiYS9pLFxuICAgIG51bWJlcjogL14oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKS9cbiAgfTtcbiAgdmFyIGlucHV0ID0gJyc7XG4gIGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChpbnB1dCwgXCI6IFwiKS5jb25jYXQobXNnKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QVNUKCkge1xuICAgIHZhciBhc3QgPSBtYXRjaExpc3REZWZpbml0aW9ucygpO1xuICAgIGlmIChpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBpbnB1dCBub3QgRU9GJyk7XG4gICAgfVxuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hMaXN0RGVmaW5pdGlvbnMoKSB7XG4gICAgcmV0dXJuIG1hdGNoTGlzdGluZyhtYXRjaERlZmluaXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gbWF0Y2hHcmFkaWVudCgnbGluZWFyLWdyYWRpZW50JywgdG9rZW5zLmxpbmVhckdyYWRpZW50LCBtYXRjaExpbmVhck9yaWVudGF0aW9uKSB8fCBtYXRjaEdyYWRpZW50KCdyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50JywgdG9rZW5zLnJlcGVhdGluZ0xpbmVhckdyYWRpZW50LCBtYXRjaExpbmVhck9yaWVudGF0aW9uKSB8fCBtYXRjaEdyYWRpZW50KCdyYWRpYWwtZ3JhZGllbnQnLCB0b2tlbnMucmFkaWFsR3JhZGllbnQsIG1hdGNoTGlzdFJhZGlhbE9yaWVudGF0aW9ucykgfHwgbWF0Y2hHcmFkaWVudCgncmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudCcsIHRva2Vucy5yZXBlYXRpbmdSYWRpYWxHcmFkaWVudCwgbWF0Y2hMaXN0UmFkaWFsT3JpZW50YXRpb25zKSB8fCBtYXRjaEdyYWRpZW50KCdjb25pYy1ncmFkaWVudCcsIHRva2Vucy5jb25pY0dyYWRpZW50LCBtYXRjaExpc3RSYWRpYWxPcmllbnRhdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoR3JhZGllbnQoZ3JhZGllbnRUeXBlLCBwYXR0ZXJuLCBvcmllbnRhdGlvbk1hdGNoZXIpIHtcbiAgICByZXR1cm4gbWF0Y2hDYWxsKHBhdHRlcm4sIGZ1bmN0aW9uIChjYXB0dXJlcykge1xuICAgICAgdmFyIG9yaWVudGF0aW9uID0gb3JpZW50YXRpb25NYXRjaGVyKCk7XG4gICAgICBpZiAob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKCFzY2FuKHRva2Vucy5jb21tYSkpIHtcbiAgICAgICAgICBlcnJvcignTWlzc2luZyBjb21tYSBiZWZvcmUgY29sb3Igc3RvcHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogZ3JhZGllbnRUeXBlLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIGNvbG9yU3RvcHM6IG1hdGNoTGlzdGluZyhtYXRjaENvbG9yU3RvcClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hDYWxsKHBhdHRlcm4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNhcHR1cmVzID0gc2NhbihwYXR0ZXJuKTtcbiAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgIGlmICghc2Nhbih0b2tlbnMuc3RhcnRDYWxsKSkge1xuICAgICAgICBlcnJvcignTWlzc2luZyAoJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY2FwdHVyZXMpO1xuICAgICAgaWYgKCFzY2FuKHRva2Vucy5lbmRDYWxsKSkge1xuICAgICAgICBlcnJvcignTWlzc2luZyApJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXRjaExpbmVhck9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiBtYXRjaFNpZGVPckNvcm5lcigpIHx8IG1hdGNoQW5nbGUoKTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaFNpZGVPckNvcm5lcigpIHtcbiAgICByZXR1cm4gbWF0Y2goJ2RpcmVjdGlvbmFsJywgdG9rZW5zLnNpZGVPckNvcm5lciwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hBbmdsZSgpIHtcbiAgICByZXR1cm4gbWF0Y2goJ2FuZ3VsYXInLCB0b2tlbnMuYW5nbGVWYWx1ZSwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hMaXN0UmFkaWFsT3JpZW50YXRpb25zKCkge1xuICAgIHZhciByYWRpYWxPcmllbnRhdGlvbnM7XG4gICAgdmFyIHJhZGlhbE9yaWVudGF0aW9uID0gbWF0Y2hSYWRpYWxPcmllbnRhdGlvbigpO1xuICAgIHZhciBsb29rYWhlYWRDYWNoZTtcbiAgICBpZiAocmFkaWFsT3JpZW50YXRpb24pIHtcbiAgICAgIHJhZGlhbE9yaWVudGF0aW9ucyA9IFtdO1xuICAgICAgcmFkaWFsT3JpZW50YXRpb25zLnB1c2gocmFkaWFsT3JpZW50YXRpb24pO1xuICAgICAgbG9va2FoZWFkQ2FjaGUgPSBpbnB1dDtcbiAgICAgIGlmIChzY2FuKHRva2Vucy5jb21tYSkpIHtcbiAgICAgICAgcmFkaWFsT3JpZW50YXRpb24gPSBtYXRjaFJhZGlhbE9yaWVudGF0aW9uKCk7XG4gICAgICAgIGlmIChyYWRpYWxPcmllbnRhdGlvbikge1xuICAgICAgICAgIHJhZGlhbE9yaWVudGF0aW9ucy5wdXNoKHJhZGlhbE9yaWVudGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dCA9IGxvb2thaGVhZENhY2hlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYWRpYWxPcmllbnRhdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hSYWRpYWxPcmllbnRhdGlvbigpIHtcbiAgICB2YXIgcmFkaWFsVHlwZSA9IG1hdGNoQ2lyY2xlKCkgfHwgbWF0Y2hFbGxpcHNlKCk7XG4gICAgaWYgKHJhZGlhbFR5cGUpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJhZGlhbFR5cGUuYXQgPSBtYXRjaEF0UG9zaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4dGVudCA9IG1hdGNoRXh0ZW50S2V5d29yZCgpO1xuICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICByYWRpYWxUeXBlID0gZXh0ZW50O1xuICAgICAgICB2YXIgcG9zaXRpb25BdCA9IG1hdGNoQXRQb3NpdGlvbigpO1xuICAgICAgICBpZiAocG9zaXRpb25BdCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByYWRpYWxUeXBlLmF0ID0gcG9zaXRpb25BdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlZmF1bHRQb3NpdGlvbiA9IG1hdGNoUG9zaXRpb25pbmcoKTtcbiAgICAgICAgaWYgKGRlZmF1bHRQb3NpdGlvbikge1xuICAgICAgICAgIHJhZGlhbFR5cGUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnZGVmYXVsdC1yYWRpYWwnLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgYXQ6IGRlZmF1bHRQb3NpdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbFR5cGU7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hDaXJjbGUoKSB7XG4gICAgdmFyIGNpcmNsZSA9IG1hdGNoKCdzaGFwZScsIC9eKGNpcmNsZSkvaSwgMCk7XG4gICAgaWYgKGNpcmNsZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY2lyY2xlLnN0eWxlID0gbWF0Y2hMZW5ndGgoKSB8fCBtYXRjaEV4dGVudEtleXdvcmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaEVsbGlwc2UoKSB7XG4gICAgdmFyIGVsbGlwc2UgPSBtYXRjaCgnc2hhcGUnLCAvXihlbGxpcHNlKS9pLCAwKTtcbiAgICBpZiAoZWxsaXBzZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZWxsaXBzZS5zdHlsZSA9IG1hdGNoRGlzdGFuY2UoKSB8fCBtYXRjaEV4dGVudEtleXdvcmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsbGlwc2U7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hFeHRlbnRLZXl3b3JkKCkge1xuICAgIHJldHVybiBtYXRjaCgnZXh0ZW50LWtleXdvcmQnLCB0b2tlbnMuZXh0ZW50S2V5d29yZHMsIDEpO1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoQXRQb3NpdGlvbigpIHtcbiAgICBpZiAobWF0Y2goJ3Bvc2l0aW9uJywgL15hdC8sIDApKSB7XG4gICAgICB2YXIgcG9zaXRpb25pbmcgPSBtYXRjaFBvc2l0aW9uaW5nKCk7XG4gICAgICBpZiAoIXBvc2l0aW9uaW5nKSB7XG4gICAgICAgIGVycm9yKCdNaXNzaW5nIHBvc2l0aW9uaW5nIHZhbHVlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zaXRpb25pbmc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hdGNoUG9zaXRpb25pbmcoKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbWF0Y2hDb29yZGluYXRlcygpO1xuICAgIGlmIChsb2NhdGlvbi54IHx8IGxvY2F0aW9uLnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgIHZhbHVlOiBsb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbWF0Y2hEaXN0YW5jZSgpLFxuICAgICAgeTogbWF0Y2hEaXN0YW5jZSgpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaExpc3RpbmcobWF0Y2hlcikge1xuICAgIHZhciBjYXB0dXJlcyA9IG1hdGNoZXIoKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICByZXN1bHQucHVzaChjYXB0dXJlcyk7XG4gICAgICB3aGlsZSAoc2Nhbih0b2tlbnMuY29tbWEpKSB7XG4gICAgICAgIGNhcHR1cmVzID0gbWF0Y2hlcigpO1xuICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChjYXB0dXJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ09uZSBleHRyYSBjb21tYScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hDb2xvclN0b3AoKSB7XG4gICAgdmFyIGNvbG9yID0gbWF0Y2hDb2xvcigpO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBjb2xvciBkZWZpbml0aW9uJyk7XG4gICAgfVxuICAgIGNvbG9yLmxlbmd0aCA9IG1hdGNoRGlzdGFuY2UoKTtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hDb2xvcigpIHtcbiAgICByZXR1cm4gbWF0Y2hIZXhDb2xvcigpIHx8IG1hdGNoUkdCQUNvbG9yKCkgfHwgbWF0Y2hSR0JDb2xvcigpIHx8IG1hdGNoTGl0ZXJhbENvbG9yKCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hMaXRlcmFsQ29sb3IoKSB7XG4gICAgcmV0dXJuIG1hdGNoKCdsaXRlcmFsJywgdG9rZW5zLmxpdGVyYWxDb2xvciwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hIZXhDb2xvcigpIHtcbiAgICByZXR1cm4gbWF0Y2goJ2hleCcsIHRva2Vucy5oZXhDb2xvciwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hSR0JDb2xvcigpIHtcbiAgICByZXR1cm4gbWF0Y2hDYWxsKHRva2Vucy5yZ2JDb2xvciwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3JnYicsXG4gICAgICAgIHZhbHVlOiBtYXRjaExpc3RpbmcobWF0Y2hOdW1iZXIpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoUkdCQUNvbG9yKCkge1xuICAgIHJldHVybiBtYXRjaENhbGwodG9rZW5zLnJnYmFDb2xvciwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3JnYmEnLFxuICAgICAgICB2YWx1ZTogbWF0Y2hMaXN0aW5nKG1hdGNoTnVtYmVyKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaE51bWJlcigpIHtcbiAgICByZXR1cm4gc2Nhbih0b2tlbnMubnVtYmVyKVsxXTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaERpc3RhbmNlKCkge1xuICAgIHJldHVybiBtYXRjaCgnJScsIHRva2Vucy5wZXJjZW50YWdlVmFsdWUsIDEpIHx8IG1hdGNoUG9zaXRpb25LZXl3b3JkKCkgfHwgbWF0Y2hMZW5ndGgoKTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaFBvc2l0aW9uS2V5d29yZCgpIHtcbiAgICByZXR1cm4gbWF0Y2goJ3Bvc2l0aW9uLWtleXdvcmQnLCB0b2tlbnMucG9zaXRpb25LZXl3b3JkcywgMSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hMZW5ndGgoKSB7XG4gICAgcmV0dXJuIG1hdGNoKCdweCcsIHRva2Vucy5waXhlbFZhbHVlLCAxKSB8fCBtYXRjaCgnZW0nLCB0b2tlbnMuZW1WYWx1ZSwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2godHlwZSwgcGF0dGVybiwgY2FwdHVyZUluZGV4KSB7XG4gICAgdmFyIGNhcHR1cmVzID0gc2NhbihwYXR0ZXJuKTtcbiAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbHVlOiBjYXB0dXJlc1tjYXB0dXJlSW5kZXhdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzY2FuKHJlZ2V4cCkge1xuICAgIHZhciBibGFua0NhcHR1cmVzID0gL15bXFxuXFxyXFx0XFxzXSsvLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChibGFua0NhcHR1cmVzKSB7XG4gICAgICBjb25zdW1lKGJsYW5rQ2FwdHVyZXNbMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGNhcHR1cmVzID0gcmVnZXhwLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZXM7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3VtZShzaXplKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoc2l6ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaW5wdXQgPSBjb2RlO1xuICAgIHJldHVybiBnZXRBU1QoKTtcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJHcmFkaWVudChtaW4sIHdpZHRoLCBoZWlnaHQsIGFuZ2xlKSB7XG4gIHZhciByYWQgPSBkZWcycmFkKGFuZ2xlLnZhbHVlKTtcbiAgdmFyIHJ4ID0gMDtcbiAgdmFyIHJ5ID0gMDtcbiAgdmFyIHJjeCA9IHJ4ICsgd2lkdGggLyAyO1xuICB2YXIgcmN5ID0gcnkgKyBoZWlnaHQgLyAyO1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiBncmFkaWVudCBsaW5lXG4gIC8vIEBzZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkYW5idXJ6by9jc3MtZ3JhZGllbnQtbGluZVxuICB2YXIgbGVuZ3RoID0gTWF0aC5hYnMod2lkdGggKiBNYXRoLmNvcyhyYWQpKSArIE1hdGguYWJzKGhlaWdodCAqIE1hdGguc2luKHJhZCkpO1xuICB2YXIgeDEgPSBtaW5bMF0gKyByY3ggLSBNYXRoLmNvcyhyYWQpICogbGVuZ3RoIC8gMjtcbiAgdmFyIHkxID0gbWluWzFdICsgcmN5IC0gTWF0aC5zaW4ocmFkKSAqIGxlbmd0aCAvIDI7XG4gIHZhciB4MiA9IG1pblswXSArIHJjeCArIE1hdGguY29zKHJhZCkgKiBsZW5ndGggLyAyO1xuICB2YXIgeTIgPSBtaW5bMV0gKyByY3kgKyBNYXRoLnNpbihyYWQpICogbGVuZ3RoIC8gMjtcbiAgcmV0dXJuIHtcbiAgICB4MTogeDEsXG4gICAgeTE6IHkxLFxuICAgIHgyOiB4MixcbiAgICB5MjogeTJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSYWRpYWxHcmFkaWVudChtaW4sIHdpZHRoLCBoZWlnaHQsIGN4LCBjeSwgc2l6ZSkge1xuICAvLyAncHgnXG4gIHZhciB4ID0gY3gudmFsdWU7XG4gIHZhciB5ID0gY3kudmFsdWU7XG5cbiAgLy8gVE9ETzogJ2VtJ1xuXG4gIC8vICclJ1xuICBpZiAoY3gudW5pdCA9PT0gVW5pdFR5cGUua1BlcmNlbnRhZ2UpIHtcbiAgICB4ID0gY3gudmFsdWUgLyAxMDAgKiB3aWR0aDtcbiAgfVxuICBpZiAoY3kudW5pdCA9PT0gVW5pdFR5cGUua1BlcmNlbnRhZ2UpIHtcbiAgICB5ID0gY3kudmFsdWUgLyAxMDAgKiBoZWlnaHQ7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGZhcnRoZXN0LXNpZGVcbiAgdmFyIHIgPSBNYXRoLm1heChkaXN0YW5jZVNxdWFyZVJvb3QoWzAsIDBdLCBbeCwgeV0pLCBkaXN0YW5jZVNxdWFyZVJvb3QoWzAsIGhlaWdodF0sIFt4LCB5XSksIGRpc3RhbmNlU3F1YXJlUm9vdChbd2lkdGgsIGhlaWdodF0sIFt4LCB5XSksIGRpc3RhbmNlU3F1YXJlUm9vdChbd2lkdGgsIDBdLCBbeCwgeV0pKTtcbiAgaWYgKHNpemUpIHtcbiAgICBpZiAoc2l6ZSBpbnN0YW5jZW9mIENTU1VuaXRWYWx1ZSkge1xuICAgICAgciA9IHNpemUudmFsdWU7XG4gICAgfSBlbHNlIGlmIChzaXplIGluc3RhbmNlb2YgQ1NTS2V5d29yZFZhbHVlKSB7XG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0NTUy9DU1NfSW1hZ2VzL1VzaW5nX0NTU19ncmFkaWVudHMjZXhhbXBsZV9jbG9zZXN0LXNpZGVfZm9yX2NpcmNsZXNcbiAgICAgIGlmIChzaXplLnZhbHVlID09PSAnY2xvc2VzdC1zaWRlJykge1xuICAgICAgICByID0gTWF0aC5taW4oeCwgd2lkdGggLSB4LCB5LCBoZWlnaHQgLSB5KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZS52YWx1ZSA9PT0gJ2ZhcnRoZXN0LXNpZGUnKSB7XG4gICAgICAgIHIgPSBNYXRoLm1heCh4LCB3aWR0aCAtIHgsIHksIGhlaWdodCAtIHkpO1xuICAgICAgfSBlbHNlIGlmIChzaXplLnZhbHVlID09PSAnY2xvc2VzdC1jb3JuZXInKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbihkaXN0YW5jZVNxdWFyZVJvb3QoWzAsIDBdLCBbeCwgeV0pLCBkaXN0YW5jZVNxdWFyZVJvb3QoWzAsIGhlaWdodF0sIFt4LCB5XSksIGRpc3RhbmNlU3F1YXJlUm9vdChbd2lkdGgsIGhlaWdodF0sIFt4LCB5XSksIGRpc3RhbmNlU3F1YXJlUm9vdChbd2lkdGgsIDBdLCBbeCwgeV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgbWluWzBdLFxuICAgIHk6IHkgKyBtaW5bMV0sXG4gICAgcjogclxuICB9O1xufVxuXG52YXIgcmVnZXhMRyA9IC9ebFxccypcXChcXHMqKFtcXGQuXSspXFxzKlxcKVxccyooLiopL2k7XG52YXIgcmVnZXhSRyA9IC9eclxccypcXChcXHMqKFtcXGQuXSspXFxzKixcXHMqKFtcXGQuXSspXFxzKixcXHMqKFtcXGQuXSspXFxzKlxcKVxccyooLiopL2k7XG52YXIgcmVnZXhQUiA9IC9ecFxccypcXChcXHMqKFtheHluXSlcXHMqXFwpXFxzKiguKikvaTtcbnZhciByZWdleENvbG9yU3RvcCA9IC9bXFxkLl0rOigjW15cXHNdK3xbXlxcKV0rXFwpKS9naTtcbmZ1bmN0aW9uIHNwYWNlQ29sb3JTdG9wcyhjb2xvclN0b3BzKSB7XG4gIHZhciBfY29sb3JTdG9wcyRsZW5ndGg7XG4gIHZhciBsZW5ndGggPSBjb2xvclN0b3BzLmxlbmd0aDtcbiAgY29sb3JTdG9wc1tsZW5ndGggLSAxXS5sZW5ndGggPSAoX2NvbG9yU3RvcHMkbGVuZ3RoID0gY29sb3JTdG9wc1tsZW5ndGggLSAxXS5sZW5ndGgpICE9PSBudWxsICYmIF9jb2xvclN0b3BzJGxlbmd0aCAhPT0gdm9pZCAwID8gX2NvbG9yU3RvcHMkbGVuZ3RoIDoge1xuICAgIHR5cGU6ICclJyxcbiAgICB2YWx1ZTogJzEwMCdcbiAgfTtcbiAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICB2YXIgX2NvbG9yU3RvcHMkMCRsZW5ndGg7XG4gICAgY29sb3JTdG9wc1swXS5sZW5ndGggPSAoX2NvbG9yU3RvcHMkMCRsZW5ndGggPSBjb2xvclN0b3BzWzBdLmxlbmd0aCkgIT09IG51bGwgJiYgX2NvbG9yU3RvcHMkMCRsZW5ndGggIT09IHZvaWQgMCA/IF9jb2xvclN0b3BzJDAkbGVuZ3RoIDoge1xuICAgICAgdHlwZTogJyUnLFxuICAgICAgdmFsdWU6ICcwJ1xuICAgIH07XG4gIH1cbiAgdmFyIHByZXZpb3VzSW5kZXggPSAwO1xuICB2YXIgcHJldmlvdXNPZmZzZXQgPSBOdW1iZXIoY29sb3JTdG9wc1swXS5sZW5ndGgudmFsdWUpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jb2xvclN0b3BzJGkkbGVuZ3RoO1xuICAgIC8vIHN1cHBvcnQgJyUnICYgJ3B4J1xuICAgIHZhciBvZmZzZXQgPSAoX2NvbG9yU3RvcHMkaSRsZW5ndGggPSBjb2xvclN0b3BzW2ldLmxlbmd0aCkgPT09IG51bGwgfHwgX2NvbG9yU3RvcHMkaSRsZW5ndGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xvclN0b3BzJGkkbGVuZ3RoLnZhbHVlO1xuICAgIGlmICghaXNOaWwob2Zmc2V0KSAmJiAhaXNOaWwocHJldmlvdXNPZmZzZXQpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGkgLSBwcmV2aW91c0luZGV4OyBqKyspIGNvbG9yU3RvcHNbcHJldmlvdXNJbmRleCArIGpdLmxlbmd0aCA9IHtcbiAgICAgICAgdHlwZTogJyUnLFxuICAgICAgICB2YWx1ZTogXCJcIi5jb25jYXQocHJldmlvdXNPZmZzZXQgKyAoTnVtYmVyKG9mZnNldCkgLSBwcmV2aW91c09mZnNldCkgKiBqIC8gKGkgLSBwcmV2aW91c0luZGV4KSlcbiAgICAgIH07XG4gICAgICBwcmV2aW91c0luZGV4ID0gaTtcbiAgICAgIHByZXZpb3VzT2Zmc2V0ID0gTnVtYmVyKG9mZnNldCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgZ3JhZGllbnQgbGluZSdzIHN0YXJ0aW5nIHBvaW50LlxuLy8gZGlmZmVyZW50IGZyb20gQ1NTIHNpZGUodG8gdG9wKSBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9ncmFkaWVudC9saW5lYXItZ3JhZGllbnQjdmFsdWVzXG52YXIgU2lkZU9yQ29ybmVyVG9EZWdNYXAgPSB7XG4gIGxlZnQ6IDI3MCAtIDkwLFxuICB0b3A6IDAgLSA5MCxcbiAgYm90dG9tOiAxODAgLSA5MCxcbiAgcmlnaHQ6IDkwIC0gOTAsXG4gICdsZWZ0IHRvcCc6IDMxNSAtIDkwLFxuICAndG9wIGxlZnQnOiAzMTUgLSA5MCxcbiAgJ2xlZnQgYm90dG9tJzogMjI1IC0gOTAsXG4gICdib3R0b20gbGVmdCc6IDIyNSAtIDkwLFxuICAncmlnaHQgdG9wJzogNDUgLSA5MCxcbiAgJ3RvcCByaWdodCc6IDQ1IC0gOTAsXG4gICdyaWdodCBib3R0b20nOiAxMzUgLSA5MCxcbiAgJ2JvdHRvbSByaWdodCc6IDEzNSAtIDkwXG59O1xudmFyIGFuZ2xlVG9EZWcgPSBtZW1vaXplKGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xuICB2YXIgYW5nbGU7XG4gIGlmIChvcmllbnRhdGlvbi50eXBlID09PSAnYW5ndWxhcicpIHtcbiAgICBhbmdsZSA9IE51bWJlcihvcmllbnRhdGlvbi52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBTaWRlT3JDb3JuZXJUb0RlZ01hcFtvcmllbnRhdGlvbi52YWx1ZV0gfHwgMDtcbiAgfVxuICByZXR1cm4gZ2V0T3JDcmVhdGVVbml0VmFsdWUoYW5nbGUsICdkZWcnKTtcbn0pO1xudmFyIHBvc2l0b25Ub0NTU1VuaXRWYWx1ZSA9IG1lbW9pemUoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gIHZhciBjeCA9IDUwO1xuICB2YXIgY3kgPSA1MDtcbiAgdmFyIHVuaXRYID0gJyUnO1xuICB2YXIgdW5pdFkgPSAnJSc7XG4gIGlmICgocG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLnR5cGUpID09PSAncG9zaXRpb24nKSB7XG4gICAgdmFyIF9wb3NpdGlvbiR2YWx1ZSA9IHBvc2l0aW9uLnZhbHVlLFxuICAgICAgeCA9IF9wb3NpdGlvbiR2YWx1ZS54LFxuICAgICAgeSA9IF9wb3NpdGlvbiR2YWx1ZS55O1xuICAgIGlmICgoeCA9PT0gbnVsbCB8fCB4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB4LnR5cGUpID09PSAncG9zaXRpb24ta2V5d29yZCcpIHtcbiAgICAgIGlmICh4LnZhbHVlID09PSAnbGVmdCcpIHtcbiAgICAgICAgY3ggPSAwO1xuICAgICAgfSBlbHNlIGlmICh4LnZhbHVlID09PSAnY2VudGVyJykge1xuICAgICAgICBjeCA9IDUwO1xuICAgICAgfSBlbHNlIGlmICh4LnZhbHVlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGN4ID0gMTAwO1xuICAgICAgfSBlbHNlIGlmICh4LnZhbHVlID09PSAndG9wJykge1xuICAgICAgICBjeSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHgudmFsdWUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGN5ID0gMTAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHkgPT09IG51bGwgfHwgeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogeS50eXBlKSA9PT0gJ3Bvc2l0aW9uLWtleXdvcmQnKSB7XG4gICAgICBpZiAoeS52YWx1ZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGN4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoeS52YWx1ZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgY3kgPSA1MDtcbiAgICAgIH0gZWxzZSBpZiAoeS52YWx1ZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBjeCA9IDEwMDtcbiAgICAgIH0gZWxzZSBpZiAoeS52YWx1ZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgY3kgPSAwO1xuICAgICAgfSBlbHNlIGlmICh5LnZhbHVlID09PSAnYm90dG9tJykge1xuICAgICAgICBjeSA9IDEwMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh4ID09PSBudWxsIHx8IHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHgudHlwZSkgPT09ICdweCcgfHwgKHggPT09IG51bGwgfHwgeCA9PT0gdm9pZCAwID8gdm9pZCAwIDogeC50eXBlKSA9PT0gJyUnIHx8ICh4ID09PSBudWxsIHx8IHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHgudHlwZSkgPT09ICdlbScpIHtcbiAgICAgIHVuaXRYID0geCA9PT0gbnVsbCB8fCB4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB4LnR5cGU7XG4gICAgICBjeCA9IE51bWJlcih4LnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCh5ID09PSBudWxsIHx8IHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHkudHlwZSkgPT09ICdweCcgfHwgKHkgPT09IG51bGwgfHwgeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogeS50eXBlKSA9PT0gJyUnIHx8ICh5ID09PSBudWxsIHx8IHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHkudHlwZSkgPT09ICdlbScpIHtcbiAgICAgIHVuaXRZID0geSA9PT0gbnVsbCB8fCB5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5LnR5cGU7XG4gICAgICBjeSA9IE51bWJlcih5LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjeDogZ2V0T3JDcmVhdGVVbml0VmFsdWUoY3gsIHVuaXRYKSxcbiAgICBjeTogZ2V0T3JDcmVhdGVVbml0VmFsdWUoY3ksIHVuaXRZKVxuICB9O1xufSk7XG52YXIgcGFyc2VHcmFkaWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKGNvbG9yU3RyKSB7XG4gIGlmIChjb2xvclN0ci5pbmRleE9mKCdsaW5lYXInKSA+IC0xIHx8IGNvbG9yU3RyLmluZGV4T2YoJ3JhZGlhbCcpID4gLTEpIHtcbiAgICB2YXIgYXN0ID0gcGFyc2VHcmFkaWVudCQxKGNvbG9yU3RyKTtcbiAgICByZXR1cm4gYXN0Lm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgICAgY29sb3JTdG9wcyA9IF9yZWYuY29sb3JTdG9wcztcbiAgICAgIHNwYWNlQ29sb3JTdG9wcyhjb2xvclN0b3BzKTtcbiAgICAgIHZhciBzdGVwcyA9IGNvbG9yU3RvcHMubWFwKGZ1bmN0aW9uIChjb2xvclN0b3ApIHtcbiAgICAgICAgLy8gVE9ETzogb25seSBzdXBwb3J0ICUgZm9yIG5vdywgc2hvdWxkIGNhbGMgcGVyY2VudGFnZSBvZiBheGlzIGxlbmd0aCB3aGVuIHVzaW5nIHB4L2VtXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb2Zmc2V0OiBnZXRPckNyZWF0ZVVuaXRWYWx1ZShOdW1iZXIoY29sb3JTdG9wLmxlbmd0aC52YWx1ZSksICclJyksXG4gICAgICAgICAgY29sb3I6IGNvbG9yU3RvcFRvU3RyaW5nKGNvbG9yU3RvcClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGUgPT09ICdsaW5lYXItZ3JhZGllbnQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1NTR3JhZGllbnRWYWx1ZShHcmFkaWVudFR5cGUuTGluZWFyR3JhZGllbnQsIHtcbiAgICAgICAgICBhbmdsZTogb3JpZW50YXRpb24gPyBhbmdsZVRvRGVnKG9yaWVudGF0aW9uKSA6IE9kZWcsXG4gICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICAgIGlmICghb3JpZW50YXRpb24pIHtcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IFt7XG4gICAgICAgICAgICB0eXBlOiAnc2hhcGUnLFxuICAgICAgICAgICAgdmFsdWU6ICdjaXJjbGUnXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uWzBdLnR5cGUgPT09ICdzaGFwZScgJiYgb3JpZW50YXRpb25bMF0udmFsdWUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgdmFyIF9wb3NpdG9uVG9DU1NVbml0VmFsdSA9IHBvc2l0b25Ub0NTU1VuaXRWYWx1ZShvcmllbnRhdGlvblswXS5hdCksXG4gICAgICAgICAgICBjeCA9IF9wb3NpdG9uVG9DU1NVbml0VmFsdS5jeCxcbiAgICAgICAgICAgIGN5ID0gX3Bvc2l0b25Ub0NTU1VuaXRWYWx1LmN5O1xuICAgICAgICAgIHZhciBzaXplO1xuICAgICAgICAgIGlmIChvcmllbnRhdGlvblswXS5zdHlsZSkge1xuICAgICAgICAgICAgdmFyIF9vcmllbnRhdGlvbiQwJHN0eWxlID0gb3JpZW50YXRpb25bMF0uc3R5bGUsXG4gICAgICAgICAgICAgIF90eXBlID0gX29yaWVudGF0aW9uJDAkc3R5bGUudHlwZSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfb3JpZW50YXRpb24kMCRzdHlsZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChfdHlwZSA9PT0gJ2V4dGVudC1rZXl3b3JkJykge1xuICAgICAgICAgICAgICBzaXplID0gZ2V0T3JDcmVhdGVLZXl3b3JkKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNpemUgPSBnZXRPckNyZWF0ZVVuaXRWYWx1ZSh2YWx1ZSwgX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENTU0dyYWRpZW50VmFsdWUoR3JhZGllbnRUeXBlLlJhZGlhbEdyYWRpZW50LCB7XG4gICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBlbGxpcHNlIHNoYXBlXG4gICAgICAgIC8vIFRPRE86IHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQgJiByZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50XG4gICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlcGVhdGluZy1saW5lYXItZ3JhZGllbnQnKSB7XG4gICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gbGVnYWN5IGZvcm1hdCwgc2hvdWxkIGJlIGRlcHJlY2F0ZWQgbGF0ZXJcbiAgdmFyIHR5cGUgPSBjb2xvclN0clswXTtcbiAgaWYgKGNvbG9yU3RyWzFdID09PSAnKCcgfHwgY29sb3JTdHJbMl0gPT09ICcoJykge1xuICAgIGlmICh0eXBlID09PSAnbCcpIHtcbiAgICAgIHZhciBhcnIgPSByZWdleExHLmV4ZWMoY29sb3JTdHIpO1xuICAgICAgaWYgKGFycikge1xuICAgICAgICB2YXIgX2FyciQyJG1hdGNoO1xuICAgICAgICB2YXIgc3RlcHMgPSAoKF9hcnIkMiRtYXRjaCA9IGFyclsyXS5tYXRjaChyZWdleENvbG9yU3RvcCkpID09PSBudWxsIHx8IF9hcnIkMiRtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyciQyJG1hdGNoLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgIHJldHVybiBzdG9wLnNwbGl0KCc6Jyk7XG4gICAgICAgIH0pKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgQ1NTR3JhZGllbnRWYWx1ZShHcmFkaWVudFR5cGUuTGluZWFyR3JhZGllbnQsIHtcbiAgICAgICAgICBhbmdsZTogZ2V0T3JDcmVhdGVVbml0VmFsdWUocGFyc2VGbG9hdChhcnJbMV0pLCAnZGVnJyksXG4gICAgICAgICAgc3RlcHM6IHN0ZXBzLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjNbMF0sXG4gICAgICAgICAgICAgIGNvbG9yID0gX3JlZjNbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBvZmZzZXQ6IGdldE9yQ3JlYXRlVW5pdFZhbHVlKE51bWJlcihvZmZzZXQpICogMTAwLCAnJScpLFxuICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfSldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3InKSB7XG4gICAgICB2YXIgcGFyc2VkUmFkaWFsR3JhZGllbnQgPSBwYXJzZVJhZGlhbEdyYWRpZW50KGNvbG9yU3RyKTtcbiAgICAgIGlmIChwYXJzZWRSYWRpYWxHcmFkaWVudCkge1xuICAgICAgICBpZiAoaXNTdHJpbmcocGFyc2VkUmFkaWFsR3JhZGllbnQpKSB7XG4gICAgICAgICAgY29sb3JTdHIgPSBwYXJzZWRSYWRpYWxHcmFkaWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBDU1NHcmFkaWVudFZhbHVlKEdyYWRpZW50VHlwZS5SYWRpYWxHcmFkaWVudCwgcGFyc2VkUmFkaWFsR3JhZGllbnQpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3AnKSB7XG4gICAgICByZXR1cm4gcGFyc2VQYXR0ZXJuKGNvbG9yU3RyKTtcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gcGFyc2VSYWRpYWxHcmFkaWVudChncmFkaWVudFN0cikge1xuICB2YXIgYXJyID0gcmVnZXhSRy5leGVjKGdyYWRpZW50U3RyKTtcbiAgaWYgKGFycikge1xuICAgIHZhciBfYXJyJDQkbWF0Y2g7XG4gICAgdmFyIHN0ZXBzID0gKChfYXJyJDQkbWF0Y2ggPSBhcnJbNF0ubWF0Y2gocmVnZXhDb2xvclN0b3ApKSA9PT0gbnVsbCB8fCBfYXJyJDQkbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hcnIkNCRtYXRjaC5tYXAoZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgIHJldHVybiBzdG9wLnNwbGl0KCc6Jyk7XG4gICAgfSkpIHx8IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogZ2V0T3JDcmVhdGVVbml0VmFsdWUoNTAsICclJyksXG4gICAgICBjeTogZ2V0T3JDcmVhdGVVbml0VmFsdWUoNTAsICclJyksXG4gICAgICBzdGVwczogc3RlcHMubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgX3JlZjUgPSBfc2xpY2VkVG9BcnJheShfcmVmNCwgMiksXG4gICAgICAgICAgb2Zmc2V0ID0gX3JlZjVbMF0sXG4gICAgICAgICAgY29sb3IgPSBfcmVmNVsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvZmZzZXQ6IGdldE9yQ3JlYXRlVW5pdFZhbHVlKE51bWJlcihvZmZzZXQpICogMTAwLCAnJScpLFxuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VQYXR0ZXJuKHBhdHRlcm5TdHIpIHtcbiAgdmFyIGFyciA9IHJlZ2V4UFIuZXhlYyhwYXR0ZXJuU3RyKTtcbiAgaWYgKGFycikge1xuICAgIHZhciByZXBldGl0aW9uID0gYXJyWzFdO1xuICAgIHZhciBzcmMgPSBhcnJbMl07XG4gICAgc3dpdGNoIChyZXBldGl0aW9uKSB7XG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgcmVwZXRpdGlvbiA9ICdyZXBlYXQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICByZXBldGl0aW9uID0gJ3JlcGVhdC14JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd5JzpcbiAgICAgICAgcmVwZXRpdGlvbiA9ICdyZXBlYXQteSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbic6XG4gICAgICAgIHJlcGV0aXRpb24gPSAnbm8tcmVwZWF0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXBldGl0aW9uID0gJ25vLXJlcGVhdCc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWFnZTogc3JjLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVwZXRpdGlvbjogcmVwZXRpdGlvblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NyZWF0ZVBhdHRlcm5cbiAqL1xuXG5mdW5jdGlvbiBpc0NTU0dyYWRpZW50VmFsdWUob2JqZWN0KSB7XG4gIHJldHVybiAhIW9iamVjdC50eXBlICYmICEhb2JqZWN0LnZhbHVlO1xufVxuZnVuY3Rpb24gaXNQYXR0ZXJuKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICYmICEhb2JqZWN0LmltYWdlO1xufVxuZnVuY3Rpb24gaXNDU1NSR0Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgJiYgIWlzTmlsKG9iamVjdC5yKSAmJiAhaXNOaWwob2JqZWN0LmcpICYmICFpc05pbChvYmplY3QuYik7XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vV2ViS2l0L1dlYktpdC9ibG9iL21haW4vU291cmNlL1dlYkNvcmUvY3NzL3BhcnNlci9DU1NQYXJzZXIuY3BwI0w5N1xuICovXG52YXIgcGFyc2VDb2xvciA9IG1lbW9pemUoZnVuY3Rpb24gKGNvbG9yU3RyKSB7XG4gIGlmIChpc1BhdHRlcm4oY29sb3JTdHIpKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcmVwZXRpdGlvbjogJ3JlcGVhdCdcbiAgICB9LCBjb2xvclN0cik7XG4gIH1cbiAgaWYgKGlzTmlsKGNvbG9yU3RyKSkge1xuICAgIGNvbG9yU3RyID0gJyc7XG4gIH1cbiAgaWYgKGNvbG9yU3RyID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgLy8gdHJhbnNwYXJlbnQgYmxhY2tcbiAgICByZXR1cm4gdHJhbnNwYXJlbnRDb2xvcjtcbiAgfVxuICBpZiAoY29sb3JTdHIgPT09ICdjdXJyZW50Q29sb3InKSB7XG4gICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUtd2VicGxhdGZvcm0vU25hcC5zdmcvaXNzdWVzLzUyNlxuICAgIGNvbG9yU3RyID0gJ2JsYWNrJztcbiAgfSBlbHNlIGlmIChjb2xvclN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIG5vbmVDb2xvcjtcbiAgfVxuXG4gIC8vIHN1cHBvcnQgQ1NTIGdyYWRpZW50IHN5bnRheFxuICB2YXIgZyA9IHBhcnNlR3JhZGllbnQoY29sb3JTdHIpO1xuICBpZiAoZykge1xuICAgIHJldHVybiBnO1xuICB9XG5cbiAgLy8gY29uc3RhbnRzXG4gIHZhciBjb2xvciQxID0gY29sb3IoY29sb3JTdHIpO1xuICB2YXIgcmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgaWYgKGNvbG9yJDEgIT09IG51bGwpIHtcbiAgICByZ2JhWzBdID0gY29sb3IkMS5yIHx8IDA7XG4gICAgcmdiYVsxXSA9IGNvbG9yJDEuZyB8fCAwO1xuICAgIHJnYmFbMl0gPSBjb2xvciQxLmIgfHwgMDtcbiAgICByZ2JhWzNdID0gY29sb3IkMS5vcGFjaXR5O1xuICB9XG5cbiAgLy8gcmV0dXJuIG5ldyBDU1NSR0IoLi4ucmdiYSk7XG4gIHJldHVybiBnZXRPckNyZWF0ZVJHQkEuYXBwbHkodm9pZCAwLCByZ2JhKTtcbn0pO1xuZnVuY3Rpb24gbWVyZ2VDb2xvcnMobGVmdCwgcmlnaHQpIHtcbiAgLy8gb25seSBzdXBwb3J0IGNvbnN0YW50IHZhbHVlLCBleGNsdWRlIGdyYWRpZW50ICYgcGF0dGVyblxuICBpZiAoIWlzQ1NTUkdCKGxlZnQpIHx8ICFpc0NTU1JHQihyaWdodCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIFtbTnVtYmVyKGxlZnQuciksIE51bWJlcihsZWZ0LmcpLCBOdW1iZXIobGVmdC5iKSwgTnVtYmVyKGxlZnQuYWxwaGEpXSwgW051bWJlcihyaWdodC5yKSwgTnVtYmVyKHJpZ2h0LmcpLCBOdW1iZXIocmlnaHQuYiksIE51bWJlcihyaWdodC5hbHBoYSldLCBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgcmdiYSA9IGNvbG9yLnNsaWNlKCk7XG4gICAgaWYgKHJnYmFbM10pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSByZ2JhW2ldID0gTWF0aC5yb3VuZChjbGFtcChyZ2JhW2ldLCAwLCAyNTUpKTtcbiAgICB9XG4gICAgcmdiYVszXSA9IGNsYW1wKHJnYmFbM10sIDAsIDEpO1xuICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KHJnYmEuam9pbignLCcpLCBcIilcIik7XG4gIH1dO1xufVxuXG5mdW5jdGlvbiBwYXJzZURpbWVuc2lvbih1bml0UmVnRXhwLCBzdHJpbmcpIHtcbiAgaWYgKGlzTmlsKHN0cmluZykpIHtcbiAgICByZXR1cm4gZ2V0T3JDcmVhdGVVbml0VmFsdWUoMCwgJ3B4Jyk7XG4gIH1cbiAgc3RyaW5nID0gXCJcIi5jb25jYXQoc3RyaW5nKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGlzRmluaXRlKE51bWJlcihzdHJpbmcpKSkge1xuICAgIGlmICgncHgnLnNlYXJjaCh1bml0UmVnRXhwKSA+PSAwKSB7XG4gICAgICByZXR1cm4gZ2V0T3JDcmVhdGVVbml0VmFsdWUoTnVtYmVyKHN0cmluZyksICdweCcpO1xuICAgIH1cbiAgICBpZiAoJ2RlZycuc2VhcmNoKHVuaXRSZWdFeHApID49IDApIHtcbiAgICAgIHJldHVybiBnZXRPckNyZWF0ZVVuaXRWYWx1ZShOdW1iZXIoc3RyaW5nKSwgJ2RlZycpO1xuICAgIH1cbiAgfVxuICB2YXIgbWF0Y2hlZFVuaXRzID0gW107XG4gIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHVuaXRSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIG1hdGNoZWRVbml0cy5wdXNoKG1hdGNoKTtcbiAgICByZXR1cm4gXCJVXCIuY29uY2F0KG1hdGNoKTtcbiAgfSk7XG4gIHZhciB0YWdnZWRVbml0UmVnRXhwID0gXCJVKFwiLmNvbmNhdCh1bml0UmVnRXhwLnNvdXJjZSwgXCIpXCIpO1xuICByZXR1cm4gbWF0Y2hlZFVuaXRzLm1hcChmdW5jdGlvbiAodW5pdCkge1xuICAgIHJldHVybiBnZXRPckNyZWF0ZVVuaXRWYWx1ZShOdW1iZXIoc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChcIlVcIi5jb25jYXQodW5pdCksICdnJyksICcnKS5yZXBsYWNlKG5ldyBSZWdFeHAodGFnZ2VkVW5pdFJlZ0V4cCwgJ2cnKSwgJyowJykpLCB1bml0KTtcbiAgfSlbMF07XG59XG5cbi8qKlxuICogPGxlbmd0aD5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL2xlbmd0aFxuICogbGVuZ3RoIHdpdGggb25seSBhYnNvbHV0ZSB1bml0LCBlZy4gMXB4XG4gKi9cbnZhciBwYXJzZUxlbmd0aFVubWVtb2l6ZSA9IGZ1bmN0aW9uIHBhcnNlTGVuZ3RoVW5tZW1vaXplKGNzcykge1xuICByZXR1cm4gcGFyc2VEaW1lbnNpb24obmV3IFJlZ0V4cCgncHgnLCAnZycpLCBjc3MpO1xufTtcbnZhciBwYXJzZUxlbmd0aCA9IG1lbW9pemUocGFyc2VMZW5ndGhVbm1lbW9pemUpO1xuXG4vKipcbiAqIDxwZXJjZW50YWdlPlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9DU1MvcGVyY2VudGFnZVxuICovXG52YXIgcGFyc2VyUGVyY2VudGFnZVVubWVtb2l6ZSA9IGZ1bmN0aW9uIHBhcnNlclBlcmNlbnRhZ2VVbm1lbW9pemUoY3NzKSB7XG4gIHJldHVybiBwYXJzZURpbWVuc2lvbihuZXcgUmVnRXhwKCclJywgJ2cnKSwgY3NzKTtcbn07XG5tZW1vaXplKHBhcnNlclBlcmNlbnRhZ2VVbm1lbW9pemUpO1xuXG4vKipcbiAqIGxlbmd0aCB3aXRoIGFic29sdXRlIG9yIHJlbGF0aXZlIHVuaXQsXG4gKiBlZy4gMXB4LCAwLjdlbSwgNTAlLCBjYWxjKDEwMCUgLSAyMDBweCk7XG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9DU1MvbGVuZ3RoLXBlcmNlbnRhZ2VcbiAqL1xudmFyIHBhcnNlTGVuZ3RoT3JQZXJjZW50YWdlVW5tZW1vaXplID0gZnVuY3Rpb24gcGFyc2VMZW5ndGhPclBlcmNlbnRhZ2VVbm1lbW9pemUoY3NzKSB7XG4gIGlmIChpc051bWJlcihjc3MpIHx8IGlzRmluaXRlKE51bWJlcihjc3MpKSkge1xuICAgIC8vIE51bWJlcihjc3MpIGlzIE5hTlxuICAgIHJldHVybiBnZXRPckNyZWF0ZVVuaXRWYWx1ZShOdW1iZXIoY3NzKSB8fCAwLCAncHgnKTtcbiAgICAvLyByZXR1cm4gTnVtYmVyKGNzcyk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlRGltZW5zaW9uKG5ldyBSZWdFeHAoJ3B4fCV8ZW18cmVtJywgJ2cnKSwgY3NzKTtcbn07XG52YXIgcGFyc2VMZW5ndGhPclBlcmNlbnRhZ2UgPSBtZW1vaXplKHBhcnNlTGVuZ3RoT3JQZXJjZW50YWdlVW5tZW1vaXplKTtcbnZhciBwYXJzZUFuZ2xlVW5tZW1vaXplID0gZnVuY3Rpb24gcGFyc2VBbmdsZVVubWVtb2l6ZShjc3MpIHtcbiAgcmV0dXJuIHBhcnNlRGltZW5zaW9uKG5ldyBSZWdFeHAoJ2RlZ3xyYWR8Z3JhZHx0dXJuJywgJ2cnKSwgY3NzKTtcbn07XG52YXIgcGFyc2VBbmdsZSA9IG1lbW9pemUocGFyc2VBbmdsZVVubWVtb2l6ZSk7XG5cbi8qKlxuICogbWVyZ2UgQ1NTVW5pdFZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIDEwcHggKyAyMHB4ID0gMzBweFxuICogMTBkZWcgKyAxMHJhZFxuICogMTAlICsgMjAlID0gMzAlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGltZW5zaW9ucyhsZWZ0LCByaWdodCwgdGFyZ2V0LCBub25OZWdhdGl2ZSkge1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gIHZhciB1bml0ID0gJyc7XG4gIHZhciBsZWZ0VmFsdWUgPSBsZWZ0LnZhbHVlIHx8IDA7XG4gIHZhciByaWdodFZhbHVlID0gcmlnaHQudmFsdWUgfHwgMDtcbiAgdmFyIGNhbm9uaWNhbFVuaXQgPSB0b0Nhbm9uaWNhbFVuaXQobGVmdC51bml0KTtcbiAgdmFyIGxlZnRDYW5vbmljYWxVbml0VmFsdWUgPSBsZWZ0LmNvbnZlcnRUbyhjYW5vbmljYWxVbml0KTtcbiAgdmFyIHJpZ2h0Q2Fub25pY2FsVW5pdFZhbHVlID0gcmlnaHQuY29udmVydFRvKGNhbm9uaWNhbFVuaXQpO1xuICBpZiAobGVmdENhbm9uaWNhbFVuaXRWYWx1ZSAmJiByaWdodENhbm9uaWNhbFVuaXRWYWx1ZSkge1xuICAgIGxlZnRWYWx1ZSA9IGxlZnRDYW5vbmljYWxVbml0VmFsdWUudmFsdWU7XG4gICAgcmlnaHRWYWx1ZSA9IHJpZ2h0Q2Fub25pY2FsVW5pdFZhbHVlLnZhbHVlO1xuICAgIHVuaXQgPSB1bml0VHlwZVRvU3RyaW5nKGxlZnQudW5pdCk7XG4gIH1cbiAgLy8gZm9ybWF0ICclJyB0byAncHgnXG4gIGVsc2UgaWYgKENTU1VuaXRWYWx1ZS5pc0xlbmd0aChsZWZ0LnVuaXQpIHx8IENTU1VuaXRWYWx1ZS5pc0xlbmd0aChyaWdodC51bml0KSkge1xuICAgIGxlZnRWYWx1ZSA9IGNvbnZlcnRQZXJjZW50VW5pdChsZWZ0LCBpbmRleCwgdGFyZ2V0KTtcbiAgICByaWdodFZhbHVlID0gY29udmVydFBlcmNlbnRVbml0KHJpZ2h0LCBpbmRleCwgdGFyZ2V0KTtcbiAgICB1bml0ID0gJ3B4JztcbiAgfVxuICByZXR1cm4gW2xlZnRWYWx1ZSwgcmlnaHRWYWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKG5vbk5lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IE1hdGgubWF4KHZhbHVlLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICsgdW5pdDtcbiAgfV07XG59XG5mdW5jdGlvbiBjb252ZXJ0QW5nbGVVbml0KHZhbHVlKSB7XG4gIHZhciBkZWcgPSAwO1xuICBpZiAodmFsdWUudW5pdCA9PT0gVW5pdFR5cGUua0RlZ3JlZXMpIHtcbiAgICBkZWcgPSB2YWx1ZS52YWx1ZTtcbiAgfSBlbHNlIGlmICh2YWx1ZS51bml0ID09PSBVbml0VHlwZS5rUmFkaWFucykge1xuICAgIGRlZyA9IHJhZDJkZWcoTnVtYmVyKHZhbHVlLnZhbHVlKSk7XG4gIH0gZWxzZSBpZiAodmFsdWUudW5pdCA9PT0gVW5pdFR5cGUua1R1cm5zKSB7XG4gICAgZGVnID0gdHVybjJkZWcoTnVtYmVyKHZhbHVlLnZhbHVlKSk7XG4gIH0gZWxzZSBpZiAodmFsdWUudmFsdWUpIHtcbiAgICBkZWcgPSB2YWx1ZS52YWx1ZTtcbiAgfVxuICByZXR1cm4gZGVnO1xufVxuZnVuY3Rpb24gcGFyc2VEaW1lbnNpb25BcnJheUZvcm1hdChzdHJpbmcsIHNpemUpIHtcbiAgdmFyIHBhcnNlZDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyaW5nKSkge1xuICAgIC8vIFsxLCAnMnB4JywgM11cbiAgICBwYXJzZWQgPSBzdHJpbmcubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHNlZ21lbnQpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHN0cmluZykpIHtcbiAgICBwYXJzZWQgPSBzdHJpbmcuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoc2VnbWVudCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoc3RyaW5nKSkge1xuICAgIHBhcnNlZCA9IFtzdHJpbmddO1xuICB9XG4gIGlmIChzaXplID09PSAyKSB7XG4gICAgaWYgKHBhcnNlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBbcGFyc2VkWzBdLCBwYXJzZWRbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gW3BhcnNlZFswXSwgcGFyc2VkWzFdXTtcbiAgfVxuICBpZiAoc2l6ZSA9PT0gNCkge1xuICAgIGlmIChwYXJzZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gW3BhcnNlZFswXSwgcGFyc2VkWzBdLCBwYXJzZWRbMF0sIHBhcnNlZFswXV07XG4gICAgfVxuICAgIGlmIChwYXJzZWQubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gW3BhcnNlZFswXSwgcGFyc2VkWzFdLCBwYXJzZWRbMF0sIHBhcnNlZFsxXV07XG4gICAgfVxuICAgIGlmIChwYXJzZWQubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gW3BhcnNlZFswXSwgcGFyc2VkWzFdLCBwYXJzZWRbMl0sIHBhcnNlZFsxXV07XG4gICAgfVxuICAgIHJldHVybiBbcGFyc2VkWzBdLCBwYXJzZWRbMV0sIHBhcnNlZFsyXSwgcGFyc2VkWzNdXTtcbiAgfVxuICBpZiAoc2l6ZSA9PT0gJ2V2ZW4nICYmIHBhcnNlZC5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGFyc2VkKSwgX3RvQ29uc3VtYWJsZUFycmF5KHBhcnNlZCkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBtZXJnZURpbWVuc2lvbkxpc3QoXG4vLyAgIGxlZnQ6IENTU1VuaXRWYWx1ZVtdLFxuLy8gICByaWdodDogQ1NTVW5pdFZhbHVlW10sXG4vLyAgIHRhcmdldDogSUVsZW1lbnQgfCBudWxsLFxuLy8gKTogW251bWJlcltdLCBudW1iZXJbXSwgKGxpc3Q6IG51bWJlcltdKSA9PiBzdHJpbmddIHwgdW5kZWZpbmVkIHtcbi8vICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcbi8vICAgICByZXR1cm47XG4vLyAgIH1cblxuLy8gICBjb25zdCB1bml0ID0gbGVmdFswXS51bml0O1xuXG4vLyAgIHJldHVybiBbXG4vLyAgICAgbGVmdC5tYXAoKGwpID0+IGwudmFsdWUpLFxuLy8gICAgIHJpZ2h0Lm1hcCgobCkgPT4gbC52YWx1ZSksXG4vLyAgICAgKHZhbHVlczogbnVtYmVyW10pID0+IHtcbi8vICAgICAgIHJldHVybiB2YWx1ZXMubWFwKChuKSA9PiBuZXcgQ1NTVW5pdFZhbHVlKG4sIHVuaXQpKS5qb2luKCcgJyk7XG4vLyAgICAgfSxcbi8vICAgXTtcbi8vIH1cblxuZnVuY3Rpb24gY29udmVydFBlcmNlbnRVbml0KHZhbHVlV2l0aFVuaXQsIHZlYzNJbmRleCwgdGFyZ2V0KSB7XG4gIHZhciB1c2VNaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICBpZiAodmFsdWVXaXRoVW5pdC51bml0ID09PSBVbml0VHlwZS5rUGl4ZWxzKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZVdpdGhVbml0LnZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWVXaXRoVW5pdC51bml0ID09PSBVbml0VHlwZS5rUGVyY2VudGFnZSAmJiB0YXJnZXQpIHtcbiAgICB2YXIgYm91bmRzID0gdGFyZ2V0Lm5vZGVOYW1lID09PSBTaGFwZS5HUk9VUCA/IHRhcmdldC5nZXRMb2NhbEJvdW5kcygpIDogdGFyZ2V0LmdldEdlb21ldHJ5Qm91bmRzKCk7XG4gICAgcmV0dXJuICh1c2VNaW4gPyBib3VuZHMubWluW3ZlYzNJbmRleF0gOiAwKSArIHZhbHVlV2l0aFVuaXQudmFsdWUgLyAxMDAgKiBib3VuZHMuaGFsZkV4dGVudHNbdmVjM0luZGV4XSAqIDI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBwYXJzZVBhcmFtID0gZnVuY3Rpb24gcGFyc2VQYXJhbShjc3MpIHtcbiAgcmV0dXJuIHBhcnNlRGltZW5zaW9uKC9kZWd8cmFkfGdyYWR8dHVybnxweHwlL2csIGNzcyk7XG59O1xudmFyIHN1cHBvcnRlZEZpbHRlcnMgPSBbJ2JsdXInLCAnYnJpZ2h0bmVzcycsICdkcm9wLXNoYWRvdycsICdjb250cmFzdCcsICdncmF5c2NhbGUnLCAnc2VwaWEnLCAnc2F0dXJhdGUnLCAnaHVlLXJvdGF0ZScsICdpbnZlcnQnXTtcbmZ1bmN0aW9uIHBhcnNlRmlsdGVyKCkge1xuICB2YXIgZmlsdGVyU3RyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgZmlsdGVyU3RyID0gZmlsdGVyU3RyLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBpZiAoZmlsdGVyU3RyID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGZpbHRlclJlZ0V4cCA9IC9cXHMqKFtcXHctXSspXFwoKFteKV0qKVxcKS9nO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBtYXRjaDtcbiAgdmFyIHByZXZMYXN0SW5kZXggPSAwO1xuICB3aGlsZSAobWF0Y2ggPSBmaWx0ZXJSZWdFeHAuZXhlYyhmaWx0ZXJTdHIpKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBwcmV2TGFzdEluZGV4KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHByZXZMYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBpZiAoc3VwcG9ydGVkRmlsdGVycy5pbmRleE9mKG1hdGNoWzFdKSA+IC0xKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIG5hbWU6IG1hdGNoWzFdLFxuICAgICAgICBwYXJhbXM6IG1hdGNoWzJdLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0ocCkgfHwgcGFyc2VDb2xvcihwKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyUmVnRXhwLmxhc3RJbmRleCA9PT0gZmlsdGVyU3RyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBudW1iZXJUb1N0cmluZyh4KSB7XG4gIC8vIHNjYWxlKDAuMDAwMDAwMDEpIC0+IHNjYWxlKDApXG4gIC8vIHJldHVybiB4LnRvRml4ZWQoNikucmVwbGFjZSgvMCskLywgJycpLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gIHJldHVybiB4LnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogcGFyc2Ugc3RyaW5nIG9yIG51bWJlciB0byBDU1NVbml0VmFsdWUobnVtZXJpYylcbiAqXG4gKiBlZy5cbiAqICogMCAtPiBDU1NVbml0VmFsdWUoMClcbiAqICogJzInIC0+IENTU1VuaXRWYWx1ZSgyKVxuICovXG52YXIgcGFyc2VOdW1iZXJVbm1lbW9pemUgPSBmdW5jdGlvbiBwYXJzZU51bWJlclVubWVtb2l6ZShzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGdldE9yQ3JlYXRlVW5pdFZhbHVlKHN0cmluZyk7XG4gIH1cbiAgaWYgKC9eXFxzKlstK10/KFxcZCpcXC4pP1xcZCtcXHMqJC8udGVzdChzdHJpbmcpKSB7XG4gICAgcmV0dXJuIGdldE9yQ3JlYXRlVW5pdFZhbHVlKE51bWJlcihzdHJpbmcpKTtcbiAgfVxuICByZXR1cm4gZ2V0T3JDcmVhdGVVbml0VmFsdWUoMCk7XG59O1xudmFyIHBhcnNlTnVtYmVyID0gbWVtb2l6ZShwYXJzZU51bWJlclVubWVtb2l6ZSk7XG5tZW1vaXplKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgaWYgKGlzU3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcgJykubWFwKHBhcnNlTnVtYmVyKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLm1hcChwYXJzZU51bWJlcik7XG59KTtcbmZ1bmN0aW9uIG1lcmdlTnVtYmVycyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0LCBudW1iZXJUb1N0cmluZ107XG59XG5mdW5jdGlvbiBjbGFtcGVkTWVyZ2VOdW1iZXJzKG1pbiwgbWF4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0LCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG51bWJlclRvU3RyaW5nKGNsYW1wKHgsIG1pbiwgbWF4KSk7XG4gICAgfV07XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU51bWJlckxpc3RzKGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHQsIGZ1bmN0aW9uIChudW1iZXJMaXN0KSB7XG4gICAgcmV0dXJuIG51bWJlckxpc3Q7XG4gIH1dO1xufVxuXG5mdW5jdGlvbiBnZXRPckNhbGN1bGF0ZVBhdGhUb3RhbExlbmd0aChwYXRoKSB7XG4gIGlmIChwYXRoLnBhcnNlZFN0eWxlLmQudG90YWxMZW5ndGggPT09IDApIHtcbiAgICBwYXRoLnBhcnNlZFN0eWxlLmQudG90YWxMZW5ndGggPSBnZXRUb3RhbExlbmd0aChwYXRoLnBhcnNlZFN0eWxlLmQuYWJzb2x1dGVQYXRoKTtcbiAgfVxuICByZXR1cm4gcGF0aC5wYXJzZWRTdHlsZS5kLnRvdGFsTGVuZ3RoO1xufVxuZnVuY3Rpb24gZ2V0T3JDYWxjdWxhdGVQb2x5bGluZVRvdGFsTGVuZ3RoKHBvbHlsaW5lKSB7XG4gIGlmIChwb2x5bGluZS5wYXJzZWRTdHlsZS5wb2ludHMudG90YWxMZW5ndGggPT09IDApIHtcbiAgICBwb2x5bGluZS5wYXJzZWRTdHlsZS5wb2ludHMudG90YWxMZW5ndGggPSBwb2x5bGluZUxlbmd0aChwb2x5bGluZS5wYXJzZWRTdHlsZS5wb2ludHMucG9pbnRzKTtcbiAgfVxuICByZXR1cm4gcG9seWxpbmUucGFyc2VkU3R5bGUucG9pbnRzLnRvdGFsTGVuZ3RoO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVkdW5kYW50TUNvbW1hbmQocGF0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJldlNlZ21lbnQgPSBwYXRoW2kgLSAxXTtcbiAgICB2YXIgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgdmFyIGNtZCA9IHNlZ21lbnRbMF07XG4gICAgaWYgKGNtZCA9PT0gJ00nKSB7XG4gICAgICBpZiAocHJldlNlZ21lbnQpIHtcbiAgICAgICAgdmFyIHByZXZDbWQgPSBwcmV2U2VnbWVudFswXTtcbiAgICAgICAgdmFyIHNyY1BvaW50ID0gW3NlZ21lbnRbMV0sIHNlZ21lbnRbMl1dO1xuICAgICAgICB2YXIgZGVzdFBvaW50ID0gdm9pZCAwO1xuICAgICAgICBpZiAocHJldkNtZCA9PT0gJ0wnIHx8IHByZXZDbWQgPT09ICdNJykge1xuICAgICAgICAgIGRlc3RQb2ludCA9IFtwcmV2U2VnbWVudFsxXSwgcHJldlNlZ21lbnRbMl1dO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZDbWQgPT09ICdDJyB8fCBwcmV2Q21kID09PSAnQScgfHwgcHJldkNtZCA9PT0gJ1EnKSB7XG4gICAgICAgICAgZGVzdFBvaW50ID0gW3ByZXZTZWdtZW50W3ByZXZTZWdtZW50Lmxlbmd0aCAtIDJdLCBwcmV2U2VnbWVudFtwcmV2U2VnbWVudC5sZW5ndGggLSAxXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RQb2ludCAmJiBpc1NhbWVQb2ludChzcmNQb2ludCwgZGVzdFBvaW50KSkge1xuICAgICAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaGFzQXJjT3JCZXppZXIocGF0aCkge1xuICB2YXIgaGFzQXJjID0gZmFsc2U7XG4gIHZhciBjb3VudCA9IHBhdGgubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICB2YXIgcGFyYW1zID0gcGF0aFtpXTtcbiAgICB2YXIgY21kID0gcGFyYW1zWzBdO1xuICAgIGlmIChjbWQgPT09ICdDJyB8fCBjbWQgPT09ICdBJyB8fCBjbWQgPT09ICdRJykge1xuICAgICAgaGFzQXJjID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQXJjO1xufVxuZnVuY3Rpb24gZXh0cmFjdFBvbHlnb25zKHBhdGhBcnJheSkge1xuICB2YXIgcG9seWdvbnMgPSBbXTtcbiAgdmFyIHBvbHlsaW5lcyA9IFtdO1xuICB2YXIgcG9pbnRzID0gW107IC8vIOmYsuatouesrOS4gOS4quWRveS7pOS4jeaYryAnTSdcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyYW1zID0gcGF0aEFycmF5W2ldO1xuICAgIHZhciBjbWQgPSBwYXJhbXNbMF07XG4gICAgaWYgKGNtZCA9PT0gJ00nKSB7XG4gICAgICAvLyDpgYfliLAgJ00nIOWIpOWumuaYr+WQpuaYr+aWsOaVsOe7hO+8jOaWsOaVsOe7hOS4reayoeacieeCuVxuICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8g5aaC5p6c5a2Y5Zyo54K577yM5YiZ6K+05piO5rKh5pyJ6YGH5YiwICdaJ++8jOW8gOWni+S6huS4gOS4quaWsOeahOWkmui+ueW9olxuICAgICAgICBwb2x5bGluZXMucHVzaChwb2ludHMpO1xuICAgICAgICBwb2ludHMgPSBbXTsgLy8g5Yib5bu65paw55qE54K5XG4gICAgICB9XG4gICAgICBwb2ludHMucHVzaChbcGFyYW1zWzFdLCBwYXJhbXNbMl1dKTtcbiAgICB9IGVsc2UgaWYgKGNtZCA9PT0gJ1onKSB7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyDlrZjlnKjngrlcbiAgICAgICAgcG9seWdvbnMucHVzaChwb2ludHMpO1xuICAgICAgICBwb2ludHMgPSBbXTsgLy8g5byA5aeL5paw55qE54K56ZuG5ZCIXG4gICAgICB9XG4gICAgICAvLyDlpoLmnpzkuI3lrZjlnKjngrnvvIzlkIzml7YgJ1on77yM5YiZ6K+05piO5piv6ZSZ6K+v77yM5LiN5aSE55CGXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKFtwYXJhbXNbMV0sIHBhcmFtc1syXV0pO1xuICAgIH1cbiAgfVxuICAvLyDor7TmmI4gcG9pbnRzIOacquaUvuWFpSBwb2x5Z29ucyDmiJbogIUgcG9seWxpbmVcbiAgLy8g5LuF5b2T5Y+q5pyJ5LiA5LiqIE3vvIzmsqHmnIkgWiDml7bkvJrlj5HnlJ/ov5nnp43mg4XlhrVcbiAgaWYgKHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgcG9seWxpbmVzLnB1c2gocG9pbnRzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBvbHlnb25zOiBwb2x5Z29ucyxcbiAgICBwb2x5bGluZXM6IHBvbHlsaW5lc1xuICB9O1xufVxuZnVuY3Rpb24gaXNTYW1lUG9pbnQocG9pbnQxLCBwb2ludDIpIHtcbiAgcmV0dXJuIHBvaW50MVswXSA9PT0gcG9pbnQyWzBdICYmIHBvaW50MVsxXSA9PT0gcG9pbnQyWzFdO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEJCb3goc2VnbWVudHMsIGxpbmVXaWR0aCkge1xuICB2YXIgeEFyciA9IFtdO1xuICB2YXIgeUFyciA9IFtdO1xuICB2YXIgc2VnbWVudHNXaXRoQW5nbGUgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHNlZ21lbnQuY3VycmVudFBvaW50LFxuICAgICAgcGFyYW1zID0gc2VnbWVudC5wYXJhbXMsXG4gICAgICBwcmVQb2ludCA9IHNlZ21lbnQucHJlUG9pbnQ7XG4gICAgdmFyIGJveCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHNlZ21lbnQuY29tbWFuZCkge1xuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIGJveCA9IHF1YWRCb3gocHJlUG9pbnRbMF0sIHByZVBvaW50WzFdLCBwYXJhbXNbMV0sIHBhcmFtc1syXSwgcGFyYW1zWzNdLCBwYXJhbXNbNF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICBib3ggPSBjdWJpY0JveChwcmVQb2ludFswXSwgcHJlUG9pbnRbMV0sIHBhcmFtc1sxXSwgcGFyYW1zWzJdLCBwYXJhbXNbM10sIHBhcmFtc1s0XSwgcGFyYW1zWzVdLCBwYXJhbXNbNl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICB2YXIgYXJjUGFyYW1zID0gc2VnbWVudC5hcmNQYXJhbXM7XG4gICAgICAgIGJveCA9IGFyY0JveChhcmNQYXJhbXMuY3gsIGFyY1BhcmFtcy5jeSwgYXJjUGFyYW1zLnJ4LCBhcmNQYXJhbXMucnksIGFyY1BhcmFtcy54Um90YXRpb24sIGFyY1BhcmFtcy5zdGFydEFuZ2xlLCBhcmNQYXJhbXMuZW5kQW5nbGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHhBcnIucHVzaChjdXJyZW50UG9pbnRbMF0pO1xuICAgICAgICB5QXJyLnB1c2goY3VycmVudFBvaW50WzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChib3gpIHtcbiAgICAgIHNlZ21lbnQuYm94ID0gYm94O1xuICAgICAgeEFyci5wdXNoKGJveC54LCBib3gueCArIGJveC53aWR0aCk7XG4gICAgICB5QXJyLnB1c2goYm94LnksIGJveC55ICsgYm94LmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChsaW5lV2lkdGggJiYgKHNlZ21lbnQuY29tbWFuZCA9PT0gJ0wnIHx8IHNlZ21lbnQuY29tbWFuZCA9PT0gJ00nKSAmJiBzZWdtZW50LnByZVBvaW50ICYmIHNlZ21lbnQubmV4dFBvaW50KSB7XG4gICAgICBzZWdtZW50c1dpdGhBbmdsZS5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuICAvLyBiYm94IGNhbGN1bGF0aW9uIHNob3VsZCBpZ25vcmUgTmFOIGZvciBwYXRoIGF0dHJpYnV0ZVxuICAvLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnR2aXMvZy9pc3N1ZXMvMjEwXG4gIC8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2FudHZpcy9HMi9pc3N1ZXMvMzEwOVxuICB4QXJyID0geEFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gIU51bWJlci5pc05hTihpdGVtKSAmJiBpdGVtICE9PSBJbmZpbml0eSAmJiBpdGVtICE9PSAtSW5maW5pdHk7XG4gIH0pO1xuICB5QXJyID0geUFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gIU51bWJlci5pc05hTihpdGVtKSAmJiBpdGVtICE9PSBJbmZpbml0eSAmJiBpdGVtICE9PSAtSW5maW5pdHk7XG4gIH0pO1xuICB2YXIgbWluWCA9IG1pbih4QXJyKTtcbiAgdmFyIG1pblkgPSBtaW4oeUFycik7XG4gIHZhciBtYXhYID0gbWF4KHhBcnIpO1xuICB2YXIgbWF4WSA9IG1heCh5QXJyKTtcbiAgaWYgKHNlZ21lbnRzV2l0aEFuZ2xlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBtaW5YLFxuICAgICAgeTogbWluWSxcbiAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICB9O1xuICB9XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZWdtZW50c1dpdGhBbmdsZS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX3NlZ21lbnQgPSBzZWdtZW50c1dpdGhBbmdsZVtfaV07XG4gICAgdmFyIF9jdXJyZW50UG9pbnQgPSBfc2VnbWVudC5jdXJyZW50UG9pbnQ7XG4gICAgdmFyIGV4dHJhID0gdm9pZCAwO1xuICAgIGlmIChfY3VycmVudFBvaW50WzBdID09PSBtaW5YKSB7XG4gICAgICBleHRyYSA9IGdldEV4dHJhRnJvbVNlZ21lbnRXaXRoQW5nbGUoX3NlZ21lbnQsIGxpbmVXaWR0aCk7XG4gICAgICBtaW5YIC09IGV4dHJhLnhFeHRyYTtcbiAgICB9IGVsc2UgaWYgKF9jdXJyZW50UG9pbnRbMF0gPT09IG1heFgpIHtcbiAgICAgIGV4dHJhID0gZ2V0RXh0cmFGcm9tU2VnbWVudFdpdGhBbmdsZShfc2VnbWVudCwgbGluZVdpZHRoKTtcbiAgICAgIG1heFggKz0gZXh0cmEueEV4dHJhO1xuICAgIH1cbiAgICBpZiAoX2N1cnJlbnRQb2ludFsxXSA9PT0gbWluWSkge1xuICAgICAgZXh0cmEgPSBnZXRFeHRyYUZyb21TZWdtZW50V2l0aEFuZ2xlKF9zZWdtZW50LCBsaW5lV2lkdGgpO1xuICAgICAgbWluWSAtPSBleHRyYS55RXh0cmE7XG4gICAgfSBlbHNlIGlmIChfY3VycmVudFBvaW50WzFdID09PSBtYXhZKSB7XG4gICAgICBleHRyYSA9IGdldEV4dHJhRnJvbVNlZ21lbnRXaXRoQW5nbGUoX3NlZ21lbnQsIGxpbmVXaWR0aCk7XG4gICAgICBtYXhZICs9IGV4dHJhLnlFeHRyYTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEV4dHJhRnJvbVNlZ21lbnRXaXRoQW5nbGUoc2VnbWVudCwgbGluZVdpZHRoKSB7XG4gIHZhciBwcmVQb2ludCA9IHNlZ21lbnQucHJlUG9pbnQsXG4gICAgY3VycmVudFBvaW50ID0gc2VnbWVudC5jdXJyZW50UG9pbnQsXG4gICAgbmV4dFBvaW50ID0gc2VnbWVudC5uZXh0UG9pbnQ7XG4gIHZhciBjdXJyZW50QW5kUHJlID0gTWF0aC5wb3coY3VycmVudFBvaW50WzBdIC0gcHJlUG9pbnRbMF0sIDIpICsgTWF0aC5wb3coY3VycmVudFBvaW50WzFdIC0gcHJlUG9pbnRbMV0sIDIpO1xuICB2YXIgY3VycmVudEFuZE5leHQgPSBNYXRoLnBvdyhjdXJyZW50UG9pbnRbMF0gLSBuZXh0UG9pbnRbMF0sIDIpICsgTWF0aC5wb3coY3VycmVudFBvaW50WzFdIC0gbmV4dFBvaW50WzFdLCAyKTtcbiAgdmFyIHByZUFuZE5leHQgPSBNYXRoLnBvdyhwcmVQb2ludFswXSAtIG5leHRQb2ludFswXSwgMikgKyBNYXRoLnBvdyhwcmVQb2ludFsxXSAtIG5leHRQb2ludFsxXSwgMik7XG4gIC8vIOS7pSBjdXJyZW50UG9pbnQg5Li66aG254K555qE5aS56KeSXG4gIHZhciBjdXJyZW50QW5nbGUgPSBNYXRoLmFjb3MoKGN1cnJlbnRBbmRQcmUgKyBjdXJyZW50QW5kTmV4dCAtIHByZUFuZE5leHQpIC8gKDIgKiBNYXRoLnNxcnQoY3VycmVudEFuZFByZSkgKiBNYXRoLnNxcnQoY3VycmVudEFuZE5leHQpKSk7XG4gIC8vIOWkueinkuS4uuepuuOAgSAwIOaIliBQSSDml7bvvIzkuI3pnIDopoHorqHnrpflpLnop5LlpITnmoTpop3lpJblrr3luqZcbiAgLy8g5rOo5oSPOiDnlLHkuo7orqHnrpfnsr7luqbpl67popjvvIzlpLnop5LkuLogMCDnmoTmg4XlhrXorqHnrpflh7rmnaXnmoTop5Lluqblj6/og73mmK/kuIDkuKrlvojlsI/nmoTlgLzvvIzov5jpnIDopoHliKTmlq3lhbbkuI4gMCDmmK/lkKbov5HkvLznm7jnrYlcbiAgaWYgKCFjdXJyZW50QW5nbGUgfHwgTWF0aC5zaW4oY3VycmVudEFuZ2xlKSA9PT0gMCB8fCBpc051bWJlckVxdWFsKGN1cnJlbnRBbmdsZSwgMCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeEV4dHJhOiAwLFxuICAgICAgeUV4dHJhOiAwXG4gICAgfTtcbiAgfVxuICB2YXIgeEFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hdGFuMihuZXh0UG9pbnRbMV0gLSBjdXJyZW50UG9pbnRbMV0sIG5leHRQb2ludFswXSAtIGN1cnJlbnRQb2ludFswXSkpO1xuICB2YXIgeUFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hdGFuMihuZXh0UG9pbnRbMF0gLSBjdXJyZW50UG9pbnRbMF0sIG5leHRQb2ludFsxXSAtIGN1cnJlbnRQb2ludFsxXSkpO1xuICAvLyDlsIblpLnop5LovazkuLrplJDop5JcbiAgeEFuZ2xlID0geEFuZ2xlID4gTWF0aC5QSSAvIDIgPyBNYXRoLlBJIC0geEFuZ2xlIDogeEFuZ2xlO1xuICB5QW5nbGUgPSB5QW5nbGUgPiBNYXRoLlBJIC8gMiA/IE1hdGguUEkgLSB5QW5nbGUgOiB5QW5nbGU7XG4gIC8vIOi/memHjOS4jeiAg+iZkeWcqOawtOW5s+WSjOWeguebtOaWueWQkeeahOaKleW9se+8jOebtOaOpeS9v+eUqOacgOWkp+W3ruWAvFxuICAvLyDnlLHkuo7kuIrlsYLnu5/kuIDliqDlh4/kuobkuozliIbkuYvkuIDnur/lrr3vvIzov5nph4zpnIDopoHov5vooYzlvKXooaVcbiAgdmFyIGV4dHJhID0ge1xuICAgIC8vIOawtOW5s+aWueWQkeaKleW9sVxuICAgIHhFeHRyYTogTWF0aC5jb3MoY3VycmVudEFuZ2xlIC8gMiAtIHhBbmdsZSkgKiAobGluZVdpZHRoIC8gMiAqICgxIC8gTWF0aC5zaW4oY3VycmVudEFuZ2xlIC8gMikpKSAtIGxpbmVXaWR0aCAvIDIgfHwgMCxcbiAgICAvLyDlnoLnm7TmlrnlkJHmipXlvbFcbiAgICB5RXh0cmE6IE1hdGguY29zKHlBbmdsZSAtIGN1cnJlbnRBbmdsZSAvIDIpICogKGxpbmVXaWR0aCAvIDIgKiAoMSAvIE1hdGguc2luKGN1cnJlbnRBbmdsZSAvIDIpKSkgLSBsaW5lV2lkdGggLyAyIHx8IDBcbiAgfTtcbiAgcmV0dXJuIGV4dHJhO1xufVxuXG4vLyDngrnlr7nnp7BcbmZ1bmN0aW9uIHRvU3ltbWV0cnkocG9pbnQsIGNlbnRlcikge1xuICByZXR1cm4gW2NlbnRlclswXSArIChjZW50ZXJbMF0gLSBwb2ludFswXSksIGNlbnRlclsxXSArIChjZW50ZXJbMV0gLSBwb2ludFsxXSldO1xufVxudmFyIGFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uIGFuZ2xlQmV0d2Vlbih2MCwgdjEpIHtcbiAgdmFyIHAgPSB2MC54ICogdjEueCArIHYwLnkgKiB2MS55O1xuICB2YXIgbiA9IE1hdGguc3FydCgoTWF0aC5wb3codjAueCwgMikgKyBNYXRoLnBvdyh2MC55LCAyKSkgKiAoTWF0aC5wb3codjEueCwgMikgKyBNYXRoLnBvdyh2MS55LCAyKSkpO1xuICB2YXIgc2lnbiA9IHYwLnggKiB2MS55IC0gdjAueSAqIHYxLnggPCAwID8gLTEgOiAxO1xuICB2YXIgYW5nbGUgPSBzaWduICogTWF0aC5hY29zKHAgLyBuKTtcbiAgcmV0dXJuIGFuZ2xlO1xufTtcbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnZlY2lhbmEvc3ZnLXBhdGgtcHJvcGVydGllcy9ibG9iL2I2YmQ5YTMyMjk2NmY2ZWY3YTMxMTg3MmQ4MGM1NmUzNzE4ZGU4NjEvc3JjL2FyYy50cyNMMTIxXG4gKi9cbnZhciBwb2ludE9uRWxsaXB0aWNhbEFyYyA9IGZ1bmN0aW9uIHBvaW50T25FbGxpcHRpY2FsQXJjKHAwLCByeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCBwMSwgdCkge1xuICAvLyBJbiBhY2NvcmRhbmNlIHRvOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNPdXRPZlJhbmdlUGFyYW1ldGVyc1xuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIHhBeGlzUm90YXRpb24gPSBtb2QoeEF4aXNSb3RhdGlvbiwgMzYwKTtcbiAgdmFyIHhBeGlzUm90YXRpb25SYWRpYW5zID0gZGVnMnJhZCh4QXhpc1JvdGF0aW9uKTtcbiAgLy8gSWYgdGhlIGVuZHBvaW50cyBhcmUgaWRlbnRpY2FsLCB0aGVuIHRoaXMgaXMgZXF1aXZhbGVudCB0byBvbWl0dGluZyB0aGUgZWxsaXB0aWNhbCBhcmMgc2VnbWVudCBlbnRpcmVseS5cbiAgaWYgKHAwLnggPT09IHAxLnggJiYgcDAueSA9PT0gcDEueSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwMC54LFxuICAgICAgeTogcDAueSxcbiAgICAgIGVsbGlwdGljYWxBcmNBbmdsZTogMFxuICAgIH07IC8vIENoZWNrIGlmIGFuZ2xlIGlzIGNvcnJlY3RcbiAgfVxuXG4gIC8vIElmIHJ4ID0gMCBvciByeSA9IDAgdGhlbiB0aGlzIGFyYyBpcyB0cmVhdGVkIGFzIGEgc3RyYWlnaHQgbGluZSBzZWdtZW50IGpvaW5pbmcgdGhlIGVuZHBvaW50cy5cbiAgaWYgKHJ4ID09PSAwIHx8IHJ5ID09PSAwKSB7XG4gICAgLy8gcmV0dXJuIHRoaXMucG9pbnRPbkxpbmUocDAsIHAxLCB0KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBlbGxpcHRpY2FsQXJjQW5nbGU6IDBcbiAgICB9OyAvLyBDaGVjayBpZiBhbmdsZSBpcyBjb3JyZWN0XG4gIH1cblxuICAvLyBGb2xsb3dpbmcgXCJDb252ZXJzaW9uIGZyb20gZW5kcG9pbnQgdG8gY2VudGVyIHBhcmFtZXRlcml6YXRpb25cIlxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNDb252ZXJzaW9uRW5kcG9pbnRUb0NlbnRlclxuXG4gIC8vIFN0ZXAgIzE6IENvbXB1dGUgdHJhbnNmb3JtZWRQb2ludFxuICB2YXIgZHggPSAocDAueCAtIHAxLngpIC8gMjtcbiAgdmFyIGR5ID0gKHAwLnkgLSBwMS55KSAvIDI7XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0ge1xuICAgIHg6IE1hdGguY29zKHhBeGlzUm90YXRpb25SYWRpYW5zKSAqIGR4ICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvblJhZGlhbnMpICogZHksXG4gICAgeTogLU1hdGguc2luKHhBeGlzUm90YXRpb25SYWRpYW5zKSAqIGR4ICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvblJhZGlhbnMpICogZHlcbiAgfTtcbiAgLy8gRW5zdXJlIHJhZGlpIGFyZSBsYXJnZSBlbm91Z2hcbiAgdmFyIHJhZGlpQ2hlY2sgPSBNYXRoLnBvdyh0cmFuc2Zvcm1lZFBvaW50LngsIDIpIC8gTWF0aC5wb3cocngsIDIpICsgTWF0aC5wb3codHJhbnNmb3JtZWRQb2ludC55LCAyKSAvIE1hdGgucG93KHJ5LCAyKTtcbiAgaWYgKHJhZGlpQ2hlY2sgPiAxKSB7XG4gICAgcnggKj0gTWF0aC5zcXJ0KHJhZGlpQ2hlY2spO1xuICAgIHJ5ICo9IE1hdGguc3FydChyYWRpaUNoZWNrKTtcbiAgfVxuXG4gIC8vIFN0ZXAgIzI6IENvbXB1dGUgdHJhbnNmb3JtZWRDZW50ZXJcbiAgdmFyIGNTcXVhcmVOdW1lcmF0b3IgPSBNYXRoLnBvdyhyeCwgMikgKiBNYXRoLnBvdyhyeSwgMikgLSBNYXRoLnBvdyhyeCwgMikgKiBNYXRoLnBvdyh0cmFuc2Zvcm1lZFBvaW50LnksIDIpIC0gTWF0aC5wb3cocnksIDIpICogTWF0aC5wb3codHJhbnNmb3JtZWRQb2ludC54LCAyKTtcbiAgdmFyIGNTcXVhcmVSb290RGVub20gPSBNYXRoLnBvdyhyeCwgMikgKiBNYXRoLnBvdyh0cmFuc2Zvcm1lZFBvaW50LnksIDIpICsgTWF0aC5wb3cocnksIDIpICogTWF0aC5wb3codHJhbnNmb3JtZWRQb2ludC54LCAyKTtcbiAgdmFyIGNSYWRpY2FuZCA9IGNTcXVhcmVOdW1lcmF0b3IgLyBjU3F1YXJlUm9vdERlbm9tO1xuICAvLyBNYWtlIHN1cmUgdGhpcyBuZXZlciBkcm9wcyBiZWxvdyB6ZXJvIGJlY2F1c2Ugb2YgcHJlY2lzaW9uXG4gIGNSYWRpY2FuZCA9IGNSYWRpY2FuZCA8IDAgPyAwIDogY1JhZGljYW5kO1xuICB2YXIgY0NvZWYgPSAobGFyZ2VBcmNGbGFnICE9PSBzd2VlcEZsYWcgPyAxIDogLTEpICogTWF0aC5zcXJ0KGNSYWRpY2FuZCk7XG4gIHZhciB0cmFuc2Zvcm1lZENlbnRlciA9IHtcbiAgICB4OiBjQ29lZiAqIChyeCAqIHRyYW5zZm9ybWVkUG9pbnQueSAvIHJ5KSxcbiAgICB5OiBjQ29lZiAqICgtKHJ5ICogdHJhbnNmb3JtZWRQb2ludC54KSAvIHJ4KVxuICB9O1xuXG4gIC8vIFN0ZXAgIzM6IENvbXB1dGUgY2VudGVyXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogTWF0aC5jb3MoeEF4aXNSb3RhdGlvblJhZGlhbnMpICogdHJhbnNmb3JtZWRDZW50ZXIueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb25SYWRpYW5zKSAqIHRyYW5zZm9ybWVkQ2VudGVyLnkgKyAocDAueCArIHAxLngpIC8gMixcbiAgICB5OiBNYXRoLnNpbih4QXhpc1JvdGF0aW9uUmFkaWFucykgKiB0cmFuc2Zvcm1lZENlbnRlci54ICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvblJhZGlhbnMpICogdHJhbnNmb3JtZWRDZW50ZXIueSArIChwMC55ICsgcDEueSkgLyAyXG4gIH07XG5cbiAgLy8gU3RlcCAjNDogQ29tcHV0ZSBzdGFydC9zd2VlcCBhbmdsZXNcbiAgLy8gU3RhcnQgYW5nbGUgb2YgdGhlIGVsbGlwdGljYWwgYXJjIHByaW9yIHRvIHRoZSBzdHJldGNoIGFuZCByb3RhdGUgb3BlcmF0aW9ucy5cbiAgLy8gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlc1xuICB2YXIgc3RhcnRWZWN0b3IgPSB7XG4gICAgeDogKHRyYW5zZm9ybWVkUG9pbnQueCAtIHRyYW5zZm9ybWVkQ2VudGVyLngpIC8gcngsXG4gICAgeTogKHRyYW5zZm9ybWVkUG9pbnQueSAtIHRyYW5zZm9ybWVkQ2VudGVyLnkpIC8gcnlcbiAgfTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBhbmdsZUJldHdlZW4oe1xuICAgIHg6IDEsXG4gICAgeTogMFxuICB9LCBzdGFydFZlY3Rvcik7XG4gIHZhciBlbmRWZWN0b3IgPSB7XG4gICAgeDogKC10cmFuc2Zvcm1lZFBvaW50LnggLSB0cmFuc2Zvcm1lZENlbnRlci54KSAvIHJ4LFxuICAgIHk6ICgtdHJhbnNmb3JtZWRQb2ludC55IC0gdHJhbnNmb3JtZWRDZW50ZXIueSkgLyByeVxuICB9O1xuICB2YXIgc3dlZXBBbmdsZSA9IGFuZ2xlQmV0d2VlbihzdGFydFZlY3RvciwgZW5kVmVjdG9yKTtcbiAgaWYgKCFzd2VlcEZsYWcgJiYgc3dlZXBBbmdsZSA+IDApIHtcbiAgICBzd2VlcEFuZ2xlIC09IDIgKiBNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHN3ZWVwRmxhZyAmJiBzd2VlcEFuZ2xlIDwgMCkge1xuICAgIHN3ZWVwQW5nbGUgKz0gMiAqIE1hdGguUEk7XG4gIH1cbiAgLy8gV2UgdXNlICUgaW5zdGVhZCBvZiBgbW9kKC4uKWAgYmVjYXVzZSB3ZSB3YW50IGl0IHRvIGJlIC0zNjBkZWcgdG8gMzYwZGVnKGJ1dCBhY3R1YWxseSBpbiByYWRpYW5zKVxuICBzd2VlcEFuZ2xlICU9IDIgKiBNYXRoLlBJO1xuXG4gIC8vIEZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjUGFyYW1ldGVyaXphdGlvbkFsdGVybmF0aXZlc1xuICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZSAqIHQ7XG4gIHZhciBlbGxpcHNlQ29tcG9uZW50WCA9IHJ4ICogTWF0aC5jb3MoYW5nbGUpO1xuICB2YXIgZWxsaXBzZUNvbXBvbmVudFkgPSByeSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIHBvaW50ID0ge1xuICAgIHg6IE1hdGguY29zKHhBeGlzUm90YXRpb25SYWRpYW5zKSAqIGVsbGlwc2VDb21wb25lbnRYIC0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvblJhZGlhbnMpICogZWxsaXBzZUNvbXBvbmVudFkgKyBjZW50ZXIueCxcbiAgICB5OiBNYXRoLnNpbih4QXhpc1JvdGF0aW9uUmFkaWFucykgKiBlbGxpcHNlQ29tcG9uZW50WCArIE1hdGguY29zKHhBeGlzUm90YXRpb25SYWRpYW5zKSAqIGVsbGlwc2VDb21wb25lbnRZICsgY2VudGVyLnksXG4gICAgZWxsaXB0aWNhbEFyY1N0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgZWxsaXB0aWNhbEFyY0VuZEFuZ2xlOiBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZSxcbiAgICBlbGxpcHRpY2FsQXJjQW5nbGU6IGFuZ2xlLFxuICAgIGVsbGlwdGljYWxBcmNDZW50ZXI6IGNlbnRlcixcbiAgICByZXN1bHRhbnRSeDogcngsXG4gICAgcmVzdWx0YW50Unk6IHJ5XG4gIH07XG4gIHJldHVybiBwb2ludDtcbn07XG5mdW5jdGlvbiBwYXRoMlNlZ21lbnRzKHBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gW107XG4gIHZhciBjdXJyZW50UG9pbnQgPSBudWxsOyAvLyDlvZPliY3lm77lvaJcbiAgdmFyIG5leHRQYXJhbXMgPSBudWxsOyAvLyDkuIvkuIDoioLngrnnmoQgcGF0aCDlj4LmlbBcbiAgdmFyIHN0YXJ0TW92ZVBvaW50ID0gbnVsbDsgLy8g5byA5aeLIE0g55qE54K577yM5Y+v6IO95Lya5pyJ5aSa5LiqXG4gIHZhciBsYXN0U3RhcnRNb3ZlUG9pbnRJbmRleCA9IDA7IC8vIOacgOi/keS4gOS4quW8gOWni+eCuSBNIOeahOe0ouW8lVxuICB2YXIgY291bnQgPSBwYXRoLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHBhdGhbaV07XG4gICAgbmV4dFBhcmFtcyA9IHBhdGhbaSArIDFdO1xuICAgIHZhciBjb21tYW5kID0gcGFyYW1zWzBdO1xuICAgIC8vIOaVsOWtpuWumuS5ieS4iueahOWPguaVsO+8jOS+v+S6juWQjumdoueahOiuoeeul1xuICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgIHByZVBvaW50OiBjdXJyZW50UG9pbnQsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIHN0YXJ0VGFuZ2VudDogbnVsbCxcbiAgICAgIGVuZFRhbmdlbnQ6IG51bGwsXG4gICAgICBjdXJyZW50UG9pbnQ6IG51bGwsXG4gICAgICBuZXh0UG9pbnQ6IG51bGwsXG4gICAgICBhcmNQYXJhbXM6IG51bGwsXG4gICAgICBib3g6IG51bGwsXG4gICAgICBjdWJpY1BhcmFtczogbnVsbFxuICAgIH07XG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgc3RhcnRNb3ZlUG9pbnQgPSBbcGFyYW1zWzFdLCBwYXJhbXNbMl1dO1xuICAgICAgICBsYXN0U3RhcnRNb3ZlUG9pbnRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIHZhciBhcmNQYXJhbXMgPSBnZXRBcmNQYXJhbXMoY3VycmVudFBvaW50LCBwYXJhbXMpO1xuICAgICAgICBzZWdtZW50LmFyY1BhcmFtcyA9IGFyY1BhcmFtcztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjb21tYW5kID09PSAnWicpIHtcbiAgICAgIC8vIOacieS6hiBaIOWQju+8jOW9k+WJjeiKgueCueS7juW8gOWniyBNIOeahOeCueW8gOWni1xuICAgICAgY3VycmVudFBvaW50ID0gc3RhcnRNb3ZlUG9pbnQ7XG4gICAgICAvLyDlpoLmnpzlvZPliY3ngrnnmoTlkb3ku6TkuLogWu+8jOebuOW9k+S6juW9k+WJjeeCueS4uuacgOi/keS4gOS4qiBNIOeCue+8jOWImeS4i+S4gOS4queCueebtOaOpeaMh+WQkeacgOi/keS4gOS4qiBNIOeCueeahOS4i+S4gOS4queCuVxuICAgICAgbmV4dFBhcmFtcyA9IHBhdGhbbGFzdFN0YXJ0TW92ZVBvaW50SW5kZXggKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IHBhcmFtcy5sZW5ndGg7XG4gICAgICBjdXJyZW50UG9pbnQgPSBbcGFyYW1zW2xlbiAtIDJdLCBwYXJhbXNbbGVuIC0gMV1dO1xuICAgIH1cbiAgICBpZiAobmV4dFBhcmFtcyAmJiBuZXh0UGFyYW1zWzBdID09PSAnWicpIHtcbiAgICAgIC8vIOWmguaenOS4i+S4gOS4queCueeahOWRveS7pOS4uiBa77yM5YiZ5LiL5LiA5Liq54K555u05o6l5oyH5ZCR5pyA6L+R5LiA5LiqIE0g54K5XG4gICAgICBuZXh0UGFyYW1zID0gcGF0aFtsYXN0U3RhcnRNb3ZlUG9pbnRJbmRleF07XG4gICAgICBpZiAoc2VnbWVudHNbbGFzdFN0YXJ0TW92ZVBvaW50SW5kZXhdKSB7XG4gICAgICAgIC8vIOWmguaenOS4i+S4gOS4queCueeahOWRveS7pOS4uiBa77yM5YiZ5pyA6L+R5LiA5LiqIE0g54K555qE5YmN5LiA5Liq54K55Li65b2T5YmN54K5XG4gICAgICAgIHNlZ21lbnRzW2xhc3RTdGFydE1vdmVQb2ludEluZGV4XS5wcmVQb2ludCA9IGN1cnJlbnRQb2ludDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VnbWVudC5jdXJyZW50UG9pbnQgPSBjdXJyZW50UG9pbnQ7XG4gICAgLy8g5aaC5p6c5b2T5YmN54K55LiO5pyA6L+R5LiA5LiqIE0g54K555u45ZCM77yM5YiZ5pyA6L+R5LiA5LiqIE0g54K555qE5YmN5LiA5Liq54K55Li65b2T5YmN54K555qE5YmN5LiA5Liq54K5XG4gICAgaWYgKHNlZ21lbnRzW2xhc3RTdGFydE1vdmVQb2ludEluZGV4XSAmJiBpc1NhbWVQb2ludChjdXJyZW50UG9pbnQsIHNlZ21lbnRzW2xhc3RTdGFydE1vdmVQb2ludEluZGV4XS5jdXJyZW50UG9pbnQpKSB7XG4gICAgICBzZWdtZW50c1tsYXN0U3RhcnRNb3ZlUG9pbnRJbmRleF0ucHJlUG9pbnQgPSBzZWdtZW50LnByZVBvaW50O1xuICAgIH1cbiAgICB2YXIgbmV4dFBvaW50ID0gbmV4dFBhcmFtcyA/IFtuZXh0UGFyYW1zW25leHRQYXJhbXMubGVuZ3RoIC0gMl0sIG5leHRQYXJhbXNbbmV4dFBhcmFtcy5sZW5ndGggLSAxXV0gOiBudWxsO1xuICAgIHNlZ21lbnQubmV4dFBvaW50ID0gbmV4dFBvaW50O1xuICAgIC8vIEFkZCBzdGFydFRhbmdlbnQgYW5kIGVuZFRhbmdlbnRcbiAgICB2YXIgcHJlUG9pbnQgPSBzZWdtZW50LnByZVBvaW50O1xuICAgIGlmIChbJ0wnLCAnSCcsICdWJ10uaW5jbHVkZXMoY29tbWFuZCkpIHtcbiAgICAgIHNlZ21lbnQuc3RhcnRUYW5nZW50ID0gW3ByZVBvaW50WzBdIC0gY3VycmVudFBvaW50WzBdLCBwcmVQb2ludFsxXSAtIGN1cnJlbnRQb2ludFsxXV07XG4gICAgICBzZWdtZW50LmVuZFRhbmdlbnQgPSBbY3VycmVudFBvaW50WzBdIC0gcHJlUG9pbnRbMF0sIGN1cnJlbnRQb2ludFsxXSAtIHByZVBvaW50WzFdXTtcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09ICdRJykge1xuICAgICAgLy8g5LqM5qyh6LSd5aGe5bCU5puy57q/5Y+q5pyJ5LiA5Liq5o6n5Yi254K5XG4gICAgICB2YXIgY3AgPSBbcGFyYW1zWzFdLCBwYXJhbXNbMl1dO1xuICAgICAgLy8g5LqM5qyh6LSd5aGe5bCU5puy57q/55qE57uI54K55Li6IGN1cnJlbnRQb2ludFxuICAgICAgc2VnbWVudC5zdGFydFRhbmdlbnQgPSBbcHJlUG9pbnRbMF0gLSBjcFswXSwgcHJlUG9pbnRbMV0gLSBjcFsxXV07XG4gICAgICBzZWdtZW50LmVuZFRhbmdlbnQgPSBbY3VycmVudFBvaW50WzBdIC0gY3BbMF0sIGN1cnJlbnRQb2ludFsxXSAtIGNwWzFdXTtcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09ICdUJykge1xuICAgICAgdmFyIHByZVNlZ21lbnQgPSBzZWdtZW50c1tpIC0gMV07XG4gICAgICB2YXIgX2NwID0gdG9TeW1tZXRyeShwcmVTZWdtZW50LmN1cnJlbnRQb2ludCwgcHJlUG9pbnQpO1xuICAgICAgaWYgKHByZVNlZ21lbnQuY29tbWFuZCA9PT0gJ1EnKSB7XG4gICAgICAgIHNlZ21lbnQuY29tbWFuZCA9ICdRJztcbiAgICAgICAgc2VnbWVudC5zdGFydFRhbmdlbnQgPSBbcHJlUG9pbnRbMF0gLSBfY3BbMF0sIHByZVBvaW50WzFdIC0gX2NwWzFdXTtcbiAgICAgICAgc2VnbWVudC5lbmRUYW5nZW50ID0gW2N1cnJlbnRQb2ludFswXSAtIF9jcFswXSwgY3VycmVudFBvaW50WzFdIC0gX2NwWzFdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc2VnbWVudC5jb21tYW5kID0gJ1RMJztcbiAgICAgICAgc2VnbWVudC5zdGFydFRhbmdlbnQgPSBbcHJlUG9pbnRbMF0gLSBjdXJyZW50UG9pbnRbMF0sIHByZVBvaW50WzFdIC0gY3VycmVudFBvaW50WzFdXTtcbiAgICAgICAgc2VnbWVudC5lbmRUYW5nZW50ID0gW2N1cnJlbnRQb2ludFswXSAtIHByZVBvaW50WzBdLCBjdXJyZW50UG9pbnRbMV0gLSBwcmVQb2ludFsxXV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSAnQycpIHtcbiAgICAgIC8vIOS4ieasoei0neWhnuWwlOabsue6v+acieS4pOS4quaOp+WItueCuVxuICAgICAgdmFyIGNwMSA9IFtwYXJhbXNbMV0sIHBhcmFtc1syXV07XG4gICAgICB2YXIgY3AyID0gW3BhcmFtc1szXSwgcGFyYW1zWzRdXTtcbiAgICAgIHNlZ21lbnQuc3RhcnRUYW5nZW50ID0gW3ByZVBvaW50WzBdIC0gY3AxWzBdLCBwcmVQb2ludFsxXSAtIGNwMVsxXV07XG4gICAgICBzZWdtZW50LmVuZFRhbmdlbnQgPSBbY3VycmVudFBvaW50WzBdIC0gY3AyWzBdLCBjdXJyZW50UG9pbnRbMV0gLSBjcDJbMV1dO1xuXG4gICAgICAvLyBob3Jpem9udGFsIGxpbmUsIGVnLiBbJ0MnLCAxMDAsIDEwMCwgMTAwLCAxMDAsIDIwMCwgMjAwXVxuICAgICAgaWYgKHNlZ21lbnQuc3RhcnRUYW5nZW50WzBdID09PSAwICYmIHNlZ21lbnQuc3RhcnRUYW5nZW50WzFdID09PSAwKSB7XG4gICAgICAgIHNlZ21lbnQuc3RhcnRUYW5nZW50ID0gW2NwMVswXSAtIGNwMlswXSwgY3AxWzFdIC0gY3AyWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50LmVuZFRhbmdlbnRbMF0gPT09IDAgJiYgc2VnbWVudC5lbmRUYW5nZW50WzFdID09PSAwKSB7XG4gICAgICAgIHNlZ21lbnQuZW5kVGFuZ2VudCA9IFtjcDJbMF0gLSBjcDFbMF0sIGNwMlsxXSAtIGNwMVsxXV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSAnUycpIHtcbiAgICAgIHZhciBfcHJlU2VnbWVudCA9IHNlZ21lbnRzW2kgLSAxXTtcbiAgICAgIHZhciBfY3AyID0gdG9TeW1tZXRyeShfcHJlU2VnbWVudC5jdXJyZW50UG9pbnQsIHByZVBvaW50KTtcbiAgICAgIHZhciBfY3AzID0gW3BhcmFtc1sxXSwgcGFyYW1zWzJdXTtcbiAgICAgIGlmIChfcHJlU2VnbWVudC5jb21tYW5kID09PSAnQycpIHtcbiAgICAgICAgc2VnbWVudC5jb21tYW5kID0gJ0MnOyAvLyDlsIYgUyDlkb3ku6Tlj5jmjaLkuLogQyDlkb3ku6RcbiAgICAgICAgc2VnbWVudC5zdGFydFRhbmdlbnQgPSBbcHJlUG9pbnRbMF0gLSBfY3AyWzBdLCBwcmVQb2ludFsxXSAtIF9jcDJbMV1dO1xuICAgICAgICBzZWdtZW50LmVuZFRhbmdlbnQgPSBbY3VycmVudFBvaW50WzBdIC0gX2NwM1swXSwgY3VycmVudFBvaW50WzFdIC0gX2NwM1sxXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNlZ21lbnQuY29tbWFuZCA9ICdTUSc7IC8vIOWwhiBTIOWRveS7pOWPmOaNouS4uiBTUSDlkb3ku6RcbiAgICAgICAgc2VnbWVudC5zdGFydFRhbmdlbnQgPSBbcHJlUG9pbnRbMF0gLSBfY3AzWzBdLCBwcmVQb2ludFsxXSAtIF9jcDNbMV1dO1xuICAgICAgICBzZWdtZW50LmVuZFRhbmdlbnQgPSBbY3VycmVudFBvaW50WzBdIC0gX2NwM1swXSwgY3VycmVudFBvaW50WzFdIC0gX2NwM1sxXV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSAnQScpIHtcbiAgICAgIHZhciBfZ2V0VGFuZ2VudEF0UmF0aW8gPSBnZXRUYW5nZW50QXRSYXRpbyhzZWdtZW50LCAwKSxcbiAgICAgICAgZHgxID0gX2dldFRhbmdlbnRBdFJhdGlvLngsXG4gICAgICAgIGR5MSA9IF9nZXRUYW5nZW50QXRSYXRpby55O1xuICAgICAgdmFyIF9nZXRUYW5nZW50QXRSYXRpbzIgPSBnZXRUYW5nZW50QXRSYXRpbyhzZWdtZW50LCAxLCBmYWxzZSksXG4gICAgICAgIGR4MiA9IF9nZXRUYW5nZW50QXRSYXRpbzIueCxcbiAgICAgICAgZHkyID0gX2dldFRhbmdlbnRBdFJhdGlvMi55O1xuICAgICAgc2VnbWVudC5zdGFydFRhbmdlbnQgPSBbZHgxLCBkeTFdO1xuICAgICAgc2VnbWVudC5lbmRUYW5nZW50ID0gW2R4MiwgZHkyXTtcbiAgICB9XG4gICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgfVxuICByZXR1cm4gc2VnbWVudHM7XG59XG5cbi8qKlxuICogVXNlIGxlbmd0aCBpbnN0ZWFkIG9mIHJhdGlvXG4gKi9cbmZ1bmN0aW9uIGdldFRhbmdlbnRBdFJhdGlvKHNlZ21lbnQsIHJhdGlvKSB7XG4gIHZhciBzaWduID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICB2YXIgX3NlZ21lbnQkYXJjUGFyYW1zID0gc2VnbWVudC5hcmNQYXJhbXMsXG4gICAgX3NlZ21lbnQkYXJjUGFyYW1zJHJ4ID0gX3NlZ21lbnQkYXJjUGFyYW1zLnJ4LFxuICAgIHJ4ID0gX3NlZ21lbnQkYXJjUGFyYW1zJHJ4ID09PSB2b2lkIDAgPyAwIDogX3NlZ21lbnQkYXJjUGFyYW1zJHJ4LFxuICAgIF9zZWdtZW50JGFyY1BhcmFtcyRyeSA9IF9zZWdtZW50JGFyY1BhcmFtcy5yeSxcbiAgICByeSA9IF9zZWdtZW50JGFyY1BhcmFtcyRyeSA9PT0gdm9pZCAwID8gMCA6IF9zZWdtZW50JGFyY1BhcmFtcyRyeSxcbiAgICB4Um90YXRpb24gPSBfc2VnbWVudCRhcmNQYXJhbXMueFJvdGF0aW9uLFxuICAgIGFyY0ZsYWcgPSBfc2VnbWVudCRhcmNQYXJhbXMuYXJjRmxhZyxcbiAgICBzd2VlcEZsYWcgPSBfc2VnbWVudCRhcmNQYXJhbXMuc3dlZXBGbGFnO1xuICB2YXIgcDEgPSBwb2ludE9uRWxsaXB0aWNhbEFyYyh7XG4gICAgeDogc2VnbWVudC5wcmVQb2ludFswXSxcbiAgICB5OiBzZWdtZW50LnByZVBvaW50WzFdXG4gIH0sIHJ4LCByeSwgeFJvdGF0aW9uLCAhIWFyY0ZsYWcsICEhc3dlZXBGbGFnLCB7XG4gICAgeDogc2VnbWVudC5jdXJyZW50UG9pbnRbMF0sXG4gICAgeTogc2VnbWVudC5jdXJyZW50UG9pbnRbMV1cbiAgfSwgcmF0aW8pO1xuICB2YXIgcDIgPSBwb2ludE9uRWxsaXB0aWNhbEFyYyh7XG4gICAgeDogc2VnbWVudC5wcmVQb2ludFswXSxcbiAgICB5OiBzZWdtZW50LnByZVBvaW50WzFdXG4gIH0sIHJ4LCByeSwgeFJvdGF0aW9uLCAhIWFyY0ZsYWcsICEhc3dlZXBGbGFnLCB7XG4gICAgeDogc2VnbWVudC5jdXJyZW50UG9pbnRbMF0sXG4gICAgeTogc2VnbWVudC5jdXJyZW50UG9pbnRbMV1cbiAgfSwgc2lnbiA/IHJhdGlvICsgMC4wMDUgOiByYXRpbyAtIDAuMDA1KTtcbiAgdmFyIHhEaXN0ID0gcDIueCAtIHAxLng7XG4gIHZhciB5RGlzdCA9IHAyLnkgLSBwMS55O1xuICB2YXIgZGlzdCA9IE1hdGguc3FydCh4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdCk7XG4gIHJldHVybiB7XG4gICAgeDogLXhEaXN0IC8gZGlzdCxcbiAgICB5OiAteURpc3QgLyBkaXN0XG4gIH07XG59XG5cbi8vIOWQkemHj+mVv+W6plxuZnVuY3Rpb24gdk1hZyh2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG59XG5cbi8vIHUudi98dXx8dnzvvIzorqHnrpflpLnop5LnmoTkvZnlvKblgLxcbmZ1bmN0aW9uIHZSYXRpbyh1LCB2KSB7XG4gIC8vIOW9k+WtmOWcqOS4gOS4quWQkemHj+eahOmVv+W6puS4uiAwIOaXtu+8jOWkueinkuS5n+S4uiAw77yM5Y2z5aS56KeS55qE5L2Z5bym5YC85Li6IDFcbiAgcmV0dXJuIHZNYWcodSkgKiB2TWFnKHYpID8gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKSA6IDE7XG59XG5cbi8vIOWQkemHj+inkuW6plxuZnVuY3Rpb24gdkFuZ2xlKHUsIHYpIHtcbiAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKSAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xufVxuZnVuY3Rpb24gZ2V0QXJjUGFyYW1zKHN0YXJ0UG9pbnQsIHBhcmFtcykge1xuICB2YXIgcnggPSBwYXJhbXNbMV07XG4gIHZhciByeSA9IHBhcmFtc1syXTtcbiAgdmFyIHhSb3RhdGlvbiA9IG1vZChkZWcycmFkKHBhcmFtc1szXSksIE1hdGguUEkgKiAyKTtcbiAgdmFyIGFyY0ZsYWcgPSBwYXJhbXNbNF07XG4gIHZhciBzd2VlcEZsYWcgPSBwYXJhbXNbNV07XG4gIC8vIOW8p+W9oui1t+eCueWdkOagh1xuICB2YXIgeDEgPSBzdGFydFBvaW50WzBdO1xuICB2YXIgeTEgPSBzdGFydFBvaW50WzFdO1xuICAvLyDlvKflvaLnu4jngrnlnZDmoIdcbiAgdmFyIHgyID0gcGFyYW1zWzZdO1xuICB2YXIgeTIgPSBwYXJhbXNbN107XG4gIHZhciB4cCA9IE1hdGguY29zKHhSb3RhdGlvbikgKiAoeDEgLSB4MikgLyAyLjAgKyBNYXRoLnNpbih4Um90YXRpb24pICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgeXAgPSAtMSAqIE1hdGguc2luKHhSb3RhdGlvbikgKiAoeDEgLSB4MikgLyAyLjAgKyBNYXRoLmNvcyh4Um90YXRpb24pICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gIH1cbiAgdmFyIGRpZmYgPSByeCAqIHJ4ICogKHlwICogeXApICsgcnkgKiByeSAqICh4cCAqIHhwKTtcbiAgdmFyIGYgPSBkaWZmID8gTWF0aC5zcXJ0KChyeCAqIHJ4ICogKHJ5ICogcnkpIC0gZGlmZikgLyBkaWZmKSA6IDE7XG4gIGlmIChhcmNGbGFnID09PSBzd2VlcEZsYWcpIHtcbiAgICBmICo9IC0xO1xuICB9XG4gIGlmIChpc05hTihmKSkge1xuICAgIGYgPSAwO1xuICB9XG5cbiAgLy8g5peL6L2s5YmN55qE6LW354K55Z2Q5qCH77yM5LiU5b2T6ZW/5Y2K6L205ZKM55+t5Y2K6L2055qE6ZW/5bqm5Li6IDAg5pe277yM5Z2Q5qCH5oyJICgwLCAwKSDlpITnkIZcbiAgdmFyIGN4cCA9IHJ5ID8gZiAqIHJ4ICogeXAgLyByeSA6IDA7XG4gIHZhciBjeXAgPSByeCA/IGYgKiAtcnkgKiB4cCAvIHJ4IDogMDtcblxuICAvLyDmpK3lnIblnIblv4PlnZDmoIdcbiAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wICsgTWF0aC5jb3MoeFJvdGF0aW9uKSAqIGN4cCAtIE1hdGguc2luKHhSb3RhdGlvbikgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIE1hdGguc2luKHhSb3RhdGlvbikgKiBjeHAgKyBNYXRoLmNvcyh4Um90YXRpb24pICogY3lwO1xuXG4gIC8vIOi1t+Wni+eCueeahOWNleS9jeWQkemHj1xuICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gIC8vIOe7iOatoueCueeahOWNleS9jeWQkemHj1xuICB2YXIgdiA9IFsoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnldO1xuICAvLyDorqHnrpfotbflp4vngrnlkozlnIblv4PnmoTov57nur/vvIzkuI4geCDovbTmraPmlrnlkJHnmoTlpLnop5JcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgdSk7XG5cbiAgLy8g6K6h566X5ZyG5byn6LW35aeL54K55ZKM57uI5q2i54K55LiO5qSt5ZyG5ZyG5b+D6L+e57q/55qE5aS56KeSXG4gIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG4gIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICBkVGhldGEgPSBNYXRoLlBJO1xuICB9XG4gIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgIGRUaGV0YSA9IDA7XG4gIH1cbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgZFRoZXRhIC09IDIgKiBNYXRoLlBJO1xuICB9XG4gIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSArPSAyICogTWF0aC5QSTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgLy8g5byn5b2i55qE6LW354K55ZKM57uI54K555u45ZCM5pe277yM6ZW/6L205ZKM55+t6L2055qE6ZW/5bqm5oyJIDAg5aSE55CGXG4gICAgcng6IGlzU2FtZVBvaW50KHN0YXJ0UG9pbnQsIFt4MiwgeTJdKSA/IDAgOiByeCxcbiAgICByeTogaXNTYW1lUG9pbnQoc3RhcnRQb2ludCwgW3gyLCB5Ml0pID8gMCA6IHJ5LFxuICAgIHN0YXJ0QW5nbGU6IHRoZXRhLFxuICAgIGVuZEFuZ2xlOiB0aGV0YSArIGRUaGV0YSxcbiAgICB4Um90YXRpb246IHhSb3RhdGlvbixcbiAgICBhcmNGbGFnOiBhcmNGbGFnLFxuICAgIHN3ZWVwRmxhZzogc3dlZXBGbGFnXG4gIH07XG59XG5mdW5jdGlvbiBjb21tYW5kc1RvUGF0aFN0cmluZyhjb21tYW5kcywgb2JqZWN0LCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGNvbW1hbmRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICBpZiAoY3VyWzBdID09PSAnTScgfHwgY3VyWzBdID09PSAnTCcpIHtcbiAgICAgIHZhciBwID0gdmVjMy5mcm9tVmFsdWVzKGN1clsxXSwgY3VyWzJdLCAwKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHAsIHAsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBwYXRoID0gXCJcIi5jb25jYXQoY3VyWzBdKS5jb25jYXQocFswXSwgXCIsXCIpLmNvbmNhdChwWzFdKTtcbiAgICB9IGVsc2UgaWYgKGN1clswXSA9PT0gJ1onKSB7XG4gICAgICBwYXRoID0gY3VyWzBdO1xuICAgIH0gZWxzZSBpZiAoY3VyWzBdID09PSAnQycpIHtcbiAgICAgIHZhciBwMSA9IHZlYzMuZnJvbVZhbHVlcyhjdXJbMV0sIGN1clsyXSwgMCk7XG4gICAgICB2YXIgcDIgPSB2ZWMzLmZyb21WYWx1ZXMoY3VyWzNdLCBjdXJbNF0sIDApO1xuICAgICAgdmFyIHAzID0gdmVjMy5mcm9tVmFsdWVzKGN1cls1XSwgY3VyWzZdLCAwKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHAxLCBwMSwgdHJhbnNmb3JtKTtcbiAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHAyLCBwMiwgdHJhbnNmb3JtKTtcbiAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHAzLCBwMywgdHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBcIlwiLmNvbmNhdChjdXJbMF0pLmNvbmNhdChwMVswXSwgXCIsXCIpLmNvbmNhdChwMVsxXSwgXCIsXCIpLmNvbmNhdChwMlswXSwgXCIsXCIpLmNvbmNhdChwMlsxXSwgXCIsXCIpLmNvbmNhdChwM1swXSwgXCIsXCIpLmNvbmNhdChwM1sxXSk7XG4gICAgfSBlbHNlIGlmIChjdXJbMF0gPT09ICdBJykge1xuICAgICAgdmFyIGMgPSB2ZWMzLmZyb21WYWx1ZXMoY3VyWzZdLCBjdXJbN10sIDApO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoYywgYywgdHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBcIlwiLmNvbmNhdChjdXJbMF0pLmNvbmNhdChjdXJbMV0sIFwiLFwiKS5jb25jYXQoY3VyWzJdLCBcIixcIikuY29uY2F0KGN1clszXSwgXCIsXCIpLmNvbmNhdChjdXJbNF0sIFwiLFwiKS5jb25jYXQoY3VyWzVdLCBcIixcIikuY29uY2F0KGNbMF0sIFwiLFwiKS5jb25jYXQoY1sxXSk7XG4gICAgfSBlbHNlIGlmIChjdXJbMF0gPT09ICdRJykge1xuICAgICAgdmFyIF9wID0gdmVjMy5mcm9tVmFsdWVzKGN1clsxXSwgY3VyWzJdLCAwKTtcbiAgICAgIHZhciBfcDIgPSB2ZWMzLmZyb21WYWx1ZXMoY3VyWzNdLCBjdXJbNF0sIDApO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoX3AsIF9wLCB0cmFuc2Zvcm0pO1xuICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoX3AyLCBfcDIsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBwYXRoID0gXCJcIi5jb25jYXQoY3VyWzBdKS5jb25jYXQoY3VyWzFdLCBcIixcIikuY29uY2F0KGN1clsyXSwgXCIsXCIpLmNvbmNhdChjdXJbM10sIFwiLFwiKS5jb25jYXQoY3VyWzRdLCBcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBwcmV2ICs9IHBhdGg7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGxpbmVUb0NvbW1hbmRzKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiBbWydNJywgeDEsIHkxXSwgWydMJywgeDIsIHkyXV07XG59XG5mdW5jdGlvbiBlbGxpcHNlVG9Db21tYW5kcyhyeCwgcnksIGN4LCBjeSkge1xuICB2YXIgZmFjdG9yID0gKC0xICsgTWF0aC5zcXJ0KDIpKSAvIDMgKiA0O1xuICB2YXIgZHggPSByeCAqIGZhY3RvcjtcbiAgdmFyIGR5ID0gcnkgKiBmYWN0b3I7XG4gIHZhciBsZWZ0ID0gY3ggLSByeDtcbiAgdmFyIHJpZ2h0ID0gY3ggKyByeDtcbiAgdmFyIHRvcCA9IGN5IC0gcnk7XG4gIHZhciBib3R0b20gPSBjeSArIHJ5O1xuICByZXR1cm4gW1snTScsIGxlZnQsIGN5XSwgWydDJywgbGVmdCwgY3kgLSBkeSwgY3ggLSBkeCwgdG9wLCBjeCwgdG9wXSwgWydDJywgY3ggKyBkeCwgdG9wLCByaWdodCwgY3kgLSBkeSwgcmlnaHQsIGN5XSwgWydDJywgcmlnaHQsIGN5ICsgZHksIGN4ICsgZHgsIGJvdHRvbSwgY3gsIGJvdHRvbV0sIFsnQycsIGN4IC0gZHgsIGJvdHRvbSwgbGVmdCwgY3kgKyBkeSwgbGVmdCwgY3ldLCBbJ1onXV07XG59XG5mdW5jdGlvbiBwb2x5Z29uVG9Db21tYW5kcyhwb2ludHMsIGNsb3NlZCkge1xuICB2YXIgcmVzdWx0ID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQsIGkpIHtcbiAgICByZXR1cm4gW2kgPT09IDAgPyAnTScgOiAnTCcsIHBvaW50WzBdLCBwb2ludFsxXV07XG4gIH0pO1xuICBpZiAoY2xvc2VkKSB7XG4gICAgcmVzdWx0LnB1c2goWydaJ10pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWN0VG9Db21tYW5kcyh3aWR0aCwgaGVpZ2h0LCB4LCB5LCByYWRpdXMpIHtcbiAgLy8gQHNlZSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kYW5pZWxwcXVpbm4vZGQ5NjZhZjQyNDAzMGQ0N2U0NzZcbiAgaWYgKHJhZGl1cykge1xuICAgIHZhciBfcmFkaXVzID0gX3NsaWNlZFRvQXJyYXkocmFkaXVzLCA0KSxcbiAgICAgIHRsciA9IF9yYWRpdXNbMF0sXG4gICAgICB0cnIgPSBfcmFkaXVzWzFdLFxuICAgICAgYnJyID0gX3JhZGl1c1syXSxcbiAgICAgIGJsciA9IF9yYWRpdXNbM107XG4gICAgdmFyIHNpZ25YID0gd2lkdGggPiAwID8gMSA6IC0xO1xuICAgIHZhciBzaWduWSA9IGhlaWdodCA+IDAgPyAxIDogLTE7XG4gICAgLy8gc3dlZXAtZmxhZyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL1NWRy9UdXRvcmlhbC9QYXRocyNhcmNzXG4gICAgdmFyIHN3ZWVwRmxhZyA9IHNpZ25YICsgc2lnblkgIT09IDAgPyAxIDogMDtcbiAgICByZXR1cm4gW1snTScsIHNpZ25YICogdGxyICsgeCwgeV0sIFsnTCcsIHdpZHRoIC0gc2lnblggKiB0cnIgKyB4LCB5XSwgdHJyID8gWydBJywgdHJyLCB0cnIsIDAsIDAsIHN3ZWVwRmxhZywgd2lkdGggKyB4LCBzaWduWSAqIHRyciArIHldIDogbnVsbCwgWydMJywgd2lkdGggKyB4LCBoZWlnaHQgLSBzaWduWSAqIGJyciArIHldLCBicnIgPyBbJ0EnLCBicnIsIGJyciwgMCwgMCwgc3dlZXBGbGFnLCB3aWR0aCArIHggLSBzaWduWCAqIGJyciwgaGVpZ2h0ICsgeV0gOiBudWxsLCBbJ0wnLCB4ICsgc2lnblggKiBibHIsIGhlaWdodCArIHldLCBibHIgPyBbJ0EnLCBibHIsIGJsciwgMCwgMCwgc3dlZXBGbGFnLCB4LCBoZWlnaHQgKyB5IC0gc2lnblkgKiBibHJdIDogbnVsbCwgWydMJywgeCwgc2lnblkgKiB0bHIgKyB5XSwgdGxyID8gWydBJywgdGxyLCB0bHIsIDAsIDAsIHN3ZWVwRmxhZywgc2lnblggKiB0bHIgKyB4LCB5XSA6IG51bGwsIFsnWiddXS5maWx0ZXIoZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiBjb21tYW5kO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbWydNJywgeCwgeV0sIFsnTCcsIHggKyB3aWR0aCwgeV0sIFsnTCcsIHggKyB3aWR0aCwgeSArIGhlaWdodF0sIFsnTCcsIHgsIHkgKyBoZWlnaHRdLCBbJ1onXV07XG59XG5cbi8qKlxuICogY29udmVydCBvYmplY3QgdG8gcGF0aCwgc2hvdWxkIGFjY291bnQgZm9yOlxuICogKiB0cmFuc2Zvcm0gJiBvcmlnaW5cbiAqICogbGluZVdpZHRoXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgob2JqZWN0KSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG9iamVjdC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICB2YXIgY29tbWFuZHMgPSBbXTtcbiAgc3dpdGNoIChvYmplY3Qubm9kZU5hbWUpIHtcbiAgICBjYXNlIFNoYXBlLkxJTkU6XG4gICAgICB2YXIgX3BhcnNlZFN0eWxlID0gb2JqZWN0LnBhcnNlZFN0eWxlLFxuICAgICAgICBfcGFyc2VkU3R5bGUkeCA9IF9wYXJzZWRTdHlsZS54MSxcbiAgICAgICAgeDEgPSBfcGFyc2VkU3R5bGUkeCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR4LFxuICAgICAgICBfcGFyc2VkU3R5bGUkeSA9IF9wYXJzZWRTdHlsZS55MSxcbiAgICAgICAgeTEgPSBfcGFyc2VkU3R5bGUkeSA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR5LFxuICAgICAgICBfcGFyc2VkU3R5bGUkeDIgPSBfcGFyc2VkU3R5bGUueDIsXG4gICAgICAgIHgyID0gX3BhcnNlZFN0eWxlJHgyID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJHgyLFxuICAgICAgICBfcGFyc2VkU3R5bGUkeTIgPSBfcGFyc2VkU3R5bGUueTIsXG4gICAgICAgIHkyID0gX3BhcnNlZFN0eWxlJHkyID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJHkyO1xuICAgICAgY29tbWFuZHMgPSBsaW5lVG9Db21tYW5kcyh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNoYXBlLkNJUkNMRTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXJzZWRTdHlsZTIgPSBvYmplY3QucGFyc2VkU3R5bGUsXG4gICAgICAgICAgX3BhcnNlZFN0eWxlMiRyID0gX3BhcnNlZFN0eWxlMi5yLFxuICAgICAgICAgIHIgPSBfcGFyc2VkU3R5bGUyJHIgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUyJHIsXG4gICAgICAgICAgX3BhcnNlZFN0eWxlMiRjeCA9IF9wYXJzZWRTdHlsZTIuY3gsXG4gICAgICAgICAgY3ggPSBfcGFyc2VkU3R5bGUyJGN4ID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlMiRjeCxcbiAgICAgICAgICBfcGFyc2VkU3R5bGUyJGN5ID0gX3BhcnNlZFN0eWxlMi5jeSxcbiAgICAgICAgICBjeSA9IF9wYXJzZWRTdHlsZTIkY3kgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUyJGN5O1xuICAgICAgICBjb21tYW5kcyA9IGVsbGlwc2VUb0NvbW1hbmRzKHIsIHIsIGN4LCBjeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgU2hhcGUuRUxMSVBTRTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXJzZWRTdHlsZTMgPSBvYmplY3QucGFyc2VkU3R5bGUsXG4gICAgICAgICAgX3BhcnNlZFN0eWxlMyRyeCA9IF9wYXJzZWRTdHlsZTMucngsXG4gICAgICAgICAgcnggPSBfcGFyc2VkU3R5bGUzJHJ4ID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlMyRyeCxcbiAgICAgICAgICBfcGFyc2VkU3R5bGUzJHJ5ID0gX3BhcnNlZFN0eWxlMy5yeSxcbiAgICAgICAgICByeSA9IF9wYXJzZWRTdHlsZTMkcnkgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUzJHJ5LFxuICAgICAgICAgIF9wYXJzZWRTdHlsZTMkY3ggPSBfcGFyc2VkU3R5bGUzLmN4LFxuICAgICAgICAgIF9jeCA9IF9wYXJzZWRTdHlsZTMkY3ggPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUzJGN4LFxuICAgICAgICAgIF9wYXJzZWRTdHlsZTMkY3kgPSBfcGFyc2VkU3R5bGUzLmN5LFxuICAgICAgICAgIF9jeSA9IF9wYXJzZWRTdHlsZTMkY3kgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUzJGN5O1xuICAgICAgICBjb21tYW5kcyA9IGVsbGlwc2VUb0NvbW1hbmRzKHJ4LCByeSwgX2N4LCBfY3kpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFNoYXBlLlBPTFlMSU5FOlxuICAgIGNhc2UgU2hhcGUuUE9MWUdPTjpcbiAgICAgIHZhciBwb2ludHMgPSBvYmplY3QucGFyc2VkU3R5bGUucG9pbnRzO1xuICAgICAgY29tbWFuZHMgPSBwb2x5Z29uVG9Db21tYW5kcyhwb2ludHMucG9pbnRzLCBvYmplY3Qubm9kZU5hbWUgPT09IFNoYXBlLlBPTFlHT04pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTaGFwZS5SRUNUOlxuICAgICAgdmFyIF9wYXJzZWRTdHlsZTQgPSBvYmplY3QucGFyc2VkU3R5bGUsXG4gICAgICAgIF9wYXJzZWRTdHlsZTQkd2lkdGggPSBfcGFyc2VkU3R5bGU0LndpZHRoLFxuICAgICAgICB3aWR0aCA9IF9wYXJzZWRTdHlsZTQkd2lkdGggPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGU0JHdpZHRoLFxuICAgICAgICBfcGFyc2VkU3R5bGU0JGhlaWdodCA9IF9wYXJzZWRTdHlsZTQuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQgPSBfcGFyc2VkU3R5bGU0JGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZTQkaGVpZ2h0LFxuICAgICAgICBfcGFyc2VkU3R5bGU0JHggPSBfcGFyc2VkU3R5bGU0LngsXG4gICAgICAgIHggPSBfcGFyc2VkU3R5bGU0JHggPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGU0JHgsXG4gICAgICAgIF9wYXJzZWRTdHlsZTQkeSA9IF9wYXJzZWRTdHlsZTQueSxcbiAgICAgICAgeSA9IF9wYXJzZWRTdHlsZTQkeSA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZTQkeSxcbiAgICAgICAgcmFkaXVzID0gX3BhcnNlZFN0eWxlNC5yYWRpdXM7XG4gICAgICB2YXIgaGFzUmFkaXVzID0gcmFkaXVzICYmIHJhZGl1cy5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByICE9PSAwO1xuICAgICAgfSk7XG4gICAgICBjb21tYW5kcyA9IHJlY3RUb0NvbW1hbmRzKHdpZHRoLCBoZWlnaHQsIHgsIHksIGhhc1JhZGl1cyAmJiByYWRpdXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChyLCAwLCBNYXRoLm1pbihNYXRoLmFicyh3aWR0aCkgLyAyLCBNYXRoLmFicyhoZWlnaHQpIC8gMikpO1xuICAgICAgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTaGFwZS5QQVRIOlxuICAgICAgdmFyIGFic29sdXRlUGF0aCA9IG9iamVjdC5wYXJzZWRTdHlsZS5kLmFic29sdXRlUGF0aDtcbiAgICAgIGNvbW1hbmRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGFic29sdXRlUGF0aCk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzVG9QYXRoU3RyaW5nKGNvbW1hbmRzLCBvYmplY3QsIHRyYW5zZm9ybSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZVBhdGhUb1N0cmluZyhhYnNvbHV0ZVBhdGgpIHtcbiAgdmFyIHN0YXJ0T2Zmc2V0WCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIHN0YXJ0T2Zmc2V0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIGVuZE9mZnNldFggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gIHZhciBlbmRPZmZzZXRZID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICB2YXIgbmV3VmFsdWUgPSBhYnNvbHV0ZVBhdGgubWFwKGZ1bmN0aW9uIChwYXJhbXMsIGkpIHtcbiAgICB2YXIgY29tbWFuZCA9IHBhcmFtc1swXTtcbiAgICB2YXIgbmV4dFNlZ21lbnQgPSBhYnNvbHV0ZVBhdGhbaSArIDFdO1xuICAgIHZhciB1c2VTdGFydE9mZnNldCA9IGkgPT09IDAgJiYgKHN0YXJ0T2Zmc2V0WCAhPT0gMCB8fCBzdGFydE9mZnNldFkgIT09IDApO1xuICAgIHZhciB1c2VFbmRPZmZzZXQgPSAoaSA9PT0gYWJzb2x1dGVQYXRoLmxlbmd0aCAtIDEgfHwgbmV4dFNlZ21lbnQgJiYgKG5leHRTZWdtZW50WzBdID09PSAnTScgfHwgbmV4dFNlZ21lbnRbMF0gPT09ICdaJykpICYmIGVuZE9mZnNldFggIT09IDAgJiYgZW5kT2Zmc2V0WSAhPT0gMDtcbiAgICB2YXIgX3JlZiA9IHVzZVN0YXJ0T2Zmc2V0ID8gW3N0YXJ0T2Zmc2V0WCwgc3RhcnRPZmZzZXRZXSA6IFswLCAwXSxcbiAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICBzdGFydE9mZnNldFhUZW1wID0gX3JlZjJbMF0sXG4gICAgICBzdGFydE9mZnNldFlUZW1wID0gX3JlZjJbMV07XG4gICAgdmFyIF9yZWYzID0gdXNlRW5kT2Zmc2V0ID8gW2VuZE9mZnNldFgsIGVuZE9mZnNldFldIDogWzAsIDBdLFxuICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICBlbmRPZmZzZXRYVGVtcCA9IF9yZWY0WzBdLFxuICAgICAgZW5kT2Zmc2V0WVRlbXAgPSBfcmVmNFsxXTtcbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICByZXR1cm4gXCJNIFwiLmNvbmNhdChwYXJhbXNbMV0gKyBzdGFydE9mZnNldFhUZW1wLCBcIixcIikuY29uY2F0KHBhcmFtc1syXSArIHN0YXJ0T2Zmc2V0WVRlbXApO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIHJldHVybiBcIkwgXCIuY29uY2F0KHBhcmFtc1sxXSArIGVuZE9mZnNldFhUZW1wLCBcIixcIikuY29uY2F0KHBhcmFtc1syXSArIGVuZE9mZnNldFlUZW1wKTtcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICByZXR1cm4gXCJRIFwiLmNvbmNhdChwYXJhbXNbMV0sIFwiIFwiKS5jb25jYXQocGFyYW1zWzJdLCBcIixcIikuY29uY2F0KHBhcmFtc1szXSArIGVuZE9mZnNldFhUZW1wLCBcIiBcIikuY29uY2F0KHBhcmFtc1s0XSArIGVuZE9mZnNldFlUZW1wKTtcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICByZXR1cm4gXCJDIFwiLmNvbmNhdChwYXJhbXNbMV0sIFwiIFwiKS5jb25jYXQocGFyYW1zWzJdLCBcIixcIikuY29uY2F0KHBhcmFtc1szXSwgXCIgXCIpLmNvbmNhdChwYXJhbXNbNF0sIFwiLFwiKS5jb25jYXQocGFyYW1zWzVdICsgZW5kT2Zmc2V0WFRlbXAsIFwiIFwiKS5jb25jYXQocGFyYW1zWzZdICsgZW5kT2Zmc2V0WVRlbXApO1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIHJldHVybiBcIkEgXCIuY29uY2F0KHBhcmFtc1sxXSwgXCIgXCIpLmNvbmNhdChwYXJhbXNbMl0sIFwiIFwiKS5jb25jYXQocGFyYW1zWzNdLCBcIiBcIikuY29uY2F0KHBhcmFtc1s0XSwgXCIgXCIpLmNvbmNhdChwYXJhbXNbNV0sIFwiIFwiKS5jb25jYXQocGFyYW1zWzZdLCBcIiBcIikuY29uY2F0KHBhcmFtc1s3XSkuY29uY2F0KHVzZUVuZE9mZnNldCA/IFwiIEwgXCIuY29uY2F0KHBhcmFtc1s2XSArIGVuZE9mZnNldFgsIFwiLFwiKS5jb25jYXQocGFyYW1zWzddICsgZW5kT2Zmc2V0WSkgOiAnJyk7XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgcmV0dXJuICdaJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gIT09IG51bGw7XG4gIH0pLmpvaW4oJyAnKTtcbiAgaWYgKH5uZXdWYWx1ZS5pbmRleE9mKCdOYU4nKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gbmV3VmFsdWU7XG59XG5cbnZhciBpbnRlcm5hbFBhcnNlUGF0aCA9IGZ1bmN0aW9uIGludGVybmFsUGFyc2VQYXRoKHBhdGgpIHtcbiAgLy8gZW1wdHkgcGF0aFxuICBpZiAocGF0aCA9PT0gJycgfHwgQXJyYXkuaXNBcnJheShwYXRoKSAmJiBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBhYnNvbHV0ZVBhdGg6IFtdLFxuICAgICAgaGFzQXJjOiBmYWxzZSxcbiAgICAgIHNlZ21lbnRzOiBbXSxcbiAgICAgIHBvbHlnb25zOiBbXSxcbiAgICAgIHBvbHlsaW5lczogW10sXG4gICAgICBjdXJ2ZTogbnVsbCxcbiAgICAgIHRvdGFsTGVuZ3RoOiAwLFxuICAgICAgcmVjdDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgYWJzb2x1dGVQYXRoO1xuICB0cnkge1xuICAgIGFic29sdXRlUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICBhYnNvbHV0ZVBhdGggPSBub3JtYWxpemVQYXRoKCcnKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2ddOiBJbnZhbGlkIFNWRyBQYXRoIGRlZmluaXRpb246IFwiLmNvbmNhdChwYXRoKSk7XG4gIH1cbiAgcmVtb3ZlUmVkdW5kYW50TUNvbW1hbmQoYWJzb2x1dGVQYXRoKTtcbiAgdmFyIGhhc0FyYyA9IGhhc0FyY09yQmV6aWVyKGFic29sdXRlUGF0aCk7XG4gIHZhciBfZXh0cmFjdFBvbHlnb25zID0gZXh0cmFjdFBvbHlnb25zKGFic29sdXRlUGF0aCksXG4gICAgcG9seWdvbnMgPSBfZXh0cmFjdFBvbHlnb25zLnBvbHlnb25zLFxuICAgIHBvbHlsaW5lcyA9IF9leHRyYWN0UG9seWdvbnMucG9seWxpbmVzO1xuXG4gIC8vIGZvciBsYXRlciB1c2VcbiAgdmFyIHNlZ21lbnRzID0gcGF0aDJTZWdtZW50cyhhYnNvbHV0ZVBhdGgpO1xuXG4gIC8vIE9ubHkgY2FsY3VsYXRlIGJib3ggaGVyZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGxlbmd0aCBub3cuXG4gIHZhciBfZ2V0UGF0aEJCb3ggPSBnZXRQYXRoQkJveChzZWdtZW50cywgMCksXG4gICAgeCA9IF9nZXRQYXRoQkJveC54LFxuICAgIHkgPSBfZ2V0UGF0aEJCb3gueSxcbiAgICB3aWR0aCA9IF9nZXRQYXRoQkJveC53aWR0aCxcbiAgICBoZWlnaHQgPSBfZ2V0UGF0aEJCb3guaGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIGFic29sdXRlUGF0aDogYWJzb2x1dGVQYXRoLFxuICAgIGhhc0FyYzogaGFzQXJjLFxuICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBwb2x5Z29uczogcG9seWdvbnMsXG4gICAgcG9seWxpbmVzOiBwb2x5bGluZXMsXG4gICAgLy8gY3VydmUsXG4gICAgLy8gRGVsYXkgdGhlIGNhbGN1bGF0aW9uIG9mIGxlbmd0aC5cbiAgICB0b3RhbExlbmd0aDogMCxcbiAgICByZWN0OiB7XG4gICAgICB4OiBOdW1iZXIuaXNGaW5pdGUoeCkgPyB4IDogMCxcbiAgICAgIHk6IE51bWJlci5pc0Zpbml0ZSh5KSA/IHkgOiAwLFxuICAgICAgd2lkdGg6IE51bWJlci5pc0Zpbml0ZSh3aWR0aCkgPyB3aWR0aCA6IDAsXG4gICAgICBoZWlnaHQ6IE51bWJlci5pc0Zpbml0ZShoZWlnaHQpID8gaGVpZ2h0IDogMFxuICAgIH1cbiAgfTtcbn07XG52YXIgbWVtb2l6ZWRQYXJzZVBhdGggPSBtZW1vaXplKGludGVybmFsUGFyc2VQYXRoKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHJldHVybiBpc1N0cmluZyhwYXRoKSA/IG1lbW9pemVkUGFyc2VQYXRoKHBhdGgpIDogaW50ZXJuYWxQYXJzZVBhdGgocGF0aCk7XG59XG5mdW5jdGlvbiBtZXJnZVBhdGhzKGxlZnQsIHJpZ2h0LCBvYmplY3QpIHtcbiAgdmFyIGN1cnZlMSA9IGxlZnQuY3VydmU7XG4gIHZhciBjdXJ2ZTIgPSByaWdodC5jdXJ2ZTtcbiAgaWYgKCFjdXJ2ZTEgfHwgY3VydmUxLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGNvbnZlcnQgdG8gY3VydmVzIHRvIGRvIG1vcnBoaW5nICYgcGlja2luZyBsYXRlclxuICAgIC8vIEBzZWUgaHR0cDovL3RoZWRucC5naXRodWIuaW8va3V0ZS5qcy9zdmdDdWJpY01vcnBoLmh0bWxcbiAgICBjdXJ2ZTEgPSBwYXRoMkN1cnZlKGxlZnQuYWJzb2x1dGVQYXRoLCBmYWxzZSk7XG4gICAgbGVmdC5jdXJ2ZSA9IGN1cnZlMTtcbiAgfVxuICBpZiAoIWN1cnZlMiB8fCBjdXJ2ZTIubGVuZ3RoID09PSAwKSB7XG4gICAgY3VydmUyID0gcGF0aDJDdXJ2ZShyaWdodC5hYnNvbHV0ZVBhdGgsIGZhbHNlKTtcbiAgICByaWdodC5jdXJ2ZSA9IGN1cnZlMjtcbiAgfVxuICB2YXIgY3VydmVzID0gW2N1cnZlMSwgY3VydmUyXTtcbiAgaWYgKGN1cnZlMS5sZW5ndGggIT09IGN1cnZlMi5sZW5ndGgpIHtcbiAgICBjdXJ2ZXMgPSBlcXVhbGl6ZVNlZ21lbnRzKGN1cnZlMSwgY3VydmUyKTtcbiAgfVxuICB2YXIgY3VydmUwID0gZ2V0RHJhd0RpcmVjdGlvbihjdXJ2ZXNbMF0pICE9PSBnZXREcmF3RGlyZWN0aW9uKGN1cnZlc1sxXSkgPyByZXZlcnNlQ3VydmUoY3VydmVzWzBdKSA6IGNsb25lUGF0aChjdXJ2ZXNbMF0pO1xuICByZXR1cm4gW2N1cnZlMCwgZ2V0Um90YXRlZEN1cnZlKGN1cnZlc1sxXSwgY3VydmUwKSwgZnVuY3Rpb24gKHBhdGhBcnJheSkge1xuICAgIC8vIG5lZWQgY29udmVydGluZyB0byBwYXRoIHN0cmluZz9cbiAgICByZXR1cm4gcGF0aEFycmF5O1xuICB9XTtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvcG9pbnRzXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvaW50cz1cIjEwMCwxMCAyNTAsMTUwIDIwMCwxMTBcIlxuICovXG5mdW5jdGlvbiBwYXJzZVBvaW50cyhwb2ludHNPclN0ciwgb2JqZWN0KSB7XG4gIHZhciBwb2ludHM7XG4gIGlmIChpc1N0cmluZyhwb2ludHNPclN0cikpIHtcbiAgICBwb2ludHMgPSBwb2ludHNPclN0ci5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAocG9pbnRTdHIpIHtcbiAgICAgIHZhciBfcG9pbnRTdHIkc3BsaXQgPSBwb2ludFN0ci5zcGxpdCgnLCcpLFxuICAgICAgICBfcG9pbnRTdHIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3BvaW50U3RyJHNwbGl0LCAyKSxcbiAgICAgICAgeCA9IF9wb2ludFN0ciRzcGxpdDJbMF0sXG4gICAgICAgIHkgPSBfcG9pbnRTdHIkc3BsaXQyWzFdO1xuICAgICAgcmV0dXJuIFtOdW1iZXIoeCksIE51bWJlcih5KV07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gcG9pbnRzT3JTdHI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICB0b3RhbExlbmd0aDogMCxcbiAgICBzZWdtZW50czogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlUG9pbnRzKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBbbGVmdC5wb2ludHMsIHJpZ2h0LnBvaW50cywgZnVuY3Rpb24gKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHM7XG4gIH1dO1xufVxuXG4vLyBlZy4geyB0OiAnc2NhbGUnLCBkOiBbQ1NTVW5pdFZhbHVlKDEpLCBDU1NVbml0VmFsdWUoMildIH1cblxudmFyIF8gPSBudWxsO1xudmFyIFRSQU5TRk9STV9SRUdFWFAgPSAvXFxzKihcXHcrKVxcKChbXildKilcXCkvZztcbmZ1bmN0aW9uIGNhc3QocGF0dGVybikge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHggPT09IF8gPyBjb250ZW50c1tpKytdIDogeDtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlkKHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbi8vIHR5cGU6IFthcmdUeXBlcywgY29udmVydFRvM0QsIGNvbnZlcnRUbzJEXVxuLy8gSW4gdGhlIGFyZ3VtZW50IHR5cGVzIHN0cmluZywgbG93ZXJjYXNlIGNoYXJhY3RlcnMgcmVwcmVzZW50IG9wdGlvbmFsIGFyZ3VtZW50c1xudmFyIHRyYW5zZm9ybUZ1bmN0aW9ucyA9IHtcbiAgLy8gQHRzLWlnbm9yZVxuICBtYXRyaXg6IFsnTk5OTk5OJywgW18sIF8sIDAsIDAsIF8sIF8sIDAsIDAsIDAsIDAsIDEsIDAsIF8sIF8sIDAsIDFdLCBpZF0sXG4gIG1hdHJpeDNkOiBbJ05OTk5OTk5OTk5OTk5OTk4nLCBpZF0sXG4gIHJvdGF0ZTogWydBJ10sXG4gIHJvdGF0ZVg6IFsnQSddLFxuICByb3RhdGVZOiBbJ0EnXSxcbiAgcm90YXRlWjogWydBJ10sXG4gIHJvdGF0ZTNkOiBbJ05OTkEnXSxcbiAgcGVyc3BlY3RpdmU6IFsnTCddLFxuICBzY2FsZTogWydObicsIGNhc3QoW18sIF8sIG5ldyBDU1NVbml0VmFsdWUoMSldKSwgaWRdLFxuICBzY2FsZVg6IFsnTicsIGNhc3QoW18sIG5ldyBDU1NVbml0VmFsdWUoMSksIG5ldyBDU1NVbml0VmFsdWUoMSldKSwgY2FzdChbXywgbmV3IENTU1VuaXRWYWx1ZSgxKV0pXSxcbiAgc2NhbGVZOiBbJ04nLCBjYXN0KFtuZXcgQ1NTVW5pdFZhbHVlKDEpLCBfLCBuZXcgQ1NTVW5pdFZhbHVlKDEpXSksIGNhc3QoW25ldyBDU1NVbml0VmFsdWUoMSksIF9dKV0sXG4gIHNjYWxlWjogWydOJywgY2FzdChbbmV3IENTU1VuaXRWYWx1ZSgxKSwgbmV3IENTU1VuaXRWYWx1ZSgxKSwgX10pXSxcbiAgc2NhbGUzZDogWydOTk4nLCBpZF0sXG4gIHNrZXc6IFsnQWEnLCBudWxsLCBpZF0sXG4gIHNrZXdYOiBbJ0EnLCBudWxsLCBjYXN0KFtfLCBPZGVnXSldLFxuICBza2V3WTogWydBJywgbnVsbCwgY2FzdChbT2RlZywgX10pXSxcbiAgdHJhbnNsYXRlOiBbJ1R0JywgY2FzdChbXywgXywgT3B4XSksIGlkXSxcbiAgdHJhbnNsYXRlWDogWydUJywgY2FzdChbXywgT3B4LCBPcHhdKSwgY2FzdChbXywgT3B4XSldLFxuICB0cmFuc2xhdGVZOiBbJ1QnLCBjYXN0KFtPcHgsIF8sIE9weF0pLCBjYXN0KFtPcHgsIF9dKV0sXG4gIHRyYW5zbGF0ZVo6IFsnTCcsIGNhc3QoW09weCwgT3B4LCBfXSldLFxuICB0cmFuc2xhdGUzZDogWydUVEwnLCBpZF1cbn07XG5mdW5jdGlvbiBwYXJzZUFycmF5VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBsZW5ndGggPSB0cmFuc2Zvcm0ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSB0cmFuc2Zvcm1baV07XG4gICAgdmFyIG5hbWUgPSBpdGVtWzBdO1xuICAgIHZhciBhcmdzID0gaXRlbS5zbGljZSgxKTtcbiAgICAvLyBpbmZlciBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKG5hbWUgPT09ICd0cmFuc2xhdGUnIHx8IG5hbWUgPT09ICdza2V3Jykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSBhcmdzLnB1c2goMCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnc2NhbGUnKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIGFyZ3MucHVzaChhcmdzWzBdKTtcbiAgICB9XG4gICAgdmFyIGZ1bmN0aW9uRGF0YSA9IHRyYW5zZm9ybUZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmN0aW9uRGF0YSkgcmV0dXJuIFtdO1xuICAgIHZhciBwYXJzZWRBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0T3JDcmVhdGVVbml0VmFsdWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHQ6IG5hbWUsXG4gICAgICBkOiBwYXJzZWRBcmdzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBub25lXG4gKiBzY2FsZSgxKSBzY2FsZSgxLCAyKVxuICogc2NhbGVYKDEpXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm0pKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuICB0cmFuc2Zvcm0gPSAodHJhbnNmb3JtIHx8ICdub25lJykudHJpbSgpO1xuICBpZiAodHJhbnNmb3JtID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHZhciBwcmV2TGFzdEluZGV4ID0gMDtcbiAgVFJBTlNGT1JNX1JFR0VYUC5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAobWF0Y2ggPSBUUkFOU0ZPUk1fUkVHRVhQLmV4ZWModHJhbnNmb3JtKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gcHJldkxhc3RJbmRleCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBwcmV2TGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG1hdGNoWzFdOyAvLyBzY2FsZVxuICAgIHZhciBmdW5jdGlvbkRhdGEgPSB0cmFuc2Zvcm1GdW5jdGlvbnNbZnVuY3Rpb25OYW1lXTsgLy8gc2NhbGUoMSwgMilcbiAgICBpZiAoIWZ1bmN0aW9uRGF0YSkge1xuICAgICAgLy8gaW52YWxpZCwgZWcuIHNjYWxlKClcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBtYXRjaFsyXS5zcGxpdCgnLCcpOyAvLyAxLDJcbiAgICB2YXIgYXJnVHlwZXMgPSBmdW5jdGlvbkRhdGFbMF07IC8vIE5uXG4gICAgaWYgKGFyZ1R5cGVzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAvLyBzY2FsZShOLCBuKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgdmFyIHR5cGUgPSBhcmdUeXBlc1tpXTtcbiAgICAgIHZhciBwYXJzZWRBcmcgPSB2b2lkIDA7XG4gICAgICBpZiAoIWFyZykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBhcnNlZEFyZyA9IHtcbiAgICAgICAgICBhOiBPZGVnLFxuICAgICAgICAgIG46IHBhcnNlZEFyZ3NbMF0sXG4gICAgICAgICAgdDogT3B4XG4gICAgICAgIH1bdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBhcnNlZEFyZyA9IHtcbiAgICAgICAgICBBOiBmdW5jdGlvbiBBKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKSA9PT0gJzAnID8gT2RlZyA6IHBhcnNlQW5nbGUocyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBOOiBwYXJzZU51bWJlcixcbiAgICAgICAgICBUOiBwYXJzZUxlbmd0aE9yUGVyY2VudGFnZSxcbiAgICAgICAgICBMOiBwYXJzZUxlbmd0aFxuICAgICAgICB9W3R5cGUudG9VcHBlckNhc2UoKV0oYXJnKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWRBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkQXJnKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgdDogZnVuY3Rpb25OYW1lLFxuICAgICAgZDogcGFyc2VkQXJnc1xuICAgIH0pOyAvLyB7IHQ6IHNjYWxlLCBkOiBbMSwgMl0gfVxuXG4gICAgaWYgKFRSQU5TRk9STV9SRUdFWFAubGFzdEluZGV4ID09PSB0cmFuc2Zvcm0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybVVubWVtb2l6ZSh0cmFuc2Zvcm0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cbiAgdHJhbnNmb3JtID0gKHRyYW5zZm9ybSB8fCAnbm9uZScpLnRyaW0oKTtcbiAgaWYgKHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgcHJldkxhc3RJbmRleCA9IDA7XG4gIFRSQU5TRk9STV9SRUdFWFAubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKG1hdGNoID0gVFJBTlNGT1JNX1JFR0VYUC5leGVjKHRyYW5zZm9ybSkpIHtcbiAgICBpZiAobWF0Y2guaW5kZXggIT09IHByZXZMYXN0SW5kZXgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcHJldkxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXTsgLy8gc2NhbGVcbiAgICB2YXIgZnVuY3Rpb25EYXRhID0gdHJhbnNmb3JtRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07IC8vIHNjYWxlKDEsIDIpXG4gICAgaWYgKCFmdW5jdGlvbkRhdGEpIHtcbiAgICAgIC8vIGludmFsaWQsIGVnLiBzY2FsZSgpXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBhcmdzID0gbWF0Y2hbMl0uc3BsaXQoJywnKTsgLy8gMSwyXG4gICAgdmFyIGFyZ1R5cGVzID0gZnVuY3Rpb25EYXRhWzBdOyAvLyBOblxuICAgIGlmIChhcmdUeXBlcy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgLy8gc2NhbGUoTiwgbilcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ1R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICAgIHZhciB0eXBlID0gYXJnVHlwZXNbaV07XG4gICAgICB2YXIgcGFyc2VkQXJnID0gdm9pZCAwO1xuICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwYXJzZWRBcmcgPSB7XG4gICAgICAgICAgYTogT2RlZyxcbiAgICAgICAgICBuOiBwYXJzZWRBcmdzWzBdLFxuICAgICAgICAgIHQ6IE9weFxuICAgICAgICB9W3R5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwYXJzZWRBcmcgPSB7XG4gICAgICAgICAgQTogZnVuY3Rpb24gQShzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy50cmltKCkgPT09ICcwJyA/IE9kZWcgOiBwYXJzZUFuZ2xlVW5tZW1vaXplKHMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgTjogcGFyc2VOdW1iZXJVbm1lbW9pemUsXG4gICAgICAgICAgVDogcGFyc2VMZW5ndGhPclBlcmNlbnRhZ2VVbm1lbW9pemUsXG4gICAgICAgICAgTDogcGFyc2VMZW5ndGhVbm1lbW9pemVcbiAgICAgICAgfVt0eXBlLnRvVXBwZXJDYXNlKCldKGFyZyk7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcGFyc2VkQXJncy5wdXNoKHBhcnNlZEFyZyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHQ6IGZ1bmN0aW9uTmFtZSxcbiAgICAgIGQ6IHBhcnNlZEFyZ3NcbiAgICB9KTsgLy8geyB0OiBzY2FsZSwgZDogWzEsIDJdIH1cblxuICAgIGlmIChUUkFOU0ZPUk1fUkVHRVhQLmxhc3RJbmRleCA9PT0gdHJhbnNmb3JtLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gY29udmVydEl0ZW1Ub01hdHJpeChpdGVtKSB7XG4gIHZhciB4O1xuICB2YXIgeTtcbiAgdmFyIHo7XG4gIHZhciBhbmdsZTtcbiAgc3dpdGNoIChpdGVtLnQpIHtcbiAgICBjYXNlICdyb3RhdGVYJzpcbiAgICAgIGFuZ2xlID0gZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGl0ZW0uZFswXSkpO1xuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCBNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSwgMCwgMCwgLU1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICdyb3RhdGVZJzpcbiAgICAgIGFuZ2xlID0gZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGl0ZW0uZFswXSkpO1xuICAgICAgcmV0dXJuIFtNYXRoLmNvcyhhbmdsZSksIDAsIC1NYXRoLnNpbihhbmdsZSksIDAsIDAsIDEsIDAsIDAsIE1hdGguc2luKGFuZ2xlKSwgMCwgTWF0aC5jb3MoYW5nbGUpLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICdyb3RhdGUnOlxuICAgIGNhc2UgJ3JvdGF0ZVonOlxuICAgICAgYW5nbGUgPSBkZWcycmFkKGNvbnZlcnRBbmdsZVVuaXQoaXRlbS5kWzBdKSk7XG4gICAgICByZXR1cm4gW01hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpLCAwLCAwLCAtTWF0aC5zaW4oYW5nbGUpLCBNYXRoLmNvcyhhbmdsZSksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuICAgIGNhc2UgJ3JvdGF0ZTNkJzpcbiAgICAgIHggPSBpdGVtLmRbMF0udmFsdWU7XG4gICAgICB5ID0gaXRlbS5kWzFdLnZhbHVlO1xuICAgICAgeiA9IGl0ZW0uZFsyXS52YWx1ZTtcbiAgICAgIGFuZ2xlID0gZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGl0ZW0uZFszXSkpO1xuICAgICAgdmFyIHNxckxlbmd0aCA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICAgIGlmIChzcXJMZW5ndGggPT09IDApIHtcbiAgICAgICAgeCA9IDE7XG4gICAgICAgIHkgPSAwO1xuICAgICAgICB6ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3FyTGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoc3FyTGVuZ3RoKTtcbiAgICAgICAgeCAvPSBsZW5ndGg7XG4gICAgICAgIHkgLz0gbGVuZ3RoO1xuICAgICAgICB6IC89IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUgLyAyKTtcbiAgICAgIHZhciBzYyA9IHMgKiBNYXRoLmNvcyhhbmdsZSAvIDIpO1xuICAgICAgdmFyIHNxID0gcyAqIHM7XG4gICAgICByZXR1cm4gWzEgLSAyICogKHkgKiB5ICsgeiAqIHopICogc3EsIDIgKiAoeCAqIHkgKiBzcSArIHogKiBzYyksIDIgKiAoeCAqIHogKiBzcSAtIHkgKiBzYyksIDAsIDIgKiAoeCAqIHkgKiBzcSAtIHogKiBzYyksIDEgLSAyICogKHggKiB4ICsgeiAqIHopICogc3EsIDIgKiAoeSAqIHogKiBzcSArIHggKiBzYyksIDAsIDIgKiAoeCAqIHogKiBzcSArIHkgKiBzYyksIDIgKiAoeSAqIHogKiBzcSAtIHggKiBzYyksIDEgLSAyICogKHggKiB4ICsgeSAqIHkpICogc3EsIDAsIDAsIDAsIDAsIDFdO1xuICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgIHJldHVybiBbaXRlbS5kWzBdLnZhbHVlLCAwLCAwLCAwLCAwLCBpdGVtLmRbMV0udmFsdWUsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuICAgIGNhc2UgJ3NjYWxlWCc6XG4gICAgICByZXR1cm4gW2l0ZW0uZFswXS52YWx1ZSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG4gICAgY2FzZSAnc2NhbGVZJzpcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgaXRlbS5kWzBdLnZhbHVlLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICdzY2FsZVonOlxuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCBpdGVtLmRbMF0udmFsdWUsIDAsIDAsIDAsIDAsIDFdO1xuICAgIGNhc2UgJ3NjYWxlM2QnOlxuICAgICAgcmV0dXJuIFtpdGVtLmRbMF0udmFsdWUsIDAsIDAsIDAsIDAsIGl0ZW0uZFsxXS52YWx1ZSwgMCwgMCwgMCwgMCwgaXRlbS5kWzJdLnZhbHVlLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICdza2V3JzpcbiAgICAgIHZhciB4QW5nbGUgPSBkZWcycmFkKGNvbnZlcnRBbmdsZVVuaXQoaXRlbS5kWzBdKSk7XG4gICAgICB2YXIgeUFuZ2xlID0gZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGl0ZW0uZFsxXSkpO1xuICAgICAgcmV0dXJuIFsxLCBNYXRoLnRhbih5QW5nbGUpLCAwLCAwLCBNYXRoLnRhbih4QW5nbGUpLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICdza2V3WCc6XG4gICAgICBhbmdsZSA9IGRlZzJyYWQoY29udmVydEFuZ2xlVW5pdChpdGVtLmRbMF0pKTtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgTWF0aC50YW4oYW5nbGUpLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICdza2V3WSc6XG4gICAgICBhbmdsZSA9IGRlZzJyYWQoY29udmVydEFuZ2xlVW5pdChpdGVtLmRbMF0pKTtcbiAgICAgIHJldHVybiBbMSwgTWF0aC50YW4oYW5nbGUpLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgLy8gVE9ETzogcGFzcyB0YXJnZXRcbiAgICAgIHggPSBjb252ZXJ0UGVyY2VudFVuaXQoaXRlbS5kWzBdLCAwLCBudWxsKSB8fCAwO1xuICAgICAgeSA9IGNvbnZlcnRQZXJjZW50VW5pdChpdGVtLmRbMV0sIDAsIG51bGwpIHx8IDA7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIHgsIHksIDAsIDFdO1xuICAgIGNhc2UgJ3RyYW5zbGF0ZVgnOlxuICAgICAgeCA9IGNvbnZlcnRQZXJjZW50VW5pdChpdGVtLmRbMF0sIDAsIG51bGwpIHx8IDA7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIHgsIDAsIDAsIDFdO1xuICAgIGNhc2UgJ3RyYW5zbGF0ZVknOlxuICAgICAgeSA9IGNvbnZlcnRQZXJjZW50VW5pdChpdGVtLmRbMF0sIDAsIG51bGwpIHx8IDA7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIHksIDAsIDFdO1xuICAgIGNhc2UgJ3RyYW5zbGF0ZVonOlxuICAgICAgeiA9IGNvbnZlcnRQZXJjZW50VW5pdChpdGVtLmRbMF0sIDAsIG51bGwpIHx8IDA7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIHosIDFdO1xuICAgIGNhc2UgJ3RyYW5zbGF0ZTNkJzpcbiAgICAgIHggPSBjb252ZXJ0UGVyY2VudFVuaXQoaXRlbS5kWzBdLCAwLCBudWxsKSB8fCAwO1xuICAgICAgeSA9IGNvbnZlcnRQZXJjZW50VW5pdChpdGVtLmRbMV0sIDAsIG51bGwpIHx8IDA7XG4gICAgICB6ID0gY29udmVydFBlcmNlbnRVbml0KGl0ZW0uZFsyXSwgMCwgbnVsbCkgfHwgMDtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgeCwgeSwgeiwgMV07XG4gICAgY2FzZSAncGVyc3BlY3RpdmUnOlxuICAgICAgdmFyIHQgPSBjb252ZXJ0UGVyY2VudFVuaXQoaXRlbS5kWzBdLCAwLCBudWxsKSB8fCAwO1xuICAgICAgdmFyIHAgPSB0ID8gLTEgLyB0IDogMDtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgcCwgMCwgMCwgMCwgMV07XG4gICAgY2FzZSAnbWF0cml4JzpcbiAgICAgIHJldHVybiBbaXRlbS5kWzBdLnZhbHVlLCBpdGVtLmRbMV0udmFsdWUsIDAsIDAsIGl0ZW0uZFsyXS52YWx1ZSwgaXRlbS5kWzNdLnZhbHVlLCAwLCAwLCAwLCAwLCAxLCAwLCBpdGVtLmRbNF0udmFsdWUsIGl0ZW0uZFs1XS52YWx1ZSwgMCwgMV07XG4gICAgY2FzZSAnbWF0cml4M2QnOlxuICAgICAgcmV0dXJuIGl0ZW0uZC5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbXVsdGlwbHlNYXRyaWNlcyhhLCBiKSB7XG4gIHJldHVybiBbYVswXSAqIGJbMF0gKyBhWzRdICogYlsxXSArIGFbOF0gKiBiWzJdICsgYVsxMl0gKiBiWzNdLCBhWzFdICogYlswXSArIGFbNV0gKiBiWzFdICsgYVs5XSAqIGJbMl0gKyBhWzEzXSAqIGJbM10sIGFbMl0gKiBiWzBdICsgYVs2XSAqIGJbMV0gKyBhWzEwXSAqIGJbMl0gKyBhWzE0XSAqIGJbM10sIGFbM10gKiBiWzBdICsgYVs3XSAqIGJbMV0gKyBhWzExXSAqIGJbMl0gKyBhWzE1XSAqIGJbM10sIGFbMF0gKiBiWzRdICsgYVs0XSAqIGJbNV0gKyBhWzhdICogYls2XSArIGFbMTJdICogYls3XSwgYVsxXSAqIGJbNF0gKyBhWzVdICogYls1XSArIGFbOV0gKiBiWzZdICsgYVsxM10gKiBiWzddLCBhWzJdICogYls0XSArIGFbNl0gKiBiWzVdICsgYVsxMF0gKiBiWzZdICsgYVsxNF0gKiBiWzddLCBhWzNdICogYls0XSArIGFbN10gKiBiWzVdICsgYVsxMV0gKiBiWzZdICsgYVsxNV0gKiBiWzddLCBhWzBdICogYls4XSArIGFbNF0gKiBiWzldICsgYVs4XSAqIGJbMTBdICsgYVsxMl0gKiBiWzExXSwgYVsxXSAqIGJbOF0gKyBhWzVdICogYls5XSArIGFbOV0gKiBiWzEwXSArIGFbMTNdICogYlsxMV0sIGFbMl0gKiBiWzhdICsgYVs2XSAqIGJbOV0gKyBhWzEwXSAqIGJbMTBdICsgYVsxNF0gKiBiWzExXSwgYVszXSAqIGJbOF0gKyBhWzddICogYls5XSArIGFbMTFdICogYlsxMF0gKyBhWzE1XSAqIGJbMTFdLCBhWzBdICogYlsxMl0gKyBhWzRdICogYlsxM10gKyBhWzhdICogYlsxNF0gKyBhWzEyXSAqIGJbMTVdLCBhWzFdICogYlsxMl0gKyBhWzVdICogYlsxM10gKyBhWzldICogYlsxNF0gKyBhWzEzXSAqIGJbMTVdLCBhWzJdICogYlsxMl0gKyBhWzZdICogYlsxM10gKyBhWzEwXSAqIGJbMTRdICsgYVsxNF0gKiBiWzE1XSwgYVszXSAqIGJbMTJdICsgYVs3XSAqIGJbMTNdICsgYVsxMV0gKiBiWzE0XSArIGFbMTVdICogYlsxNV1dO1xufVxuZnVuY3Rpb24gY29udmVydFRvTWF0cml4KHRyYW5zZm9ybUxpc3QpIHtcbiAgaWYgKHRyYW5zZm9ybUxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtTGlzdC5tYXAoY29udmVydEl0ZW1Ub01hdHJpeCkucmVkdWNlKG11bHRpcGx5TWF0cmljZXMpO1xufVxuZnVuY3Rpb24gbWFrZU1hdHJpeERlY29tcG9zaXRpb24odHJhbnNmb3JtTGlzdCkge1xuICB2YXIgdHJhbnNsYXRlID0gWzAsIDAsIDBdO1xuICB2YXIgc2NhbGUgPSBbMSwgMSwgMV07XG4gIHZhciBza2V3ID0gWzAsIDAsIDBdO1xuICB2YXIgcGVyc3BlY3RpdmUgPSBbMCwgMCwgMCwgMV07XG4gIHZhciBxdWF0ZXJuaW9uID0gWzAsIDAsIDAsIDFdO1xuICBkZWNvbXBvc2VNYXQ0KFxuICAvLyBAdHMtaWdub3JlXG4gIGNvbnZlcnRUb01hdHJpeCh0cmFuc2Zvcm1MaXN0KSwgdHJhbnNsYXRlLCBzY2FsZSwgc2tldywgcGVyc3BlY3RpdmUsIHF1YXRlcm5pb24pO1xuICByZXR1cm4gW1t0cmFuc2xhdGUsIHNjYWxlLCBza2V3LCBxdWF0ZXJuaW9uLCBwZXJzcGVjdGl2ZV1dO1xufVxudmFyIGNvbXBvc2VNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW1swLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgNDsgaysrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldW2pdICs9IGJbaV1ba10gKiBhW2tdW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gaXMyRChtKSB7XG4gICAgcmV0dXJuIG1bMF1bMl0gPT09IDAgJiYgbVswXVszXSA9PT0gMCAmJiBtWzFdWzJdID09PSAwICYmIG1bMV1bM10gPT09IDAgJiYgbVsyXVswXSA9PT0gMCAmJiBtWzJdWzFdID09PSAwICYmIG1bMl1bMl0gPT09IDEgJiYgbVsyXVszXSA9PT0gMCAmJiBtWzNdWzJdID09PSAwICYmIG1bM11bM10gPT09IDE7XG4gIH1cbiAgZnVuY3Rpb24gY29tcG9zZU1hdHJpeCh0cmFuc2xhdGUsIHNjYWxlLCBza2V3LCBxdWF0LCBwZXJzcGVjdGl2ZSkge1xuICAgIHZhciBtYXRyaXggPSBbWzEsIDAsIDAsIDBdLCBbMCwgMSwgMCwgMF0sIFswLCAwLCAxLCAwXSwgWzAsIDAsIDAsIDFdXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbWF0cml4W2ldWzNdID0gcGVyc3BlY3RpdmVbaV07XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAzOyBfaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICBtYXRyaXhbM11bX2ldICs9IHRyYW5zbGF0ZVtqXSAqIG1hdHJpeFtqXVtfaV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB4ID0gcXVhdFswXTtcbiAgICB2YXIgeSA9IHF1YXRbMV07XG4gICAgdmFyIHogPSBxdWF0WzJdO1xuICAgIHZhciB3ID0gcXVhdFszXTtcbiAgICB2YXIgcm90TWF0cml4ID0gW1sxLCAwLCAwLCAwXSwgWzAsIDEsIDAsIDBdLCBbMCwgMCwgMSwgMF0sIFswLCAwLCAwLCAxXV07XG4gICAgcm90TWF0cml4WzBdWzBdID0gMSAtIDIgKiAoeSAqIHkgKyB6ICogeik7XG4gICAgcm90TWF0cml4WzBdWzFdID0gMiAqICh4ICogeSAtIHogKiB3KTtcbiAgICByb3RNYXRyaXhbMF1bMl0gPSAyICogKHggKiB6ICsgeSAqIHcpO1xuICAgIHJvdE1hdHJpeFsxXVswXSA9IDIgKiAoeCAqIHkgKyB6ICogdyk7XG4gICAgcm90TWF0cml4WzFdWzFdID0gMSAtIDIgKiAoeCAqIHggKyB6ICogeik7XG4gICAgcm90TWF0cml4WzFdWzJdID0gMiAqICh5ICogeiAtIHggKiB3KTtcbiAgICByb3RNYXRyaXhbMl1bMF0gPSAyICogKHggKiB6IC0geSAqIHcpO1xuICAgIHJvdE1hdHJpeFsyXVsxXSA9IDIgKiAoeSAqIHogKyB4ICogdyk7XG4gICAgcm90TWF0cml4WzJdWzJdID0gMSAtIDIgKiAoeCAqIHggKyB5ICogeSk7XG4gICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCByb3RNYXRyaXgpO1xuICAgIHZhciB0ZW1wID0gW1sxLCAwLCAwLCAwXSwgWzAsIDEsIDAsIDBdLCBbMCwgMCwgMSwgMF0sIFswLCAwLCAwLCAxXV07XG4gICAgaWYgKHNrZXdbMl0pIHtcbiAgICAgIHRlbXBbMl1bMV0gPSBza2V3WzJdO1xuICAgICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCB0ZW1wKTtcbiAgICB9XG4gICAgaWYgKHNrZXdbMV0pIHtcbiAgICAgIHRlbXBbMl1bMV0gPSAwO1xuICAgICAgdGVtcFsyXVswXSA9IHNrZXdbMF07XG4gICAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIHRlbXApO1xuICAgIH1cbiAgICBpZiAoc2tld1swXSkge1xuICAgICAgdGVtcFsyXVswXSA9IDA7XG4gICAgICB0ZW1wWzFdWzBdID0gc2tld1swXTtcbiAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgdGVtcCk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IDM7IF9pMisrKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgMzsgX2orKykge1xuICAgICAgICBtYXRyaXhbX2kyXVtfal0gKj0gc2NhbGVbX2kyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzMkQobWF0cml4KSkge1xuICAgICAgcmV0dXJuIFttYXRyaXhbMF1bMF0sIG1hdHJpeFswXVsxXSwgbWF0cml4WzFdWzBdLCBtYXRyaXhbMV1bMV0sIG1hdHJpeFszXVswXSwgbWF0cml4WzNdWzFdXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeFswXS5jb25jYXQobWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2VNYXRyaXg7XG59KCk7XG5mdW5jdGlvbiBudW1iZXJUb0xvbmdTdHJpbmcoeCkge1xuICByZXR1cm4geC50b0ZpeGVkKDYpLnJlcGxhY2UoJy4wMDAwMDAnLCAnJyk7XG59XG5mdW5jdGlvbiBtZXJnZU1hdHJpY2VzKGxlZnQsIHJpZ2h0KSB7XG4gIHZhciBsZWZ0QXJncztcbiAgdmFyIHJpZ2h0QXJncztcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAobGVmdC5kZWNvbXBvc2l0aW9uUGFpciAhPT0gcmlnaHQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGVmdC5kZWNvbXBvc2l0aW9uUGFpciA9IHJpZ2h0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZWZ0QXJncyA9IG1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uKGxlZnQpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKHJpZ2h0LmRlY29tcG9zaXRpb25QYWlyICE9PSBsZWZ0KSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJpZ2h0LmRlY29tcG9zaXRpb25QYWlyID0gbGVmdDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmlnaHRBcmdzID0gbWFrZU1hdHJpeERlY29tcG9zaXRpb24ocmlnaHQpO1xuICB9XG4gIGlmIChsZWZ0QXJnc1swXSA9PT0gbnVsbCB8fCByaWdodEFyZ3NbMF0gPT09IG51bGwpIHJldHVybiBbXG4gIC8vIEB0cy1pZ25vcmVcbiAgW2ZhbHNlXSxcbiAgLy8gQHRzLWlnbm9yZVxuICBbdHJ1ZV0sXG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCA/IHJpZ2h0WzBdLmQgOiBsZWZ0WzBdLmQ7XG4gIH1dO1xuICBsZWZ0QXJnc1swXS5wdXNoKDApO1xuICByaWdodEFyZ3NbMF0ucHVzaCgxKTtcbiAgcmV0dXJuIFtsZWZ0QXJncywgcmlnaHRBcmdzLFxuICAvLyBAdHMtaWdub3JlXG4gIGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBxID0gcXVhdChsZWZ0QXJnc1swXVszXSwgcmlnaHRBcmdzWzBdWzNdLCBsaXN0WzVdKTtcbiAgICB2YXIgbWF0ID0gY29tcG9zZU1hdHJpeChsaXN0WzBdLCBsaXN0WzFdLCBsaXN0WzJdLCBxLCBsaXN0WzRdKTtcbiAgICB2YXIgc3RyaW5naWZpZWRBcmdzID0gbWF0Lm1hcChudW1iZXJUb0xvbmdTdHJpbmcpLmpvaW4oJywnKTtcbiAgICByZXR1cm4gc3RyaW5naWZpZWRBcmdzO1xuICB9XTtcbn1cbmZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gdjFbaV0gKiB2MltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcXVhdChmcm9tUSwgdG9RLCBmKSB7XG4gIHZhciBwcm9kdWN0ID0gZG90KGZyb21RLCB0b1EpO1xuICBwcm9kdWN0ID0gY2xhbXAocHJvZHVjdCwgLTEuMCwgMS4wKTtcbiAgdmFyIHF1YXQgPSBbXTtcbiAgaWYgKHByb2R1Y3QgPT09IDEuMCkge1xuICAgIHF1YXQgPSBmcm9tUTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MocHJvZHVjdCk7XG4gICAgdmFyIHcgPSBNYXRoLnNpbihmICogdGhldGEpICogMSAvIE1hdGguc3FydCgxIC0gcHJvZHVjdCAqIHByb2R1Y3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBxdWF0LnB1c2goZnJvbVFbaV0gKiAoTWF0aC5jb3MoZiAqIHRoZXRhKSAtIHByb2R1Y3QgKiB3KSArIHRvUVtpXSAqIHcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcXVhdDtcbn1cblxuLy8gc2NhbGVYL1kvWiAtPiBzY2FsZVxuZnVuY3Rpb24gdHlwZVRvMkQodHlwZSkge1xuICByZXR1cm4gdHlwZS5yZXBsYWNlKC9bWFldLywgJycpO1xufVxuXG4vLyBzY2FsZVgvWS9aIC0+IHNjYWxlM2RcbmZ1bmN0aW9uIHR5cGVUbzNEKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUucmVwbGFjZSgvKFh8WXxafDNkKT8kLywgJzNkJyk7XG59XG52YXIgaXNNYXRyaXhPclBlcnNwZWN0aXZlID0gZnVuY3Rpb24gaXNNYXRyaXhPclBlcnNwZWN0aXZlKGx0LCBydCkge1xuICByZXR1cm4gbHQgPT09ICdwZXJzcGVjdGl2ZScgJiYgcnQgPT09ICdwZXJzcGVjdGl2ZScgfHwgKGx0ID09PSAnbWF0cml4JyB8fCBsdCA9PT0gJ21hdHJpeDNkJykgJiYgKHJ0ID09PSAnbWF0cml4JyB8fCBydCA9PT0gJ21hdHJpeDNkJyk7XG59O1xuZnVuY3Rpb24gbWVyZ2VUcmFuc2Zvcm1zKGxlZnQsIHJpZ2h0LCB0YXJnZXQpIHtcbiAgdmFyIGZsaXBSZXN1bHRzID0gZmFsc2U7XG4gIC8vIHBhZGRpbmcgZW1wdHkgdHJhbnNmb3JtLCBlZy4gbWVyZ2UgJ3NjYWxlKDEwKScgd2l0aCAnbm9uZScgLT4gc2NhbGUoMSlcbiAgaWYgKCFsZWZ0Lmxlbmd0aCB8fCAhcmlnaHQubGVuZ3RoKSB7XG4gICAgaWYgKCFsZWZ0Lmxlbmd0aCkge1xuICAgICAgZmxpcFJlc3VsdHMgPSB0cnVlO1xuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgcmlnaHQgPSBbXTtcbiAgICB9XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgX2xlZnQkaSA9IGxlZnRbaV0sXG4gICAgICAgIHR5cGUgPSBfbGVmdCRpLnQsXG4gICAgICAgIGFyZ3MgPSBfbGVmdCRpLmQ7XG4gICAgICAvLyBub25lIC0+IHNjYWxlKDEpL3RyYW5zbGF0ZVgoMClcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSB0eXBlLnN1YnN0cmluZygwLCA1KSA9PT0gJ3NjYWxlJyA/IDEgOiAwO1xuICAgICAgcmlnaHQucHVzaCh7XG4gICAgICAgIHQ6IHR5cGUsXG4gICAgICAgIGQ6IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRPckNyZWF0ZVVuaXRWYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0T3JDcmVhdGVVbml0VmFsdWUoZGVmYXVsdFZhbHVlLCBhcmcudW5pdCk7XG4gICAgICAgICAgLy8gICB7XG4gICAgICAgICAgLy8gICAgIHVuaXQ6IGFyZy51bml0LFxuICAgICAgICAgIC8vICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIC8vICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgfVxuICB2YXIgbGVmdFJlc3VsdCA9IFtdO1xuICB2YXIgcmlnaHRSZXN1bHQgPSBbXTtcbiAgdmFyIHR5cGVzID0gW107XG5cbiAgLy8gbWVyZ2UgbWF0cml4KCkgd2l0aCBtYXRyaXgzZCgpXG4gIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlTWF0cmljZXMobGVmdCwgcmlnaHQpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZWZ0UmVzdWx0ID0gW21lcmdlZFswXV07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJpZ2h0UmVzdWx0ID0gW21lcmdlZFsxXV07XG4gICAgdHlwZXMgPSBbWydtYXRyaXgnLCBbbWVyZ2VkWzJdXV1dO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxlZnQubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIGxlZnRUeXBlID0gbGVmdFtfaTNdLnQ7XG4gICAgICB2YXIgcmlnaHRUeXBlID0gcmlnaHRbX2kzXS50O1xuICAgICAgdmFyIGxlZnRBcmdzID0gbGVmdFtfaTNdLmQ7XG4gICAgICB2YXIgcmlnaHRBcmdzID0gcmlnaHRbX2kzXS5kO1xuICAgICAgdmFyIGxlZnRGdW5jdGlvbkRhdGEgPSB0cmFuc2Zvcm1GdW5jdGlvbnNbbGVmdFR5cGVdO1xuICAgICAgdmFyIHJpZ2h0RnVuY3Rpb25EYXRhID0gdHJhbnNmb3JtRnVuY3Rpb25zW3JpZ2h0VHlwZV07XG4gICAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICAgIGlmIChpc01hdHJpeE9yUGVyc3BlY3RpdmUobGVmdFR5cGUsIHJpZ2h0VHlwZSkpIHtcbiAgICAgICAgdmFyIF9tZXJnZWQgPSBtZXJnZU1hdHJpY2VzKFtsZWZ0W19pM11dLCBbcmlnaHRbX2kzXV0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxlZnRSZXN1bHQucHVzaChfbWVyZ2VkWzBdKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByaWdodFJlc3VsdC5wdXNoKF9tZXJnZWRbMV0pO1xuICAgICAgICB0eXBlcy5wdXNoKFsnbWF0cml4JywgW19tZXJnZWRbMl1dXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChsZWZ0VHlwZSA9PT0gcmlnaHRUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBsZWZ0VHlwZTtcbiAgICAgIH0gZWxzZSBpZiAobGVmdEZ1bmN0aW9uRGF0YVsyXSAmJiByaWdodEZ1bmN0aW9uRGF0YVsyXSAmJiB0eXBlVG8yRChsZWZ0VHlwZSkgPT09IHR5cGVUbzJEKHJpZ2h0VHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IHR5cGVUbzJEKGxlZnRUeXBlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZWZ0QXJncyA9IGxlZnRGdW5jdGlvbkRhdGFbMl0obGVmdEFyZ3MpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJpZ2h0QXJncyA9IHJpZ2h0RnVuY3Rpb25EYXRhWzJdKHJpZ2h0QXJncyk7XG4gICAgICB9IGVsc2UgaWYgKGxlZnRGdW5jdGlvbkRhdGFbMV0gJiYgcmlnaHRGdW5jdGlvbkRhdGFbMV0gJiYgdHlwZVRvM0QobGVmdFR5cGUpID09PSB0eXBlVG8zRChyaWdodFR5cGUpKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlVG8zRChsZWZ0VHlwZSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGVmdEFyZ3MgPSBsZWZ0RnVuY3Rpb25EYXRhWzFdKGxlZnRBcmdzKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByaWdodEFyZ3MgPSByaWdodEZ1bmN0aW9uRGF0YVsxXShyaWdodEFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9tZXJnZWQyID0gbWVyZ2VNYXRyaWNlcyhsZWZ0LCByaWdodCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGVmdFJlc3VsdCA9IFtfbWVyZ2VkMlswXV07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmlnaHRSZXN1bHQgPSBbX21lcmdlZDJbMV1dO1xuICAgICAgICB0eXBlcyA9IFtbJ21hdHJpeCcsIFtfbWVyZ2VkMlsyXV1dXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgbGVmdEFyZ3NDb3B5ID0gW107XG4gICAgICB2YXIgcmlnaHRBcmdzQ29weSA9IFtdO1xuICAgICAgdmFyIHN0cmluZ0NvbnZlcnNpb25zID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlZnRBcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIGNvbnN0IG1lcmdlID0gbGVmdEFyZ3Nbal0udW5pdCA9PT0gVW5pdFR5cGUua051bWJlciA/IG1lcmdlRGltZW5zaW9ucyA6IG1lcmdlRGltZW5zaW9ucztcbiAgICAgICAgdmFyIF9tZXJnZWQzID0gbWVyZ2VEaW1lbnNpb25zKGxlZnRBcmdzW2pdLCByaWdodEFyZ3Nbal0sIHRhcmdldCwgZmFsc2UsIGopO1xuICAgICAgICBsZWZ0QXJnc0NvcHlbal0gPSBfbWVyZ2VkM1swXTtcbiAgICAgICAgcmlnaHRBcmdzQ29weVtqXSA9IF9tZXJnZWQzWzFdO1xuICAgICAgICBzdHJpbmdDb252ZXJzaW9ucy5wdXNoKF9tZXJnZWQzWzJdKTtcbiAgICAgIH1cbiAgICAgIGxlZnRSZXN1bHQucHVzaChsZWZ0QXJnc0NvcHkpO1xuICAgICAgcmlnaHRSZXN1bHQucHVzaChyaWdodEFyZ3NDb3B5KTtcbiAgICAgIHR5cGVzLnB1c2goW3R5cGUsIHN0cmluZ0NvbnZlcnNpb25zXSk7XG4gICAgfVxuICB9XG4gIGlmIChmbGlwUmVzdWx0cykge1xuICAgIHZhciB0bXAgPSBsZWZ0UmVzdWx0O1xuICAgIGxlZnRSZXN1bHQgPSByaWdodFJlc3VsdDtcbiAgICByaWdodFJlc3VsdCA9IHRtcDtcbiAgfVxuICByZXR1cm4gW2xlZnRSZXN1bHQsIHJpZ2h0UmVzdWx0LCBmdW5jdGlvbiAobGlzdCkge1xuICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbiAoYXJncywgaSkge1xuICAgICAgdmFyIHN0cmluZ2lmaWVkQXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcsIGopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzW2ldWzFdW2pdKGFyZyk7XG4gICAgICB9KS5qb2luKCcsJyk7XG4gICAgICBpZiAodHlwZXNbaV1bMF0gPT09ICdtYXRyaXgnICYmIHN0cmluZ2lmaWVkQXJncy5zcGxpdCgnLCcpLmxlbmd0aCA9PT0gMTYpIHtcbiAgICAgICAgdHlwZXNbaV1bMF0gPSAnbWF0cml4M2QnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVzW2ldWzBdID09PSAnbWF0cml4M2QnICYmIHN0cmluZ2lmaWVkQXJncy5zcGxpdCgnLCcpLmxlbmd0aCA9PT0gNikge1xuICAgICAgICB0eXBlc1tpXVswXSA9ICdtYXRyaXgnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHR5cGVzW2ldWzBdLCBcIihcIikuY29uY2F0KHN0cmluZ2lmaWVkQXJncywgXCIpXCIpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfV07XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtLW9yaWdpblxuICogZWcuICdjZW50ZXInICd0b3AgbGVmdCcgJzUwcHggNTBweCdcbiAqL1xudmFyIHBhcnNlVHJhbnNmb3JtT3JpZ2luID0gbWVtb2l6ZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ3RleHQtYW5jaG9yJykge1xuICAgICAgcmV0dXJuIFtnZXRPckNyZWF0ZVVuaXRWYWx1ZSgwLCAncHgnKSwgZ2V0T3JDcmVhdGVVbml0VmFsdWUoMCwgJ3B4JyldO1xuICAgIH1cbiAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHZhbHVlc1swXSA9PT0gJ3RvcCcgfHwgdmFsdWVzWzBdID09PSAnYm90dG9tJykge1xuICAgICAgICAvLyAndG9wJyAtPiAnY2VudGVyIHRvcCdcbiAgICAgICAgdmFsdWVzWzFdID0gdmFsdWVzWzBdO1xuICAgICAgICB2YWx1ZXNbMF0gPSAnY2VudGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICc1MHB4JyAtPiAnNTBweCBjZW50ZXInXG4gICAgICAgIHZhbHVlc1sxXSA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZWcuIGNlbnRlciBib3R0b21cbiAgICByZXR1cm4gW3BhcnNlTGVuZ3RoT3JQZXJjZW50YWdlKGNvbnZlcnRLZXl3b3JkMlBlcmNlbnQodmFsdWVzWzBdKSksIHBhcnNlTGVuZ3RoT3JQZXJjZW50YWdlKGNvbnZlcnRLZXl3b3JkMlBlcmNlbnQodmFsdWVzWzFdKSldO1xuICB9XG4gIHJldHVybiBbZ2V0T3JDcmVhdGVVbml0VmFsdWUodmFsdWVbMF0gfHwgMCwgJ3B4JyksIGdldE9yQ3JlYXRlVW5pdFZhbHVlKHZhbHVlWzFdIHx8IDAsICdweCcpXTtcbn0pO1xuZnVuY3Rpb24gY29udmVydEtleXdvcmQyUGVyY2VudChrZXl3b3JkKSB7XG4gIGlmIChrZXl3b3JkID09PSAnY2VudGVyJykge1xuICAgIHJldHVybiAnNTAlJztcbiAgfVxuICBpZiAoa2V5d29yZCA9PT0gJ2xlZnQnIHx8IGtleXdvcmQgPT09ICd0b3AnKSB7XG4gICAgcmV0dXJuICcwJSc7XG4gIH1cbiAgaWYgKGtleXdvcmQgPT09ICdyaWdodCcgfHwga2V5d29yZCA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJzEwMCUnO1xuICB9XG4gIHJldHVybiBrZXl3b3JkO1xufVxuXG4vKipcbiAqIEJsaW5rIHVzZWQgdGhlbSBpbiBjb2RlIGdlbmVyYXRpb24oY3NzX3Byb3BlcnRpZXMuanNvbjUpXG4gKi9cbnZhciBCVUlMVF9JTl9QUk9QRVJUSUVTID0gW3tcbiAgLyoqXG4gICAqIHVzZWQgaW4gQ1NTIExheW91dCBBUElcbiAgICogZWcuIGBkaXNwbGF5OiAnZmxleCdgXG4gICAqL1xuICBuOiAnZGlzcGxheScsXG4gIGs6IFsnbm9uZSddXG59LCB7XG4gIC8qKlxuICAgKiByYW5nZSBbMC4wLCAxLjBdXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29wYWNpdHlcbiAgICovXG4gIG46ICdvcGFjaXR5JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICBkOiAnMScsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguT1BBQ0lUWV9WQUxVRVxufSwge1xuICAvKipcbiAgICogaW5oZXJpdGFibGUsIHJhbmdlIFswLjAsIDEuMF1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtb3BhY2l0eVxuICAgKiBAc2VlIGh0dHBzOi8vc3Znd2cub3JnL3N2ZzItZHJhZnQvcGFpbnRpbmcuaHRtbCNGaWxsT3BhY2l0eVxuICAgKi9cbiAgbjogJ2ZpbGxPcGFjaXR5JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICBkOiAnMScsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguT1BBQ0lUWV9WQUxVRVxufSwge1xuICAvKipcbiAgICogaW5oZXJpdGFibGUsIHJhbmdlIFswLjAsIDEuMF1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1vcGFjaXR5XG4gICAqIEBzZWUgaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9wYWludGluZy5odG1sI1N0cm9rZU9wYWNpdHlcbiAgICovXG4gIG46ICdzdHJva2VPcGFjaXR5JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICBkOiAnMScsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguT1BBQ0lUWV9WQUxVRVxufSwge1xuICAvKipcbiAgICogYmFja2dyb3VuZC1jb2xvciBpcyBub3QgaW5oZXJpdGFibGVcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvVHV0b3JpYWwvRmlsbHNfYW5kX1N0cm9rZXNcbiAgICovXG4gIG46ICdmaWxsJyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgazogWydub25lJ10sXG4gIGQ6ICdub25lJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5QQUlOVFxufSwge1xuICBuOiAnZmlsbFJ1bGUnLFxuICBrOiBbJ25vbnplcm8nLCAnZXZlbm9kZCddLFxuICBkOiAnbm9uemVybydcbn0sXG4vKipcbiAqIGRlZmF1bHQgdG8gbm9uZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZSN1c2FnZV9ub3Rlc1xuICovXG57XG4gIG46ICdzdHJva2UnLFxuICBcImludFwiOiB0cnVlLFxuICBrOiBbJ25vbmUnXSxcbiAgZDogJ25vbmUnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LlBBSU5ULFxuICAvKipcbiAgICogU3Ryb2tlICdub25lJyB3b24ndCBhZmZlY3QgZ2VvbWV0cnkgYnV0IG90aGVycyB3aWxsLlxuICAgKi9cbiAgbDogdHJ1ZVxufSwge1xuICBuOiAnc2hhZG93VHlwZScsXG4gIGs6IFsnaW5uZXInLCAnb3V0ZXInLCAnYm90aCddLFxuICBkOiAnb3V0ZXInLFxuICBsOiB0cnVlXG59LCB7XG4gIG46ICdzaGFkb3dDb2xvcicsXG4gIFwiaW50XCI6IHRydWUsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguQ09MT1Jcbn0sIHtcbiAgbjogJ3NoYWRvd09mZnNldFgnLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBkOiAnMCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0Vcbn0sIHtcbiAgbjogJ3NoYWRvd09mZnNldFknLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBkOiAnMCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0Vcbn0sIHtcbiAgbjogJ3NoYWRvd0JsdXInLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBkOiAnMCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguU0hBRE9XX0JMVVJcbn0sIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2Utd2lkdGhcbiAgICovXG4gIG46ICdsaW5lV2lkdGgnLFxuICBcImludFwiOiB0cnVlLFxuICBpbmg6IHRydWUsXG4gIGQ6ICcxJyxcbiAgbDogdHJ1ZSxcbiAgYTogWydzdHJva2VXaWR0aCddLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFXG59LCB7XG4gIG46ICdpbmNyZWFzZWRMaW5lV2lkdGhGb3JIaXRUZXN0aW5nJyxcbiAgaW5oOiB0cnVlLFxuICBkOiAnMCcsXG4gIGw6IHRydWUsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0Vcbn0sIHtcbiAgbjogJ2xpbmVKb2luJyxcbiAgaW5oOiB0cnVlLFxuICBsOiB0cnVlLFxuICBhOiBbJ3N0cm9rZUxpbmVqb2luJ10sXG4gIGs6IFsnbWl0ZXInLCAnYmV2ZWwnLCAncm91bmQnXSxcbiAgZDogJ21pdGVyJ1xufSwge1xuICBuOiAnbGluZUNhcCcsXG4gIGluaDogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgYTogWydzdHJva2VMaW5lY2FwJ10sXG4gIGs6IFsnYnV0dCcsICdyb3VuZCcsICdzcXVhcmUnXSxcbiAgZDogJ2J1dHQnXG59LCB7XG4gIG46ICdsaW5lRGFzaCcsXG4gIFwiaW50XCI6IHRydWUsXG4gIGluaDogdHJ1ZSxcbiAgazogWydub25lJ10sXG4gIGE6IFsnc3Ryb2tlRGFzaGFycmF5J10sXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0VfMTJcbn0sIHtcbiAgbjogJ2xpbmVEYXNoT2Zmc2V0JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICBkOiAnMCcsXG4gIGE6IFsnc3Ryb2tlRGFzaG9mZnNldCddLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFXG59LCB7XG4gIG46ICdvZmZzZXRQYXRoJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5ERUZJTkVEX1BBVEhcbn0sIHtcbiAgbjogJ29mZnNldERpc3RhbmNlJyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5PRkZTRVRfRElTVEFOQ0Vcbn0sIHtcbiAgbjogJ2R4JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFXG59LCB7XG4gIG46ICdkeScsXG4gIFwiaW50XCI6IHRydWUsXG4gIGw6IHRydWUsXG4gIGQ6ICcwJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5MRU5HVEhfUEVSQ0VOVEFHRVxufSwge1xuICBuOiAnekluZGV4JyxcbiAgaW5kOiB0cnVlLFxuICBcImludFwiOiB0cnVlLFxuICBkOiAnMCcsXG4gIGs6IFsnYXV0byddLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LlpfSU5ERVhcbn0sIHtcbiAgbjogJ3Zpc2liaWxpdHknLFxuICBrOiBbJ3Zpc2libGUnLCAnaGlkZGVuJ10sXG4gIGluZDogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICAvKipcbiAgICogc3VwcG9ydCBpbnRlcnBvbGF0aW9uXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Zpc2liaWxpdHkjaW50ZXJwb2xhdGlvblxuICAgKi9cbiAgXCJpbnRcIjogdHJ1ZSxcbiAgZDogJ3Zpc2libGUnXG59LCB7XG4gIG46ICdwb2ludGVyRXZlbnRzJyxcbiAgaW5oOiB0cnVlLFxuICBrOiBbJ25vbmUnLCAnYXV0bycsICdzdHJva2UnLCAnZmlsbCcsICdwYWludGVkJywgJ3Zpc2libGUnLCAndmlzaWJsZXN0cm9rZScsICd2aXNpYmxlZmlsbCcsICd2aXNpYmxlcGFpbnRlZCcsXG4gIC8vICdib3VuZGluZy1ib3gnLFxuICAnYWxsJ10sXG4gIGQ6ICdhdXRvJ1xufSwge1xuICBuOiAnZmlsdGVyJyxcbiAgaW5kOiB0cnVlLFxuICBsOiB0cnVlLFxuICBrOiBbJ25vbmUnXSxcbiAgZDogJ25vbmUnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkZJTFRFUlxufSwge1xuICBuOiAnY2xpcFBhdGgnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkRFRklORURfUEFUSFxufSwge1xuICBuOiAndGV4dFBhdGgnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkRFRklORURfUEFUSFxufSwge1xuICBuOiAndGV4dFBhdGhTaWRlJyxcbiAgazogWydsZWZ0JywgJ3JpZ2h0J10sXG4gIGQ6ICdsZWZ0J1xufSwge1xuICBuOiAndGV4dFBhdGhTdGFydE9mZnNldCcsXG4gIGw6IHRydWUsXG4gIGQ6ICcwJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5MRU5HVEhfUEVSQ0VOVEFHRVxufSwge1xuICBuOiAndHJhbnNmb3JtJyxcbiAgcDogMTAwLFxuICBcImludFwiOiB0cnVlLFxuICBrOiBbJ25vbmUnXSxcbiAgZDogJ25vbmUnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LlRSQU5TRk9STVxufSwge1xuICBuOiAndHJhbnNmb3JtT3JpZ2luJyxcbiAgcDogMTAwLFxuICBkOiAnMCAwJyxcbiAgLy8gLy8gaW50OiB0cnVlLFxuICAvLyBkOiAobm9kZU5hbWU6IHN0cmluZykgPT4ge1xuICAvLyAgIGlmIChub2RlTmFtZSA9PT0gU2hhcGUuQ0lSQ0xFIHx8IG5vZGVOYW1lID09PSBTaGFwZS5FTExJUFNFKSB7XG4gIC8vICAgICByZXR1cm4gJ2NlbnRlcic7XG4gIC8vICAgfVxuICAvLyAgIGlmIChub2RlTmFtZSA9PT0gU2hhcGUuVEVYVCkge1xuICAvLyAgICAgcmV0dXJuICd0ZXh0LWFuY2hvcic7XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiAnbGVmdCB0b3AnO1xuICAvLyB9LFxuICBsOiB0cnVlLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LlRSQU5TRk9STV9PUklHSU5cbn0sIHtcbiAgbjogJ2N4JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkNPT1JESU5BVEVcbn0sIHtcbiAgbjogJ2N5JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkNPT1JESU5BVEVcbn0sIHtcbiAgbjogJ2N6JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkNPT1JESU5BVEVcbn0sIHtcbiAgbjogJ3InLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBkOiAnMCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0Vcbn0sIHtcbiAgbjogJ3J4JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFXG59LCB7XG4gIG46ICdyeScsXG4gIFwiaW50XCI6IHRydWUsXG4gIGw6IHRydWUsXG4gIGQ6ICcwJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5MRU5HVEhfUEVSQ0VOVEFHRVxufSxcbi8vIFJlY3QgSW1hZ2UgR3JvdXBcbntcbiAgLy8geCBpbiBsb2NhbCBzcGFjZVxuICBuOiAneCcsXG4gIFwiaW50XCI6IHRydWUsXG4gIGw6IHRydWUsXG4gIGQ6ICcwJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5DT09SRElOQVRFXG59LCB7XG4gIC8vIHkgaW4gbG9jYWwgc3BhY2VcbiAgbjogJ3knLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBkOiAnMCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguQ09PUkRJTkFURVxufSwge1xuICAvLyB6IGluIGxvY2FsIHNwYWNlXG4gIG46ICd6JyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkNPT1JESU5BVEVcbn0sIHtcbiAgbjogJ3dpZHRoJyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL3dpZHRoXG4gICAqL1xuICBrOiBbJ2F1dG8nLCAnZml0LWNvbnRlbnQnLCAnbWluLWNvbnRlbnQnLCAnbWF4LWNvbnRlbnQnXSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFXG59LCB7XG4gIG46ICdoZWlnaHQnLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9DU1MvaGVpZ2h0XG4gICAqL1xuICBrOiBbJ2F1dG8nLCAnZml0LWNvbnRlbnQnLCAnbWluLWNvbnRlbnQnLCAnbWF4LWNvbnRlbnQnXSxcbiAgZDogJzAnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFXG59LCB7XG4gIG46ICdyYWRpdXMnLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBkOiAnMCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0VfMTRcbn0sXG4vLyBMaW5lXG57XG4gIG46ICd4MScsXG4gIFwiaW50XCI6IHRydWUsXG4gIGw6IHRydWUsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguQ09PUkRJTkFURVxufSwge1xuICBuOiAneTEnLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkNPT1JESU5BVEVcbn0sIHtcbiAgbjogJ3oxJyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5DT09SRElOQVRFXG59LCB7XG4gIG46ICd4MicsXG4gIFwiaW50XCI6IHRydWUsXG4gIGw6IHRydWUsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguQ09PUkRJTkFURVxufSwge1xuICBuOiAneTInLFxuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkNPT1JESU5BVEVcbn0sIHtcbiAgbjogJ3oyJyxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgbDogdHJ1ZSxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5DT09SRElOQVRFXG59LFxuLy8gUGF0aFxue1xuICBuOiAnZCcsXG4gIFwiaW50XCI6IHRydWUsXG4gIGw6IHRydWUsXG4gIGQ6ICcnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LlBBVEgsXG4gIHA6IDUwXG59LFxuLy8gUG9seWxpbmUgJiBQb2x5Z29uXG57XG4gIG46ICdwb2ludHMnLFxuICAvKipcbiAgICogc3VwcG9ydCBpbnRlcnBvbGF0aW9uXG4gICAqL1xuICBcImludFwiOiB0cnVlLFxuICBsOiB0cnVlLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxJU1RfT0ZfUE9JTlRTLFxuICBwOiA1MFxufSxcbi8vIFRleHRcbntcbiAgbjogJ3RleHQnLFxuICBsOiB0cnVlLFxuICBkOiAnJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5URVhULFxuICBwOiA1MFxufSwge1xuICBuOiAndGV4dFRyYW5zZm9ybScsXG4gIGw6IHRydWUsXG4gIGluaDogdHJ1ZSxcbiAgazogWydjYXBpdGFsaXplJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnLCAnbm9uZSddLFxuICBkOiAnbm9uZScsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguVEVYVF9UUkFOU0ZPUk0sXG4gIHA6IDUxIC8vIGl0IG11c3QgZ2V0IHBhcnNlZCBhZnRlciB0ZXh0XG59LCB7XG4gIG46ICdmb250JyxcbiAgbDogdHJ1ZVxufSwge1xuICBuOiAnZm9udFNpemUnLFxuICBcImludFwiOiB0cnVlLFxuICBpbmg6IHRydWUsXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vY3NzL2Nzc19mb250X3NpemUuYXNwXG4gICAqL1xuICBkOiAnMTZweCcsXG4gIGw6IHRydWUsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0Vcbn0sIHtcbiAgbjogJ2ZvbnRGYW1pbHknLFxuICBsOiB0cnVlLFxuICBpbmg6IHRydWUsXG4gIGQ6ICdzYW5zLXNlcmlmJ1xufSwge1xuICBuOiAnZm9udFN0eWxlJyxcbiAgbDogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICBrOiBbJ25vcm1hbCcsICdpdGFsaWMnLCAnb2JsaXF1ZSddLFxuICBkOiAnbm9ybWFsJ1xufSwge1xuICBuOiAnZm9udFdlaWdodCcsXG4gIGw6IHRydWUsXG4gIGluaDogdHJ1ZSxcbiAgazogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlciddLFxuICBkOiAnbm9ybWFsJ1xufSwge1xuICBuOiAnZm9udFZhcmlhbnQnLFxuICBsOiB0cnVlLFxuICBpbmg6IHRydWUsXG4gIGs6IFsnbm9ybWFsJywgJ3NtYWxsLWNhcHMnXSxcbiAgZDogJ25vcm1hbCdcbn0sIHtcbiAgbjogJ2xpbmVIZWlnaHQnLFxuICBsOiB0cnVlLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4LkxFTkdUSCxcbiAgXCJpbnRcIjogdHJ1ZSxcbiAgZDogJzAnXG59LCB7XG4gIG46ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbDogdHJ1ZSxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5MRU5HVEgsXG4gIFwiaW50XCI6IHRydWUsXG4gIGQ6ICcwJ1xufSwge1xuICBuOiAnbWl0ZXJMaW1pdCcsXG4gIGw6IHRydWUsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTlVNQkVSLFxuICBkOiBmdW5jdGlvbiBkKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSBTaGFwZS5QQVRIIHx8IG5vZGVOYW1lID09PSBTaGFwZS5QT0xZR09OIHx8IG5vZGVOYW1lID09PSBTaGFwZS5QT0xZTElORSkge1xuICAgICAgcmV0dXJuICc0JztcbiAgICB9XG4gICAgcmV0dXJuICcxMCc7XG4gIH1cbn0sIHtcbiAgbjogJ3dvcmRXcmFwJyxcbiAgbDogdHJ1ZVxufSwge1xuICBuOiAnd29yZFdyYXBXaWR0aCcsXG4gIGw6IHRydWVcbn0sIHtcbiAgbjogJ21heExpbmVzJyxcbiAgbDogdHJ1ZVxufSwge1xuICBuOiAndGV4dE92ZXJmbG93JyxcbiAgbDogdHJ1ZSxcbiAgZDogJ2NsaXAnXG59LCB7XG4gIG46ICdsZWFkaW5nJyxcbiAgbDogdHJ1ZVxufSwge1xuICBuOiAndGV4dEJhc2VsaW5lJyxcbiAgbDogdHJ1ZSxcbiAgaW5oOiB0cnVlLFxuICBrOiBbJ3RvcCcsICdoYW5naW5nJywgJ21pZGRsZScsICdhbHBoYWJldGljJywgJ2lkZW9ncmFwaGljJywgJ2JvdHRvbSddLFxuICBkOiAnYWxwaGFiZXRpYydcbn0sIHtcbiAgbjogJ3RleHRBbGlnbicsXG4gIGw6IHRydWUsXG4gIGluaDogdHJ1ZSxcbiAgazogWydzdGFydCcsICdjZW50ZXInLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10sXG4gIGQ6ICdzdGFydCdcbn0sXG4vLyB7XG4vLyAgIG46ICd3aGl0ZVNwYWNlJyxcbi8vICAgbDogdHJ1ZSxcbi8vIH0sXG57XG4gIG46ICdtYXJrZXJTdGFydCcsXG4gIHN5bnRheDogUHJvcGVydHlTeW50YXguTUFSS0VSXG59LCB7XG4gIG46ICdtYXJrZXJFbmQnLFxuICBzeW50YXg6IFByb3BlcnR5U3ludGF4Lk1BUktFUlxufSwge1xuICBuOiAnbWFya2VyTWlkJyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5NQVJLRVJcbn0sIHtcbiAgbjogJ21hcmtlclN0YXJ0T2Zmc2V0JyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5MRU5HVEgsXG4gIGw6IHRydWUsXG4gIFwiaW50XCI6IHRydWUsXG4gIGQ6ICcwJ1xufSwge1xuICBuOiAnbWFya2VyRW5kT2Zmc2V0JyxcbiAgc3ludGF4OiBQcm9wZXJ0eVN5bnRheC5MRU5HVEgsXG4gIGw6IHRydWUsXG4gIFwiaW50XCI6IHRydWUsXG4gIGQ6ICcwJ1xufV07XG52YXIgR0VPTUVUUllfQVRUUklCVVRFX05BTUVTID0gbmV3IFNldChCVUlMVF9JTl9QUk9QRVJUSUVTLmZpbHRlcihmdW5jdGlvbiAobikge1xuICByZXR1cm4gISFuLmw7XG59KS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4ubjtcbn0pKTtcbnZhciBwcm9wZXJ0eU1ldGFkYXRhQ2FjaGUgPSB7fTtcbnZhciBEZWZhdWx0U3R5bGVWYWx1ZVJlZ2lzdHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVmYXVsdFN0eWxlVmFsdWVSZWdpc3RyeShydW50aW1lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdFN0eWxlVmFsdWVSZWdpc3RyeSk7XG4gICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgICBCVUlMVF9JTl9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBfdGhpcy5yZWdpc3Rlck1ldGFkYXRhKHByb3BlcnR5KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERlZmF1bHRTdHlsZVZhbHVlUmVnaXN0cnksIFt7XG4gICAga2V5OiBcInJlZ2lzdGVyTWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgW21ldGFkYXRhLm5dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobWV0YWRhdGEuYSB8fCBbXSkpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcHJvcGVydHlNZXRhZGF0YUNhY2hlW25hbWVdID0gbWV0YWRhdGE7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvcGVydHlTeW50YXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHlTeW50YXgoc3ludGF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ydW50aW1lLkNTU1Byb3BlcnR5U3ludGF4RmFjdG9yeVtzeW50YXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICogcGFyc2UgdmFsdWUsIGVnLlxuICAgICAqIGZpbGw6ICdyZWQnID0+IENTU1JHQlxuICAgICAqIHRyYW5zbGF0ZVg6ICcxMHB4JyA9PiBDU1NVbml0VmFsdWUgeyB1bml0OiAncHgnLCB2YWx1ZTogMTAgfVxuICAgICAqIGZvbnRTaXplOiAnMmVtJyA9PiB7IHVuaXQ6ICdweCcsIHZhbHVlOiAzMiB9XG4gICAgICpcbiAgICAgKiAqIGNhbGN1bGF0ZSB1c2VkIHZhbHVlXG4gICAgICogKiBwb3N0IHByb2Nlc3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzUHJvcGVydGllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzUHJvcGVydGllcyhvYmplY3QsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7XG4gICAgICAgIHNraXBVcGRhdGVBdHRyaWJ1dGU6IGZhbHNlLFxuICAgICAgICBza2lwUGFyc2U6IGZhbHNlLFxuICAgICAgICBmb3JjZVVwZGF0ZUdlb21ldHJ5OiBmYWxzZSxcbiAgICAgICAgdXNlZEF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICBtZW1vaXplOiB0cnVlXG4gICAgICB9O1xuICAgICAgT2JqZWN0LmFzc2lnbihvYmplY3QuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAgIC8vIGNsaXBQYXRoXG4gICAgICB2YXIgb2xkQ2xpcFBhdGggPSBvYmplY3QucGFyc2VkU3R5bGUuY2xpcFBhdGg7XG4gICAgICB2YXIgb2xkT2Zmc2V0UGF0aCA9IG9iamVjdC5wYXJzZWRTdHlsZS5vZmZzZXRQYXRoO1xuICAgICAgYXNzaWduUGFyc2VkU3R5bGUob2JqZWN0LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHZhciBuZWVkVXBkYXRlR2VvbWV0cnkgPSAhIW9wdGlvbnMuZm9yY2VVcGRhdGVHZW9tZXRyeTtcbiAgICAgIGlmICghbmVlZFVwZGF0ZUdlb21ldHJ5KSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChHRU9NRVRSWV9BVFRSSUJVVEVfTkFNRVMuaGFzKGkpKSB7XG4gICAgICAgICAgICBuZWVkVXBkYXRlR2VvbWV0cnkgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbGlzdCA9IGdldFBhcnNlZFN0eWxlTGlzdE9mKG9iamVjdCk7XG4gICAgICBpZiAobGlzdC5oYXMoJ2ZpbGwnKSAmJiBhdHRyaWJ1dGVzLmZpbGwpIHtcbiAgICAgICAgb2JqZWN0LnBhcnNlZFN0eWxlLmZpbGwgPSBwYXJzZUNvbG9yKGF0dHJpYnV0ZXMuZmlsbCk7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5oYXMoJ3N0cm9rZScpICYmIGF0dHJpYnV0ZXMuc3Ryb2tlKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5zdHJva2UgPSBwYXJzZUNvbG9yKGF0dHJpYnV0ZXMuc3Ryb2tlKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Lmhhcygnc2hhZG93Q29sb3InKSAmJiBhdHRyaWJ1dGVzLnNoYWRvd0NvbG9yKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5zaGFkb3dDb2xvciA9IHBhcnNlQ29sb3IoYXR0cmlidXRlcy5zaGFkb3dDb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5oYXMoJ2ZpbHRlcicpICYmIGF0dHJpYnV0ZXMuZmlsdGVyKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5maWx0ZXIgPSBwYXJzZUZpbHRlcihhdHRyaWJ1dGVzLmZpbHRlcik7XG4gICAgICB9XG4gICAgICAvLyBSZWN0XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAobGlzdC5oYXMoJ3JhZGl1cycpICYmICFpc05pbChhdHRyaWJ1dGVzLnJhZGl1cykpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBvYmplY3QucGFyc2VkU3R5bGUucmFkaXVzID0gcGFyc2VEaW1lbnNpb25BcnJheUZvcm1hdChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBhdHRyaWJ1dGVzLnJhZGl1cywgNCk7XG4gICAgICB9XG4gICAgICAvLyBQb2x5bGluZVxuICAgICAgaWYgKGxpc3QuaGFzKCdsaW5lRGFzaCcpICYmICFpc05pbChhdHRyaWJ1dGVzLmxpbmVEYXNoKSkge1xuICAgICAgICAvLyBkb23moIflh4boh6rliqjovazljJblpYfmlbDplb/luqbmlbDnu4Qsd2ViZ2zpnIDopoHmiYvliqjlpITnkIZcbiAgICAgICAgb2JqZWN0LnBhcnNlZFN0eWxlLmxpbmVEYXNoID0gcGFyc2VEaW1lbnNpb25BcnJheUZvcm1hdChhdHRyaWJ1dGVzLmxpbmVEYXNoLCAnZXZlbicpO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKGxpc3QuaGFzKCdwb2ludHMnKSAmJiBhdHRyaWJ1dGVzLnBvaW50cykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5wb2ludHMgPSBwYXJzZVBvaW50cyhhdHRyaWJ1dGVzLnBvaW50cyk7XG4gICAgICB9XG4gICAgICAvLyBQYXRoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAobGlzdC5oYXMoJ2QnKSAmJiBhdHRyaWJ1dGVzLmQgPT09ICcnKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5kID0gX29iamVjdFNwcmVhZCh7fSwgRU1QVFlfUEFSU0VEX1BBVEgpO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKGxpc3QuaGFzKCdkJykgJiYgYXR0cmlidXRlcy5kKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5kID0gcGFyc2VQYXRoKFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGF0dHJpYnV0ZXMuZCk7XG4gICAgICB9XG4gICAgICAvLyBUZXh0XG4gICAgICBpZiAobGlzdC5oYXMoJ3RleHRUcmFuc2Zvcm0nKSAmJiBhdHRyaWJ1dGVzLnRleHRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5ydW50aW1lLkNTU1Byb3BlcnR5U3ludGF4RmFjdG9yeVtQcm9wZXJ0eVN5bnRheC5URVhUX1RSQU5TRk9STV0uY2FsY3VsYXRvcihudWxsLCBudWxsLCB7XG4gICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZXMudGV4dFRyYW5zZm9ybVxuICAgICAgICB9LCBvYmplY3QsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QuaGFzKCdjbGlwUGF0aCcpICYmICFpc1VuZGVmaW5lZChhdHRyaWJ1dGVzLmNsaXBQYXRoKSkge1xuICAgICAgICB0aGlzLnJ1bnRpbWUuQ1NTUHJvcGVydHlTeW50YXhGYWN0b3J5W1Byb3BlcnR5U3ludGF4LkRFRklORURfUEFUSF0uY2FsY3VsYXRvcignY2xpcFBhdGgnLCBvbGRDbGlwUGF0aCwgYXR0cmlidXRlcy5jbGlwUGF0aCwgb2JqZWN0LCB0aGlzLnJ1bnRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QuaGFzKCdvZmZzZXRQYXRoJykgJiYgYXR0cmlidXRlcy5vZmZzZXRQYXRoKSB7XG4gICAgICAgIHRoaXMucnVudGltZS5DU1NQcm9wZXJ0eVN5bnRheEZhY3RvcnlbUHJvcGVydHlTeW50YXguREVGSU5FRF9QQVRIXS5jYWxjdWxhdG9yKCdvZmZzZXRQYXRoJywgb2xkT2Zmc2V0UGF0aCwgYXR0cmlidXRlcy5vZmZzZXRQYXRoLCBvYmplY3QsIHRoaXMucnVudGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5oYXMoJ3RyYW5zZm9ybScpICYmIGF0dHJpYnV0ZXMudHJhbnNmb3JtKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS50cmFuc2Zvcm0gPSBwYXJzZVRyYW5zZm9ybShhdHRyaWJ1dGVzLnRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5oYXMoJ3RyYW5zZm9ybU9yaWdpbicpICYmIGF0dHJpYnV0ZXMudHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBwYXJzZVRyYW5zZm9ybU9yaWdpbihhdHRyaWJ1dGVzLnRyYW5zZm9ybU9yaWdpbik7XG4gICAgICB9XG4gICAgICAvLyBNYXJrZXJcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChsaXN0LmhhcygnbWFya2VyU3RhcnQnKSAmJiBhdHRyaWJ1dGVzLm1hcmtlclN0YXJ0KSB7XG4gICAgICAgIG9iamVjdC5wYXJzZWRTdHlsZS5tYXJrZXJTdGFydCA9IHRoaXMucnVudGltZS5DU1NQcm9wZXJ0eVN5bnRheEZhY3RvcnlbUHJvcGVydHlTeW50YXguTUFSS0VSXS5jYWxjdWxhdG9yKG51bGwsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0cmlidXRlcy5tYXJrZXJTdGFydCxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBhdHRyaWJ1dGVzLm1hcmtlclN0YXJ0LCBudWxsLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChsaXN0LmhhcygnbWFya2VyRW5kJykgJiYgYXR0cmlidXRlcy5tYXJrZXJFbmQpIHtcbiAgICAgICAgb2JqZWN0LnBhcnNlZFN0eWxlLm1hcmtlckVuZCA9IHRoaXMucnVudGltZS5DU1NQcm9wZXJ0eVN5bnRheEZhY3RvcnlbUHJvcGVydHlTeW50YXguTUFSS0VSXS5jYWxjdWxhdG9yKG51bGwsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0cmlidXRlcy5tYXJrZXJFbmQsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0cmlidXRlcy5tYXJrZXJFbmQsIG51bGwsIG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKGxpc3QuaGFzKCdtYXJrZXJNaWQnKSAmJiBhdHRyaWJ1dGVzLm1hcmtlck1pZCkge1xuICAgICAgICBvYmplY3QucGFyc2VkU3R5bGUubWFya2VyTWlkID0gdGhpcy5ydW50aW1lLkNTU1Byb3BlcnR5U3ludGF4RmFjdG9yeVtQcm9wZXJ0eVN5bnRheC5NQVJLRVJdLmNhbGN1bGF0b3IoJycsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0cmlidXRlcy5tYXJrZXJNaWQsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0cmlidXRlcy5tYXJrZXJNaWQsIG51bGwsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QuaGFzKCd6SW5kZXgnKSAmJiAhaXNOaWwoYXR0cmlidXRlcy56SW5kZXgpKSB7XG4gICAgICAgIHRoaXMucnVudGltZS5DU1NQcm9wZXJ0eVN5bnRheEZhY3RvcnlbUHJvcGVydHlTeW50YXguWl9JTkRFWF0ucG9zdFByb2Nlc3NvcihvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QuaGFzKCdvZmZzZXREaXN0YW5jZScpICYmICFpc05pbChhdHRyaWJ1dGVzLm9mZnNldERpc3RhbmNlKSkge1xuICAgICAgICB0aGlzLnJ1bnRpbWUuQ1NTUHJvcGVydHlTeW50YXhGYWN0b3J5W1Byb3BlcnR5U3ludGF4Lk9GRlNFVF9ESVNUQU5DRV0ucG9zdFByb2Nlc3NvcihvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QuaGFzKCd0cmFuc2Zvcm0nKSAmJiBhdHRyaWJ1dGVzLnRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLnJ1bnRpbWUuQ1NTUHJvcGVydHlTeW50YXhGYWN0b3J5W1Byb3BlcnR5U3ludGF4LlRSQU5TRk9STV0ucG9zdFByb2Nlc3NvcihvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QuaGFzKCd0cmFuc2Zvcm1PcmlnaW4nKSAmJiBhdHRyaWJ1dGVzLnRyYW5zZm9ybU9yaWdpbikge1xuICAgICAgICB0aGlzLnJ1bnRpbWUuQ1NTUHJvcGVydHlTeW50YXhGYWN0b3J5W1Byb3BlcnR5U3ludGF4LlRSQU5TRk9STV9PUklHSU5dLnBvc3RQcm9jZXNzb3Iob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkVXBkYXRlR2VvbWV0cnkpIHtcbiAgICAgICAgb2JqZWN0Lmdlb21ldHJ5LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgb2JqZWN0LnJlbmRlcmFibGUuYm91bmRzRGlydHkgPSB0cnVlO1xuICAgICAgICBvYmplY3QucmVuZGVyYWJsZS5yZW5kZXJCb3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghb3B0aW9ucy5mb3JjZVVwZGF0ZUdlb21ldHJ5KSB7XG4gICAgICAgICAgdGhpcy5ydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmRpcnRpZnlUb1Jvb3Qob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBnZW9tZXRyeSB3aGVuIHJlbGF0aXZlIHByb3BzIGNoYW5nZWQsXG4gICAgICogZWcuIHIgb2YgQ2lyY2xlLCB3aWR0aC9oZWlnaHQgb2YgUmVjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUdlb21ldHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdlb21ldHJ5KG9iamVjdCkge1xuICAgICAgdmFyIG5vZGVOYW1lID0gb2JqZWN0Lm5vZGVOYW1lO1xuICAgICAgdmFyIGdlb21ldHJ5VXBkYXRlciA9IHRoaXMucnVudGltZS5nZW9tZXRyeVVwZGF0ZXJGYWN0b3J5W25vZGVOYW1lXTtcbiAgICAgIGlmIChnZW9tZXRyeVVwZGF0ZXIpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICAgICAgICBpZiAoIWdlb21ldHJ5LmNvbnRlbnRCb3VuZHMpIHtcbiAgICAgICAgICBnZW9tZXRyeS5jb250ZW50Qm91bmRzID0gbmV3IEFBQkIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdlb21ldHJ5LnJlbmRlckJvdW5kcykge1xuICAgICAgICAgIGdlb21ldHJ5LnJlbmRlckJvdW5kcyA9IG5ldyBBQUJCKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZFN0eWxlID0gb2JqZWN0LnBhcnNlZFN0eWxlO1xuICAgICAgICB2YXIgX2dlb21ldHJ5VXBkYXRlciR1cGRhID0gZ2VvbWV0cnlVcGRhdGVyLnVwZGF0ZShwYXJzZWRTdHlsZSwgb2JqZWN0KSxcbiAgICAgICAgICBfZ2VvbWV0cnlVcGRhdGVyJHVwZGEyID0gX2dlb21ldHJ5VXBkYXRlciR1cGRhLmN4LFxuICAgICAgICAgIGN4ID0gX2dlb21ldHJ5VXBkYXRlciR1cGRhMiA9PT0gdm9pZCAwID8gMCA6IF9nZW9tZXRyeVVwZGF0ZXIkdXBkYTIsXG4gICAgICAgICAgX2dlb21ldHJ5VXBkYXRlciR1cGRhMyA9IF9nZW9tZXRyeVVwZGF0ZXIkdXBkYS5jeSxcbiAgICAgICAgICBjeSA9IF9nZW9tZXRyeVVwZGF0ZXIkdXBkYTMgPT09IHZvaWQgMCA/IDAgOiBfZ2VvbWV0cnlVcGRhdGVyJHVwZGEzLFxuICAgICAgICAgIF9nZW9tZXRyeVVwZGF0ZXIkdXBkYTQgPSBfZ2VvbWV0cnlVcGRhdGVyJHVwZGEuY3osXG4gICAgICAgICAgY3ogPSBfZ2VvbWV0cnlVcGRhdGVyJHVwZGE0ID09PSB2b2lkIDAgPyAwIDogX2dlb21ldHJ5VXBkYXRlciR1cGRhNCxcbiAgICAgICAgICBfZ2VvbWV0cnlVcGRhdGVyJHVwZGE1ID0gX2dlb21ldHJ5VXBkYXRlciR1cGRhLmh3aWR0aCxcbiAgICAgICAgICBod2lkdGggPSBfZ2VvbWV0cnlVcGRhdGVyJHVwZGE1ID09PSB2b2lkIDAgPyAwIDogX2dlb21ldHJ5VXBkYXRlciR1cGRhNSxcbiAgICAgICAgICBfZ2VvbWV0cnlVcGRhdGVyJHVwZGE2ID0gX2dlb21ldHJ5VXBkYXRlciR1cGRhLmhoZWlnaHQsXG4gICAgICAgICAgaGhlaWdodCA9IF9nZW9tZXRyeVVwZGF0ZXIkdXBkYTYgPT09IHZvaWQgMCA/IDAgOiBfZ2VvbWV0cnlVcGRhdGVyJHVwZGE2LFxuICAgICAgICAgIF9nZW9tZXRyeVVwZGF0ZXIkdXBkYTcgPSBfZ2VvbWV0cnlVcGRhdGVyJHVwZGEuaGRlcHRoLFxuICAgICAgICAgIGhkZXB0aCA9IF9nZW9tZXRyeVVwZGF0ZXIkdXBkYTcgPT09IHZvaWQgMCA/IDAgOiBfZ2VvbWV0cnlVcGRhdGVyJHVwZGE3O1xuICAgICAgICAvLyBpbml0IHdpdGggY29udGVudCBib3hcbiAgICAgICAgdmFyIGhhbGZFeHRlbnRzID0gW01hdGguYWJzKGh3aWR0aCksIE1hdGguYWJzKGhoZWlnaHQpLCBoZGVwdGhdO1xuICAgICAgICAvLyBhbmNob3IgaXMgY2VudGVyIGJ5IGRlZmF1bHQsIGRvbid0IGFjY291bnQgZm9yIGxpbmVXaWR0aCBoZXJlXG4gICAgICAgIHZhciBzdHJva2UgPSBwYXJzZWRTdHlsZS5zdHJva2UsXG4gICAgICAgICAgX3BhcnNlZFN0eWxlJGxpbmVXaWR0ID0gcGFyc2VkU3R5bGUubGluZVdpZHRoLFxuICAgICAgICAgIGxpbmVXaWR0aCA9IF9wYXJzZWRTdHlsZSRsaW5lV2lkdCA9PT0gdm9pZCAwID8gMSA6IF9wYXJzZWRTdHlsZSRsaW5lV2lkdCxcbiAgICAgICAgICBfcGFyc2VkU3R5bGUkaW5jcmVhc2UgPSBwYXJzZWRTdHlsZS5pbmNyZWFzZWRMaW5lV2lkdGhGb3JIaXRUZXN0aW5nLFxuICAgICAgICAgIGluY3JlYXNlZExpbmVXaWR0aEZvckhpdFRlc3RpbmcgPSBfcGFyc2VkU3R5bGUkaW5jcmVhc2UgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUkaW5jcmVhc2UsXG4gICAgICAgICAgX3BhcnNlZFN0eWxlJHNoYWRvd1R5ID0gcGFyc2VkU3R5bGUuc2hhZG93VHlwZSxcbiAgICAgICAgICBzaGFkb3dUeXBlID0gX3BhcnNlZFN0eWxlJHNoYWRvd1R5ID09PSB2b2lkIDAgPyAnb3V0ZXInIDogX3BhcnNlZFN0eWxlJHNoYWRvd1R5LFxuICAgICAgICAgIHNoYWRvd0NvbG9yID0gcGFyc2VkU3R5bGUuc2hhZG93Q29sb3IsXG4gICAgICAgICAgX3BhcnNlZFN0eWxlJGZpbHRlciA9IHBhcnNlZFN0eWxlLmZpbHRlcixcbiAgICAgICAgICBmaWx0ZXIgPSBfcGFyc2VkU3R5bGUkZmlsdGVyID09PSB2b2lkIDAgPyBbXSA6IF9wYXJzZWRTdHlsZSRmaWx0ZXIsXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gcGFyc2VkU3R5bGUudHJhbnNmb3JtT3JpZ2luO1xuICAgICAgICB2YXIgY2VudGVyID0gW2N4LCBjeSwgY3pdO1xuICAgICAgICAvLyB1cGRhdGUgZ2VvbWV0cnkncyBBQUJCXG4gICAgICAgIGdlb21ldHJ5LmNvbnRlbnRCb3VuZHMudXBkYXRlKGNlbnRlciwgaGFsZkV4dGVudHMpO1xuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLm1vbGdlbi5tcGcuZGUvZ2l0LW1pcnJvci9jYWlyby9ibG9iL21hc3Rlci9zcmMvY2Fpcm8tc3Ryb2tlLXN0eWxlLmMjTDk3Li5MMTI4XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBub2RlTmFtZSA9PT0gU2hhcGUuUE9MWUxJTkUgfHwgbm9kZU5hbWUgPT09IFNoYXBlLlBPTFlHT04gfHwgbm9kZU5hbWUgPT09IFNoYXBlLlBBVEggPyBNYXRoLlNRUlQyIDogMC41O1xuICAgICAgICAvLyBhcHBlbmQgYm9yZGVyIG9ubHkgaWYgc3Ryb2tlIGV4aXN0ZWRcbiAgICAgICAgdmFyIGhhc1N0cm9rZSA9IHN0cm9rZSAmJiAhc3Ryb2tlLmlzTm9uZTtcbiAgICAgICAgaWYgKGhhc1N0cm9rZSkge1xuICAgICAgICAgIHZhciBoYWxmTGluZVdpZHRoID0gKChsaW5lV2lkdGggfHwgMCkgKyAoaW5jcmVhc2VkTGluZVdpZHRoRm9ySGl0VGVzdGluZyB8fCAwKSkgKiBleHBhbnNpb247XG4gICAgICAgICAgaGFsZkV4dGVudHNbMF0gKz0gaGFsZkxpbmVXaWR0aDtcbiAgICAgICAgICBoYWxmRXh0ZW50c1sxXSArPSBoYWxmTGluZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnJlbmRlckJvdW5kcy51cGRhdGUoY2VudGVyLCBoYWxmRXh0ZW50cyk7XG4gICAgICAgIC8vIGFjY291bnQgZm9yIHNoYWRvdywgb25seSBzdXBwb3J0IGNvbnN0YW50IHZhbHVlIG5vd1xuICAgICAgICBpZiAoc2hhZG93Q29sb3IgJiYgc2hhZG93VHlwZSAmJiBzaGFkb3dUeXBlICE9PSAnaW5uZXInKSB7XG4gICAgICAgICAgdmFyIF9nZW9tZXRyeSRyZW5kZXJCb3VuZCA9IGdlb21ldHJ5LnJlbmRlckJvdW5kcyxcbiAgICAgICAgICAgIG1pbiA9IF9nZW9tZXRyeSRyZW5kZXJCb3VuZC5taW4sXG4gICAgICAgICAgICBtYXggPSBfZ2VvbWV0cnkkcmVuZGVyQm91bmQubWF4O1xuICAgICAgICAgIHZhciBzaGFkb3dCbHVyID0gcGFyc2VkU3R5bGUuc2hhZG93Qmx1cixcbiAgICAgICAgICAgIHNoYWRvd09mZnNldFggPSBwYXJzZWRTdHlsZS5zaGFkb3dPZmZzZXRYLFxuICAgICAgICAgICAgc2hhZG93T2Zmc2V0WSA9IHBhcnNlZFN0eWxlLnNoYWRvd09mZnNldFk7XG4gICAgICAgICAgdmFyIHNoYWRvd0JsdXJJblBpeGVscyA9IHNoYWRvd0JsdXIgfHwgMDtcbiAgICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WEluUGl4ZWxzID0gc2hhZG93T2Zmc2V0WCB8fCAwO1xuICAgICAgICAgIHZhciBzaGFkb3dPZmZzZXRZSW5QaXhlbHMgPSBzaGFkb3dPZmZzZXRZIHx8IDA7XG4gICAgICAgICAgdmFyIHNoYWRvd0xlZnQgPSBtaW5bMF0gLSBzaGFkb3dCbHVySW5QaXhlbHMgKyBzaGFkb3dPZmZzZXRYSW5QaXhlbHM7XG4gICAgICAgICAgdmFyIHNoYWRvd1JpZ2h0ID0gbWF4WzBdICsgc2hhZG93Qmx1ckluUGl4ZWxzICsgc2hhZG93T2Zmc2V0WEluUGl4ZWxzO1xuICAgICAgICAgIHZhciBzaGFkb3dUb3AgPSBtaW5bMV0gLSBzaGFkb3dCbHVySW5QaXhlbHMgKyBzaGFkb3dPZmZzZXRZSW5QaXhlbHM7XG4gICAgICAgICAgdmFyIHNoYWRvd0JvdHRvbSA9IG1heFsxXSArIHNoYWRvd0JsdXJJblBpeGVscyArIHNoYWRvd09mZnNldFlJblBpeGVscztcbiAgICAgICAgICBtaW5bMF0gPSBNYXRoLm1pbihtaW5bMF0sIHNoYWRvd0xlZnQpO1xuICAgICAgICAgIG1heFswXSA9IE1hdGgubWF4KG1heFswXSwgc2hhZG93UmlnaHQpO1xuICAgICAgICAgIG1pblsxXSA9IE1hdGgubWluKG1pblsxXSwgc2hhZG93VG9wKTtcbiAgICAgICAgICBtYXhbMV0gPSBNYXRoLm1heChtYXhbMV0sIHNoYWRvd0JvdHRvbSk7XG4gICAgICAgICAgZ2VvbWV0cnkucmVuZGVyQm91bmRzLnNldE1pbk1heChtaW4sIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWNjb3VudCBmb3IgZmlsdGVyLCBlZy4gYmx1cig1cHgpLCBkcm9wLXNoYWRvdygpXG4gICAgICAgIGZpbHRlci5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBwYXJhbXMgPSBfcmVmLnBhcmFtcztcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICB2YXIgYmx1clJhZGl1cyA9IHBhcmFtc1swXS52YWx1ZTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnJlbmRlckJvdW5kcy51cGRhdGUoZ2VvbWV0cnkucmVuZGVyQm91bmRzLmNlbnRlciwgdmVjMy5hZGQoZ2VvbWV0cnkucmVuZGVyQm91bmRzLmhhbGZFeHRlbnRzLCBnZW9tZXRyeS5yZW5kZXJCb3VuZHMuaGFsZkV4dGVudHMsIFtibHVyUmFkaXVzLCBibHVyUmFkaXVzLCAwXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2Ryb3Atc2hhZG93Jykge1xuICAgICAgICAgICAgdmFyIF9zaGFkb3dPZmZzZXRYID0gcGFyYW1zWzBdLnZhbHVlO1xuICAgICAgICAgICAgdmFyIF9zaGFkb3dPZmZzZXRZID0gcGFyYW1zWzFdLnZhbHVlO1xuICAgICAgICAgICAgdmFyIF9zaGFkb3dCbHVyID0gcGFyYW1zWzJdLnZhbHVlO1xuICAgICAgICAgICAgdmFyIF9nZW9tZXRyeSRyZW5kZXJCb3VuZDIgPSBnZW9tZXRyeS5yZW5kZXJCb3VuZHMsXG4gICAgICAgICAgICAgIF9taW4gPSBfZ2VvbWV0cnkkcmVuZGVyQm91bmQyLm1pbixcbiAgICAgICAgICAgICAgX21heCA9IF9nZW9tZXRyeSRyZW5kZXJCb3VuZDIubWF4O1xuICAgICAgICAgICAgdmFyIF9zaGFkb3dMZWZ0ID0gX21pblswXSAtIF9zaGFkb3dCbHVyICsgX3NoYWRvd09mZnNldFg7XG4gICAgICAgICAgICB2YXIgX3NoYWRvd1JpZ2h0ID0gX21heFswXSArIF9zaGFkb3dCbHVyICsgX3NoYWRvd09mZnNldFg7XG4gICAgICAgICAgICB2YXIgX3NoYWRvd1RvcCA9IF9taW5bMV0gLSBfc2hhZG93Qmx1ciArIF9zaGFkb3dPZmZzZXRZO1xuICAgICAgICAgICAgdmFyIF9zaGFkb3dCb3R0b20gPSBfbWF4WzFdICsgX3NoYWRvd0JsdXIgKyBfc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgICAgIF9taW5bMF0gPSBNYXRoLm1pbihfbWluWzBdLCBfc2hhZG93TGVmdCk7XG4gICAgICAgICAgICBfbWF4WzBdID0gTWF0aC5tYXgoX21heFswXSwgX3NoYWRvd1JpZ2h0KTtcbiAgICAgICAgICAgIF9taW5bMV0gPSBNYXRoLm1pbihfbWluWzFdLCBfc2hhZG93VG9wKTtcbiAgICAgICAgICAgIF9tYXhbMV0gPSBNYXRoLm1heChfbWF4WzFdLCBfc2hhZG93Qm90dG9tKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnJlbmRlckJvdW5kcy5zZXRNaW5NYXgoX21pbiwgX21heCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JqZWN0Lmdlb21ldHJ5LmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW50dmlzL2cvaXNzdWVzLzk1N1xuICAgICAgICB2YXIgZmxpcFkgPSBod2lkdGggPCAwO1xuICAgICAgICB2YXIgZmxpcFggPSBoaGVpZ2h0IDwgMDtcbiAgICAgICAgLy8gc2V0IHRyYW5zZm9ybSBvcmlnaW5cbiAgICAgICAgdmFyIHVzZWRPcmlnaW5YVmFsdWUgPSAoZmxpcFkgPyAtMSA6IDEpICogKHRyYW5zZm9ybU9yaWdpbiA/IGNvbnZlcnRQZXJjZW50VW5pdCh0cmFuc2Zvcm1PcmlnaW5bMF0sIDAsIG9iamVjdCwgdHJ1ZSkgOiAwKTtcbiAgICAgICAgdmFyIHVzZWRPcmlnaW5ZVmFsdWUgPSAoZmxpcFggPyAtMSA6IDEpICogKHRyYW5zZm9ybU9yaWdpbiA/IGNvbnZlcnRQZXJjZW50VW5pdCh0cmFuc2Zvcm1PcmlnaW5bMV0sIDEsIG9iamVjdCwgdHJ1ZSkgOiAwKTtcbiAgICAgICAgaWYgKHVzZWRPcmlnaW5YVmFsdWUgfHwgdXNlZE9yaWdpbllWYWx1ZSkge1xuICAgICAgICAgIG9iamVjdC5zZXRPcmlnaW4odXNlZE9yaWdpblhWYWx1ZSwgdXNlZE9yaWdpbllWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2l6ZUF0dGVudWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNpemVBdHRlbnVhdGlvbihub2RlLCB6b29tKSB7XG4gICAgICBpZiAobm9kZS5zdHlsZS5pc1NpemVBdHRlbnVhdGlvbikge1xuICAgICAgICBpZiAoIW5vZGUuc3R5bGUucmF3TGluZVdpZHRoKSB7XG4gICAgICAgICAgbm9kZS5zdHlsZS5yYXdMaW5lV2lkdGggPSBub2RlLnN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnN0eWxlLmxpbmVXaWR0aCA9IChub2RlLnN0eWxlLnJhd0xpbmVXaWR0aCB8fCAxKSAvIHpvb207XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBTaGFwZS5DSVJDTEUpIHtcbiAgICAgICAgICBpZiAoIW5vZGUuc3R5bGUucmF3Uikge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5yYXdSID0gbm9kZS5zdHlsZS5yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnN0eWxlLnIgPSAobm9kZS5zdHlsZS5yYXdSIHx8IDEpIC8gem9vbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUuc3R5bGUucmF3TGluZVdpZHRoKSB7XG4gICAgICAgICAgbm9kZS5zdHlsZS5saW5lV2lkdGggPSBub2RlLnN0eWxlLnJhd0xpbmVXaWR0aDtcbiAgICAgICAgICBkZWxldGUgbm9kZS5zdHlsZS5yYXdMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFNoYXBlLkNJUkNMRSkge1xuICAgICAgICAgIGlmIChub2RlLnN0eWxlLnJhd1IpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuciA9IG5vZGUuc3R5bGUucmF3UjtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0eWxlLnJhd1I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiBhc3NpZ25QYXJzZWRTdHlsZShvYmplY3QsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGxpc3QgPSBnZXRQYXJzZWRTdHlsZUxpc3RPZihvYmplY3QpO1xuICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgIGlmIChsaXN0LmhhcyhrZXkpKSB7XG4gICAgICBvYmplY3QucGFyc2VkU3R5bGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcnNlZFN0eWxlTGlzdE9mKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0LmNvbnN0cnVjdG9yLlBBUlNFRF9TVFlMRV9MSVNUO1xufVxuXG52YXIgQ1NTUHJvcGVydHlBbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1Byb3BlcnR5QW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5QW5nbGUpO1xuICAgIHRoaXMubWl4ZXIgPSBtZXJnZU51bWJlcnM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NQcm9wZXJ0eUFuZ2xlLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkUGFyc2VkLCBwYXJzZWQsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRBbmdsZVVuaXQocGFyc2VkKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBjbGlwUGF0aCAvIHRleHRQYXRoIC8gb2Zmc2V0UGF0aFxuICovXG52YXIgQ1NTUHJvcGVydHlDbGlwUGF0aCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1Byb3BlcnR5Q2xpcFBhdGgoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5Q2xpcFBhdGgpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlDbGlwUGF0aCwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdG9yKG5hbWUsIG9sZFBhdGgsIG5ld1BhdGgsIG9iamVjdCwgcnVudGltZSkge1xuICAgICAgLy8gdW5zZXRcbiAgICAgIGlmIChuZXdQYXRoIGluc3RhbmNlb2YgQ1NTS2V5d29yZFZhbHVlKSB7XG4gICAgICAgIG5ld1BhdGggPSBudWxsO1xuICAgICAgfVxuICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS51cGRhdGVEaXNwbGF5T2JqZWN0RGVwZW5kZW5jeShuYW1lLCBvbGRQYXRoLCBuZXdQYXRoLCBvYmplY3QpO1xuICAgICAgaWYgKG5hbWUgPT09ICdjbGlwUGF0aCcpIHtcbiAgICAgICAgLy8gc2hvdWxkIGFmZmVjdCBjaGlsZHJlblxuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgIGlmIChsZWFmLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmRpcnRpZnlUb1Jvb3QobGVhZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQYXRoO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgQ1NTUHJvcGVydHlDb2xvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1Byb3BlcnR5Q29sb3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5Q29sb3IpO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VDb2xvcjtcbiAgICB0aGlzLm1peGVyID0gbWVyZ2VDb2xvcnM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NQcm9wZXJ0eUNvbG9yLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkUGFyc2VkLCBwYXJzZWQsIG9iamVjdCkge1xuICAgICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIENTU0tleXdvcmRWYWx1ZSkge1xuICAgICAgICAvLyAndW5zZXQnICdub25lJ1xuICAgICAgICByZXR1cm4gcGFyc2VkLnZhbHVlID09PSAnbm9uZScgPyBub25lQ29sb3IgOiB0cmFuc3BhcmVudENvbG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIENTU1Byb3BlcnR5RmlsdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ1NTUHJvcGVydHlGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5RmlsdGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU1Byb3BlcnR5RmlsdGVyLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkUGFyc2VkLCBwYXJzZWQpIHtcbiAgICAgIC8vIHVuc2V0IG9yIG5vbmVcbiAgICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBDU1NLZXl3b3JkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0Rm9udFNpemUob2JqZWN0KSB7XG4gIHZhciBfcmVmID0gb2JqZWN0LnBhcnNlZFN0eWxlLFxuICAgIGZvbnRTaXplID0gX3JlZi5mb250U2l6ZTtcbiAgcmV0dXJuIGlzTmlsKGZvbnRTaXplKSA/IG51bGwgOiBmb250U2l6ZTtcbn1cblxuLyoqXG4gKiA8bGVuZ3RoPiAmIDxwZXJjZW50YWdlPlxuICovXG52YXIgQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eUxlbmd0aE9yUGVyY2VudGFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UpO1xuICAgIHRoaXMubWl4ZXIgPSBtZXJnZU51bWJlcnM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NQcm9wZXJ0eUxlbmd0aE9yUGVyY2VudGFnZSwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRvclwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIGFjY29yZGluZyB0byBwYXJlbnQncyBib3VuZHNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQ1NTLnBlcmNlbnQoNTApIC0+IENTUy5weCgwLjUgKiBwYXJlbnQud2lkdGgpXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRvcihuYW1lLCBvbGRQYXJzZWQsIGNvbXB1dGVkLCBvYmplY3QsIHJ1bnRpbWUpIHtcbiAgICAgIGlmIChpc051bWJlcihjb21wdXRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgICAgfVxuICAgICAgaWYgKENTU1VuaXRWYWx1ZS5pc1JlbGF0aXZlVW5pdChjb21wdXRlZC51bml0KSkge1xuICAgICAgICBpZiAoY29tcHV0ZWQudW5pdCA9PT0gVW5pdFR5cGUua1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAvLyBUT0RPOiBtZXJnZSBkaW1lbnNpb25zXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVkLnVuaXQgPT09IFVuaXRUeXBlLmtFbXMpIHtcbiAgICAgICAgICBpZiAob2JqZWN0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IGdldEZvbnRTaXplKG9iamVjdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICAgICAgICBmb250U2l6ZSAqPSBjb21wdXRlZC52YWx1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZWQudW5pdCA9PT0gVW5pdFR5cGUua1JlbXMpIHtcbiAgICAgICAgICB2YXIgX29iamVjdCRvd25lckRvY3VtZW50O1xuICAgICAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0ICE9PSB2b2lkIDAgJiYgKF9vYmplY3Qkb3duZXJEb2N1bWVudCA9IG9iamVjdC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfb2JqZWN0JG93bmVyRG9jdW1lbnQgIT09IHZvaWQgMCAmJiBfb2JqZWN0JG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgX2ZvbnRTaXplID0gZ2V0Rm9udFNpemUob2JqZWN0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChfZm9udFNpemUpIHtcbiAgICAgICAgICAgICAgX2ZvbnRTaXplICo9IGNvbXB1dGVkLnZhbHVlO1xuICAgICAgICAgICAgICByZXR1cm4gX2ZvbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIGlmIGV4aXN0c1xuICAgICAgICAvLyByZWdpc3RyeS51bnJlZ2lzdGVyUGFyZW50R2VvbWV0cnlCb3VuZHNDaGFuZ2VkSGFuZGxlcihvYmplY3QsIG5hbWUpO1xuXG4gICAgICAgIC8vIHJldHVybiBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gY29tcHV0ZWQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKlxuICogZm9ybWF0IHRvIFR1cGxlMjxDU1NVbml0VmFsdWU+XG4gKlxuICogQGV4YW1wbGVcbiAqIHJlY3Quc3R5bGUubGluZURhc2ggPSAxMDtcbiAqIHJlY3Quc3R5bGUubGluZURhc2ggPSBbMTAsIDEwXTtcbiAqIHJlY3Quc3R5bGUubGluZURhc2ggPSAnMTAgMTAnO1xuICovXG52YXIgQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UxMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1Byb3BlcnR5TGVuZ3RoT3JQZXJjZW50YWdlMTIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5TGVuZ3RoT3JQZXJjZW50YWdlMTIpO1xuICAgIHRoaXMubWl4ZXIgPSBtZXJnZU51bWJlckxpc3RzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UxMiwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdG9yKG5hbWUsIG9sZFBhcnNlZCwgY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybiBjb21wdXRlZC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiB1c2VkIGluIHJvdW5kZWQgcmVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiByZWN0LnN0eWxlLnJhZGl1cyA9IDEwO1xuICogcmVjdC5zdHlsZS5yYWRpdXMgPSAnMTAgMTAnO1xuICogcmVjdC5zdHlsZS5yYWRpdXMgPSAnMTAgMTAgMTAgMTAnO1xuICovXG52YXIgQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UxNCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1Byb3BlcnR5TGVuZ3RoT3JQZXJjZW50YWdlMTQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5TGVuZ3RoT3JQZXJjZW50YWdlMTQpO1xuICAgIHRoaXMubWl4ZXIgPSBtZXJnZU51bWJlckxpc3RzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UxNCwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdG9yKG5hbWUsIG9sZFBhcnNlZCwgY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybiBjb21wdXRlZC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIENTU1Byb3BlcnR5TWFya2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ1NTUHJvcGVydHlNYXJrZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5TWFya2VyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU1Byb3BlcnR5TWFya2VyLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkTWFya2VyLCBuZXdNYXJrZXIsIG9iamVjdCkge1xuICAgICAgdmFyIF9uZXdNYXJrZXI7XG4gICAgICAvLyB1bnNldFxuICAgICAgaWYgKG5ld01hcmtlciBpbnN0YW5jZW9mIENTU0tleXdvcmRWYWx1ZSkge1xuICAgICAgICBuZXdNYXJrZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNsb25lZCA9IChfbmV3TWFya2VyID0gbmV3TWFya2VyKSA9PT0gbnVsbCB8fCBfbmV3TWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmV3TWFya2VyLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGlmIChjbG9uZWQpIHtcbiAgICAgICAgLy8gRklYTUU6IFNWRyBzaG91bGQgbm90IGluaGVyaXQgcGFyZW50J3Mgc3R5bGUsIGFkZCBhIGZsYWcgaGVyZVxuICAgICAgICBjbG9uZWQuc3R5bGUuaXNNYXJrZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIENTU1Byb3BlcnR5TnVtYmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ1NTUHJvcGVydHlOdW1iZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5TnVtYmVyKTtcbiAgICB0aGlzLm1peGVyID0gbWVyZ2VOdW1iZXJzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlOdW1iZXIsIFt7XG4gICAga2V5OiBcImNhbGN1bGF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRvcihuYW1lLCBvbGRQYXJzZWQsIGNvbXB1dGVkKSB7XG4gICAgICByZXR1cm4gY29tcHV0ZWQudmFsdWU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBDU1NQcm9wZXJ0eU9mZnNldERpc3RhbmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ1NTUHJvcGVydHlPZmZzZXREaXN0YW5jZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUHJvcGVydHlPZmZzZXREaXN0YW5jZSk7XG4gICAgdGhpcy5taXhlciA9IGNsYW1wZWRNZXJnZU51bWJlcnMoMCwgMSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NQcm9wZXJ0eU9mZnNldERpc3RhbmNlLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkUGFyc2VkLCBjb21wdXRlZCkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVkLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0UHJvY2Vzc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RQcm9jZXNzb3Iob2JqZWN0KSB7XG4gICAgICB2YXIgX29iamVjdCRwYXJzZWRTdHlsZSA9IG9iamVjdC5wYXJzZWRTdHlsZSxcbiAgICAgICAgb2Zmc2V0UGF0aCA9IF9vYmplY3QkcGFyc2VkU3R5bGUub2Zmc2V0UGF0aCxcbiAgICAgICAgb2Zmc2V0RGlzdGFuY2UgPSBfb2JqZWN0JHBhcnNlZFN0eWxlLm9mZnNldERpc3RhbmNlO1xuICAgICAgaWYgKCFvZmZzZXRQYXRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlTmFtZSA9IG9mZnNldFBhdGgubm9kZU5hbWU7XG4gICAgICBpZiAobm9kZU5hbWUgPT09IFNoYXBlLkxJTkUgfHwgbm9kZU5hbWUgPT09IFNoYXBlLlBBVEggfHwgbm9kZU5hbWUgPT09IFNoYXBlLlBPTFlMSU5FKSB7XG4gICAgICAgIC8vIHNldCBwb3NpdGlvbiBpbiB3b3JsZCBzcGFjZVxuICAgICAgICB2YXIgcG9pbnQgPSBvZmZzZXRQYXRoLmdldFBvaW50KG9mZnNldERpc3RhbmNlKTtcbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgb2JqZWN0LnNldExvY2FsUG9zaXRpb24ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBvcGFjaXR5XG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wYWNpdHkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eU9wYWNpdHkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5T3BhY2l0eSk7XG4gICAgdGhpcy5taXhlciA9IGNsYW1wZWRNZXJnZU51bWJlcnMoMCwgMSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NQcm9wZXJ0eU9wYWNpdHksIFt7XG4gICAga2V5OiBcImNhbGN1bGF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRvcihuYW1lLCBvbGRQYXJzZWQsIGNvbXB1dGVkKSB7XG4gICAgICByZXR1cm4gY29tcHV0ZWQudmFsdWU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBDU1NQcm9wZXJ0eVBhdGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eVBhdGgoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5UGF0aCk7XG4gICAgLyoqXG4gICAgICogcGF0aDJDdXJ2ZVxuICAgICAqL1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VQYXRoO1xuICAgIHRoaXMubWl4ZXIgPSBtZXJnZVBhdGhzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlQYXRoLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkUGFyc2VkLCBwYXJzZWQpIHtcbiAgICAgIC8vIHVuc2V0XG4gICAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgQ1NTS2V5d29yZFZhbHVlICYmIHBhcnNlZC52YWx1ZSA9PT0gJ3Vuc2V0Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFic29sdXRlUGF0aDogW10sXG4gICAgICAgICAgaGFzQXJjOiBmYWxzZSxcbiAgICAgICAgICBzZWdtZW50czogW10sXG4gICAgICAgICAgcG9seWdvbnM6IFtdLFxuICAgICAgICAgIHBvbHlsaW5lczogW10sXG4gICAgICAgICAgY3VydmU6IG51bGwsXG4gICAgICAgICAgdG90YWxMZW5ndGg6IDAsXG4gICAgICAgICAgcmVjdDogbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIENTU1Byb3BlcnR5UG9pbnRzID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhmdW5jdGlvbiBDU1NQcm9wZXJ0eVBvaW50cygpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5UG9pbnRzKTtcbiAgdGhpcy5taXhlciA9IG1lcmdlUG9pbnRzO1xufSk7XG5cbnZhciBDU1NQcm9wZXJ0eVNoYWRvd0JsdXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DU1NQcm9wZXJ0eUxlbmd0aE9yUCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eVNoYWRvd0JsdXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDU1NQcm9wZXJ0eVNoYWRvd0JsdXIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENTU1Byb3BlcnR5U2hhZG93Qmx1ciwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfdGhpcy5taXhlciA9IGNsYW1wZWRNZXJnZU51bWJlcnMoMCwgSW5maW5pdHkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQ1NTUHJvcGVydHlTaGFkb3dCbHVyLCBfQ1NTUHJvcGVydHlMZW5ndGhPclApO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU1Byb3BlcnR5U2hhZG93Qmx1cik7XG59KENTU1Byb3BlcnR5TGVuZ3RoT3JQZXJjZW50YWdlKTtcblxudmFyIENTU1Byb3BlcnR5VGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENTU1Byb3BlcnR5VGV4dCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUHJvcGVydHlUZXh0KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU1Byb3BlcnR5VGV4dCwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdG9yKG5hbWUsIG9sZFBhcnNlZCwgcGFyc2VkLCBvYmplY3QpIHtcbiAgICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBDU1NLZXl3b3JkVmFsdWUpIHtcbiAgICAgICAgaWYgKHBhcnNlZC52YWx1ZSA9PT0gJ3Vuc2V0Jykge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBudW1iZXIgYXMgdmFsaWQgdGV4dCBjb250ZW50XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocGFyc2VkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdFByb2Nlc3NvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0UHJvY2Vzc29yKG9iamVjdCkge1xuICAgICAgb2JqZWN0Lm5vZGVWYWx1ZSA9IFwiXCIuY29uY2F0KG9iamVjdC5wYXJzZWRTdHlsZS50ZXh0KSB8fCAnJztcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBpdCBtdXN0IHRyYW5zZm9ybSBhZnRlciB0ZXh0IGdldCBwYXJzZWRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL3RleHQtdHJhbnNmb3JtXG4gKi9cbnZhciBDU1NQcm9wZXJ0eVRleHRUcmFuc2Zvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eVRleHRUcmFuc2Zvcm0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1Byb3BlcnR5VGV4dFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDU1NQcm9wZXJ0eVRleHRUcmFuc2Zvcm0sIFt7XG4gICAga2V5OiBcImNhbGN1bGF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRvcihuYW1lLCBvbGRQYXJzZWQsIHBhcnNlZCwgb2JqZWN0KSB7XG4gICAgICB2YXIgcmF3VGV4dCA9IG9iamVjdC5nZXRBdHRyaWJ1dGUoJ3RleHQnKTtcbiAgICAgIGlmIChyYXdUZXh0KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFRleHQgPSByYXdUZXh0O1xuICAgICAgICBpZiAocGFyc2VkLnZhbHVlID09PSAnY2FwaXRhbGl6ZScpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZFRleHQgPSByYXdUZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcmF3VGV4dC5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQudmFsdWUgPT09ICdsb3dlcmNhc2UnKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRUZXh0ID0gcmF3VGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZC52YWx1ZSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZFRleHQgPSByYXdUZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnBhcnNlZFN0eWxlLnRleHQgPSB0cmFuc2Zvcm1lZFRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkLnZhbHVlO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgZGVmaW5lZFByb3BzID0gZnVuY3Rpb24gZGVmaW5lZFByb3BzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICB2ID0gX3JlZjJbMV07XG4gICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDtcbiAgfSkpO1xufTtcblxudmFyIENBTlZBU19NYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIGRlc3Ryb3kgZXhpc3RlZCBjYW52YXMgd2l0aCB0aGUgc2FtZSBpZFxuICovXG5mdW5jdGlvbiBjbGVhbkV4aXN0ZWRDYW52YXMoY29udGFpbmVyLCBjYW52YXMsIGNsZWFuVXApIHtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHZhciAkZG9tID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpIDogY29udGFpbmVyO1xuICAgIGlmIChDQU5WQVNfTWFwLmhhcygkZG9tKSkgQ0FOVkFTX01hcC5nZXQoJGRvbSkuZGVzdHJveShjbGVhblVwKTtcbiAgICBDQU5WQVNfTWFwLnNldCgkZG9tLCBjYW52YXMpO1xuICB9XG59XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh0YXJnZXQpIHtcbiAgcmV0dXJuICEhdGFyZ2V0LmdldEF0dHJpYnV0ZTtcbn1cbmZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbG93ID0gMDtcbiAgdmFyIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgdmFyIG1pZCA9IGxvdyArIGhpZ2ggPj4+IDE7XG4gICAgaWYgKHNvcnRCeVpJbmRleChhcnJheVttaWRdLCB2YWx1ZSkgPCAwKSB7XG4gICAgICBsb3cgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gc29ydEJ5WkluZGV4KG8xLCBvMikge1xuICB2YXIgekluZGV4MSA9IE51bWJlcihvMS5wYXJzZWRTdHlsZS56SW5kZXggfHwgMCk7XG4gIHZhciB6SW5kZXgyID0gTnVtYmVyKG8yLnBhcnNlZFN0eWxlLnpJbmRleCB8fCAwKTtcbiAgaWYgKHpJbmRleDEgPT09IHpJbmRleDIpIHtcbiAgICB2YXIgcGFyZW50ID0gbzEucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGROb2RlcyB8fCBbXTtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5pbmRleE9mKG8xKSAtIGNoaWxkcmVuLmluZGV4T2YobzIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gekluZGV4MSAtIHpJbmRleDI7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdENsaXBQYXRoVGFyZ2V0KG9iamVjdCkge1xuICB2YXIgZWwgPSBvYmplY3Q7XG4gIGRvIHtcbiAgICB2YXIgX2VsJHBhcnNlZFN0eWxlO1xuICAgIHZhciBjbGlwUGF0aCA9IChfZWwkcGFyc2VkU3R5bGUgPSBlbC5wYXJzZWRTdHlsZSkgPT09IG51bGwgfHwgX2VsJHBhcnNlZFN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWwkcGFyc2VkU3R5bGUuY2xpcFBhdGg7XG4gICAgaWYgKGNsaXBQYXRoKSByZXR1cm4gZWw7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9IHdoaWxlIChlbCAhPT0gbnVsbCk7XG4gIHJldHVybiBudWxsO1xufVxudmFyIFBYX1NVRkZJWCA9ICdweCc7XG5mdW5jdGlvbiBzZXRET01TaXplKCRlbCwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoaXNCcm93c2VyICYmICRlbC5zdHlsZSkge1xuICAgICRlbC5zdHlsZS53aWR0aCA9IHdpZHRoICsgUFhfU1VGRklYO1xuICAgICRlbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBQWF9TVUZGSVg7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN0eWxlKCRlbCwgcHJvcGVydHkpIHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHJldHVybiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCRlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFdpZHRoKCRlbCkge1xuICB2YXIgd2lkdGggPSBnZXRTdHlsZSgkZWwsICd3aWR0aCcpO1xuICBpZiAod2lkdGggPT09ICdhdXRvJykge1xuICAgIHJldHVybiAkZWwub2Zmc2V0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQod2lkdGgpO1xufVxuZnVuY3Rpb24gZ2V0SGVpZ2h0KCRlbCkge1xuICB2YXIgaGVpZ2h0ID0gZ2V0U3R5bGUoJGVsLCAnaGVpZ2h0Jyk7XG4gIGlmIChoZWlnaHQgPT09ICdhdXRvJykge1xuICAgIHJldHVybiAkZWwub2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiBwYXJzZUZsb2F0KGhlaWdodCk7XG59XG5cbi8vIGJvcnJvdyBmcm9tIGhhbW1lci5qc1xudmFyIE1PVVNFX1BPSU5URVJfSUQgPSAxO1xudmFyIFRPVUNIX1RPX1BPSU5URVIgPSB7XG4gIHRvdWNoc3RhcnQ6ICdwb2ludGVyZG93bicsXG4gIHRvdWNoZW5kOiAncG9pbnRlcnVwJyxcbiAgdG91Y2hlbmRvdXRzaWRlOiAncG9pbnRlcnVwb3V0c2lkZScsXG4gIHRvdWNobW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgdG91Y2hjYW5jZWw6ICdwb2ludGVyY2FuY2VsJ1xufTtcbnZhciBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xuXG5mdW5jdGlvbiBpc0luRnJhZ21lbnQobm9kZSkge1xuICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gU2hhcGUuRlJBR01FTlQpIHJldHVybiB0cnVlO1xuICByZXR1cm4gbm9kZS5nZXRSb290Tm9kZSgpLm5vZGVOYW1lID09PSBTaGFwZS5GUkFHTUVOVDtcbn1cblxuZnVuY3Rpb24gaXNGaWxsT3JTdHJva2VBZmZlY3RlZCgpIHtcbiAgdmFyIHBvaW50ZXJFdmVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdhdXRvJztcbiAgdmFyIGZpbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHN0cm9rZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAvLyBhY2NvdW50IGZvciBwb2ludGVyRXZlbnRzXG4gIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3BvaW50ZXItZXZlbnRzXG5cbiAgdmFyIGhhc0ZpbGwgPSBmYWxzZTtcbiAgdmFyIGhhc1N0cm9rZSA9IGZhbHNlO1xuICB2YXIgaXNGaWxsT3RoZXJUaGFuTm9uZSA9ICEhZmlsbCAmJiAhZmlsbC5pc05vbmU7XG4gIHZhciBpc1N0cm9rZU90aGVyVGhhbk5vbmUgPSAhIXN0cm9rZSAmJiAhc3Ryb2tlLmlzTm9uZTtcbiAgaWYgKHBvaW50ZXJFdmVudHMgPT09ICd2aXNpYmxlcGFpbnRlZCcgfHwgcG9pbnRlckV2ZW50cyA9PT0gJ3BhaW50ZWQnIHx8IHBvaW50ZXJFdmVudHMgPT09ICdhdXRvJykge1xuICAgIGhhc0ZpbGwgPSBpc0ZpbGxPdGhlclRoYW5Ob25lO1xuICAgIGhhc1N0cm9rZSA9IGlzU3Ryb2tlT3RoZXJUaGFuTm9uZTtcbiAgfSBlbHNlIGlmIChwb2ludGVyRXZlbnRzID09PSAndmlzaWJsZWZpbGwnIHx8IHBvaW50ZXJFdmVudHMgPT09ICdmaWxsJykge1xuICAgIGhhc0ZpbGwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHBvaW50ZXJFdmVudHMgPT09ICd2aXNpYmxlc3Ryb2tlJyB8fCBwb2ludGVyRXZlbnRzID09PSAnc3Ryb2tlJykge1xuICAgIGhhc1N0cm9rZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAocG9pbnRlckV2ZW50cyA9PT0gJ3Zpc2libGUnIHx8IHBvaW50ZXJFdmVudHMgPT09ICdhbGwnKSB7XG4gICAgLy8gVGhlIHZhbHVlcyBvZiB0aGUgZmlsbCBhbmQgc3Ryb2tlIGRvIG5vdCBhZmZlY3QgZXZlbnQgcHJvY2Vzc2luZy5cbiAgICBoYXNGaWxsID0gdHJ1ZTtcbiAgICBoYXNTdHJva2UgPSB0cnVlO1xuICB9XG4gIHJldHVybiBbaGFzRmlsbCwgaGFzU3Ryb2tlXTtcbn1cblxuLyoqXG4gKiBUaGFua3MgZm9yIGZvbGxvd2luZyBjb250cmlidXRvciBvZiBjb2Rlc1xuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTg2NjQ3NFxuICogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAqIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtbGlicmFyeS9ibG9iL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lL3BvbHlmaWxsLmpzXG4gKiAqL1xuXG52YXIgdUlkID0gMTtcbnZhciB1bmlxdWVJZCA9IGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICByZXR1cm4gdUlkKys7XG59O1xuXG4vLyBXZSB1c2UgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG52YXIgcm9vdCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbnR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgPyBzZWxmIDpcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCA/XG4vLyBAdHMtaWdub3JlXG5nbG9iYWwgOiB7fTtcbnZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuXG4vLyB1c2UgcGVyZm9ybWFuY2UgYXBpIGlmIGV4aXN0LCBvdGhlcndpc2UgdXNlIERhdGUubm93LlxuLy8gRGF0ZS5ub3cgcG9seWZpbGwgcmVxdWlyZWQuXG52YXIgcG5vdyA9IGZ1bmN0aW9uIHBub3coKSB7XG4gIGlmIChyb290LnBlcmZvcm1hbmNlICYmIHR5cGVvZiByb290LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByb290LnBlcmZvcm1hbmNlLm5vdygpO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG59O1xudmFyIHJlc2VydmVkQ0JzID0ge307XG52YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xudmFyIHBvbHlmaWxsUmFmID0gZnVuY3Rpb24gcG9seWZpbGxSYWYoY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY2FsbGJhY2ssIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpKTtcbiAgfVxuICB2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICB2YXIgZ2FwID0gY3VycmVudFRpbWUgLSBsYXN0VGltZTtcbiAgdmFyIGRlbGF5ID0gZ2FwID4gMTYgPyAwIDogMTYgLSBnYXA7XG4gIHZhciBpZCA9IHVuaXF1ZUlkKCk7XG4gIHJlc2VydmVkQ0JzW2lkXSA9IGNhbGxiYWNrO1xuXG4gIC8vIGtleXMocmVzZXJ2ZWRDQnMpLmxlbmd0aCA+IDEg7J2Y66+464qUIOydtOuvuCBzZXRUaW1lb3V0IOydtCDqsbjroKTsnojripQg6rK97JqwLlxuICAvLyDtlajqu5ggY2FsbGJhY2sg7J20IOyLpO2WieuQoCDsiJgg7J6I6rKMIHJlc2VydmVkQ0JzIOyXkOunjCDstpTqsIDtlbTso7zqs6AgcmV0dXJuXG4gIGlmIChPYmplY3Qua2V5cyhyZXNlcnZlZENCcykubGVuZ3RoID4gMSkgcmV0dXJuIGlkO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBsYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHZhciBjb3BpZWQgPSByZXNlcnZlZENCcztcbiAgICByZXNlcnZlZENCcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGNvcGllZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gY29waWVkW2tleV0ocG5vdygpKTtcbiAgICB9KTtcbiAgfSwgZGVsYXkpO1xuICByZXR1cm4gaWQ7XG59O1xudmFyIHBvbHlmaWxsQ2FmID0gZnVuY3Rpb24gcG9seWZpbGxDYWYoaWQpIHtcbiAgZGVsZXRlIHJlc2VydmVkQ0JzW2lkXTtcbn07XG52YXIgdmVuZG9yUHJlZml4ZXMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nXTtcbnZhciBnZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiBnZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUodnApIHtcbiAgaWYgKHR5cGVvZiB2cCAhPT0gJ3N0cmluZycpIHJldHVybiBwb2x5ZmlsbFJhZjtcbiAgaWYgKHZwID09PSAnJykgcmV0dXJuIHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICByZXR1cm4gcm9vdFtcIlwiLmNvbmNhdCh2cCwgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildO1xufTtcbnZhciBnZXRDYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIGdldENhbmNlbEFuaW1hdGlvbkZyYW1lKHZwKSB7XG4gIGlmICh0eXBlb2YgdnAgIT09ICdzdHJpbmcnKSByZXR1cm4gcG9seWZpbGxDYWY7XG4gIGlmICh2cCA9PT0gJycpIHJldHVybiByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICByZXR1cm4gcm9vdFtcIlwiLmNvbmNhdCh2cCwgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiKV0gfHwgcm9vdFtcIlwiLmNvbmNhdCh2cCwgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildO1xufTtcbnZhciBmaW5kID0gZnVuY3Rpb24gZmluZChhcnIsIHByZWRpY2F0ZSkge1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkgcmV0dXJuIGFycltpXTtcbiAgICBpICs9IDE7XG4gIH1cbn07XG52YXIgdnAgPSBmaW5kKHZlbmRvclByZWZpeGVzLCBmdW5jdGlvbiAodnApIHtcbiAgcmV0dXJuICEhZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHZwKTtcbn0pO1xudmFyIHJhZiA9IGdldFJlcXVlc3RBbmltYXRpb25GcmFtZSh2cCk7XG52YXIgY2FmID0gZ2V0Q2FuY2VsQW5pbWF0aW9uRnJhbWUodnApO1xucm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWY7XG5yb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FmO1xuXG52YXIgQXN5bmNQYXJhbGxlbEhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBc3luY1BhcmFsbGVsSG9vaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXN5bmNQYXJhbGxlbEhvb2spO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBc3luY1BhcmFsbGVsSG9vaywgW3tcbiAgICBrZXk6IFwiZ2V0Q2FsbGJhY2tzTnVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbGxiYWNrc051bSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRhcFByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFwUHJvbWlzZShvcHRpb25zLCBmbikge1xuICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChmbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvbWlzZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuY2FsbGJhY2tzLm1hcChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBBc3luY1Nlcmllc1dhdGVyZmFsbEhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBc3luY1Nlcmllc1dhdGVyZmFsbEhvb2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzeW5jU2VyaWVzV2F0ZXJmYWxsSG9vayk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFzeW5jU2VyaWVzV2F0ZXJmYWxsSG9vaywgW3tcbiAgICBrZXk6IFwidGFwUHJvbWlzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YXBQcm9taXNlKG9wdGlvbnMsIGZuKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGZuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvbWlzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Byb21pc2UgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIF90aGlzJGNhbGxiYWNrcyxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpWzBdLmFwcGx5KF90aGlzJGNhbGxiYWNrcywgX2FyZ3MpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMuY2FsbGJhY2tzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbaV07IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIF9wcm9taXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9KClcbiAgfV0pO1xufSgpO1xuXG52YXIgU3luY0hvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTeW5jSG9vaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3luY0hvb2spO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTeW5jSG9vaywgW3tcbiAgICBrZXk6IFwidGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhcChvcHRpb25zLCBmbikge1xuICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChmbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgdmFyIGFyZ3NBcnIgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZCAqL1xuICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3NBcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBTeW5jV2F0ZXJmYWxsSG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN5bmNXYXRlcmZhbGxIb29rKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW5jV2F0ZXJmYWxsSG9vayk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFN5bmNXYXRlcmZhbGxIb29rLCBbe1xuICAgIGtleTogXCJ0YXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFwKG9wdGlvbnMsIGZuKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGZuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgdmFyIGFyZ3NBcnIgPSBhcmd1bWVudHM7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkICovXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNhbGxiYWNrc1swXS5hcHBseSh1bmRlZmluZWQsIGFyZ3NBcnIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2ldO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIGdlbmVyaWNGb250RmFtaWxpZXMgPSBbJ3NlcmlmJywgJ3NhbnMtc2VyaWYnLCAnbW9ub3NwYWNlJywgJ2N1cnNpdmUnLCAnZmFudGFzeScsICdzeXN0ZW0tdWknXTtcbnZhciBzdHJpbmdSZWdFeHAgPSAvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS87XG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoYXR0cmlidXRlcykge1xuICB2YXIgX2F0dHJpYnV0ZXMkZm9udFNpemUgPSBhdHRyaWJ1dGVzLmZvbnRTaXplLFxuICAgIGZvbnRTaXplID0gX2F0dHJpYnV0ZXMkZm9udFNpemUgPT09IHZvaWQgMCA/IDE2IDogX2F0dHJpYnV0ZXMkZm9udFNpemUsXG4gICAgX2F0dHJpYnV0ZXMkZm9udEZhbWlsID0gYXR0cmlidXRlcy5mb250RmFtaWx5LFxuICAgIGZvbnRGYW1pbHkgPSBfYXR0cmlidXRlcyRmb250RmFtaWwgPT09IHZvaWQgMCA/ICdzYW5zLXNlcmlmJyA6IF9hdHRyaWJ1dGVzJGZvbnRGYW1pbCxcbiAgICBfYXR0cmlidXRlcyRmb250U3R5bGUgPSBhdHRyaWJ1dGVzLmZvbnRTdHlsZSxcbiAgICBmb250U3R5bGUgPSBfYXR0cmlidXRlcyRmb250U3R5bGUgPT09IHZvaWQgMCA/ICdub3JtYWwnIDogX2F0dHJpYnV0ZXMkZm9udFN0eWxlLFxuICAgIF9hdHRyaWJ1dGVzJGZvbnRWYXJpYSA9IGF0dHJpYnV0ZXMuZm9udFZhcmlhbnQsXG4gICAgZm9udFZhcmlhbnQgPSBfYXR0cmlidXRlcyRmb250VmFyaWEgPT09IHZvaWQgMCA/ICdub3JtYWwnIDogX2F0dHJpYnV0ZXMkZm9udFZhcmlhLFxuICAgIF9hdHRyaWJ1dGVzJGZvbnRXZWlnaCA9IGF0dHJpYnV0ZXMuZm9udFdlaWdodCxcbiAgICBmb250V2VpZ2h0ID0gX2F0dHJpYnV0ZXMkZm9udFdlaWdoID09PSB2b2lkIDAgPyAnbm9ybWFsJyA6IF9hdHRyaWJ1dGVzJGZvbnRXZWlnaDtcblxuICAvLyBidWlsZCBjYW52YXMgYXBpIGZvbnQgc2V0dGluZyBmcm9tIGluZGl2aWR1YWwgY29tcG9uZW50cy4gQ29udmVydCBhIG51bWVyaWMgdGhpcy5mb250U2l6ZSB0byBweFxuICAvLyBjb25zdCBmb250U2l6ZVN0cmluZzogc3RyaW5nID0gaXNOdW1iZXIoZm9udFNpemUpID8gYCR7Zm9udFNpemV9cHhgIDogZm9udFNpemUudG9TdHJpbmcoKTtcbiAgdmFyIGZvbnRTaXplU3RyaW5nID0gaXNOdW1iZXIoZm9udFNpemUpICYmIFwiXCIuY29uY2F0KGZvbnRTaXplLCBcInB4XCIpIHx8ICcxNnB4JztcbiAgLy8gQ2xlYW4tdXAgZm9udEZhbWlseSBwcm9wZXJ0eSBieSBxdW90aW5nIGVhY2ggZm9udCBuYW1lXG4gIC8vIHRoaXMgd2lsbCBzdXBwb3J0IGZvbnQgbmFtZXMgd2l0aCBzcGFjZXNcblxuICB2YXIgZm9udEZhbWlsaWVzID0gZm9udEZhbWlseS5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gZm9udEZhbWlsaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gVHJpbSBhbnkgZXh0cmEgd2hpdGUtc3BhY2VcbiAgICB2YXIgX2ZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgIC8vIENoZWNrIGlmIGZvbnQgYWxyZWFkeSBjb250YWlucyBzdHJpbmdzXG4gICAgaWYgKCFzdHJpbmdSZWdFeHAudGVzdChfZm9udEZhbWlseSkgJiYgZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmRleE9mKF9mb250RmFtaWx5KSA8IDApIHtcbiAgICAgIF9mb250RmFtaWx5ID0gXCJcXFwiXCIuY29uY2F0KF9mb250RmFtaWx5LCBcIlxcXCJcIik7XG4gICAgfVxuICAgIGZvbnRGYW1pbGllc1tpXSA9IF9mb250RmFtaWx5O1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChmb250U3R5bGUsIFwiIFwiKS5jb25jYXQoZm9udFZhcmlhbnQsIFwiIFwiKS5jb25jYXQoZm9udFdlaWdodCwgXCIgXCIpLmNvbmNhdChmb250U2l6ZVN0cmluZywgXCIgXCIpLmNvbmNhdChmb250RmFtaWxpZXMuam9pbignLCcpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2tld01hdHJpeChza2V3TWF0cml4LCBza2V3WCwgc2tld1kpIHtcbiAgLy8gQ3JlYXRlIGFuIGlkZW50aXR5IG1hdHJpeFxuICBtYXQ0LmlkZW50aXR5KHNrZXdNYXRyaXgpO1xuICAvLyBBcHBseSBza2V3IHRvIHRoZSBtYXRyaXhcbiAgc2tld01hdHJpeFs0XSA9IE1hdGgudGFuKHNrZXdYKTsgLy8gU2tldyBZIGF4aXMgaW4gWCBkaXJlY3Rpb25cbiAgc2tld01hdHJpeFsxXSA9IE1hdGgudGFuKHNrZXdZKTsgLy8gU2tldyBYIGF4aXMgaW4gWSBkaXJlY3Rpb25cblxuICByZXR1cm4gc2tld01hdHJpeDtcbn1cbnZhciAkbWF0NF8xID0gbWF0NC5jcmVhdGUoKTtcbnZhciAkbWF0NF8yID0gbWF0NC5jcmVhdGUoKTtcbnZhciBwYXJzZXIgPSB7XG4gIHNjYWxlOiBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgbWF0NC5mcm9tU2NhbGluZygkbWF0NF8xLCBbZFswXS52YWx1ZSwgZFsxXS52YWx1ZSwgMV0pO1xuICB9LFxuICBzY2FsZVg6IGZ1bmN0aW9uIHNjYWxlWChkKSB7XG4gICAgbWF0NC5mcm9tU2NhbGluZygkbWF0NF8xLCBbZFswXS52YWx1ZSwgMSwgMV0pO1xuICB9LFxuICBzY2FsZVk6IGZ1bmN0aW9uIHNjYWxlWShkKSB7XG4gICAgbWF0NC5mcm9tU2NhbGluZygkbWF0NF8xLCBbMSwgZFswXS52YWx1ZSwgMV0pO1xuICB9LFxuICBzY2FsZVo6IGZ1bmN0aW9uIHNjYWxlWihkKSB7XG4gICAgbWF0NC5mcm9tU2NhbGluZygkbWF0NF8xLCBbMSwgMSwgZFswXS52YWx1ZV0pO1xuICB9LFxuICBzY2FsZTNkOiBmdW5jdGlvbiBzY2FsZTNkKGQpIHtcbiAgICBtYXQ0LmZyb21TY2FsaW5nKCRtYXQ0XzEsIFtkWzBdLnZhbHVlLCBkWzFdLnZhbHVlLCBkWzJdLnZhbHVlXSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gdHJhbnNsYXRlKGQpIHtcbiAgICBtYXQ0LmZyb21UcmFuc2xhdGlvbigkbWF0NF8xLCBbZFswXS52YWx1ZSwgZFsxXS52YWx1ZSwgMF0pO1xuICB9LFxuICB0cmFuc2xhdGVYOiBmdW5jdGlvbiB0cmFuc2xhdGVYKGQpIHtcbiAgICBtYXQ0LmZyb21UcmFuc2xhdGlvbigkbWF0NF8xLCBbZFswXS52YWx1ZSwgMCwgMF0pO1xuICB9LFxuICB0cmFuc2xhdGVZOiBmdW5jdGlvbiB0cmFuc2xhdGVZKGQpIHtcbiAgICBtYXQ0LmZyb21UcmFuc2xhdGlvbigkbWF0NF8xLCBbMCwgZFswXS52YWx1ZSwgMF0pO1xuICB9LFxuICB0cmFuc2xhdGVaOiBmdW5jdGlvbiB0cmFuc2xhdGVaKGQpIHtcbiAgICBtYXQ0LmZyb21UcmFuc2xhdGlvbigkbWF0NF8xLCBbMCwgMCwgZFswXS52YWx1ZV0pO1xuICB9LFxuICB0cmFuc2xhdGUzZDogZnVuY3Rpb24gdHJhbnNsYXRlM2QoZCkge1xuICAgIG1hdDQuZnJvbVRyYW5zbGF0aW9uKCRtYXQ0XzEsIFtkWzBdLnZhbHVlLCBkWzFdLnZhbHVlLCBkWzJdLnZhbHVlXSk7XG4gIH0sXG4gIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKGQpIHtcbiAgICBtYXQ0LmZyb21aUm90YXRpb24oJG1hdDRfMSwgZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGRbMF0pKSk7XG4gIH0sXG4gIHJvdGF0ZVg6IGZ1bmN0aW9uIHJvdGF0ZVgoZCkge1xuICAgIG1hdDQuZnJvbVhSb3RhdGlvbigkbWF0NF8xLCBkZWcycmFkKGNvbnZlcnRBbmdsZVVuaXQoZFswXSkpKTtcbiAgfSxcbiAgcm90YXRlWTogZnVuY3Rpb24gcm90YXRlWShkKSB7XG4gICAgbWF0NC5mcm9tWVJvdGF0aW9uKCRtYXQ0XzEsIGRlZzJyYWQoY29udmVydEFuZ2xlVW5pdChkWzBdKSkpO1xuICB9LFxuICByb3RhdGVaOiBmdW5jdGlvbiByb3RhdGVaKGQpIHtcbiAgICBtYXQ0LmZyb21aUm90YXRpb24oJG1hdDRfMSwgZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGRbMF0pKSk7XG4gIH0sXG4gIHJvdGF0ZTNkOiBmdW5jdGlvbiByb3RhdGUzZChkKSB7XG4gICAgbWF0NC5mcm9tUm90YXRpb24oJG1hdDRfMSwgZGVnMnJhZChjb252ZXJ0QW5nbGVVbml0KGRbM10pKSwgW2RbMF0udmFsdWUsIGRbMV0udmFsdWUsIGRbMl0udmFsdWVdKTtcbiAgfSxcbiAgc2tldzogZnVuY3Rpb24gc2tldyhkKSB7XG4gICAgY3JlYXRlU2tld01hdHJpeCgkbWF0NF8xLCBkZWcycmFkKGRbMF0udmFsdWUpLCBkZWcycmFkKGRbMV0udmFsdWUpKTtcbiAgfSxcbiAgc2tld1g6IGZ1bmN0aW9uIHNrZXdYKGQpIHtcbiAgICBjcmVhdGVTa2V3TWF0cml4KCRtYXQ0XzEsIGRlZzJyYWQoZFswXS52YWx1ZSksIDApO1xuICB9LFxuICBza2V3WTogZnVuY3Rpb24gc2tld1koZCkge1xuICAgIGNyZWF0ZVNrZXdNYXRyaXgoJG1hdDRfMSwgMCwgZGVnMnJhZChkWzBdLnZhbHVlKSk7XG4gIH0sXG4gIG1hdHJpeDogZnVuY3Rpb24gbWF0cml4KGQpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBtYXQ0LnNldCgkbWF0NF8xLCBkWzBdLnZhbHVlLCBkWzFdLnZhbHVlLCAwLCAwLCBkWzJdLnZhbHVlLCBkWzNdLnZhbHVlLCAwLCAwLCAwLCAwLCAxLCAwLCBkWzRdLnZhbHVlLCBkWzVdLnZhbHVlLCAwLCAxKTtcbiAgfSxcbiAgbWF0cml4M2Q6IGZ1bmN0aW9uIG1hdHJpeDNkKGQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbWF0NC5zZXQuYXBwbHkobWF0NCwgWyRtYXQ0XzFdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgIH0pKSkpO1xuICB9XG59O1xudmFyICR2ZWMzT25lJDEgPSB2ZWMzLmZyb21WYWx1ZXMoMSwgMSwgMSk7XG52YXIgJHZlYzNaZXJvJDEgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyIG9wdGltaXplciA9IHtcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUob2JqZWN0LCBkKSB7XG4gICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5zZXRMb2NhbFNjYWxlKG9iamVjdCwgJHZlYzNPbmUkMSwgZmFsc2UpO1xuICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2Uuc2V0TG9jYWxFdWxlckFuZ2xlcyhvYmplY3QsICR2ZWMzWmVybyQxLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2Uuc2V0TG9jYWxQb3NpdGlvbihvYmplY3QsIFtkWzBdLnZhbHVlLCBkWzFdLnZhbHVlLCAwXSwgZmFsc2UpO1xuICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZGlydGlmeUxvY2FsKG9iamVjdCwgb2JqZWN0LnRyYW5zZm9ybWFibGUpO1xuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VkVHJhbnNmb3JtVG9NYXQ0KHRyYW5zZm9ybSwgb2JqZWN0KSB7XG4gIGlmICh0cmFuc2Zvcm0ubGVuZ3RoKSB7XG4gICAgaWYgKHRyYW5zZm9ybS5sZW5ndGggPT09IDEgJiYgb3B0aW1pemVyW3RyYW5zZm9ybVswXS50XSkge1xuICAgICAgb3B0aW1pemVyW3RyYW5zZm9ybVswXS50XShvYmplY3QsIHRyYW5zZm9ybVswXS5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG0gPSBtYXQ0LmlkZW50aXR5KCRtYXQ0XzIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3RyYW5zZm9ybSRpID0gdHJhbnNmb3JtW2ldLFxuICAgICAgICB0ID0gX3RyYW5zZm9ybSRpLnQsXG4gICAgICAgIGQgPSBfdHJhbnNmb3JtJGkuZDtcbiAgICAgIHZhciBwID0gcGFyc2VyW3RdO1xuICAgICAgaWYgKHApIHtcbiAgICAgICAgcChkKTtcbiAgICAgICAgbWF0NC5tdWwobSwgbSwgJG1hdDRfMSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9iamVjdC5zZXRMb2NhbFRyYW5zZm9ybShtKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3QucmVzZXRMb2NhbFRyYW5zZm9ybSgpO1xuICB9XG4gIHJldHVybiBvYmplY3QuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbn1cblxuLyoqXG4gKiBAc2VlIC96aC9kb2NzL2FwaS9hbmltYXRpb24j5pSv5oyB5Y+Y5o2i55qE5bGe5oCnXG4gKlxuICogc3VwcG9ydCB0aGUgZm9sbG93aW5nIGZvcm1hdHMgbGlrZSBDU1MgVHJhbnNmb3JtOlxuICpcbiAqIHNjYWxlXG4gKiAqIHNjYWxlKHgsIHkpXG4gKiAqIHNjYWxlWCh4KVxuICogKiBzY2FsZVkoeClcbiAqICogc2NhbGVaKHopXG4gKiAqIHNjYWxlM2QoeCwgeSwgeilcbiAqXG4gKiB0cmFuc2xhdGUgKHVuaXQ6IG5vbmUsIHB4LCAlKHJlbGF0aXZlIHRvIGl0cyBib3VuZHMpKVxuICogKiB0cmFuc2xhdGUoeCwgeSkgZWcuIHRyYW5zbGF0ZSgwLCAwKSB0cmFuc2xhdGUoMCwgMzBweCkgdHJhbnNsYXRlKDEwMCUsIDEwMCUpXG4gKiAqIHRyYW5zbGF0ZVgoMClcbiAqICogdHJhbnNsYXRlWSgwKVxuICogKiB0cmFuc2xhdGVaKDApXG4gKiAqIHRyYW5zbGF0ZTNkKDAsIDAsIDApXG4gKlxuICogcm90YXRlICh1bml0OiBkZWcgcmFkIHR1cm4pXG4gKiAqIHJvdGF0ZSgwLjV0dXJuKSByb3RhdGUoMzBkZWcpIHJvdGF0ZSgxcmFkKVxuICpcbiAqIG5vbmVcbiAqXG4gKiB1bnN1cHBvcnRlZCBmb3Igbm93OlxuICogKiBjYWxjKCkgZWcuIHRyYW5zbGF0ZShjYWxjKDEwMCUgKyAxMHB4KSlcbiAqICogbWF0cml4L21hdHJpeDNkKClcbiAqICogc2tldy9za2V3WC9za2V3WVxuICogKiBwZXJzcGVjdGl2ZVxuICovXG52YXIgQ1NTUHJvcGVydHlUcmFuc2Zvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eVRyYW5zZm9ybSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUHJvcGVydHlUcmFuc2Zvcm0pO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VUcmFuc2Zvcm1Vbm1lbW9pemU7XG4gICAgdGhpcy5taXhlciA9IG1lcmdlVHJhbnNmb3JtcztcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENTU1Byb3BlcnR5VHJhbnNmb3JtLCBbe1xuICAgIGtleTogXCJjYWxjdWxhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0b3IobmFtZSwgb2xkUGFyc2VkLCBwYXJzZWQsIG9iamVjdCkge1xuICAgICAgLy8gJ25vbmUnXG4gICAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgQ1NTS2V5d29yZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RQcm9jZXNzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdFByb2Nlc3NvcihvYmplY3QpIHtcbiAgICAgIHBhcnNlZFRyYW5zZm9ybVRvTWF0NChvYmplY3QucGFyc2VkU3R5bGUudHJhbnNmb3JtLCBvYmplY3QpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1vcmlnaW5cbiAqIEBleGFtcGxlXG4gKiBbMTBweCwgMTBweF0gWzEwJSwgMTAlXVxuICovXG52YXIgQ1NTUHJvcGVydHlUcmFuc2Zvcm1PcmlnaW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eVRyYW5zZm9ybU9yaWdpbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUHJvcGVydHlUcmFuc2Zvcm1PcmlnaW4pO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlUcmFuc2Zvcm1PcmlnaW4sIFt7XG4gICAga2V5OiBcInBvc3RQcm9jZXNzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdFByb2Nlc3NvcihvYmplY3QpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBvYmplY3QucGFyc2VkU3R5bGUudHJhbnNmb3JtT3JpZ2luO1xuICAgICAgaWYgKHRyYW5zZm9ybU9yaWdpblswXS51bml0ID09PSBVbml0VHlwZS5rUGl4ZWxzICYmIHRyYW5zZm9ybU9yaWdpblsxXS51bml0ID09PSBVbml0VHlwZS5rUGl4ZWxzKSB7XG4gICAgICAgIG9iamVjdC5zZXRPcmlnaW4odHJhbnNmb3JtT3JpZ2luWzBdLnZhbHVlLCB0cmFuc2Zvcm1PcmlnaW5bMV0udmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsYXRpdmUgdG8gZ2VvbWV0cnkgYm91bmRzLCBjYWxjdWxhdGUgbGF0ZXIuXG4gICAgICAgIG9iamVjdC5nZXRHZW9tZXRyeUJvdW5kcygpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgQ1NTUHJvcGVydHlaSW5kZXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDU1NQcm9wZXJ0eVpJbmRleCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1NTUHJvcGVydHlaSW5kZXgpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ1NTUHJvcGVydHlaSW5kZXgsIFt7XG4gICAga2V5OiBcImNhbGN1bGF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRvcihuYW1lLCBvbGRQYXJzZWQsIGNvbXB1dGVkLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb21wdXRlZC52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdFByb2Nlc3NvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0UHJvY2Vzc29yKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbnRpdHkgPSBvYmplY3QucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHBhcmVudFJlbmRlcmFibGUgPSBwYXJlbnRFbnRpdHkucmVuZGVyYWJsZTtcbiAgICAgICAgdmFyIHBhcmVudFNvcnRhYmxlID0gcGFyZW50RW50aXR5LnNvcnRhYmxlO1xuICAgICAgICBpZiAocGFyZW50UmVuZGVyYWJsZSkge1xuICAgICAgICAgIHBhcmVudFJlbmRlcmFibGUuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgcmUtc29ydCBvbiBwYXJlbnRcbiAgICAgICAgaWYgKHBhcmVudFNvcnRhYmxlKSB7XG4gICAgICAgICAgcGFyZW50U29ydGFibGUuZGlydHkgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudFNvcnRhYmxlLmRpcnR5UmVhc29uID0gU29ydFJlYXNvbi5aX0lOREVYX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIENpcmNsZVVwZGF0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaXJjbGVVcGRhdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGVVcGRhdGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENpcmNsZVVwZGF0ZXIsIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocGFyc2VkU3R5bGUsIG9iamVjdCkge1xuICAgICAgdmFyIF9wYXJzZWRTdHlsZSRjeCA9IHBhcnNlZFN0eWxlLmN4LFxuICAgICAgICBjeCA9IF9wYXJzZWRTdHlsZSRjeCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRjeCxcbiAgICAgICAgX3BhcnNlZFN0eWxlJGN5ID0gcGFyc2VkU3R5bGUuY3ksXG4gICAgICAgIGN5ID0gX3BhcnNlZFN0eWxlJGN5ID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJGN5LFxuICAgICAgICBfcGFyc2VkU3R5bGUkciA9IHBhcnNlZFN0eWxlLnIsXG4gICAgICAgIHIgPSBfcGFyc2VkU3R5bGUkciA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3ksXG4gICAgICAgIGh3aWR0aDogcixcbiAgICAgICAgaGhlaWdodDogclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIEVsbGlwc2VVcGRhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWxsaXBzZVVwZGF0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsbGlwc2VVcGRhdGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVsbGlwc2VVcGRhdGVyLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHBhcnNlZFN0eWxlLCBvYmplY3QpIHtcbiAgICAgIHZhciBfcGFyc2VkU3R5bGUkY3ggPSBwYXJzZWRTdHlsZS5jeCxcbiAgICAgICAgY3ggPSBfcGFyc2VkU3R5bGUkY3ggPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUkY3gsXG4gICAgICAgIF9wYXJzZWRTdHlsZSRjeSA9IHBhcnNlZFN0eWxlLmN5LFxuICAgICAgICBjeSA9IF9wYXJzZWRTdHlsZSRjeSA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRjeSxcbiAgICAgICAgX3BhcnNlZFN0eWxlJHJ4ID0gcGFyc2VkU3R5bGUucngsXG4gICAgICAgIHJ4ID0gX3BhcnNlZFN0eWxlJHJ4ID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJHJ4LFxuICAgICAgICBfcGFyc2VkU3R5bGUkcnkgPSBwYXJzZWRTdHlsZS5yeSxcbiAgICAgICAgcnkgPSBfcGFyc2VkU3R5bGUkcnkgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUkcnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgaHdpZHRoOiByeCxcbiAgICAgICAgaGhlaWdodDogcnlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBMaW5lVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmVVcGRhdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lVXBkYXRlcik7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMaW5lVXBkYXRlciwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwYXJzZWRTdHlsZSkge1xuICAgICAgdmFyIHgxID0gcGFyc2VkU3R5bGUueDEsXG4gICAgICAgIHkxID0gcGFyc2VkU3R5bGUueTEsXG4gICAgICAgIHgyID0gcGFyc2VkU3R5bGUueDIsXG4gICAgICAgIHkyID0gcGFyc2VkU3R5bGUueTI7XG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgICB2YXIgbWF4WCA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgICB2YXIgbWluWSA9IE1hdGgubWluKHkxLCB5Mik7XG4gICAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHkxLCB5Mik7XG4gICAgICB2YXIgd2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICAgIHZhciBoZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICAgIHZhciBod2lkdGggPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaGhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjeDogbWluWCArIGh3aWR0aCxcbiAgICAgICAgY3k6IG1pblkgKyBoaGVpZ2h0LFxuICAgICAgICBod2lkdGg6IGh3aWR0aCxcbiAgICAgICAgaGhlaWdodDogaGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIFBhdGhVcGRhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGF0aFVwZGF0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGhVcGRhdGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBhdGhVcGRhdGVyLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHBhcnNlZFN0eWxlKSB7XG4gICAgICB2YXIgZCA9IHBhcnNlZFN0eWxlLmQ7XG4gICAgICB2YXIgX2QkcmVjdCA9IGQucmVjdCxcbiAgICAgICAgeCA9IF9kJHJlY3QueCxcbiAgICAgICAgeSA9IF9kJHJlY3QueSxcbiAgICAgICAgd2lkdGggPSBfZCRyZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfZCRyZWN0LmhlaWdodDtcbiAgICAgIHZhciBod2lkdGggPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaGhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjeDogeCArIGh3aWR0aCxcbiAgICAgICAgY3k6IHkgKyBoaGVpZ2h0LFxuICAgICAgICBod2lkdGg6IGh3aWR0aCxcbiAgICAgICAgaGhlaWdodDogaGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIFBvbHlsaW5lVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbHlsaW5lVXBkYXRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seWxpbmVVcGRhdGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBvbHlsaW5lVXBkYXRlciwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwYXJzZWRTdHlsZSkge1xuICAgICAgaWYgKHBhcnNlZFN0eWxlLnBvaW50cyAmJiBpc0FycmF5KHBhcnNlZFN0eWxlLnBvaW50cy5wb2ludHMpKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBwYXJzZWRTdHlsZS5wb2ludHMucG9pbnRzO1xuXG4gICAgICAgIC8vIEZJWE1FOiBhY2NvdW50IGZvciBtaXRlciBsaW5lSm9pblxuICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIHJldHVybiBwb2ludFswXTtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgdmFyIG1heFggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkocG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICByZXR1cm4gcG9pbnRbMF07XG4gICAgICAgIH0pKSk7XG4gICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgcmV0dXJuIHBvaW50WzFdO1xuICAgICAgICB9KSkpO1xuICAgICAgICB2YXIgbWF4WSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIHJldHVybiBwb2ludFsxXTtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgdmFyIHdpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICAgICAgdmFyIGh3aWR0aCA9IHdpZHRoIC8gMjtcbiAgICAgICAgdmFyIGhoZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGN4OiBtaW5YICsgaHdpZHRoLFxuICAgICAgICAgIGN5OiBtaW5ZICsgaGhlaWdodCxcbiAgICAgICAgICBod2lkdGg6IGh3aWR0aCxcbiAgICAgICAgICBoaGVpZ2h0OiBoaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjeDogMCxcbiAgICAgICAgY3k6IDAsXG4gICAgICAgIGh3aWR0aDogMCxcbiAgICAgICAgaGhlaWdodDogMFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIFJlY3RVcGRhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVjdFVwZGF0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3RVcGRhdGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlY3RVcGRhdGVyLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHBhcnNlZFN0eWxlLCBvYmplY3QpIHtcbiAgICAgIHZhciBfcGFyc2VkU3R5bGUkeCA9IHBhcnNlZFN0eWxlLngsXG4gICAgICAgIHggPSBfcGFyc2VkU3R5bGUkeCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR4LFxuICAgICAgICBfcGFyc2VkU3R5bGUkeSA9IHBhcnNlZFN0eWxlLnksXG4gICAgICAgIHkgPSBfcGFyc2VkU3R5bGUkeSA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR5LFxuICAgICAgICBzcmMgPSBwYXJzZWRTdHlsZS5zcmMsXG4gICAgICAgIF9wYXJzZWRTdHlsZSR3aWR0aCA9IHBhcnNlZFN0eWxlLndpZHRoLFxuICAgICAgICB3aWR0aCA9IF9wYXJzZWRTdHlsZSR3aWR0aCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR3aWR0aCxcbiAgICAgICAgX3BhcnNlZFN0eWxlJGhlaWdodCA9IHBhcnNlZFN0eWxlLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0ID0gX3BhcnNlZFN0eWxlJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRoZWlnaHQ7XG4gICAgICB2YXIgY29udGVudFdpZHRoID0gd2lkdGg7XG4gICAgICB2YXIgY29udGVudEhlaWdodCA9IGhlaWdodDtcblxuICAgICAgLy8gcmVzaXplIHdpdGggSFRNTEltYWdlRWxlbWVudCdzIHNpemVcbiAgICAgIGlmIChzcmMgJiYgIWlzU3RyaW5nKHNyYykpIHtcbiAgICAgICAgaWYgKCFjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICBjb250ZW50V2lkdGggPSBzcmMud2lkdGg7XG4gICAgICAgICAgcGFyc2VkU3R5bGUud2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50SGVpZ2h0KSB7XG4gICAgICAgICAgY29udGVudEhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgICAgICAgcGFyc2VkU3R5bGUuaGVpZ2h0ID0gY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3g6IHggKyBjb250ZW50V2lkdGggLyAyLFxuICAgICAgICBjeTogeSArIGNvbnRlbnRIZWlnaHQgLyAyLFxuICAgICAgICBod2lkdGg6IGNvbnRlbnRXaWR0aCAvIDIsXG4gICAgICAgIGhoZWlnaHQ6IGNvbnRlbnRIZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgVGV4dFVwZGF0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZXh0VXBkYXRlcihnbG9iYWxSdW50aW1lKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRVcGRhdGVyKTtcbiAgICB0aGlzLmdsb2JhbFJ1bnRpbWUgPSBnbG9iYWxSdW50aW1lO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVGV4dFVwZGF0ZXIsIFt7XG4gICAga2V5OiBcImlzUmVhZHlUb01lYXN1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeVRvTWVhc3VyZShwYXJzZWRTdHlsZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgdGV4dCA9IHBhcnNlZFN0eWxlLnRleHQ7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwYXJzZWRTdHlsZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgX29iamVjdCRvd25lckRvY3VtZW50O1xuICAgICAgdmFyIHRleHQgPSBwYXJzZWRTdHlsZS50ZXh0LFxuICAgICAgICBfcGFyc2VkU3R5bGUkdGV4dEFsaWcgPSBwYXJzZWRTdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRBbGlnbiA9IF9wYXJzZWRTdHlsZSR0ZXh0QWxpZyA9PT0gdm9pZCAwID8gJ3N0YXJ0JyA6IF9wYXJzZWRTdHlsZSR0ZXh0QWxpZyxcbiAgICAgICAgX3BhcnNlZFN0eWxlJGxpbmVXaWR0ID0gcGFyc2VkU3R5bGUubGluZVdpZHRoLFxuICAgICAgICBsaW5lV2lkdGggPSBfcGFyc2VkU3R5bGUkbGluZVdpZHQgPT09IHZvaWQgMCA/IDEgOiBfcGFyc2VkU3R5bGUkbGluZVdpZHQsXG4gICAgICAgIF9wYXJzZWRTdHlsZSR0ZXh0QmFzZSA9IHBhcnNlZFN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gX3BhcnNlZFN0eWxlJHRleHRCYXNlID09PSB2b2lkIDAgPyAnYWxwaGFiZXRpYycgOiBfcGFyc2VkU3R5bGUkdGV4dEJhc2UsXG4gICAgICAgIF9wYXJzZWRTdHlsZSRkeCA9IHBhcnNlZFN0eWxlLmR4LFxuICAgICAgICBkeCA9IF9wYXJzZWRTdHlsZSRkeCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRkeCxcbiAgICAgICAgX3BhcnNlZFN0eWxlJGR5ID0gcGFyc2VkU3R5bGUuZHksXG4gICAgICAgIGR5ID0gX3BhcnNlZFN0eWxlJGR5ID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJGR5LFxuICAgICAgICBfcGFyc2VkU3R5bGUkeCA9IHBhcnNlZFN0eWxlLngsXG4gICAgICAgIHggPSBfcGFyc2VkU3R5bGUkeCA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR4LFxuICAgICAgICBfcGFyc2VkU3R5bGUkeSA9IHBhcnNlZFN0eWxlLnksXG4gICAgICAgIHkgPSBfcGFyc2VkU3R5bGUkeSA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR5O1xuICAgICAgaWYgKCF0aGlzLmlzUmVhZHlUb01lYXN1cmUocGFyc2VkU3R5bGUsIG9iamVjdCkpIHtcbiAgICAgICAgcGFyc2VkU3R5bGUubWV0cmljcyA9IHtcbiAgICAgICAgICBmb250OiAnJyxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIGxpbmVXaWR0aHM6IFtdLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IDAsXG4gICAgICAgICAgbWF4TGluZVdpZHRoOiAwLFxuICAgICAgICAgIGZvbnRQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBhc2NlbnQ6IDAsXG4gICAgICAgICAgICBkZXNjZW50OiAwLFxuICAgICAgICAgICAgZm9udFNpemU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbmVNZXRyaWNzOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGh3aWR0aDogMCxcbiAgICAgICAgICBoaGVpZ2h0OiAwLFxuICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgIGN5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgX3JlZiA9IChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgfHwgKF9vYmplY3Qkb3duZXJEb2N1bWVudCA9IG9iamVjdC5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfb2JqZWN0JG93bmVyRG9jdW1lbnQgPT09IHZvaWQgMCB8fCAoX29iamVjdCRvd25lckRvY3VtZW50ID0gX29iamVjdCRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfb2JqZWN0JG93bmVyRG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vYmplY3Qkb3duZXJEb2N1bWVudC5nZXRDb25maWcoKSkgfHwge30sXG4gICAgICAgIG9mZnNjcmVlbkNhbnZhcyA9IF9yZWYub2Zmc2NyZWVuQ2FudmFzO1xuICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLmdsb2JhbFJ1bnRpbWUudGV4dFNlcnZpY2UubWVhc3VyZVRleHQodGV4dCwgcGFyc2VkU3R5bGUsIG9mZnNjcmVlbkNhbnZhcyk7XG4gICAgICBwYXJzZWRTdHlsZS5tZXRyaWNzID0gbWV0cmljcztcbiAgICAgIHZhciB3aWR0aCA9IG1ldHJpY3Mud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0O1xuICAgICAgdmFyIGh3aWR0aCA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciBoaGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICAgICAgLy8gZGVmYXVsdCAnbGVmdCdcbiAgICAgIHZhciBsaW5lWE9mZnNldCA9IHggKyBod2lkdGg7XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJyB8fCB0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIGxpbmVYT2Zmc2V0ICs9IGxpbmVXaWR0aCAvIDIgLSBod2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyB8fCB0ZXh0QWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIGxpbmVYT2Zmc2V0ICs9IGxpbmVXaWR0aCAtIGh3aWR0aCAqIDI7XG4gICAgICB9XG4gICAgICB2YXIgbGluZVlPZmZzZXQgPSB5IC0gaGhlaWdodDtcbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIGxpbmVZT2Zmc2V0ICs9IGhoZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ3RvcCcgfHwgdGV4dEJhc2VsaW5lID09PSAnaGFuZ2luZycpIHtcbiAgICAgICAgbGluZVlPZmZzZXQgKz0gaGhlaWdodCAqIDI7XG4gICAgICB9IGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2FscGhhYmV0aWMnKSA7IGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2JvdHRvbScgfHwgdGV4dEJhc2VsaW5lID09PSAnaWRlb2dyYXBoaWMnKSB7XG4gICAgICAgIGxpbmVZT2Zmc2V0ICs9IDA7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBpZGVvZ3JhcGhpYyAmIGJvdHRvbVxuXG4gICAgICBpZiAoZHgpIHtcbiAgICAgICAgbGluZVhPZmZzZXQgKz0gZHg7XG4gICAgICB9XG4gICAgICBpZiAoZHkpIHtcbiAgICAgICAgbGluZVlPZmZzZXQgKz0gZHk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjeDogbGluZVhPZmZzZXQsXG4gICAgICAgIGN5OiBsaW5lWU9mZnNldCxcbiAgICAgICAgaHdpZHRoOiBod2lkdGgsXG4gICAgICAgIGhoZWlnaHQ6IGhoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBHcm91cFVwZGF0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHcm91cFVwZGF0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyb3VwVXBkYXRlcik7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhHcm91cFVwZGF0ZXIsIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocGFyc2VkU3R5bGUsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3g6IDAsXG4gICAgICAgIGN5OiAwLFxuICAgICAgICBod2lkdGg6IDAsXG4gICAgICAgIGhoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBIVE1MVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhUTUxVcGRhdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MVXBkYXRlcik7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhIVE1MVXBkYXRlciwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwYXJzZWRTdHlsZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgX3BhcnNlZFN0eWxlJHggPSBwYXJzZWRTdHlsZS54LFxuICAgICAgICB4ID0gX3BhcnNlZFN0eWxlJHggPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUkeCxcbiAgICAgICAgX3BhcnNlZFN0eWxlJHkgPSBwYXJzZWRTdHlsZS55LFxuICAgICAgICB5ID0gX3BhcnNlZFN0eWxlJHkgPT09IHZvaWQgMCA/IDAgOiBfcGFyc2VkU3R5bGUkeSxcbiAgICAgICAgX3BhcnNlZFN0eWxlJHdpZHRoID0gcGFyc2VkU3R5bGUud2lkdGgsXG4gICAgICAgIHdpZHRoID0gX3BhcnNlZFN0eWxlJHdpZHRoID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJHdpZHRoLFxuICAgICAgICBfcGFyc2VkU3R5bGUkaGVpZ2h0ID0gcGFyc2VkU3R5bGUuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQgPSBfcGFyc2VkU3R5bGUkaGVpZ2h0ID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJGhlaWdodDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgIGh3aWR0aDogd2lkdGggLyAyLFxuICAgICAgICBoaGVpZ2h0OiBoZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG5mdW5jdGlvbiBpc0ZlZGVyYXRlZEV2ZW50KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlLnR5cGU7XG59XG5cbi8qKlxuICogQW4gRE9NLWNvbXBhdGlibGUgc3ludGhldGljIGV2ZW50IGltcGxlbWVudGF0aW9uIHRoYXQgaXMgXCJmb3J3YXJkZWRcIiBvbiBiZWhhbGYgb2YgYW4gb3JpZ2luYWxcbiAqIEZlZGVyYXRlZEV2ZW50IG9yIG5hdGl2ZSBFdmVudC5cbiAqL1xudmFyIEZlZGVyYXRlZEV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCBib3VuZGFyeSB3aGljaCBtYW5hZ2VzIHRoaXMgZXZlbnQuIFByb3BhZ2F0aW9uIGNhbiBvbmx5IG9jY3VyXG4gICAqICB3aXRoaW4gdGhlIGJvdW5kYXJ5J3MganVyaXNkaWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gRmVkZXJhdGVkRXZlbnQobWFuYWdlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGZWRlcmF0ZWRFdmVudCk7XG4gICAgLyoqXG4gICAgICogVGhlIHByb3BhZ2F0aW9uIHBoYXNlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2V2ZW50UGhhc2VcbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50UGhhc2UgPSBGZWRlcmF0ZWRFdmVudC5wcm90b3R5cGUuTk9ORTtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FdmVudC9idWJibGVzXG4gICAgICovXG4gICAgdGhpcy5idWJibGVzID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FdmVudC9jYW5jZWxCdWJibGVcbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnQvY2FuY2VsYWJsZVxuICAgICAqL1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHRoZSBkZWZhdWx0IHJlc3BvbnNlIG9mIHRoZSB1c2VyIGFnZW50IHdhcyBwcmV2ZW50IHRocm91Z2ggdGhpcyBldmVudC4gKi9cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAvKiogRmxhZ3Mgd2hldGhlciBwcm9wYWdhdGlvbiB3YXMgc3RvcHBlZC4gKi9cbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHByb3BhZ2F0aW9uIHdhcyBpbW1lZGlhdGVseSBzdG9wcGVkLiAqL1xuICAgIHRoaXMucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGV2bmV0IHJlbGF0aXZlIHRvIHRoZSBuZWFyZXN0IERPTSBsYXllci5cbiAgICAgKiBUaGlzIGlzIGEgbm9uLXN0YW5kYXJkIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMubGF5ZXIgPSBuZXcgUG9pbnQoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSBET00gZG9jdW1lbnQuXG4gICAgICogVGhpcyBpcyBhIG5vbi1zdGFuZGFyZCBwcm9wZXJ0eS5cbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgRE9NIGRvY3VtZW50LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvcGFnZVhcbiAgICAgKi9cbiAgICB0aGlzLnBhZ2UgPSBuZXcgUG9pbnQoKTtcbiAgICAvKipcbiAgICAgKiByZWxhdGl2ZSB0byBDYW52YXMsIG9yaWdpbiBpcyBsZWZ0LXRvcFxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gbmV3IFBvaW50KCk7XG4gICAgLyoqXG4gICAgICogcmVsYXRpdmUgdG8gVmlld3BvcnQsIGFjY291bnQgZm9yIENhbWVyYVxuICAgICAqL1xuICAgIHRoaXMudmlld3BvcnQgPSBuZXcgUG9pbnQoKTtcbiAgICB0aGlzLmNvbXBvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5OT05FID0gMDtcbiAgICB0aGlzLkNBUFRVUklOR19QSEFTRSA9IDE7XG4gICAgdGhpcy5BVF9UQVJHRVQgPSAyO1xuICAgIHRoaXMuQlVCQkxJTkdfUEhBU0UgPSAzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhGZWRlcmF0ZWRFdmVudCwgW3tcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBldmVudCwgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzpcbiAgICAgKiAqIHBvaW50ZXJkb3duXG4gICAgICogKiB0b3VjaHN0YXJ0XG4gICAgICogKiBtb3VzZWRvd25cbiAgICAgKiAqIHJpZ2h0ZG93blxuICAgICAqICogLi4uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxheWVyWFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXIueDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGF5ZXJZXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllci55O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlWFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZS54O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlWVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZS55O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMueDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbnZhc1hcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy54O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW52YXNZXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMueTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnRYXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC54O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3cG9ydFlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0Lnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvc2VkUGF0aFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9wYWdhdGlvbiBwYXRoIGZvciB0aGlzIGV2ZW50XG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvRXZlbnQvY29tcG9zZWRQYXRoXG4gICAgICpcbiAgICAgKiBTbyBjb21wb3NlZFBhdGgoKVswXSByZXByZXNlbnRzIHRoZSBvcmlnaW5hbCB0YXJnZXQuXG4gICAgICogQHNlZSBodHRwczovL3BvbHltZXItbGlicmFyeS5wb2x5bWVyLXByb2plY3Qub3JnLzMuMC9kb2NzL2Rldmd1aWRlL2V2ZW50cyNyZXRhcmdldGluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgIGlmICh0aGlzLm1hbmFnZXIgJiYgKCF0aGlzLnBhdGggfHwgdGhpcy5wYXRoWzBdICE9PSB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gdGhpcy50YXJnZXQgPyB0aGlzLm1hbmFnZXIucHJvcGFnYXRpb25QYXRoKHRoaXMudGFyZ2V0KSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcm9wYWdhdGlvblBhdGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvc2VkUGF0aCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0V2ZW50L3ByZXZlbnREZWZhdWx0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicHJldmVudERlZmF1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICBpZiAodGhpcy5uYXRpdmVFdmVudCBpbnN0YW5jZW9mIEV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICB0aGlzLm5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0V2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FdmVudC9zdG9wUHJvcGFnYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdG9wUHJvcGFnYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VJRXZlbnQvdmlld1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRFdmVudFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIGFkZGVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRE9NIEV2ZW50LFxuICAgICAqIGRlcHJlY2F0ZWQgcHJvcHMgYW5kIG1ldGhvZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RXZlbnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImluaXRVSUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRVSUV2ZW50KCkge31cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBGZWRlcmF0ZWRNb3VzZUV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfcmVmKSB7XG4gIGZ1bmN0aW9uIEZlZGVyYXRlZE1vdXNlRXZlbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGZWRlcmF0ZWRNb3VzZUV2ZW50KTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBGZWRlcmF0ZWRNb3VzZUV2ZW50LCBbXS5jb25jYXQoYXJncykpO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBcImFsdFwiIGtleSB3YXMgcHJlc3NlZCB3aGVuIHRoaXMgbW91c2UgZXZlbnQgb2NjdXJyZWQuICovXG4gICAgLyoqIFRoZSBzcGVjaWZpYyBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCBpbiB0aGlzIG1vdXNlIGV2ZW50LiAqL1xuICAgIC8qKiBUaGUgYnV0dG9uIGRlcHJlc3NlZCB3aGVuIHRoaXMgZXZlbnQgb2NjdXJyZWQuICovXG4gICAgLyoqIFdoZXRoZXIgdGhlIFwiY29udHJvbFwiIGtleSB3YXMgcHJlc3NlZCB3aGVuIHRoaXMgbW91c2UgZXZlbnQgb2NjdXJyZWQuICovXG4gICAgLyoqIFdoZXRoZXIgdGhlIFwibWV0YVwiIGtleSB3YXMgcHJlc3NlZCB3aGVuIHRoaXMgbW91c2UgZXZlbnQgb2NjdXJyZWQuICovXG4gICAgLyoqIFRoaXMgaXMgY3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8qKiBXaGV0aGVyIHRoZSBcInNoaWZ0XCIga2V5IHdhcyBwcmVzc2VkIHdoZW4gdGhpcyBtb3VzZSBldmVudCBvY2N1cnJlZC4gKi9cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3RoaXMuY2xpZW50ID0gbmV3IFBvaW50KCk7XG4gICAgLyoqXG4gICAgICogVGhlIG1vdmVtZW50IGluIHRoaXMgcG9pbnRlciByZWxhdGl2ZSB0byB0aGUgbGFzdCBgbW91c2Vtb3ZlYCBldmVudC5cbiAgICAgKi9cbiAgICBfdGhpcy5tb3ZlbWVudCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgb2YgdGhlIHBvaW50ZXIgY29vcmRpbmF0ZXMgdy5yLnQuIHRhcmdldCBEaXNwbGF5T2JqZWN0IGluIHdvcmxkIHNwYWNlLiBUaGlzIGlzXG4gICAgICogbm90IHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICAgICAqL1xuICAgIF90aGlzLm9mZnNldCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHdvcmxkIHNwYWNlLlxuICAgICAqL1xuICAgIF90aGlzLmdsb2JhbCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHNjZWVuIHNwYWNlLlxuICAgICAqL1xuICAgIF90aGlzLnNjcmVlbiA9IG5ldyBQb2ludCgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoRmVkZXJhdGVkTW91c2VFdmVudCwgX3JlZik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRmVkZXJhdGVkTW91c2VFdmVudCwgW3tcbiAgICBrZXk6IFwiY2xpZW50WFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Lng7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsaWVudFlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC55O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlbWVudFhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdmVtZW50Lng7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVtZW50WVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubW92ZW1lbnQueTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0WFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9mZnNldFlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldC55O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnbG9iYWxYXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nbG9iYWwueDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2xvYmFsWVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcmVlblhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcmVlbi54O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JlZW5ZXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JlZW4ueTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TW9kaWZpZXJTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RpZmllclN0YXRlKGtleSkge1xuICAgICAgcmV0dXJuICdnZXRNb2RpZmllclN0YXRlJyBpbiB0aGlzLm5hdGl2ZUV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0TW91c2VFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TW91c2VFdmVudCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9XSk7XG59KEZlZGVyYXRlZEV2ZW50KTtcblxuLy8gQHRzLWlnbm9yZVxudmFyIEZlZGVyYXRlZFBvaW50ZXJFdmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ZlZGVyYXRlZE1vdXNlRXZlbnQpIHtcbiAgZnVuY3Rpb24gRmVkZXJhdGVkUG9pbnRlckV2ZW50KCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmVkZXJhdGVkUG9pbnRlckV2ZW50KTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBGZWRlcmF0ZWRQb2ludGVyRXZlbnQsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBwb2ludGVyLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L3BvaW50ZXJJZFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgcG9pbnRlcidzIGNvbnRhY3QgYWxvbmcgdGhlIHgtYXhpcywgbWVhc3VyZWQgaW4gQ1NTIHBpeGVscy5cbiAgICAgKiByYWRpdXNYIG9mIFRvdWNoRXZlbnRzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BvaW50ZXJFdmVudC93aWR0aFxuICAgICAqL1xuICAgIF90aGlzLndpZHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwb2ludGVyJ3MgY29udGFjdCBhbG9uZyB0aGUgeS1heGlzLCBtZWFzdXJlZCBpbiBDU1MgcGl4ZWxzLlxuICAgICAqIHJhZGl1c1kgb2YgVG91Y2hFdmVudHMgd2lsbCBiZSByZXByZXNlbnRlZCBieSB0aGlzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L2hlaWdodFxuICAgICAqL1xuICAgIF90aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBwb2ludGVyIGRldmljZSB0aGF0IGNyZWF0ZWQgdGhlIGV2ZW50IGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvaXNQcmltYXJ5XG4gICAgICovXG4gICAgX3RoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhGZWRlcmF0ZWRQb2ludGVyRXZlbnQsIF9GZWRlcmF0ZWRNb3VzZUV2ZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhGZWRlcmF0ZWRQb2ludGVyRXZlbnQsIFt7XG4gICAga2V5OiBcImdldENvYWxlc2NlZEV2ZW50c1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L3BvaW50ZXJUeXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBQcmVzc3VyZSBhcHBsaWVkIGJ5IHRoZSBwb2ludGluZyBkZXZpY2UgZHVyaW5nIHRoZSBldmVudC5cbiAgICAgKnNcbiAgICAgKiBBIFRvdWNoJ3MgZm9yY2UgcHJvcGVydHkgd2lsbCBiZSByZXByZXNlbnRlZCBieSB0aGlzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L3ByZXNzdXJlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBCYXJyZWwgcHJlc3N1cmUgb24gYSBzdHlsdXMgcG9pbnRlci5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3BvaW50ZXJldmVudHMvI3BvaW50ZXJldmVudC1pbnRlcmZhY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmdsZSwgaW4gZGVncmVlcywgYmV0d2VlbiB0aGUgcG9pbnRlciBkZXZpY2UgYW5kIHRoZSBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvdGlsdFhcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmdsZSwgaW4gZGVncmVlcywgYmV0d2VlbiB0aGUgcG9pbnRlciBkZXZpY2UgYW5kIHRoZSBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvdGlsdFlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFR3aXN0IG9mIGEgc3R5bHVzIHBvaW50ZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9wb2ludGVyZXZlbnRzLyNwb2ludGVyZXZlbnQtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvZ2V0Q29hbGVzY2VkRXZlbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29hbGVzY2VkRXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3BvaW50ZXJtb3ZlJyB8fCB0aGlzLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHRoaXMudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNTc2NTU2OTY1NTYwMzIwMFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFByZWRpY3RlZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcmVkaWN0ZWRFdmVudHMoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFByZWRpY3RlZEV2ZW50cyBpcyBub3Qgc3VwcG9ydGVkIScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudHZpcy9HL2lzc3Vlcy8xMTE1XG4gICAgICogV2UgY3VycmVudGx5IHJldXNlcyBldmVudCBvYmplY3RzIGluIHRoZSBldmVudCBzeXN0ZW0sXG4gICAgICogYXZvaWRpbmcgdGhlIGNyZWF0aW9uIG9mIGEgbGFyZ2UgbnVtYmVyIG9mIGV2ZW50IG9iamVjdHMuXG4gICAgICogUmV1c2VkIG9iamVjdHMgYXJlIG9ubHkgdXNlZCB0byBjYXJyeSBkaWZmZXJlbnQgZGF0YSxcbiAgICAgKiBzdWNoIGFzIGNvb3JkaW5hdGUgaW5mb3JtYXRpb24sIG5hdGl2ZSBldmVudCBvYmplY3RzLFxuICAgICAqIGFuZCB0aGVyZWZvcmUgdGhlIGxpZmVjeWNsZSBpcyBsaW1pdGVkIHRvIHRoZSBldmVudCBoYW5kbGVyLFxuICAgICAqIHdoaWNoIGNhbiBsZWFkIHRvIHVuaW50ZW5kZWQgY29uc2VxdWVuY2VzIGlmIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBjYWNoZSB0aGUgZW50aXJlIGV2ZW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoZXJlZm9yZSwgd2hpbGUga2VlcGluZyB0aGUgYWJvdmUgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbnMgaW4gbWluZCwgaXQgaXMgcG9zc2libGUgdG8gcHJvdmlkZSBhIGNsb25lIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSBuZXcgb2JqZWN0IHdoZW4gdGhlIHVzZXIgcmVhbGx5IHdhbnRzIHRvIGNhY2hlIGl0LCBlLmcuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNsb25lUG9pbnRlckV2ZW50KHRoaXMpO1xuICAgIH1cbiAgfV0pO1xufShGZWRlcmF0ZWRNb3VzZUV2ZW50KTtcblxuLy8gQHRzLWlnbm9yZVxudmFyIEZlZGVyYXRlZFdoZWVsRXZlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9GZWRlcmF0ZWRNb3VzZUV2ZW50KSB7XG4gIGZ1bmN0aW9uIEZlZGVyYXRlZFdoZWVsRXZlbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZlZGVyYXRlZFdoZWVsRXZlbnQpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEZlZGVyYXRlZFdoZWVsRXZlbnQsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEZlZGVyYXRlZFdoZWVsRXZlbnQsIF9GZWRlcmF0ZWRNb3VzZUV2ZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhGZWRlcmF0ZWRXaGVlbEV2ZW50LCBbe1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFRoZSB1bml0cyBvZiBgZGVsdGFYYCwgYGRlbHRhWWAsIGFuZCBgZGVsdGFaYC4gVGhpcyBpcyBvbmUgb2YgYERPTV9ERUxUQV9MSU5FYCxcbiAgICAgKiBgRE9NX0RFTFRBX1BBR0VgLCBgRE9NX0RFTFRBX1BJWEVMYC5cbiAgICAgKi9cblxuICAgIC8qKiBIb3Jpem9udGFsIHNjcm9sbCBhbW91bnQgKi9cblxuICAgIC8qKiBWZXJ0aWNhbCBzY3JvbGwgYW1vdW50ICovXG5cbiAgICAvKiogei1heGlzIHNjcm9sbCBhbW91bnQuICovXG5cbiAgICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuY2xvbmVXaGVlbEV2ZW50KHRoaXMpO1xuICAgIH1cbiAgfV0pO1xufShGZWRlcmF0ZWRNb3VzZUV2ZW50KTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy9DcmVhdGluZ19hbmRfdHJpZ2dlcmluZ19ldmVudHNcbiAqXG4gKiBAZXhhbXBsZVxuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnYnVpbGQnLCB7IGRldGFpbDogeyBwcm9wMTogJ3h4JyB9IH0pO1xuICBjaXJjbGUuYWRkRXZlbnRMaXN0ZW5lcignYnVpbGQnLCAoZSkgPT4ge1xuICAgIGUudGFyZ2V0OyAvLyBjaXJjbGVcbiAgICBlLmRldGFpbDsgLy8geyBwcm9wMTogJ3h4JyB9XG4gIH0pO1xuXG4gIGNpcmNsZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAqL1xudmFyIEN1c3RvbUV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRmVkZXJhdGVkRXZlbnQpIHtcbiAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBvYmplY3QpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbUV2ZW50KTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ3VzdG9tRXZlbnQsIFtudWxsXSk7XG4gICAgX3RoaXMudHlwZSA9IGV2ZW50TmFtZTtcbiAgICBfdGhpcy5kZXRhaWwgPSBvYmplY3Q7XG5cbiAgICAvLyBjb21wYXRpYmxlIHdpdGggRyAzLjBcbiAgICBPYmplY3QuYXNzaWduKF90aGlzLCBvYmplY3QpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQ3VzdG9tRXZlbnQsIF9GZWRlcmF0ZWRFdmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ3VzdG9tRXZlbnQpO1xufShGZWRlcmF0ZWRFdmVudCk7XG5cbnZhciBDQU5WQVNfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIE9iamVjdHMgdGhhdCBjYW4gcmVjZWl2ZSBldmVudHMgYW5kIG1heSBoYXZlIGxpc3RlbmVycyBmb3IgdGhlbS5cbiAqIGVnLiBFbGVtZW50LCBDYW52YXMsIERpc3BsYXlPYmplY3RcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0XG4gKi9cbnZhciBFdmVudFRhcmdldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudFRhcmdldCk7XG4gICAgLyoqXG4gICAgICogZXZlbnQgZW1pdHRlclxuICAgICAqL1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV2ZW50VGFyZ2V0LCBbe1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQGFsaWFzIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzdXBwb3J0IGBjYXB0dXJlYCAmIGBvbmNlYCBpbiBvcHRpb25zXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgdmFyIGNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIHZhciBvbmNlID0gZmFsc2U7XG4gICAgICBpZiAoaXNCb29sZWFuKG9wdGlvbnMpKSBjYXB0dXJlID0gb3B0aW9ucztlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyRjYXB0dXJlID0gb3B0aW9ucy5jYXB0dXJlO1xuICAgICAgICBjYXB0dXJlID0gX29wdGlvbnMkY2FwdHVyZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRjYXB0dXJlO1xuICAgICAgICB2YXIgX29wdGlvbnMkb25jZSA9IG9wdGlvbnMub25jZTtcbiAgICAgICAgb25jZSA9IF9vcHRpb25zJG9uY2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkb25jZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlKSB0eXBlICs9ICdjYXB0dXJlJztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGxpc3RlbmVyID0gaXNGdW5jdGlvbihsaXN0ZW5lcikgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgICAgdmFyIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGxpc3RlbmVyKSA/IHVuZGVmaW5lZCA6IGxpc3RlbmVyO1xuICAgICAgaWYgKG9uY2UpIHRoaXMuZW1pdHRlci5vbmNlKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtlbHNlIHRoaXMuZW1pdHRlci5vbih0eXBlLCBsaXN0ZW5lciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYWxpYXMgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9mZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMkZW1pdHRlcjtcbiAgICAgIChfdGhpcyRlbWl0dGVyID0gdGhpcy5lbWl0dGVyKSA9PT0gbnVsbCB8fCBfdGhpcyRlbWl0dGVyID09PSB2b2lkIDAgfHwgX3RoaXMkZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX2xpc3RlbmVyO1xuICAgICAgaWYgKCF0aGlzLmVtaXR0ZXIpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGNhcHR1cmUgPSBpc0Jvb2xlYW4ob3B0aW9ucykgPyBvcHRpb25zIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHR1cmU7XG4gICAgICBpZiAoY2FwdHVyZSkgdHlwZSArPSAnY2FwdHVyZSc7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBsaXN0ZW5lciA9IGlzRnVuY3Rpb24obGlzdGVuZXIpID8gbGlzdGVuZXIgOiAoX2xpc3RlbmVyID0gbGlzdGVuZXIpID09PSBudWxsIHx8IF9saXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgICAgdmFyIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGxpc3RlbmVyKSA/IHVuZGVmaW5lZCA6IGxpc3RlbmVyO1xuICAgICAgdGhpcy5lbWl0dGVyLm9mZih0eXBlLCBsaXN0ZW5lciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYWxpYXMgZGlzcGF0Y2hFdmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIG9iamVjdCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIG9iamVjdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGUpIHtcbiAgICAgIHZhciBza2lwUHJvcGFnYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBjYW52YXMgPSBDQU5WQVNfQ0FDSEUuZ2V0KHRoaXMpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdmFyIF9vd25lckRvY3VtZW50O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvY3VtZW50IG1heSBiZSBkZWZpbmVkIGluIGluaGVyaXRlZCBjbGFzc1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCkgY2FudmFzID0gdGhpcztcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZhdWx0VmlldyBtYXkgYmUgZGVmaW5lZCBpbiBpbmhlcml0ZWQgY2xhc3NcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWZhdWx0VmlldykgY2FudmFzID0gdGhpcy5kZWZhdWx0VmlldztlbHNlIGNhbnZhcyA9IChfb3duZXJEb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX293bmVyRG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICBpZiAoY2FudmFzKSBDQU5WQVNfQ0FDSEUuc2V0KHRoaXMsIGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGUubWFuYWdlciA9IGNhbnZhcy5nZXRFdmVudFNlcnZpY2UoKTtcbiAgICAgICAgaWYgKCFlLm1hbmFnZXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZS5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChlLnBhdGgpIGUucGF0aC5sZW5ndGggPSAwO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsc2UgZS5wYWdlID0gW107XG4gICAgICAgIGlmICghc2tpcFByb3BhZ2F0ZSkgZS50YXJnZXQgPSB0aGlzO1xuICAgICAgICBlLm1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLCBlLnR5cGUsIHNraXBQcm9wYWdhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSEFDSyBGaXhlZCB0aGUgaXNzdWUgdGhhdCBhZnRlciBhbiBlbGVtZW50IGxlYXZlcyB0aGUgRE9NIHRyZWUsIHRoZXJlIGlzIG5vIGFzc29jaWF0ZWQgY2FudmFzLFxuICAgICAgICAvLyB3aGljaCBjYXVzZXMgdGhlIHJlbW92ZWQgYW5kIGRlc3Ryb3kgZXZlbnRzIHRvIG5vdCBiZSB0cmlnZ2VyZWRcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZS50eXBlLCBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhZS5kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVcbiAqL1xudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBOb2RlKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgTm9kZSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfdGhpcy5zaGFkb3cgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBwb2ludHMgdG8gY2FudmFzLmRvY3VtZW50XG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9vd25lckRvY3VtZW50XG4gICAgICovXG4gICAgX3RoaXMub3duZXJEb2N1bWVudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvTm9kZS9pc0Nvbm5lY3RlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICAgIGNpcmNsZS5pc0Nvbm5lY3RlZDsgLy8gZmFsc2VcbiAgICAgICAgY2FudmFzLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gICAgICAgIGNpcmNsZS5pc0Nvbm5lY3RlZDsgLy8gdHJ1ZVxuICAgICAqL1xuICAgIF90aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBub2RlJ3Mgbm9kZSBkb2N1bWVudCdzIGRvY3VtZW50IGJhc2UgVVJMLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL05vZGVcbiAgICAgKi9cbiAgICBfdGhpcy5iYXNlVVJJID0gJyc7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGRyZW4uXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9jaGlsZE5vZGVzXG4gICAgICovXG4gICAgX3RoaXMuY2hpbGROb2RlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGVcbiAgICAgKi9cbiAgICBfdGhpcy5ub2RlVHlwZSA9IDA7XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvTm9kZS9ub2RlTmFtZVxuICAgICAqL1xuICAgIF90aGlzLm5vZGVOYW1lID0gJyc7XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvTm9kZS9ub2RlVmFsdWVcbiAgICAgKi9cbiAgICBfdGhpcy5ub2RlVmFsdWUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BhcmVudE5vZGVcbiAgICAgKi9cbiAgICBfdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKE5vZGUsIF9FdmVudFRhcmdldCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICBrZXk6IFwidGV4dENvbnRlbnRcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvTm9kZS90ZXh0Q29udGVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBvdXQgPSAnJztcbiAgICAgIGlmICh0aGlzLm5vZGVOYW1lID09PSBTaGFwZS5URVhUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgb3V0ICs9IHRoaXMuc3R5bGUudGV4dDtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNoaWxkTm9kZXMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9jaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChfY2hpbGQubm9kZU5hbWUgPT09IFNoYXBlLlRFWFQpIHtcbiAgICAgICAgICAgIG91dCArPSBfY2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gX2NoaWxkLnRleHRDb250ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNvbnRlbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgLy8gcmVtb3ZlIGFsbCBjaGlsZHJlblxuICAgICAgdGhpcy5jaGlsZE5vZGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgX3RoaXMyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMubm9kZU5hbWUgPT09IFNoYXBlLlRFWFQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnN0eWxlLnRleHQgPSBcIlwiLmNvbmNhdChjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9Ob2RlL2dldFJvb3ROb2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Um9vdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdE5vZGUoKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUuZ2V0Um9vdE5vZGUob3B0cyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5jb21wb3NlZCAmJiB0aGlzLmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5nZXRSb290Tm9kZShvcHRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNDaGlsZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NoaWxkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRGVmYXVsdE5hbWVzcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RlZmF1bHROYW1lc3BhY2UobmFtZXNwYWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb29rdXBOYW1lc3BhY2VVUklcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9va3VwTmFtZXNwYWNlVVJJKHByZWZpeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9va3VwUHJlZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvb2t1cFByZWZpeChuYW1lc3BhY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vcm1hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL05vZGUvaXNFcXVhbE5vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc0VxdWFsTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsTm9kZShvdGhlck5vZGUpIHtcbiAgICAgIC8vIFRPRE86IGNvbXBhcmUgMiBub2Rlcywgbm90IHNhbWVuZXNzXG4gICAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXJOb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1NhbWVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2FtZU5vZGUob3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VxdWFsTm9kZShvdGhlck5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJlbnRcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYWxpYXMgcGFyZW50Tm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudEVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0U2libGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID4gMCA/IHRoaXMuY2hpbGROb2Rlc1swXSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggPiAwID8gdGhpcy5jaGlsZE5vZGVzW3RoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ItZnV6ZS9kZW5vLWRvbS9ibG9iL21hc3Rlci9zcmMvZG9tL25vZGUudHMjTDMzOFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgICAgLy8gc2FtZSBub2RlXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiAoIShvdGhlciBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICAvLyAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAvLyAgICAgJ05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb246IEFyZ3VtZW50IDEgZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBOb2RlLicsXG4gICAgICAvLyAgICk7XG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBub2RlMVJvb3QgPSBvdGhlcjtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgdmFyIG5vZGUyUm9vdCA9IHRoaXM7XG4gICAgICB2YXIgbm9kZTFIaWVyYXJjaHkgPSBbbm9kZTFSb290XTtcbiAgICAgIHZhciBub2RlMkhpZXJhcmNoeSA9IFtub2RlMlJvb3RdO1xuICAgICAgd2hpbGUgKChfbm9kZTFSb290JHBhcmVudE5vZGUgPSBub2RlMVJvb3QucGFyZW50Tm9kZSkgIT09IG51bGwgJiYgX25vZGUxUm9vdCRwYXJlbnROb2RlICE9PSB2b2lkIDAgPyBfbm9kZTFSb290JHBhcmVudE5vZGUgOiBub2RlMlJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgX25vZGUxUm9vdCRwYXJlbnROb2RlO1xuICAgICAgICBub2RlMVJvb3QgPSBub2RlMVJvb3QucGFyZW50Tm9kZSA/IChub2RlMUhpZXJhcmNoeS5wdXNoKG5vZGUxUm9vdC5wYXJlbnROb2RlKSwgbm9kZTFSb290LnBhcmVudE5vZGUpIDogbm9kZTFSb290O1xuICAgICAgICBub2RlMlJvb3QgPSBub2RlMlJvb3QucGFyZW50Tm9kZSA/IChub2RlMkhpZXJhcmNoeS5wdXNoKG5vZGUyUm9vdC5wYXJlbnROb2RlKSwgbm9kZTJSb290LnBhcmVudE5vZGUpIDogbm9kZTJSb290O1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGV5IGRvbid0IHNoYXJlIHRoZSBzYW1lIHJvb3Qgbm9kZVxuICAgICAgaWYgKG5vZGUxUm9vdCAhPT0gbm9kZTJSb290KSB7XG4gICAgICAgIHJldHVybiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRCB8IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fSU1QTEVNRU5UQVRJT05fU1BFQ0lGSUMgfCBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORztcbiAgICAgIH1cbiAgICAgIHZhciBsb25nZXJIaWVyYXJjaHkgPSBub2RlMUhpZXJhcmNoeS5sZW5ndGggPiBub2RlMkhpZXJhcmNoeS5sZW5ndGggPyBub2RlMUhpZXJhcmNoeSA6IG5vZGUySGllcmFyY2h5O1xuICAgICAgdmFyIHNob3J0ZXJIaWVyYXJjaHkgPSBsb25nZXJIaWVyYXJjaHkgPT09IG5vZGUxSGllcmFyY2h5ID8gbm9kZTJIaWVyYXJjaHkgOiBub2RlMUhpZXJhcmNoeTtcblxuICAgICAgLy8gQ2hlY2sgaWYgZWl0aGVyIGlzIGEgY29udGFpbmVyIG9mIHRoZSBvdGhlclxuICAgICAgaWYgKGxvbmdlckhpZXJhcmNoeVtsb25nZXJIaWVyYXJjaHkubGVuZ3RoIC0gc2hvcnRlckhpZXJhcmNoeS5sZW5ndGhdID09PSBzaG9ydGVySGllcmFyY2h5WzBdKSB7XG4gICAgICAgIHJldHVybiBsb25nZXJIaWVyYXJjaHkgPT09IG5vZGUxSGllcmFyY2h5ID9cbiAgICAgICAgLy8gb3RoZXIgaXMgYSBjaGlsZCBvZiB0aGlzXG4gICAgICAgIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZIHwgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgOlxuICAgICAgICAvLyB0aGlzIGlzIGEgY2hpbGQgb2Ygb3RoZXJcbiAgICAgICAgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyB8IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZWlyIGZpcnN0IGNvbW1vbiBhbmNlc3RvciBhbmQgc2VlIHdoZXRoZXIgdGhleVxuICAgICAgLy8gYXJlIHByZWNlZGluZyBvciBmb2xsb3dpbmdcbiAgICAgIHZhciBsb25nZXJTdGFydCA9IGxvbmdlckhpZXJhcmNoeS5sZW5ndGggLSBzaG9ydGVySGllcmFyY2h5Lmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSBzaG9ydGVySGllcmFyY2h5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBzaG9ydGVySGllcmFyY2h5Tm9kZSA9IHNob3J0ZXJIaWVyYXJjaHlbaV07XG4gICAgICAgIHZhciBsb25nZXJIaWVyYXJjaHlOb2RlID0gbG9uZ2VySGllcmFyY2h5W2xvbmdlclN0YXJ0ICsgaV07XG5cbiAgICAgICAgLy8gV2UgZm91bmQgdGhlIGZpcnN0IGNvbW1vbiBhbmNlc3RvclxuICAgICAgICBpZiAobG9uZ2VySGllcmFyY2h5Tm9kZSAhPT0gc2hvcnRlckhpZXJhcmNoeU5vZGUpIHtcbiAgICAgICAgICB2YXIgc2libGluZ3MgPSBzaG9ydGVySGllcmFyY2h5Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgaWYgKHNpYmxpbmdzLmluZGV4T2Yoc2hvcnRlckhpZXJhcmNoeU5vZGUpIDwgc2libGluZ3MuaW5kZXhPZihsb25nZXJIaWVyYXJjaHlOb2RlKSkge1xuICAgICAgICAgICAgLy8gU2hvcnRlciBpcyBiZWZvcmUgbG9uZ2VyXG4gICAgICAgICAgICBpZiAoc2hvcnRlckhpZXJhcmNoeSA9PT0gbm9kZTFIaWVyYXJjaHkpIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXIgaXMgYmVmb3JlIHRoaXNcbiAgICAgICAgICAgICAgcmV0dXJuIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWZvcmUgb3RoZXJcbiAgICAgICAgICAgIHJldHVybiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTG9uZ2VyIGlzIGJlZm9yZSBzaG9ydGVyXG4gICAgICAgICAgaWYgKGxvbmdlckhpZXJhcmNoeSA9PT0gbm9kZTFIaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIC8vIE90aGVyIGlzIGJlZm9yZSB0aGlzXG4gICAgICAgICAgICByZXR1cm4gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE90aGVyIGlzIGFmdGVyIHRoaXNcbiAgICAgICAgICByZXR1cm4gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL2Nsb25lTm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbnRhaW5cIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBhbGlhcyBjb250YWluc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKG90aGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGFpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnMob3RoZXIpIHtcbiAgICAgIC8vIHRoZSBub2RlIGl0c2VsZiwgb25lIG9mIGl0cyBkaXJlY3QgY2hpbGRyZW5cbiAgICAgIHZhciB0bXAgPSBvdGhlcjtcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvY29udGFpbnNcbiAgICAgIHdoaWxlICh0bXAgJiYgdGhpcyAhPT0gdG1wKSB7XG4gICAgICAgIHRtcCA9IHRtcC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhdG1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbmNlc3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbmNlc3RvcihuKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgIHZhciB0ZW1wID0gdGhpcztcbiAgICAgIHdoaWxlIChuID4gMCAmJiB0ZW1wKSB7XG4gICAgICAgIHRlbXAgPSB0ZW1wLnBhcmVudE5vZGU7XG4gICAgICAgIG4tLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgIHZhciBzdGFjayA9IFt0aGlzXTtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTm9kZSh0YXJnZXQpIHtcbiAgICAgIHJldHVybiAhIXRhcmdldC5jaGlsZE5vZGVzO1xuICAgIH1cbiAgfV0pO1xufShFdmVudFRhcmdldCk7XG4vKipcbiAqIEJvdGggbm9kZXMgYXJlIGluIGRpZmZlcmVudCBkb2N1bWVudHMgb3IgZGlmZmVyZW50IHRyZWVzIGluIHRoZSBzYW1lIGRvY3VtZW50LlxuICovXG5Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRCA9IDE7XG4vKipcbiAqIG90aGVyTm9kZSBwcmVjZWRlcyB0aGUgbm9kZSBpbiBlaXRoZXIgYSBwcmUtb3JkZXIgZGVwdGgtZmlyc3QgdHJhdmVyc2FsXG4gKiBvZiBhIHRyZWUgY29udGFpbmluZyBib3RoIChlLmcuLCBhcyBhbiBhbmNlc3RvciBvciBwcmV2aW91cyBzaWJsaW5nIG9yIGEgZGVzY2VuZGFudCBvZiBhIHByZXZpb3VzIHNpYmxpbmcgb3IgcHJldmlvdXMgc2libGluZyBvZiBhbiBhbmNlc3Rvcikgb3IgKGlmIHRoZXkgYXJlIGRpc2Nvbm5lY3RlZCkgaW4gYW4gYXJiaXRyYXJ5IGJ1dCBjb25zaXN0ZW50IG9yZGVyaW5nLlxuICovXG5Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyA9IDI7XG4vKipcbiAqIG90aGVyTm9kZSBmb2xsb3dzIHRoZSBub2RlIGluIGVpdGhlciBhIHByZS1vcmRlciBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgYSB0cmVlIGNvbnRhaW5pbmcgYm90aCAoZS5nLiwgYXMgYSBkZXNjZW5kYW50IG9yIGZvbGxvd2luZyBzaWJsaW5nIG9yIGEgZGVzY2VuZGFudCBvZiBhIGZvbGxvd2luZyBzaWJsaW5nIG9yIGZvbGxvd2luZyBzaWJsaW5nIG9mIGFuIGFuY2VzdG9yKSBvciAoaWYgdGhleSBhcmUgZGlzY29ubmVjdGVkKSBpbiBhbiBhcmJpdHJhcnkgYnV0IGNvbnNpc3RlbnQgb3JkZXJpbmcuXG4gKi9cbk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HID0gNDtcbi8qKlxuICogb3RoZXJOb2RlIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBub2RlLlxuICovXG5Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TID0gODtcbi8qKlxuICogb3RoZXJOb2RlIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgbm9kZS5cbiAqL1xuTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgPSAxNjtcbi8qKlxuICogVGhlIHJlc3VsdCByZWxpZXMgdXBvbiBhcmJpdHJhcnkgYW5kL29yIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIGJlaGF2aW9yIGFuZCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBwb3J0YWJsZS5cbiAqL1xuTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQyA9IDMyO1xuXG52YXIgUFJPUEFHQVRJT05fTElNSVQgPSAyMDQ4O1xudmFyIEV2ZW50U2VydmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50U2VydmljZShnbG9iYWxSdW50aW1lLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRTZXJ2aWNlKTtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBIVE1MIGVsZW1lbnRzIGluIGN1cnJlbnQgY2FudmFzLlxuICAgICAqL1xuICAgIHRoaXMubmF0aXZlSFRNTE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5tYXBwaW5nVGFibGUgPSB7fTtcbiAgICB0aGlzLm1hcHBpbmdTdGF0ZSA9IHtcbiAgICAgIHRyYWNraW5nRGF0YToge31cbiAgICB9O1xuICAgIHRoaXMuZXZlbnRQb29sID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudG1wTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICB0aGlzLnRtcFZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHRoaXMub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIChmcm9tKSB7XG4gICAgICB2YXIgZSA9IF90aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZSwgJ3BvaW50ZXJkb3duJyk7XG4gICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGUsICd0b3VjaHN0YXJ0Jyk7XG4gICAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlLCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0ZG93bicgOiAnbW91c2Vkb3duJyk7XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tpbmdEYXRhID0gX3RoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICAgIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgX3RoaXMuZnJlZUV2ZW50KGUpO1xuICAgIH07XG4gICAgdGhpcy5vblBvaW50ZXJVcCA9IGZ1bmN0aW9uIChmcm9tKSB7XG4gICAgICB2YXIgbm93ID0gY2xvY2subm93KCk7XG4gICAgICB2YXIgZSA9IF90aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgX3RoaXMuY29udGV4dC5jb25maWcuYWx3YXlzVHJpZ2dlclBvaW50ZXJFdmVudE9uQ2FudmFzID8gX3RoaXMucm9vdFRhcmdldCA6IHVuZGVmaW5lZCk7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGUsICdwb2ludGVydXAnKTtcbiAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZSwgJ3RvdWNoZW5kJyk7XG4gICAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlLCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0dXAnIDogJ21vdXNldXAnKTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFja2luZ0RhdGEgPSBfdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgICAgdmFyIHByZXNzVGFyZ2V0ID0gX3RoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSk7XG4gICAgICB2YXIgY2xpY2tUYXJnZXQgPSBwcmVzc1RhcmdldDtcblxuICAgICAgLy8gcG9pbnRlcnVwb3V0c2lkZSBvbmx5IGJ1YmJsZXMuIEl0IG9ubHkgYnViYmxlcyB1cHRvIHRoZSBwYXJlbnQgdGhhdCBkb2Vzbid0IGNvbnRhaW5cbiAgICAgIC8vIHRoZSBwb2ludGVydXAgbG9jYXRpb24uXG4gICAgICBpZiAocHJlc3NUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMocHJlc3NUYXJnZXQpKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50VGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQoZSwgJ3BvaW50ZXJ1cG91dHNpZGUnKTtcbiAgICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgX3RoaXMubm90aWZ5VGFyZ2V0KGUsICd0b3VjaGVuZG91dHNpZGUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgIHZhciBfaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgICAgICAgX3RoaXMubm90aWZ5VGFyZ2V0KGUsIF9pc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0dXBvdXRzaWRlJyA6ICdtb3VzZXVwb3V0c2lkZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoTm9kZS5pc05vZGUoY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuXG4gICAgICAgIC8vIGN1cnJlbnRUYXJnZXQgaXMgdGhlIG1vc3Qgc3BlY2lmaWMgYW5jZXN0b3IgaG9sZGluZyBib3RoIHRoZSBwb2ludGVyZG93biBhbmQgcG9pbnRlcnVwXG4gICAgICAgIC8vIHRhcmdldHMuIFRoYXQgaXMgLSBpdCdzIG91ciBjbGljayB0YXJnZXQhXG4gICAgICAgIGNsaWNrVGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlja1RhcmdldCkge1xuICAgICAgICB2YXIgX2UkZGV0YWlsO1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IF90aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsICdjbGljaycpO1xuICAgICAgICBjbGlja0V2ZW50LnRhcmdldCA9IGNsaWNrVGFyZ2V0O1xuICAgICAgICBjbGlja0V2ZW50LnBhdGggPSBbXTtcbiAgICAgICAgaWYgKCF0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dKSB7XG4gICAgICAgICAgdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXSA9IHtcbiAgICAgICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgICAgICB0YXJnZXQ6IGNsaWNrRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgdGltZVN0YW1wOiBub3dcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jb250ZXh0LnJlbmRlcmluZ0NvbnRleHQucm9vdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICB2YXIgY2xpY2tIaXN0b3J5ID0gdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXTtcbiAgICAgICAgaWYgKGNsaWNrSGlzdG9yeS50YXJnZXQgPT09IGNsaWNrRXZlbnQudGFyZ2V0ICYmIG5vdyAtIGNsaWNrSGlzdG9yeS50aW1lU3RhbXAgPCBjYW52YXMuZ2V0Q29uZmlnKCkuZGJsQ2xpY2tTcGVlZCkge1xuICAgICAgICAgICsrY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNsaWNrSGlzdG9yeS50YXJnZXQgPSBjbGlja0V2ZW50LnRhcmdldDtcbiAgICAgICAgY2xpY2tIaXN0b3J5LnRpbWVTdGFtcCA9IG5vdztcbiAgICAgICAgY2xpY2tFdmVudC5kZXRhaWwgPSBjbGlja0hpc3RvcnkuY2xpY2tDb3VudDtcblxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnR2aXMvRy9pc3N1ZXMvMTA5MVxuICAgICAgICBpZiAoISgoX2UkZGV0YWlsID0gZS5kZXRhaWwpICE9PSBudWxsICYmIF9lJGRldGFpbCAhPT0gdm9pZCAwICYmIF9lJGRldGFpbC5wcmV2ZW50Q2xpY2spKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5jb250ZXh0LmNvbmZpZy51c2VOYXRpdmVDbGlja0V2ZW50ICYmIChjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGNsaWNrRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpKSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsICdwb2ludGVydGFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZnJlZUV2ZW50KGNsaWNrRXZlbnQpO1xuICAgICAgfVxuICAgICAgX3RoaXMuZnJlZUV2ZW50KGUpO1xuICAgIH07XG4gICAgdGhpcy5vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgIHZhciBlID0gX3RoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBfdGhpcy5jb250ZXh0LmNvbmZpZy5hbHdheXNUcmlnZ2VyUG9pbnRlckV2ZW50T25DYW52YXMgPyBfdGhpcy5yb290VGFyZ2V0IDogdW5kZWZpbmVkKTtcbiAgICAgIHZhciBpc01vdXNlID0gZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBlLnBvaW50ZXJUeXBlID09PSAncGVuJztcbiAgICAgIHZhciB0cmFja2luZ0RhdGEgPSBfdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgICAgdmFyIG91dFRhcmdldCA9IF90aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG5cbiAgICAgIC8vIEZpcnN0IHBvaW50ZXJvdXQvcG9pbnRlcmxlYXZlXG4gICAgICBpZiAodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzICYmIG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgICAgLy8gcG9pbnRlcm91dCBhbHdheXMgb2NjdXJzIG9uIHRoZSBvdmVyVGFyZ2V0IHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzIG92ZXIgYW5vdGhlciBlbGVtZW50LlxuICAgICAgICB2YXIgb3V0VHlwZSA9IGZyb20udHlwZSA9PT0gJ21vdXNlbW92ZScgPyAnbW91c2VvdXQnIDogJ3BvaW50ZXJvdXQnO1xuICAgICAgICB2YXIgb3V0RXZlbnQgPSBfdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgb3V0VHlwZSwgb3V0VGFyZ2V0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsICdwb2ludGVyb3V0Jyk7XG4gICAgICAgIGlmIChpc01vdXNlKSBfdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50LCAnbW91c2VvdXQnKTtcblxuICAgICAgICAvLyBJZiB0aGUgcG9pbnRlciBleGl0cyBvdmVyVGFyZ2V0IGFuZCBpdHMgZGVzY2VuZGFudHMsIHRoZW4gYSBwb2ludGVybGVhdmUgZXZlbnQgaXMgYWxzbyBmaXJlZC4gVGhpcyBldmVudFxuICAgICAgICAvLyBpcyBkaXNwYXRjaGVkIHRvIGFsbCBhbmNlc3RvcnMgdGhhdCBubyBsb25nZXIgY2FwdHVyZSB0aGUgcG9pbnRlci5cbiAgICAgICAgaWYgKCFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG91dFRhcmdldCkpIHtcbiAgICAgICAgICB2YXIgbGVhdmVFdmVudCA9IF90aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCAncG9pbnRlcmxlYXZlJywgb3V0VGFyZ2V0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgbGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7XG4gICAgICAgICAgd2hpbGUgKGxlYXZlRXZlbnQudGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGxlYXZlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgbGVhdmVFdmVudC5jdXJyZW50VGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCk7XG4gICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCwgJ21vdXNlbGVhdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOb2RlLmlzTm9kZShsZWF2ZUV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5mcmVlRXZlbnQobGVhdmVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZnJlZUV2ZW50KG91dEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlbiBwb2ludGVyb3ZlclxuICAgICAgaWYgKG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgICAgLy8gcG9pbnRlcm92ZXIgYWx3YXlzIG9jY3VycyBvbiB0aGUgbmV3IG92ZXJUYXJnZXRcbiAgICAgICAgdmFyIG92ZXJUeXBlID0gZnJvbS50eXBlID09PSAnbW91c2Vtb3ZlJyA/ICdtb3VzZW92ZXInIDogJ3BvaW50ZXJvdmVyJztcbiAgICAgICAgdmFyIG92ZXJFdmVudCA9IF90aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIG92ZXJUeXBlKTsgLy8gY2xvbmUgZmFzdGVyXG5cbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChvdmVyRXZlbnQsICdwb2ludGVyb3ZlcicpO1xuICAgICAgICBpZiAoaXNNb3VzZSkgX3RoaXMuZGlzcGF0Y2hFdmVudChvdmVyRXZlbnQsICdtb3VzZW92ZXInKTtcblxuICAgICAgICAvLyBQcm9iZSB3aGV0aGVyIHRoZSBuZXdseSBob3ZlcmVkIE5vZGUgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIG9yaWdpbmFsIG92ZXJUYXJnZXQuXG4gICAgICAgIHZhciBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdXRUYXJnZXQgJiYgTm9kZS5pc05vZGUob3V0VGFyZ2V0KSAmJiBvdXRUYXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKG92ZXJUYXJnZXRBbmNlc3RvciAmJiBvdmVyVGFyZ2V0QW5jZXN0b3IgIT09IChOb2RlLmlzTm9kZShfdGhpcy5yb290VGFyZ2V0KSAmJiBfdGhpcy5yb290VGFyZ2V0LnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgaWYgKG92ZXJUYXJnZXRBbmNlc3RvciA9PT0gZS50YXJnZXQpIGJyZWFrO1xuICAgICAgICAgIG92ZXJUYXJnZXRBbmNlc3RvciA9IG92ZXJUYXJnZXRBbmNlc3Rvci5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHBvaW50ZXIgaGFzIGVudGVyZWQgYSBub24tYW5jZXN0b3Igb2YgdGhlIG9yaWdpbmFsIG92ZXJUYXJnZXQuIFRoaXMgbWVhbnMgd2UgbmVlZCBhIHBvaW50ZXJlbnRlcmVkXG4gICAgICAgIC8vIGV2ZW50LlxuICAgICAgICB2YXIgZGlkUG9pbnRlckVudGVyID0gIW92ZXJUYXJnZXRBbmNlc3RvciB8fCBvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IChOb2RlLmlzTm9kZShfdGhpcy5yb290VGFyZ2V0KSAmJiBfdGhpcy5yb290VGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICBpZiAoZGlkUG9pbnRlckVudGVyKSB7XG4gICAgICAgICAgdmFyIGVudGVyRXZlbnQgPSBfdGhpcy5jbG9uZVBvaW50ZXJFdmVudChlLCAncG9pbnRlcmVudGVyJyk7XG4gICAgICAgICAgZW50ZXJFdmVudC5ldmVudFBoYXNlID0gZW50ZXJFdmVudC5BVF9UQVJHRVQ7XG4gICAgICAgICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSBvdXRUYXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IChOb2RlLmlzTm9kZShfdGhpcy5yb290VGFyZ2V0KSAmJiBfdGhpcy5yb290VGFyZ2V0LnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIF90aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KTtcbiAgICAgICAgICAgIGlmIChpc01vdXNlKSBfdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgICAgIGlmIChOb2RlLmlzTm9kZShlbnRlckV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgZW50ZXJFdmVudC50YXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5mcmVlRXZlbnQoZW50ZXJFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZnJlZUV2ZW50KG92ZXJFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZW4gcG9pbnRlcm1vdmVcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZSwgJ3BvaW50ZXJtb3ZlJyk7XG4gICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykgX3RoaXMuZGlzcGF0Y2hFdmVudChlLCAndG91Y2htb3ZlJyk7XG4gICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGUsICdtb3VzZW1vdmUnKTtcbiAgICAgICAgX3RoaXMuY3Vyc29yID0gX3RoaXMuZ2V0Q3Vyc29yKGUudGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IGUuY29tcG9zZWRQYXRoKCk7XG4gICAgICBfdGhpcy5mcmVlRXZlbnQoZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uUG9pbnRlck91dCA9IGZ1bmN0aW9uIChmcm9tKSB7XG4gICAgICB2YXIgdHJhY2tpbmdEYXRhID0gX3RoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICAgIGlmICh0cmFja2luZ0RhdGEub3ZlclRhcmdldHMpIHtcbiAgICAgICAgdmFyIGlzTW91c2UgPSBmcm9tLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGZyb20ucG9pbnRlclR5cGUgPT09ICdwZW4nO1xuICAgICAgICB2YXIgb3V0VGFyZ2V0ID0gX3RoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzKTtcblxuICAgICAgICAvLyBwb2ludGVyb3V0IGZpcnN0XG4gICAgICAgIHZhciBvdXRFdmVudCA9IF90aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCAncG9pbnRlcm91dCcsIG91dFRhcmdldCB8fCB1bmRlZmluZWQpO1xuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50KTtcbiAgICAgICAgaWYgKGlzTW91c2UpIF90aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsICdtb3VzZW91dCcpO1xuXG4gICAgICAgIC8vIHBvaW50ZXJsZWF2ZShzKSBhcmUgYWxzbyBkaXNwYXRjaGVkIGIvYyB0aGUgcG9pbnRlciBtdXN0J3ZlIGxlZnQgcm9vdFRhcmdldCBhbmQgaXRzIGRlc2NlbmRhbnRzIHRvXG4gICAgICAgIC8vIGdldCBhbiB1cHN0cmVhbSBwb2ludGVyb3V0IGV2ZW50ICh1cHN0cmVhbSBldmVudHMgZG8gbm90IGtub3cgcm9vdFRhcmdldCBoYXMgZGVzY2VuZGFudHMpLlxuICAgICAgICB2YXIgbGVhdmVFdmVudCA9IF90aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCAncG9pbnRlcmxlYXZlJywgb3V0VGFyZ2V0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIGxlYXZlRXZlbnQuZXZlbnRQaGFzZSA9IGxlYXZlRXZlbnQuQVRfVEFSR0VUO1xuICAgICAgICB3aGlsZSAobGVhdmVFdmVudC50YXJnZXQgJiYgbGVhdmVFdmVudC50YXJnZXQgIT09IChOb2RlLmlzTm9kZShfdGhpcy5yb290VGFyZ2V0KSAmJiBfdGhpcy5yb290VGFyZ2V0LnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgbGVhdmVFdmVudC5jdXJyZW50VGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQ7XG4gICAgICAgICAgX3RoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQpO1xuICAgICAgICAgIGlmIChpc01vdXNlKSB7XG4gICAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCwgJ21vdXNlbGVhdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKE5vZGUuaXNOb2RlKGxlYXZlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBudWxsO1xuICAgICAgICBfdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpO1xuICAgICAgICBfdGhpcy5mcmVlRXZlbnQobGVhdmVFdmVudCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5vblBvaW50ZXJPdmVyID0gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgIHZhciB0cmFja2luZ0RhdGEgPSBfdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgICAgdmFyIGUgPSBfdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgICB2YXIgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ3Blbic7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGUsICdwb2ludGVyb3ZlcicpO1xuICAgICAgaWYgKGlzTW91c2UpIF90aGlzLmRpc3BhdGNoRXZlbnQoZSwgJ21vdXNlb3ZlcicpO1xuICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIF90aGlzLmN1cnNvciA9IF90aGlzLmdldEN1cnNvcihlLnRhcmdldCk7XG5cbiAgICAgIC8vIHBvaW50ZXJlbnRlciBldmVudHMgbXVzdCBiZSBmaXJlZCBzaW5jZSB0aGUgcG9pbnRlciBlbnRlcmVkIGZyb20gdXBzdHJlYW0uXG4gICAgICB2YXIgZW50ZXJFdmVudCA9IF90aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsICdwb2ludGVyZW50ZXInKTtcbiAgICAgIGVudGVyRXZlbnQuZXZlbnRQaGFzZSA9IGVudGVyRXZlbnQuQVRfVEFSR0VUO1xuICAgICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSAoTm9kZS5pc05vZGUoX3RoaXMucm9vdFRhcmdldCkgJiYgX3RoaXMucm9vdFRhcmdldC5wYXJlbnROb2RlKSkge1xuICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgICAgX3RoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQpO1xuICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgIC8vIG1vdXNlZW50ZXIgc2hvdWxkIG5vdCBidWJibGVcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L21vdXNlZW50ZXJfZXZlbnQjdXNhZ2Vfbm90ZXNcbiAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCwgJ21vdXNlZW50ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTm9kZS5pc05vZGUoZW50ZXJFdmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgZW50ZXJFdmVudC50YXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgX3RoaXMuZnJlZUV2ZW50KGUpO1xuICAgICAgX3RoaXMuZnJlZUV2ZW50KGVudGVyRXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5vblBvaW50ZXJVcE91dHNpZGUgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgdmFyIHRyYWNraW5nRGF0YSA9IF90aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgICB2YXIgcHJlc3NUYXJnZXQgPSBfdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICAgIHZhciBlID0gX3RoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgICAgaWYgKHByZXNzVGFyZ2V0KSB7XG4gICAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQoZSwgJ3BvaW50ZXJ1cG91dHNpZGUnKTtcbiAgICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykgOyBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGUucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICBfdGhpcy5ub3RpZnlUYXJnZXQoZSwgZS5idXR0b24gPT09IDIgPyAncmlnaHR1cG91dHNpZGUnIDogJ21vdXNldXBvdXRzaWRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChOb2RlLmlzTm9kZShjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgICB9XG4gICAgICBfdGhpcy5mcmVlRXZlbnQoZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uV2hlZWwgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgdmFyIHdoZWVsRXZlbnQgPSBfdGhpcy5jcmVhdGVXaGVlbEV2ZW50KGZyb20pO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudCh3aGVlbEV2ZW50KTtcbiAgICAgIF90aGlzLmZyZWVFdmVudCh3aGVlbEV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMub25DbGljayA9IGZ1bmN0aW9uIChmcm9tKSB7XG4gICAgICBpZiAoX3RoaXMuY29udGV4dC5jb25maWcudXNlTmF0aXZlQ2xpY2tFdmVudCkge1xuICAgICAgICB2YXIgZSA9IF90aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgX3RoaXMuZnJlZUV2ZW50KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vblBvaW50ZXJDYW5jZWwgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgdmFyIGUgPSBfdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIF90aGlzLmNvbnRleHQuY29uZmlnLmFsd2F5c1RyaWdnZXJQb2ludGVyRXZlbnRPbkNhbnZhcyA/IF90aGlzLnJvb3RUYXJnZXQgOiB1bmRlZmluZWQpO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIF90aGlzLmZyZWVFdmVudChlKTtcbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsUnVudGltZSA9IGdsb2JhbFJ1bnRpbWU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV2ZW50U2VydmljZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5yb290VGFyZ2V0ID0gdGhpcy5jb250ZXh0LnJlbmRlcmluZ0NvbnRleHQucm9vdC5wYXJlbnROb2RlOyAvLyBkb2N1bWVudFxuICAgICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoJ3BvaW50ZXJkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TWFwcGluZygncG9pbnRlcm91dCcsIHRoaXMub25Qb2ludGVyT3V0KTtcbiAgICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKCdwb2ludGVybGVhdmUnLCB0aGlzLm9uUG9pbnRlck91dCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TWFwcGluZygncG9pbnRlcmNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKCdwb2ludGVyb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XG4gICAgICB0aGlzLmFkZEV2ZW50TWFwcGluZygncG9pbnRlcnVwb3V0c2lkZScsIHRoaXMub25Qb2ludGVyVXBPdXRzaWRlKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKCd3aGVlbCcsIHRoaXMub25XaGVlbCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TWFwcGluZygnY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLm1hcHBpbmdUYWJsZSA9IHt9O1xuICAgICAgdGhpcy5tYXBwaW5nU3RhdGUgPSB7fTtcbiAgICAgIHRoaXMuZXZlbnRQb29sLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgdmFyIGJib3ggPSB0aGlzLmNvbnRleHQuY29udGV4dFNlcnZpY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2NhbGVYID0gMTtcbiAgICAgIHZhciBzY2FsZVkgPSAxO1xuICAgICAgdmFyICRlbCA9IHRoaXMuY29udGV4dC5jb250ZXh0U2VydmljZS5nZXREb21FbGVtZW50KCk7XG4gICAgICBpZiAoJGVsICYmIGJib3gpIHtcbiAgICAgICAgdmFyIG9mZnNldFdpZHRoID0gJGVsLm9mZnNldFdpZHRoLFxuICAgICAgICAgIG9mZnNldEhlaWdodCA9ICRlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmIChvZmZzZXRXaWR0aCAmJiBvZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICBzY2FsZVggPSBiYm94LndpZHRoIC8gb2Zmc2V0V2lkdGg7XG4gICAgICAgICAgc2NhbGVZID0gYmJveC5oZWlnaHQgLyBvZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgYmJveDogYmJveFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgYWNjb3VudCBmb3IgQ1NTIFRyYW5zZm9ybSBhcHBsaWVkIG9uIGNvbnRhaW5lci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnR2aXMvRy9pc3N1ZXMvMTE2MVxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudHZpcy9HL2lzc3Vlcy8xNjc3XG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9vZmZzZXRYXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xpZW50MlZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWVudDJWaWV3cG9ydChjbGllbnQpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRTY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKSxcbiAgICAgICAgc2NhbGVYID0gX3RoaXMkZ2V0U2NhbGUuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfdGhpcyRnZXRTY2FsZS5zY2FsZVksXG4gICAgICAgIGJib3ggPSBfdGhpcyRnZXRTY2FsZS5iYm94O1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCgoY2xpZW50LnggLSAoKGJib3ggPT09IG51bGwgfHwgYmJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmJveC5sZWZ0KSB8fCAwKSkgLyBzY2FsZVgsIChjbGllbnQueSAtICgoYmJveCA9PT0gbnVsbCB8fCBiYm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiYm94LnRvcCkgfHwgMCkpIC8gc2NhbGVZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnQyQ2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdwb3J0MkNsaWVudChjYW52YXMpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRTY2FsZTIgPSB0aGlzLmdldFNjYWxlKCksXG4gICAgICAgIHNjYWxlWCA9IF90aGlzJGdldFNjYWxlMi5zY2FsZVgsXG4gICAgICAgIHNjYWxlWSA9IF90aGlzJGdldFNjYWxlMi5zY2FsZVksXG4gICAgICAgIGJib3ggPSBfdGhpcyRnZXRTY2FsZTIuYmJveDtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoKGNhbnZhcy54ICsgKChiYm94ID09PSBudWxsIHx8IGJib3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJib3gubGVmdCkgfHwgMCkpICogc2NhbGVYLCAoY2FudmFzLnkgKyAoKGJib3ggPT09IG51bGwgfHwgYmJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmJveC50b3ApIHx8IDApKSAqIHNjYWxlWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0MkNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3cG9ydDJDYW52YXMoX3JlZikge1xuICAgICAgdmFyIHggPSBfcmVmLngsXG4gICAgICAgIHkgPSBfcmVmLnk7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5yb290VGFyZ2V0LmRlZmF1bHRWaWV3O1xuICAgICAgdmFyIGNhbWVyYSA9IGNhbnZhcy5nZXRDYW1lcmEoKTtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0JGNvbmZpZyA9IHRoaXMuY29udGV4dC5jb25maWcsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkY29udGV4dCRjb25maWcud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJGNvbnRleHQkY29uZmlnLmhlaWdodDtcbiAgICAgIHZhciBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZSA9IGNhbWVyYS5nZXRQZXJzcGVjdGl2ZUludmVyc2UoKTtcbiAgICAgIHZhciB3b3JsZE1hdHJpeCA9IGNhbWVyYS5nZXRXb3JsZFRyYW5zZm9ybSgpO1xuICAgICAgdmFyIHZwTWF0cml4ID0gbWF0NC5tdWx0aXBseSh0aGlzLnRtcE1hdHJpeCwgd29ybGRNYXRyaXgsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHZlYzMuc2V0KHRoaXMudG1wVmVjMywgeCAvIHdpZHRoICogMiAtIDEsICgxIC0geSAvIGhlaWdodCkgKiAyIC0gMSwgMCk7XG4gICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodmlld3BvcnQsIHZpZXdwb3J0LCB2cE1hdHJpeCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHZpZXdwb3J0WzBdLCB2aWV3cG9ydFsxXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbnZhczJWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXMyVmlld3BvcnQoY2FudmFzUCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMucm9vdFRhcmdldC5kZWZhdWx0VmlldztcbiAgICAgIHZhciBjYW1lcmEgPSBjYW52YXMuZ2V0Q2FtZXJhKCk7XG5cbiAgICAgIC8vIFdvcmxkIC0+IENsaXBcbiAgICAgIHZhciBwcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLmdldFBlcnNwZWN0aXZlKCk7XG4gICAgICB2YXIgdmlld01hdHJpeCA9IGNhbWVyYS5nZXRWaWV3VHJhbnNmb3JtKCk7XG4gICAgICB2YXIgdnBNYXRyaXggPSBtYXQ0Lm11bHRpcGx5KHRoaXMudG1wTWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCB2aWV3TWF0cml4KTtcbiAgICAgIHZhciBjbGlwID0gdmVjMy5zZXQodGhpcy50bXBWZWMzLCBjYW52YXNQLngsIGNhbnZhc1AueSwgMCk7XG4gICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy50bXBWZWMzLCB0aGlzLnRtcFZlYzMsIHZwTWF0cml4KTtcblxuICAgICAgLy8gQ2xpcCAtPiBOREMgLT4gVmlld3BvcnQsIGZsaXAgWVxuICAgICAgdmFyIF90aGlzJGNvbnRleHQkY29uZmlnMiA9IHRoaXMuY29udGV4dC5jb25maWcsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkY29udGV4dCRjb25maWcyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRjb250ZXh0JGNvbmZpZzIuaGVpZ2h0O1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCgoY2xpcFswXSArIDEpIC8gMiAqIHdpZHRoLCAoMSAtIChjbGlwWzFdICsgMSkgLyAyKSAqIGhlaWdodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBpY2tIYW5kbGVyKHBpY2tIYW5kbGVyKSB7XG4gICAgICB0aGlzLnBpY2tIYW5kbGVyID0gcGlja0hhbmRsZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TWFwcGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudE1hcHBpbmcodHlwZSwgZm4pIHtcbiAgICAgIGlmICghdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0pIHtcbiAgICAgICAgdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnB1c2goe1xuICAgICAgICBmbjogZm4sXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcEV2ZW50KGUpIHtcbiAgICAgIGlmICghdGhpcy5yb290VGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtYXBwZXJzID0gdGhpcy5tYXBwaW5nVGFibGVbZS50eXBlXTtcbiAgICAgIGlmIChtYXBwZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbWFwcGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBtYXBwZXJzW2ldLmZuKGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbRXZlbnRTZXJ2aWNlXTogRXZlbnQgbWFwcGluZyBub3QgZGVmaW5lZCBmb3IgXCIuY29uY2F0KGUudHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZSwgdHlwZSwgc2tpcFByb3BhZ2F0ZSkge1xuICAgICAgLy8gQ2FudmFzIHNob3VsZCBza2lwXG4gICAgICBpZiAoIXNraXBQcm9wYWdhdGUpIHtcbiAgICAgICAgZS5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3BhZ2F0ZShlLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRhcmdldCBwaGFzZVxuICAgICAgICBlLmV2ZW50UGhhc2UgPSBlLkFUX1RBUkdFVDtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMucm9vdFRhcmdldC5kZWZhdWx0VmlldyB8fCBudWxsO1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjYW52YXM7XG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9wYWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGFnYXRlKGUsIHR5cGUpIHtcbiAgICAgIGlmICghZS50YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBbdGFyZ2V0LCBwYXJlbnQsIHJvb3QsIENhbnZhc11cbiAgICAgIHZhciBjb21wb3NlZFBhdGggPSBlLmNvbXBvc2VkUGF0aCgpO1xuXG4gICAgICAvLyBldmVudCBmbG93OiBjYXB0dXJlIC0+IHRhcmdldCAtPiBidWJibGluZ1xuXG4gICAgICAvLyBjYXB0dXJlIHBoYXNlXG4gICAgICBlLmV2ZW50UGhhc2UgPSBlLkNBUFRVUklOR19QSEFTRTtcbiAgICAgIGZvciAodmFyIGkgPSBjb21wb3NlZFBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY29tcG9zZWRQYXRoW2ldO1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdGFyZ2V0IHBoYXNlXG4gICAgICBlLmV2ZW50UGhhc2UgPSBlLkFUX1RBUkdFVDtcbiAgICAgIGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSk7XG4gICAgICBpZiAoZS5wcm9wYWdhdGlvblN0b3BwZWQgfHwgZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBmaW5kIGN1cnJlbnQgdGFyZ2V0IGluIGNvbXBvc2VkIHBhdGhcbiAgICAgIHZhciBpbmRleCA9IGNvbXBvc2VkUGF0aC5pbmRleE9mKGUuY3VycmVudFRhcmdldCk7XG5cbiAgICAgIC8vIGJ1YmJsaW5nIHBoYXNlXG4gICAgICBlLmV2ZW50UGhhc2UgPSBlLkJVQkJMSU5HX1BIQVNFO1xuICAgICAgZm9yICh2YXIgX2kgPSBpbmRleCArIDE7IF9pIDwgY29tcG9zZWRQYXRoLmxlbmd0aDsgX2krKykge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbX2ldO1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvcGFnYXRpb25QYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BhZ2F0aW9uUGF0aCh0YXJnZXQpIHtcbiAgICAgIHZhciBwcm9wYWdhdGlvblBhdGggPSBbdGFyZ2V0XTtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLnJvb3RUYXJnZXQuZGVmYXVsdFZpZXcgfHwgbnVsbDtcbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzID09PSB0YXJnZXQpIHtcbiAgICAgICAgcHJvcGFnYXRpb25QYXRoLnVuc2hpZnQoY2FudmFzLmRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHByb3BhZ2F0aW9uUGF0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUFJPUEFHQVRJT05fTElNSVQgJiYgdGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQ7IGkrKykge1xuICAgICAgICAvLyBpZiAoTm9kZS5pc05vZGUodGFyZ2V0KSAmJiAhdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHByb3BhZ2F0aW9uIHBhdGggdG8gZGlzY29ubmVjdGVkIHRhcmdldCcpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKE5vZGUuaXNOb2RlKHRhcmdldCkgJiYgdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAvLyBbdGFyZ2V0LCBwYXJlbnQsIHBhcmVudCwgcm9vdF1cbiAgICAgICAgICBwcm9wYWdhdGlvblBhdGgucHVzaCh0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwcm9wYWdhdGlvblBhdGgucHVzaChjYW52YXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BhZ2F0aW9uUGF0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGl0VGVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaXRUZXN0KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgdmlld3BvcnRYID0gcG9zaXRpb24udmlld3BvcnRYLFxuICAgICAgICB2aWV3cG9ydFkgPSBwb3NpdGlvbi52aWV3cG9ydFk7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dCRjb25maWczID0gdGhpcy5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRjb250ZXh0JGNvbmZpZzMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJGNvbnRleHQkY29uZmlnMy5oZWlnaHQsXG4gICAgICAgIGRpc2FibGVIaXRUZXN0aW5nID0gX3RoaXMkY29udGV4dCRjb25maWczLmRpc2FibGVIaXRUZXN0aW5nO1xuICAgICAgLy8gb3V0c2lkZSBjYW52YXNcbiAgICAgIGlmICh2aWV3cG9ydFggPCAwIHx8IHZpZXdwb3J0WSA8IDAgfHwgdmlld3BvcnRYID4gd2lkdGggfHwgdmlld3BvcnRZID4gaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFkaXNhYmxlSGl0VGVzdGluZyAmJiB0aGlzLnBpY2tIYW5kbGVyKHBvc2l0aW9uKSB8fCB0aGlzLnJvb3RUYXJnZXQgfHxcbiAgICAgIC8vIHJldHVybiBEb2N1bWVudFxuICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3aGV0aGVyIHRoZSBuYXRpdmUgZXZlbnQgdHJpZ2dlciBjYW1lIGZyb20gQ2FudmFzLFxuICAgICAqIHNob3VsZCBhY2NvdW50IGZvciBIVE1MIHNoYXBlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNOYXRpdmVFdmVudEZyb21DYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOYXRpdmVFdmVudEZyb21DYW52YXMoJGVsLCBuYXRpdmVFdmVudCkge1xuICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQgPT09IG51bGwgfHwgbmF0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdGl2ZUV2ZW50LnRhcmdldDtcbiAgICAgIC8vIEdldCBldmVudCB0YXJnZXQgaW5zaWRlIGEgd2ViIGNvbXBvbmVudC5cbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTc5NjMzMTIvZ2V0LWV2ZW50LXRhcmdldC1pbnNpZGUtYS13ZWItY29tcG9uZW50XG4gICAgICBpZiAoKF90YXJnZXQgPSB0YXJnZXQpICE9PSBudWxsICYmIF90YXJnZXQgIT09IHZvaWQgMCAmJiBfdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGFyZ2V0ID0gbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIC8vIGZyb20gPGNhbnZhcz5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmcm9tIDxzdmc+XG4gICAgICAgIGlmICgkZWwgJiYgJGVsLmNvbnRhaW5zKSB7XG4gICAgICAgICAgcmV0dXJuICRlbC5jb250YWlucyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmF0aXZlRXZlbnQgIT09IG51bGwgJiYgbmF0aXZlRXZlbnQgIT09IHZvaWQgMCAmJiBuYXRpdmVFdmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpLmluZGV4T2YoJGVsKSA+IC0xO1xuICAgICAgfVxuXG4gICAgICAvLyBhY2NvdW50IGZvciBUb3VjaFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgSFRNTCBmcm9tIGNvbXBvc2VkIHBhdGggaW4gbmF0aXZlIFVJIGV2ZW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEV4aXN0ZWRIVE1MXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4aXN0ZWRIVE1MKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQubmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoKSB7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9hcnIgPSBldmVudC5uYXRpdmVFdmVudC5jb21wb3NlZFBhdGgoKTsgX2kyIDwgX2Fyci5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gX2FycltfaTJdO1xuICAgICAgICAgIHZhciBleGlzdGVkID0gdGhpcy5uYXRpdmVIVE1MTWFwLmdldChldmVudFRhcmdldCk7XG4gICAgICAgICAgaWYgKGV4aXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBpY2tUYXJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGlja1RhcmdldChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGl0VGVzdCh7XG4gICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIHZpZXdwb3J0WDogZXZlbnQudmlld3BvcnRYLFxuICAgICAgICB2aWV3cG9ydFk6IGV2ZW50LnZpZXdwb3J0WSxcbiAgICAgICAgeDogZXZlbnQuY2FudmFzWCxcbiAgICAgICAgeTogZXZlbnQuY2FudmFzWVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVBvaW50ZXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSwgdGFyZ2V0LCBmYWxsYmFja1RhcmdldCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgICB0aGlzLmNvcHlQb2ludGVyRGF0YShmcm9tLCBldmVudCk7XG4gICAgICB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpO1xuICAgICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgICBldmVudC5uYXRpdmVFdmVudCA9IGZyb20ubmF0aXZlRXZlbnQ7XG4gICAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZnJvbTtcbiAgICAgIHZhciBleGlzdGVkSFRNTCA9IHRoaXMuZ2V0RXhpc3RlZEhUTUwoZXZlbnQpO1xuICAgICAgdmFyICRlbCA9IHRoaXMuY29udGV4dC5jb250ZXh0U2VydmljZS5nZXREb21FbGVtZW50KCk7XG4gICAgICBldmVudC50YXJnZXQgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiBleGlzdGVkSFRNTCB8fCB0aGlzLmlzTmF0aXZlRXZlbnRGcm9tQ2FudmFzKCRlbCwgZXZlbnQubmF0aXZlRXZlbnQpICYmIHRoaXMucGlja1RhcmdldChldmVudCkgfHwgZmFsbGJhY2tUYXJnZXQ7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVXaGVlbEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVdoZWVsRXZlbnQoZnJvbSkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFdoZWVsRXZlbnQpO1xuICAgICAgdGhpcy5jb3B5V2hlZWxEYXRhKGZyb20sIGV2ZW50KTtcbiAgICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgICB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KTtcbiAgICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudDtcbiAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgICAgdmFyIGV4aXN0ZWRIVE1MID0gdGhpcy5nZXRFeGlzdGVkSFRNTChldmVudCk7XG4gICAgICB2YXIgJGVsID0gdGhpcy5jb250ZXh0LmNvbnRleHRTZXJ2aWNlLmdldERvbUVsZW1lbnQoKTtcbiAgICAgIGV2ZW50LnRhcmdldCA9IGV4aXN0ZWRIVE1MIHx8IHRoaXMuaXNOYXRpdmVFdmVudEZyb21DYW52YXMoJGVsLCBldmVudC5uYXRpdmVFdmVudCkgJiYgdGhpcy5waWNrVGFyZ2V0KGV2ZW50KTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2tpbmdEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWNraW5nRGF0YShpZCkge1xuICAgICAgaWYgKCF0aGlzLm1hcHBpbmdTdGF0ZS50cmFja2luZ0RhdGFbaWRdKSB7XG4gICAgICAgIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0gPSB7XG4gICAgICAgICAgcHJlc3NUYXJnZXRzQnlCdXR0b246IHt9LFxuICAgICAgICAgIGNsaWNrc0J5QnV0dG9uOiB7fSxcbiAgICAgICAgICBvdmVyVGFyZ2V0OiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVXaGVlbEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lV2hlZWxFdmVudChmcm9tKSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkV2hlZWxFdmVudCk7XG4gICAgICBldmVudC5uYXRpdmVFdmVudCA9IGZyb20ubmF0aXZlRXZlbnQ7XG4gICAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZnJvbS5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy5jb3B5V2hlZWxEYXRhKGZyb20sIGV2ZW50KTtcbiAgICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgICB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KTtcbiAgICAgIGV2ZW50LnRhcmdldCA9IGZyb20udGFyZ2V0O1xuICAgICAgZXZlbnQucGF0aCA9IGZyb20uY29tcG9zZWRQYXRoKCkuc2xpY2UoKTtcbiAgICAgIGV2ZW50LnR5cGUgPSBmcm9tLnR5cGU7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lUG9pbnRlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lUG9pbnRlckV2ZW50KGZyb20sIHR5cGUpIHtcbiAgICAgIHZhciBldmVudCA9IHRoaXMuYWxsb2NhdGVFdmVudChGZWRlcmF0ZWRQb2ludGVyRXZlbnQpO1xuICAgICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgICAgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20ub3JpZ2luYWxFdmVudDtcbiAgICAgIHRoaXMuY29weVBvaW50ZXJEYXRhKGZyb20sIGV2ZW50KTtcbiAgICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgICB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KTtcbiAgICAgIGV2ZW50LnRhcmdldCA9IGZyb20udGFyZ2V0O1xuICAgICAgZXZlbnQucGF0aCA9IGZyb20uY29tcG9zZWRQYXRoKCkuc2xpY2UoKTtcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHZvaWQgMCA/IHR5cGUgOiBldmVudC50eXBlO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5UG9pbnRlckRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weVBvaW50ZXJEYXRhKGZyb20sIHRvKSB7XG4gICAgICAvLyBpZiAoXG4gICAgICAvLyAgICEoXG4gICAgICAvLyAgICAgZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCAmJlxuICAgICAgLy8gICAgIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50XG4gICAgICAvLyAgIClcbiAgICAgIC8vIClcbiAgICAgIC8vICAgcmV0dXJuO1xuXG4gICAgICB0by5wb2ludGVySWQgPSBmcm9tLnBvaW50ZXJJZDtcbiAgICAgIHRvLndpZHRoID0gZnJvbS53aWR0aDtcbiAgICAgIHRvLmhlaWdodCA9IGZyb20uaGVpZ2h0O1xuICAgICAgdG8uaXNQcmltYXJ5ID0gZnJvbS5pc1ByaW1hcnk7XG4gICAgICB0by5wb2ludGVyVHlwZSA9IGZyb20ucG9pbnRlclR5cGU7XG4gICAgICB0by5wcmVzc3VyZSA9IGZyb20ucHJlc3N1cmU7XG4gICAgICB0by50YW5nZW50aWFsUHJlc3N1cmUgPSBmcm9tLnRhbmdlbnRpYWxQcmVzc3VyZTtcbiAgICAgIHRvLnRpbHRYID0gZnJvbS50aWx0WDtcbiAgICAgIHRvLnRpbHRZID0gZnJvbS50aWx0WTtcbiAgICAgIHRvLnR3aXN0ID0gZnJvbS50d2lzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weU1vdXNlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5TW91c2VEYXRhKGZyb20sIHRvKSB7XG4gICAgICAvLyBpZiAoXG4gICAgICAvLyAgICEoXG4gICAgICAvLyAgICAgZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZE1vdXNlRXZlbnQgJiYgdG8gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50XG4gICAgICAvLyAgIClcbiAgICAgIC8vIClcbiAgICAgIC8vICAgcmV0dXJuO1xuXG4gICAgICB0by5hbHRLZXkgPSBmcm9tLmFsdEtleTtcbiAgICAgIHRvLmJ1dHRvbiA9IGZyb20uYnV0dG9uO1xuICAgICAgdG8uYnV0dG9ucyA9IGZyb20uYnV0dG9ucztcbiAgICAgIHRvLmN0cmxLZXkgPSBmcm9tLmN0cmxLZXk7XG4gICAgICB0by5tZXRhS2V5ID0gZnJvbS5tZXRhS2V5O1xuICAgICAgdG8uc2hpZnRLZXkgPSBmcm9tLnNoaWZ0S2V5O1xuICAgICAgdG8uY2xpZW50LmNvcHlGcm9tKGZyb20uY2xpZW50KTtcbiAgICAgIHRvLm1vdmVtZW50LmNvcHlGcm9tKGZyb20ubW92ZW1lbnQpO1xuICAgICAgdG8uY2FudmFzLmNvcHlGcm9tKGZyb20uY2FudmFzKTtcbiAgICAgIHRvLnNjcmVlbi5jb3B5RnJvbShmcm9tLnNjcmVlbik7XG4gICAgICB0by5nbG9iYWwuY29weUZyb20oZnJvbS5nbG9iYWwpO1xuICAgICAgdG8ub2Zmc2V0LmNvcHlGcm9tKGZyb20ub2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVdoZWVsRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5V2hlZWxEYXRhKGZyb20sIHRvKSB7XG4gICAgICB0by5kZWx0YU1vZGUgPSBmcm9tLmRlbHRhTW9kZTtcbiAgICAgIHRvLmRlbHRhWCA9IGZyb20uZGVsdGFYO1xuICAgICAgdG8uZGVsdGFZID0gZnJvbS5kZWx0YVk7XG4gICAgICB0by5kZWx0YVogPSBmcm9tLmRlbHRhWjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weURhdGEoZnJvbSwgdG8pIHtcbiAgICAgIHRvLmlzVHJ1c3RlZCA9IGZyb20uaXNUcnVzdGVkO1xuICAgICAgdG8udGltZVN0YW1wID0gY2xvY2subm93KCk7XG4gICAgICB0by50eXBlID0gZnJvbS50eXBlO1xuICAgICAgdG8uZGV0YWlsID0gZnJvbS5kZXRhaWw7XG4gICAgICB0by52aWV3ID0gZnJvbS52aWV3O1xuICAgICAgdG8ucGFnZS5jb3B5RnJvbShmcm9tLnBhZ2UpO1xuICAgICAgdG8udmlld3BvcnQuY29weUZyb20oZnJvbS52aWV3cG9ydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFsbG9jYXRlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb2NhdGVFdmVudChjb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50UG9vbC5oYXMoY29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRoaXMuZXZlbnRQb29sLnNldChjb25zdHJ1Y3RvciwgW10pO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50UG9vbC5nZXQoY29uc3RydWN0b3IpLnBvcCgpIHx8IG5ldyBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBldmVudC5OT05FO1xuICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICBldmVudC5wYXRoID0gW107XG4gICAgICBldmVudC50YXJnZXQgPSBudWxsO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcmVlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJlZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQubWFuYWdlciAhPT0gdGhpcykgdGhyb3cgbmV3IEVycm9yKCdJdCBpcyBpbGxlZ2FsIHRvIGZyZWUgYW4gZXZlbnQgbm90IG1hbmFnZWQgYnkgdGhpcyBFdmVudEJvdW5kYXJ5IScpO1xuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZXZlbnQuY29uc3RydWN0b3I7XG4gICAgICBpZiAoIXRoaXMuZXZlbnRQb29sLmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhpcy5ldmVudFBvb2wuc2V0KGNvbnN0cnVjdG9yLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuZXZlbnRQb29sLmdldChjb25zdHJ1Y3RvcikucHVzaChldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vdGlmeVRhcmdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3RpZnlUYXJnZXQoZSwgdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdm9pZCAwID8gdHlwZSA6IGUudHlwZTtcbiAgICAgIHZhciBrZXkgPSBlLmV2ZW50UGhhc2UgPT09IGUuQ0FQVFVSSU5HX1BIQVNFIHx8IGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQgPyBcIlwiLmNvbmNhdCh0eXBlLCBcImNhcHR1cmVcIikgOiB0eXBlO1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZSwga2V5KTtcbiAgICAgIGlmIChlLmV2ZW50UGhhc2UgPT09IGUuQVRfVEFSR0VUKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3RpZnlMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpIHtcbiAgICAgIC8vIGhhY2sgRXZlbnRFbWl0dGVyLCBzdG9wcyBpZiB0aGUgYHByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkYCBmbGFnIGlzIHNldFxuICAgICAgdmFyIGVtaXR0ZXIgPSBlLmN1cnJlbnRUYXJnZXQuZW1pdHRlcjtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuICAgICAgaWYgKCdmbicgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMub25jZSkge1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5mbi5jYWxsKGUuY3VycmVudFRhcmdldCB8fCBsaXN0ZW5lcnMuY29udGV4dCwgZSk7XG4gICAgICAgIC8vIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aCAmJiAhZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwoZS5jdXJyZW50VGFyZ2V0IHx8IGxpc3RlbmVyc1tpXS5jb250ZXh0LCBlKTtcbiAgICAgICAgICAvLyBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzb21lIGRldGFjaGVkIG5vZGVzIG1heSBleGlzdCBpbiBwcm9wYWdhdGlvbiBwYXRoLCBuZWVkIHRvIHNraXAgdGhlbVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmRNb3VudGVkVGFyZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRNb3VudGVkVGFyZ2V0KHByb3BhZ2F0aW9uUGF0aCkge1xuICAgICAgaWYgKCFwcm9wYWdhdGlvblBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHByb3BhZ2F0aW9uUGF0aFtwcm9wYWdhdGlvblBhdGgubGVuZ3RoIC0gMV07XG4gICAgICBmb3IgKHZhciBpID0gcHJvcGFnYXRpb25QYXRoLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwcm9wYWdhdGlvblBhdGhbaV07XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMucm9vdFRhcmdldCB8fCBOb2RlLmlzTm9kZSh0YXJnZXQpICYmIHRhcmdldC5wYXJlbnROb2RlID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IHByb3BhZ2F0aW9uUGF0aFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJzb3IodGFyZ2V0KSB7XG4gICAgICB2YXIgdG1wID0gdGFyZ2V0O1xuICAgICAgd2hpbGUgKHRtcCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gaXNFbGVtZW50KHRtcCkgJiYgdG1wLmdldEF0dHJpYnV0ZSgnY3Vyc29yJyk7XG4gICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgICAgICB9XG4gICAgICAgIHRtcCA9IE5vZGUuaXNOb2RlKHRtcCkgJiYgdG1wLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKlxuICogdXNlZCBpbiBmb2xsb3dpbmcgc2NlbmVzOlxuICogLSBnIGBjdHgubWVhc3VyZVRleHRgXG4gKiAtIGctcGx1Z2luLWNhbnZhcy1waWNrZXIgYGN0eC5pc1BvaW50SW5QYXRoYFxuICogLSBnLXBsdWdpbi1kZXZpY2UtcmVuZGVyZXIgYGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudGAgYW5kIGdlbmVyYXRlIHRleHR1cmVcbiAqXG4gKiBAc2VlIGh0dHBzOi8vYmxvZy5zY290dGxvZ2ljLmNvbS8yMDIwLzAzLzE5L29mZnNjcmVlbi1jYW52YXMuaHRtbFxuICovXG52YXIgT2Zmc2NyZWVuQ2FudmFzQ3JlYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9mZnNjcmVlbkNhbnZhc0NyZWF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9mZnNjcmVlbkNhbnZhc0NyZWF0b3IpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoT2Zmc2NyZWVuQ2FudmFzQ3JlYXRvciwgW3tcbiAgICBrZXk6IFwiZ2V0T3JDcmVhdGVDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JDcmVhdGVDYW52YXMob2Zmc2NyZWVuQ2FudmFzLCBjb250ZXh0QXR0cmlidXRlcykge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICAgIH1cblxuICAgICAgLy8gdXNlci1kZWZpbmVkIG9mZnNjcmVlbiBjYW52YXNcbiAgICAgIGlmIChvZmZzY3JlZW5DYW52YXMgfHwgcnVudGltZS5vZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBvZmZzY3JlZW5DYW52YXMgfHwgcnVudGltZS5vZmZzY3JlZW5DYW52YXM7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJywgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICAgIH0sIGNvbnRleHRBdHRyaWJ1dGVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE9mZnNjcmVlbkNhbnZhczJEIG1lYXN1cmVUZXh0IGNhbiBiZSB1cCB0byA0MCUgZmFzdGVyLlxuICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IHdpbmRvdy5PZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgICAgIH0sIGNvbnRleHRBdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICAgICAgfSwgY29udGV4dEF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSAxMDtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDEwO1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPckNyZWF0ZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JDcmVhdGVDb250ZXh0KG9mZnNjcmVlbkNhbnZhcywgY29udGV4dEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0T3JDcmVhdGVDYW52YXMob2Zmc2NyZWVuQ2FudmFzLCBjb250ZXh0QXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZUNhbnZhc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG5ldyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYW52YXMoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5PZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgICAvL1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZDMpIHtcbiAgICAgICAgLy9cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIHdoeSB3ZSBuZWVkIHJlLXJlbmRlclxuICovXG52YXIgUmVuZGVyUmVhc29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChSZW5kZXJSZWFzb24pIHtcbiAgUmVuZGVyUmVhc29uW1JlbmRlclJlYXNvbltcIkNBTUVSQV9DSEFOR0VEXCJdID0gMF0gPSBcIkNBTUVSQV9DSEFOR0VEXCI7XG4gIFJlbmRlclJlYXNvbltSZW5kZXJSZWFzb25bXCJESVNQTEFZX09CSkVDVF9DSEFOR0VEXCJdID0gMV0gPSBcIkRJU1BMQVlfT0JKRUNUX0NIQU5HRURcIjtcbiAgUmVuZGVyUmVhc29uW1JlbmRlclJlYXNvbltcIk5PTkVcIl0gPSAyXSA9IFwiTk9ORVwiO1xuICByZXR1cm4gUmVuZGVyUmVhc29uO1xufSh7fSk7XG5cbi8qKlxuICogVXNlIGZyYW1lIHJlbmRlcmVyIGltcGxlbWVudGVkIGJ5IGBnLWNhbnZhcy9zdmcvd2ViZ2xgLCBpbiBldmVyeSBmcmFtZSB3ZSBkbyBmb2xsb3dpbmdzOlxuICogKiB1cGRhdGUgJiBtZXJnZSBkaXJ0eSByZWN0YW5nbGVzXG4gKiAqIGJlZ2luIGZyYW1lXG4gKiAqIGZpbHRlciBieSB2aXNpYmxlXG4gKiAqIHNvcnQgYnkgei1pbmRleCBpbiBzY2VuZSBncmFwaFxuICogKiBjdWxsaW5nIHdpdGggc3RyYXRlZ2llcyByZWdpc3RlcmVkIGluIGBnLWNhbnZhcy93ZWJnbGBcbiAqICogZW5kIGZyYW1lXG4gKi9cbnZhciBSZW5kZXJpbmdTZXJ2aWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVuZGVyaW5nU2VydmljZShnbG9iYWxSdW50aW1lLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcmluZ1NlcnZpY2UpO1xuICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogdG90YWwgZGlzcGxheSBvYmplY3RzIGluIHNjZW5lZ3JhcGhcbiAgICAgICAqL1xuICAgICAgdG90YWw6IDAsXG4gICAgICAvKipcbiAgICAgICAqIG51bWJlciBvZiBkaXNwbGF5IG9iamVjdHMgbmVlZCB0byByZW5kZXIgaW4gY3VycmVudCBmcmFtZVxuICAgICAgICovXG4gICAgICByZW5kZXJlZDogMFxuICAgIH07XG4gICAgdGhpcy56SW5kZXhDb3VudGVyID0gMDtcbiAgICB0aGlzLmhvb2tzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBjYWxsZWQgYmVmb3JlIGFueSBmcmFtZSByZW5kZXJlZFxuICAgICAgICovXG4gICAgICBpbml0OiBuZXcgU3luY0hvb2soKSxcbiAgICAgIGluaXRBc3luYzogbmV3IEFzeW5jUGFyYWxsZWxIb29rKCksXG4gICAgICAvKipcbiAgICAgICAqIG9ubHkgZGlydHkgb2JqZWN0IHdoaWNoIGhhcyBzdGggY2hhbmdlZCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICAgKi9cbiAgICAgIGRpcnR5Y2hlY2s6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygpLFxuICAgICAgLyoqXG4gICAgICAgKiBkbyBjdWxsaW5nXG4gICAgICAgKi9cbiAgICAgIGN1bGw6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygpLFxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsZWQgYXQgYmVnaW5uaW5nIG9mIGVhY2ggZnJhbWUsIHdvbid0IGdldCBjYWxsZWQgaWYgbm90aGluZyB0byByZS1yZW5kZXJcbiAgICAgICAqL1xuICAgICAgYmVnaW5GcmFtZTogbmV3IFN5bmNIb29rKCksXG4gICAgICAvKipcbiAgICAgICAqIGNhbGxlZCBiZWZvcmUgZXZlcnkgZGlydHkgb2JqZWN0IGdldCByZW5kZXJlZFxuICAgICAgICovXG4gICAgICBiZWZvcmVSZW5kZXI6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsZWQgd2hlbiBldmVyeSBkaXJ0eSBvYmplY3QgcmVuZGVyaW5nIGV2ZW4gaXQncyBjdWxsZWRcbiAgICAgICAqL1xuICAgICAgcmVuZGVyOiBuZXcgU3luY0hvb2soKSxcbiAgICAgIC8qKlxuICAgICAgICogY2FsbGVkIGFmdGVyIGV2ZXJ5IGRpcnR5IG9iamVjdCBnZXQgcmVuZGVyZWRcbiAgICAgICAqL1xuICAgICAgYWZ0ZXJSZW5kZXI6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgZW5kRnJhbWU6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgZGVzdHJveTogbmV3IFN5bmNIb29rKCksXG4gICAgICAvKipcbiAgICAgICAqIHVzZSBhc3luYyBidXQgZmFzdGVyIG1ldGhvZCBzdWNoIGFzIEdQVS1iYXNlZCBwaWNraW5nIGluIGBnLXBsdWdpbi1kZXZpY2UtcmVuZGVyZXJgXG4gICAgICAgKi9cbiAgICAgIHBpY2s6IG5ldyBBc3luY1Nlcmllc1dhdGVyZmFsbEhvb2soKSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zYWZlIGJ1dCBzeW5jIHZlcnNpb24gb2YgcGljay5cbiAgICAgICAqL1xuICAgICAgcGlja1N5bmM6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygpLFxuICAgICAgLyoqXG4gICAgICAgKiB1c2VkIGluIGV2ZW50IHN5c3RlbVxuICAgICAgICovXG4gICAgICBwb2ludGVyRG93bjogbmV3IFN5bmNIb29rKCksXG4gICAgICBwb2ludGVyVXA6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgcG9pbnRlck1vdmU6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgcG9pbnRlck91dDogbmV3IFN5bmNIb29rKCksXG4gICAgICBwb2ludGVyT3ZlcjogbmV3IFN5bmNIb29rKCksXG4gICAgICBwb2ludGVyV2hlZWw6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgcG9pbnRlckNhbmNlbDogbmV3IFN5bmNIb29rKCksXG4gICAgICBjbGljazogbmV3IFN5bmNIb29rKClcbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsUnVudGltZSA9IGdsb2JhbFJ1bnRpbWU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlbmRlcmluZ1NlcnZpY2UsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjb250ZXh0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmdsb2JhbFJ1bnRpbWUpLCB0aGlzLmNvbnRleHQpO1xuXG4gICAgICAvLyByZWdpc3RlciByZW5kZXJpbmcgcGx1Z2luc1xuICAgICAgdGhpcy5jb250ZXh0LnJlbmRlcmluZ1BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHBsdWdpbi5hcHBseShjb250ZXh0LCBfdGhpcy5nbG9iYWxSdW50aW1lKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ob29rcy5pbml0LmNhbGwoKTtcbiAgICAgIGlmICh0aGlzLmhvb2tzLmluaXRBc3luYy5nZXRDYWxsYmFja3NOdW0oKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhvb2tzLmluaXRBc3luYy5wcm9taXNlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RhdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZWV0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKiAqIGRpc2FibGUgRGlydHlSZWN0YW5nbGVSZW5kZXJpbmdcbiAgICAgKiAqIGNhbWVyYSBjaGFuZ2VkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZURpcnR5UmVjdGFuZ2xlUmVuZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVEaXJ0eVJlY3RhbmdsZVJlbmRlcmluZygpIHtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuY29udGV4dC5jb25maWcucmVuZGVyZXI7XG4gICAgICB2YXIgX3JlbmRlcmVyJGdldENvbmZpZyA9IHJlbmRlcmVyLmdldENvbmZpZygpLFxuICAgICAgICBlbmFibGVEaXJ0eVJlY3RhbmdsZVJlbmRlcmluZyA9IF9yZW5kZXJlciRnZXRDb25maWcuZW5hYmxlRGlydHlSZWN0YW5nbGVSZW5kZXJpbmc7XG4gICAgICByZXR1cm4gIWVuYWJsZURpcnR5UmVjdGFuZ2xlUmVuZGVyaW5nIHx8IHRoaXMuY29udGV4dC5yZW5kZXJpbmdDb250ZXh0LnJlbmRlclJlYXNvbnMuaGFzKFJlbmRlclJlYXNvbi5DQU1FUkFfQ0hBTkdFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY2FudmFzQ29uZmlnLCBmcmFtZSwgcmVyZW5kZXJDYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLnN0YXRzLnRvdGFsID0gMDtcbiAgICAgIHRoaXMuc3RhdHMucmVuZGVyZWQgPSAwO1xuICAgICAgdGhpcy56SW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHZhciByZW5kZXJpbmdDb250ZXh0ID0gdGhpcy5jb250ZXh0LnJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICB0aGlzLmdsb2JhbFJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2Uuc3luY0hpZXJhcmNoeShyZW5kZXJpbmdDb250ZXh0LnJvb3QpO1xuICAgICAgdGhpcy5nbG9iYWxSdW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnRyaWdnZXJQZW5kaW5nRXZlbnRzKCk7XG4gICAgICBpZiAocmVuZGVyaW5nQ29udGV4dC5yZW5kZXJSZWFzb25zLnNpemUgJiYgdGhpcy5pbml0ZWQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZW5kZXJpbmdDb250ZXh0LmRpcnR5UmVjdGFuZ2xlUmVuZGVyaW5nRGlzYWJsZWQgPSB0aGlzLmRpc2FibGVEaXJ0eVJlY3RhbmdsZVJlbmRlcmluZygpO1xuICAgICAgICB2YXIgb25seUNhbWVyYUNoYW5nZWQgPSByZW5kZXJpbmdDb250ZXh0LnJlbmRlclJlYXNvbnMuc2l6ZSA9PT0gMSAmJiByZW5kZXJpbmdDb250ZXh0LnJlbmRlclJlYXNvbnMuaGFzKFJlbmRlclJlYXNvbi5DQU1FUkFfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBzaG91bGRUcmlnZ2VyUmVuZGVySG9va3MgPSAhY2FudmFzQ29uZmlnLmRpc2FibGVSZW5kZXJIb29rcyB8fCAhKGNhbnZhc0NvbmZpZy5kaXNhYmxlUmVuZGVySG9va3MgJiYgb25seUNhbWVyYUNoYW5nZWQpO1xuICAgICAgICBpZiAoc2hvdWxkVHJpZ2dlclJlbmRlckhvb2tzKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJEaXNwbGF5T2JqZWN0KHJlbmRlcmluZ0NvbnRleHQucm9vdCwgY2FudmFzQ29uZmlnLCByZW5kZXJpbmdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvb2tzLmJlZ2luRnJhbWUuY2FsbChmcmFtZSk7XG4gICAgICAgIGlmIChzaG91bGRUcmlnZ2VyUmVuZGVySG9va3MpIHtcbiAgICAgICAgICByZW5kZXJpbmdDb250ZXh0LnJlbmRlckxpc3RDdXJyZW50RnJhbWUuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBfdGhpczIuaG9va3MuYmVmb3JlUmVuZGVyLmNhbGwob2JqZWN0KTtcbiAgICAgICAgICAgIF90aGlzMi5ob29rcy5yZW5kZXIuY2FsbChvYmplY3QpO1xuICAgICAgICAgICAgX3RoaXMyLmhvb2tzLmFmdGVyUmVuZGVyLmNhbGwob2JqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvb2tzLmVuZEZyYW1lLmNhbGwoZnJhbWUpO1xuICAgICAgICByZW5kZXJpbmdDb250ZXh0LnJlbmRlckxpc3RDdXJyZW50RnJhbWUgPSBbXTtcbiAgICAgICAgcmVuZGVyaW5nQ29udGV4dC5yZW5kZXJSZWFzb25zLmNsZWFyKCk7XG4gICAgICAgIHJlcmVuZGVyQ2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJ3N0YXRzJywgdGhpcy5zdGF0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckRpc3BsYXlPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCBjYW52YXNDb25maWcsIHJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBfY2FudmFzQ29uZmlnJHJlbmRlcmUgPSBjYW52YXNDb25maWcucmVuZGVyZXIuZ2V0Q29uZmlnKCksXG4gICAgICAgIGVuYWJsZURpcnR5Q2hlY2sgPSBfY2FudmFzQ29uZmlnJHJlbmRlcmUuZW5hYmxlRGlydHlDaGVjayxcbiAgICAgICAgZW5hYmxlQ3VsbGluZyA9IF9jYW52YXNDb25maWckcmVuZGVyZS5lbmFibGVDdWxsaW5nO1xuICAgICAgZnVuY3Rpb24gaW50ZXJuYWxSZW5kZXJTaW5nbGVEaXNwbGF5T2JqZWN0KG9iamVjdCkge1xuICAgICAgICAvLyBUT0RPOiByZWxheW91dFxuXG4gICAgICAgIC8vIGRpcnR5Y2hlY2sgZmlyc3RcbiAgICAgICAgdmFyIHJlbmRlcmFibGUgPSBvYmplY3QucmVuZGVyYWJsZSxcbiAgICAgICAgICBzb3J0YWJsZSA9IG9iamVjdC5zb3J0YWJsZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgIHZhciBvYmplY3RDaGFuZ2VkID0gZW5hYmxlRGlydHlDaGVjayA/XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVuZGVyYWJsZS5kaXJ0eSB8fCByZW5kZXJpbmdDb250ZXh0LmRpcnR5UmVjdGFuZ2xlUmVuZGVyaW5nRGlzYWJsZWQgPyBvYmplY3QgOiBudWxsIDogb2JqZWN0O1xuICAgICAgICBpZiAob2JqZWN0Q2hhbmdlZCkge1xuICAgICAgICAgIHZhciBvYmplY3RUb1JlbmRlciA9IGVuYWJsZUN1bGxpbmcgPyBzZWxmLmhvb2tzLmN1bGwuY2FsbChvYmplY3RDaGFuZ2VkLCBzZWxmLmNvbnRleHQuY2FtZXJhKSA6IG9iamVjdENoYW5nZWQ7XG4gICAgICAgICAgaWYgKG9iamVjdFRvUmVuZGVyKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRzLnJlbmRlcmVkICs9IDE7XG4gICAgICAgICAgICByZW5kZXJpbmdDb250ZXh0LnJlbmRlckxpc3RDdXJyZW50RnJhbWUucHVzaChvYmplY3RUb1JlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmFibGUuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgc29ydGFibGUucmVuZGVyT3JkZXIgPSBzZWxmLnpJbmRleENvdW50ZXI7XG4gICAgICAgIHNlbGYuekluZGV4Q291bnRlciArPSAxO1xuICAgICAgICBzZWxmLnN0YXRzLnRvdGFsICs9IDE7XG5cbiAgICAgICAgLy8gc29ydCBpcyB2ZXJ5IGV4cGVuc2l2ZSwgdXNlIGNhY2hlZCByZXN1bHQgaWYgcG9zc2libGVcbiAgICAgICAgaWYgKHNvcnRhYmxlLmRpcnR5KSB7XG4gICAgICAgICAgc2VsZi5zb3J0KG9iamVjdCwgc29ydGFibGUpO1xuICAgICAgICAgIHNvcnRhYmxlLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgc29ydGFibGUuZGlydHlDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIHNvcnRhYmxlLmRpcnR5UmVhc29uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3RhY2sgPSBbZGlzcGxheU9iamVjdF07XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY3VycmVudE9iamVjdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclNpbmdsZURpc3BsYXlPYmplY3QoY3VycmVudE9iamVjdCk7XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlIHJlbmRlcmluZyBpdHMgY2hpbGRyZW5cbiAgICAgICAgdmFyIG9iamVjdHMgPSBjdXJyZW50T2JqZWN0LnNvcnRhYmxlLnNvcnRlZCB8fCBjdXJyZW50T2JqZWN0LmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQoZGlzcGxheU9iamVjdCwgc29ydGFibGUpIHtcbiAgICAgIGlmIChzb3J0YWJsZS5zb3J0ZWQgJiYgc29ydGFibGUuZGlydHlSZWFzb24gIT09IFNvcnRSZWFzb24uWl9JTkRFWF9DSEFOR0VEKSB7XG4gICAgICAgIC8vIGF2b2lkIHJlLXNvcnRpbmcgdGhlIHdob2xlIGNoaWxkcmVuIGxpc3RcbiAgICAgICAgc29ydGFibGUuZGlydHlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGRpc3BsYXlPYmplY3QuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBzb3J0ZWQgbGlzdFxuICAgICAgICAgICAgdmFyIF9pbmRleCA9IHNvcnRhYmxlLnNvcnRlZC5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChfaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICBzb3J0YWJsZS5zb3J0ZWQuc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzb3J0YWJsZS5zb3J0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0YWJsZS5zb3J0ZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfaW5kZXgyID0gc29ydGVkSW5kZXgoc29ydGFibGUuc29ydGVkLCBjaGlsZCk7XG4gICAgICAgICAgICBzb3J0YWJsZS5zb3J0ZWQuc3BsaWNlKF9pbmRleDIsIDAsIGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ydGFibGUuc29ydGVkID0gZGlzcGxheU9iamVjdC5jaGlsZE5vZGVzLnNsaWNlKCkuc29ydChzb3J0QnlaSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ob29rcy5kZXN0cm95LmNhbGwoKTtcbiAgICAgIHRoaXMuZ2xvYmFsUnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5jbGVhclBlbmRpbmdFdmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlydGlmeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXJ0aWZ5KCkge1xuICAgICAgLy8gbmVlZCByZS1yZW5kZXJcbiAgICAgIHRoaXMuY29udGV4dC5yZW5kZXJpbmdDb250ZXh0LnJlbmRlclJlYXNvbnMuYWRkKFJlbmRlclJlYXNvbi5ESVNQTEFZX09CSkVDVF9DSEFOR0VEKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIEFUVFJJQlVURV9SRUdFWFAgPSAvXFxbXFxzKiguKik9KC4qKVxccypcXF0vO1xuXG4vKipcbiAqIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBET00gQVBJOlxuICogKiBnZXRFbGVtZW50QnlJZFxuICogKiBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lXG4gKiAqIGdldEVsZW1lbnRzQnlOYW1lXG4gKiAqIGdldEVsZW1lbnRzQnlUYWdcbiAqICogcXVlcnlTZWxlY3RvclxuICogKiBxdWVyeVNlbGVjdG9yQWxsXG4gKi9cbnZhciBEZWZhdWx0U2NlbmVHcmFwaFNlbGVjdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVmYXVsdFNjZW5lR3JhcGhTZWxlY3RvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdFNjZW5lR3JhcGhTZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEZWZhdWx0U2NlbmVHcmFwaFNlbGVjdG9yLCBbe1xuICAgIGtleTogXCJzZWxlY3RPbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T25lKHF1ZXJ5LCByb290KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHF1ZXJ5LnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gcm9vdC5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgLy8gcmV0dXJuICFub2RlLnNoYWRvdyAmJiBub2RlLmlkID09PSBxdWVyeS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgcmV0dXJuICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkgfHwgW10pLmluZGV4T2YoX3RoaXMuZ2V0SWRPckNsYXNzbmFtZShxdWVyeSkpID4gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5LnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCgnaWQnKVxuICAgICAgICByZXR1cm4gcm9vdC5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgLy8gcmV0dXJuICFub2RlLnNoYWRvdyAmJiBub2RlLmlkID09PSBxdWVyeS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IF90aGlzLmdldElkT3JDbGFzc25hbWUocXVlcnkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWVyeS5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldEF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKHF1ZXJ5KSxcbiAgICAgICAgICBuYW1lID0gX3RoaXMkZ2V0QXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgdmFsdWUgPSBfdGhpcyRnZXRBdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5TmFtZSgpO1xuICAgICAgICAgIHJldHVybiByb290LmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiByb290ICE9PSBub2RlICYmIChuYW1lID09PSAnbmFtZScgPyBub2RlLm5hbWUgPT09IHZhbHVlIDogX3RoaXMuYXR0cmlidXRlVG9TdHJpbmcobm9kZSwgbmFtZSkgPT09IHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIGdldEVsZW1lbnRzQnlUYWcoJ2NpcmNsZScpO1xuICAgICAgcmV0dXJuIHJvb3QuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gcm9vdCAhPT0gbm9kZSAmJiBub2RlLm5vZGVOYW1lID09PSBxdWVyeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0QWxsKHF1ZXJ5LCByb290KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIG9ubHkgc3VwcG9ydCBgW25hbWU9XCIke25hbWV9XCJdYCBgLmNsYXNzTmFtZWAgYCNpZGBcbiAgICAgIGlmIChxdWVyeS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgLy8gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xhc3NOYW1lJyk7XG4gICAgICAgIC8vIHNob3VsZCBub3QgaW5jbHVkZSBpdHNlbGZcbiAgICAgICAgcmV0dXJuIHJvb3QuZmluZEFsbChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiByb290ICE9PSBub2RlICYmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkgfHwgW10pLmluZGV4T2YoX3RoaXMyLmdldElkT3JDbGFzc25hbWUocXVlcnkpKSA+IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWVyeS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QuZmluZEFsbChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiByb290ICE9PSBub2RlICYmIG5vZGUuaWQgPT09IF90aGlzMi5nZXRJZE9yQ2xhc3NuYW1lKHF1ZXJ5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocXVlcnkuc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXRBdHRyaWJ1dGUyID0gdGhpcy5nZXRBdHRyaWJ1dGUocXVlcnkpLFxuICAgICAgICAgIG5hbWUgPSBfdGhpcyRnZXRBdHRyaWJ1dGUyLm5hbWUsXG4gICAgICAgICAgdmFsdWUgPSBfdGhpcyRnZXRBdHRyaWJ1dGUyLnZhbHVlO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIC8vIGdldEVsZW1lbnRzQnlOYW1lKCk7XG4gICAgICAgICAgcmV0dXJuIHJvb3QuZmluZEFsbChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QgIT09IG5vZGUgJiYgKG5hbWUgPT09ICduYW1lJyA/IG5vZGUubmFtZSA9PT0gdmFsdWUgOiBfdGhpczIuYXR0cmlidXRlVG9TdHJpbmcobm9kZSwgbmFtZSkgPT09IHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICAvLyBnZXRFbGVtZW50c0J5VGFnKCdjaXJjbGUnKTtcbiAgICAgIHJldHVybiByb290LmZpbmRBbGwoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QgIT09IG5vZGUgJiYgbm9kZS5ub2RlTmFtZSA9PT0gcXVlcnk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXMocXVlcnksIG5vZGUpIHtcbiAgICAgIC8vIGEgc2ltcGxlIGBtYXRjaGVzYCBpbXBsZW1lbnRhdGlvblxuICAgICAgaWYgKHF1ZXJ5LnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gbm9kZS5jbGFzc05hbWUgPT09IHRoaXMuZ2V0SWRPckNsYXNzbmFtZShxdWVyeSk7XG4gICAgICB9XG4gICAgICBpZiAocXVlcnkuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlkID09PSB0aGlzLmdldElkT3JDbGFzc25hbWUocXVlcnkpO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5LnN0YXJ0c1dpdGgoJ1snKSkge1xuICAgICAgICB2YXIgX3RoaXMkZ2V0QXR0cmlidXRlMyA9IHRoaXMuZ2V0QXR0cmlidXRlKHF1ZXJ5KSxcbiAgICAgICAgICBuYW1lID0gX3RoaXMkZ2V0QXR0cmlidXRlMy5uYW1lLFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMkZ2V0QXR0cmlidXRlMy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICduYW1lJyA/IG5vZGUubmFtZSA9PT0gdmFsdWUgOiB0aGlzLmF0dHJpYnV0ZVRvU3RyaW5nKG5vZGUsIG5hbWUpID09PSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBxdWVyeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SWRPckNsYXNzbmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZE9yQ2xhc3NuYW1lKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcXVlcnkuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKHF1ZXJ5KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHF1ZXJ5Lm1hdGNoKEFUVFJJQlVURV9SRUdFWFApO1xuICAgICAgdmFyIG5hbWUgPSAnJztcbiAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIG5hbWUgPSBtYXRjaGVzWzFdLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgdmFsdWUgPSBtYXRjaGVzWzJdLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlVG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlVG9TdHJpbmcobm9kZSwgbmFtZSkge1xuICAgICAgaWYgKCFub2RlLmdldEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIGJ1aWx0LWluIGV2ZW50cyBmb3IgZWxlbWVudFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25FdmVudFxuICpcbiAqIFRPRE86IHVzZSBNdXRhdGlvbk9ic2VydmVyIGluc3RlYWRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXJcbiAqL1xudmFyIEVsZW1lbnRFdmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRWxlbWVudEV2ZW50KSB7XG4gIC8vIC0tLSBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NdXRhdGlvbkV2ZW50XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtRE9NQXR0ck1vZGlmaWVkXG4gICAqL1xuICBFbGVtZW50RXZlbnRbXCJBVFRSX01PRElGSUVEXCJdID0gXCJET01BdHRyTW9kaWZpZWRcIjtcbiAgLyoqXG4gICAqIGl0IGhhcyBiZWVuIGluc2VydGVkXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1ET01Ob2RlSW5zZXJ0ZWRcbiAgICovXG4gIEVsZW1lbnRFdmVudFtcIklOU0VSVEVEXCJdID0gXCJET01Ob2RlSW5zZXJ0ZWRcIjtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZG9tbm9kZWluc2VydGVkaW50b2RvY3VtZW50XG4gICAqL1xuICBFbGVtZW50RXZlbnRbXCJNT1VOVEVEXCJdID0gXCJET01Ob2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnRcIjtcbiAgLyoqXG4gICAqIGl0IGlzIGJlaW5nIHJlbW92ZWRcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLURPTU5vZGVSZW1vdmVkXG4gICAqL1xuICBFbGVtZW50RXZlbnRbXCJSRU1PVkVEXCJdID0gXCJyZW1vdmVkXCI7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2RvbW5vZGVyZW1vdmVkZnJvbWRvY3VtZW50XG4gICAqL1xuICBFbGVtZW50RXZlbnRbXCJVTk1PVU5URURcIl0gPSBcIkRPTU5vZGVSZW1vdmVkRnJvbURvY3VtZW50XCI7XG4gIC8vIC0tLVxuICBFbGVtZW50RXZlbnRbXCJSRVBBUkVOVFwiXSA9IFwicmVwYXJlbnRcIjtcbiAgRWxlbWVudEV2ZW50W1wiREVTVFJPWVwiXSA9IFwiZGVzdHJveVwiO1xuICBFbGVtZW50RXZlbnRbXCJCT1VORFNfQ0hBTkdFRFwiXSA9IFwiYm91bmRzLWNoYW5nZWRcIjtcbiAgRWxlbWVudEV2ZW50W1wiQ1VMTEVEXCJdID0gXCJjdWxsZWRcIjtcbiAgcmV0dXJuIEVsZW1lbnRFdmVudDtcbn0oe30pO1xuXG4vLyAjcmVnaW9uIEV2ZW50VGFyZ2V0XG5cbi8vICNyZWdpb24gTm9kZVxuXG4vLyAjcmVnaW9uIEVsZW1lbnRcblxuLy8gI3JlZ2lvbiBBbmltYXRpb25UaW1lbGluZVxuXG4vLyAjcmVnaW9uIERvY3VtZW50XG5cbi8vICNyZWdpb24gQ1NTU3R5bGVEZWNsYXJhdGlvblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DU1NTdHlsZURlY2xhcmF0aW9uXG4gKi9cblxuLy8gI3JlZ2lvbiBDYW52YXNcblxudmFyIE11dGF0aW9uRXZlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9GZWRlcmF0ZWRFdmVudCkge1xuICBmdW5jdGlvbiBNdXRhdGlvbkV2ZW50KHR5cGVBcmcsIHJlbGF0ZWROb2RlLCBwcmV2VmFsdWUsIG5ld1ZhbHVlLCBhdHRyTmFtZSwgYXR0ckNoYW5nZSwgcHJldlBhcnNlZFZhbHVlLCBuZXdQYXJzZWRWYWx1ZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXV0YXRpb25FdmVudCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIE11dGF0aW9uRXZlbnQsIFtudWxsXSk7XG4gICAgX3RoaXMucmVsYXRlZE5vZGUgPSByZWxhdGVkTm9kZTtcbiAgICBfdGhpcy5wcmV2VmFsdWUgPSBwcmV2VmFsdWU7XG4gICAgX3RoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBfdGhpcy5hdHRyTmFtZSA9IGF0dHJOYW1lO1xuICAgIF90aGlzLmF0dHJDaGFuZ2UgPSBhdHRyQ2hhbmdlO1xuICAgIF90aGlzLnByZXZQYXJzZWRWYWx1ZSA9IHByZXZQYXJzZWRWYWx1ZTtcbiAgICBfdGhpcy5uZXdQYXJzZWRWYWx1ZSA9IG5ld1BhcnNlZFZhbHVlO1xuICAgIF90aGlzLnR5cGUgPSB0eXBlQXJnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoTXV0YXRpb25FdmVudCwgX0ZlZGVyYXRlZEV2ZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNdXRhdGlvbkV2ZW50KTtcbn0oRmVkZXJhdGVkRXZlbnQpO1xuTXV0YXRpb25FdmVudC5BRERJVElPTiA9IDI7XG5NdXRhdGlvbkV2ZW50Lk1PRElGSUNBVElPTiA9IDE7XG5NdXRhdGlvbkV2ZW50LlJFTU9WQUwgPSAzO1xuXG5mdW5jdGlvbiBtYXJrUmVuZGVyYWJsZURpcnR5KGUpIHtcbiAgdmFyIHJlbmRlcmFibGUgPSBlLnJlbmRlcmFibGU7XG4gIGlmIChyZW5kZXJhYmxlKSB7XG4gICAgcmVuZGVyYWJsZS5yZW5kZXJCb3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgcmVuZGVyYWJsZS5ib3VuZHNEaXJ0eSA9IHRydWU7XG4gIH1cbn1cbnZhciByZXBhcmVudEV2ZW50ID0gbmV3IE11dGF0aW9uRXZlbnQoRWxlbWVudEV2ZW50LlJFUEFSRU5ULCBudWxsLCAnJywgJycsICcnLCAwLCAnJywgJycpO1xuXG4vLyBPYmplY3QgcG9vbGluZ1xuLyoqIGRvIG5vdCBtb2RpZnkgdGhpcyBvYmplY3RzICovXG52YXIgJHZlYzJaZXJvID0gdmVjMi5jcmVhdGUoKTtcbi8qKiBkbyBub3QgbW9kaWZ5IHRoaXMgb2JqZWN0cyAqL1xudmFyICR2ZWMzWmVybyA9IHZlYzMuY3JlYXRlKCk7XG4vKiogZG8gbm90IG1vZGlmeSB0aGlzIG9iamVjdHMgKi9cbnZhciAkdmVjM09uZSA9IHZlYzMuZnJvbVZhbHVlcygxLCAxLCAxKTtcbi8qKiBkbyBub3QgbW9kaWZ5IHRoaXMgb2JqZWN0cyAqL1xudmFyICRtYXQ0SWRlbnRpdHkgPSBtYXQ0LmNyZWF0ZSgpO1xuXG4vKiogc2hhcmVkIG9iamVjdHMgKi9cbnZhciAkdmVjMiA9IHZlYzIuY3JlYXRlKCk7XG4vKiogc2hhcmVkIG9iamVjdHMgKi9cbnZhciAkdmVjMyQxID0gdmVjMy5jcmVhdGUoKTtcbi8qKiBzaGFyZWQgb2JqZWN0cyAqL1xudmFyICRtYXQ0ID0gbWF0NC5jcmVhdGUoKTtcbi8qKiBzaGFyZWQgb2JqZWN0cyAqL1xudmFyICRxdWF0JDEgPSBxdWF0JDEuY3JlYXRlKCk7XG52YXIgJHNldExvY2FsVHJhbnNmb3JtXzEgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyICRzZXRMb2NhbFRyYW5zZm9ybV8yID0gcXVhdCQxLmNyZWF0ZSgpO1xudmFyICRzZXRMb2NhbFRyYW5zZm9ybV8zID0gdmVjMy5jcmVhdGUoKTtcbnZhciAkc2V0TG9jYWxQb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG52YXIgJHNldFBvc2l0aW9uXzEgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyICRzZXRQb3NpdGlvbl9QYXJlbnRJbnZlcnRNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xudmFyICRzZXRFdWxlckFuZ2xlc19JbnZQYXJlbnRSb3QgPSBxdWF0JDEuY3JlYXRlKCk7XG52YXIgJHJvdGF0ZUxvY2FsID0gcXVhdCQxLmNyZWF0ZSgpO1xudmFyICRyb3RhdGVfUGFyZW50SW52ZXJ0Um90YXRpb24gPSBxdWF0JDEuY3JlYXRlKCk7XG52YXIgJHRyaWdnZXJQZW5kaW5nRXZlbnRzX2RldGFpbCA9IHtcbiAgYWZmZWN0Q2hpbGRyZW46IHRydWVcbn07XG5cbi8qKlxuICogdXBkYXRlIHRyYW5zZm9ybSBpbiBzY2VuZSBncmFwaFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9jb21tdW5pdHkua2hyb25vcy5vcmcvdC9zY2VuZS1ncmFwaHMvNTA1NDIvN1xuICovXG52YXIgRGVmYXVsdFNjZW5lR3JhcGhTZXJ2aWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVmYXVsdFNjZW5lR3JhcGhTZXJ2aWNlKHJ1bnRpbWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdFNjZW5lR3JhcGhTZXJ2aWNlKTtcbiAgICAvLyB0YXJnZXQgLT4gYWZmZWN0Q2hpbGRyZW5cbiAgICB0aGlzLnBlbmRpbmdFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5ib3VuZHNDaGFuZ2VkRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRWxlbWVudEV2ZW50LkJPVU5EU19DSEFOR0VEKTtcbiAgICB0aGlzLmRpc3BsYXlPYmplY3REZXBlbmRlbmN5TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGVmYXVsdFNjZW5lR3JhcGhTZXJ2aWNlLCBbe1xuICAgIGtleTogXCJtYXRjaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXMocXVlcnksIHJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuc2NlbmVHcmFwaFNlbGVjdG9yLmlzKHF1ZXJ5LCByb290KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVlcnlTZWxlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKHF1ZXJ5LCByb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5ydW50aW1lLnNjZW5lR3JhcGhTZWxlY3Rvci5zZWxlY3RPbmUocXVlcnksIHJvb3QpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWVyeVNlbGVjdG9yQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwocXVlcnksIHJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuc2NlbmVHcmFwaFNlbGVjdG9yLnNlbGVjdEFsbChxdWVyeSwgcm9vdCk7XG4gICAgICAvLyAuZmlsdGVyKChub2RlKSA9PiAhbm9kZS5zaGFkb3cpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKGNoaWxkLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgX3NvcnRhYmxlJHNvcnRlZDtcbiAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZGV0YWNoZWQgPSBjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGV0YWNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0NoaWxkRnJhZ21lbnQgPSBjaGlsZC5ub2RlTmFtZSA9PT0gU2hhcGUuRlJBR01FTlQ7XG4gICAgICB2YXIgaXNBdHRhY2hUb0ZyYWdtZW50ID0gaXNJbkZyYWdtZW50KHBhcmVudCk7XG4gICAgICBjaGlsZC5wYXJlbnROb2RlID0gcGFyZW50O1xuICAgICAgdmFyIG5vZGVzID0gaXNDaGlsZEZyYWdtZW50ID8gY2hpbGQuY2hpbGROb2RlcyA6IFtjaGlsZF07XG4gICAgICBpZiAoaXNOdW1iZXIoaW5kZXgpKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBwYXJlbnQuY2hpbGROb2Rlcy5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuICAgICAgICAgIG5vZGUucGFyZW50Tm9kZSA9IHBhcmVudDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcGFyZW50LmNoaWxkTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJlbnQgbmVlZHMgcmUtc29ydFxuICAgICAgdmFyIF9yZWYgPSBwYXJlbnQsXG4gICAgICAgIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZTtcbiAgICAgIGlmIChzb3J0YWJsZSAhPT0gbnVsbCAmJiBzb3J0YWJsZSAhPT0gdm9pZCAwICYmIChfc29ydGFibGUkc29ydGVkID0gc29ydGFibGUuc29ydGVkKSAhPT0gbnVsbCAmJiBfc29ydGFibGUkc29ydGVkICE9PSB2b2lkIDAgJiYgX3NvcnRhYmxlJHNvcnRlZC5sZW5ndGggfHwgY2hpbGQucGFyc2VkU3R5bGUuekluZGV4KSB7XG4gICAgICAgIGlmIChzb3J0YWJsZS5kaXJ0eUNoaWxkcmVuLmluZGV4T2YoY2hpbGQpID09PSAtMSkge1xuICAgICAgICAgIHNvcnRhYmxlLmRpcnR5Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHNvcnRhYmxlKSB7XG4gICAgICAgIC8vIG9ubHkgY2hpbGQgaGFzIHotSW5kZXhcbiAgICAgICAgc29ydGFibGUuZGlydHkgPSB0cnVlO1xuICAgICAgICBzb3J0YWJsZS5kaXJ0eVJlYXNvbiA9IFNvcnRSZWFzb24uQURERUQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNBdHRhY2hUb0ZyYWdtZW50KSByZXR1cm47XG4gICAgICBpZiAoaXNDaGlsZEZyYWdtZW50KSB0aGlzLmRpcnRpZnlGcmFnbWVudChjaGlsZCk7ZWxzZSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC50cmFuc2Zvcm1hYmxlO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0aWZ5V29ybGQoY2hpbGQsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXRhY2hlZCkge1xuICAgICAgICBjaGlsZC5kaXNwYXRjaEV2ZW50KHJlcGFyZW50RXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgX3NvcnRhYmxlJHNvcnRlZDIsIF9zdHlsZTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLnRyYW5zZm9ybWFibGU7XG4gICAgICAgIC8vIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gICBjb25zdCB3b3JsZFRyYW5zZm9ybSA9IHRoaXMuZ2V0V29ybGRUcmFuc2Zvcm0oY2hpbGQsIHRyYW5zZm9ybSk7XG4gICAgICAgIC8vICAgbWF0NC5nZXRTY2FsaW5nKHRyYW5zZm9ybS5sb2NhbFNjYWxlLCB3b3JsZFRyYW5zZm9ybSk7XG4gICAgICAgIC8vICAgbWF0NC5nZXRUcmFuc2xhdGlvbih0cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbiwgd29ybGRUcmFuc2Zvcm0pO1xuICAgICAgICAvLyAgIG1hdDQuZ2V0Um90YXRpb24odHJhbnNmb3JtLmxvY2FsUm90YXRpb24sIHdvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgLy8gICB0cmFuc2Zvcm0ubG9jYWxEaXJ0eUZsYWcgPSB0cnVlO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gcGFyZW50IG5lZWRzIHJlLXNvcnRcbiAgICAgICAgdmFyIF9yZWYyID0gY2hpbGQucGFyZW50Tm9kZSxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWYyLnNvcnRhYmxlO1xuICAgICAgICAvLyBpZiAoc29ydGFibGUpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlICE9PSBudWxsICYmIHNvcnRhYmxlICE9PSB2b2lkIDAgJiYgKF9zb3J0YWJsZSRzb3J0ZWQyID0gc29ydGFibGUuc29ydGVkKSAhPT0gbnVsbCAmJiBfc29ydGFibGUkc29ydGVkMiAhPT0gdm9pZCAwICYmIF9zb3J0YWJsZSRzb3J0ZWQyLmxlbmd0aCB8fCAoX3N0eWxlID0gY2hpbGQuc3R5bGUpICE9PSBudWxsICYmIF9zdHlsZSAhPT0gdm9pZCAwICYmIF9zdHlsZS56SW5kZXgpIHtcbiAgICAgICAgICBpZiAoc29ydGFibGUuZGlydHlDaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNvcnRhYmxlLmRpcnR5Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvcnRhYmxlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBzb3J0YWJsZS5kaXJ0eVJlYXNvbiA9IFNvcnRSZWFzb24uUkVNT1ZFRDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBjaGlsZC5wYXJlbnROb2RlLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5jaGlsZE5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIHRoaXMuZGlydGlmeVdvcmxkKGNoaWxkLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLnBhcmVudE5vZGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcmlnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JpZ2luKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuZ2V0R2VvbWV0cnlCb3VuZHMoKTtcbiAgICAgIHJldHVybiBlbGVtZW50LnRyYW5zZm9ybWFibGUub3JpZ2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNhbWUgYXMgcGl2b3QgaW4gUGl4aS5qc1xuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MDc0ODQ1Mi9ob3ctdG8tY2hhbmdlLWNzcy10cmFuc2Zvcm0tb3JpZ2luLWJ1dC1wcmVzZXJ2ZS10cmFuc2Zvcm1hdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9yaWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnaW4oZWxlbWVudCwgb3JpZ2luKSB7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG9yaWdpbiA9IFtvcmlnaW4sIHksIHpdO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIGlmIChvcmlnaW5bMF0gPT09IHRyYW5zZm9ybS5vcmlnaW5bMF0gJiYgb3JpZ2luWzFdID09PSB0cmFuc2Zvcm0ub3JpZ2luWzFdICYmIG9yaWdpblsyXSA9PT0gdHJhbnNmb3JtLm9yaWdpblsyXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luVmVjID0gdHJhbnNmb3JtLm9yaWdpbjtcblxuICAgICAgLy8gY29uc3QgZGVsdGEgPSB2ZWMzLnN1YnRyYWN0KHZlYzMuY3JlYXRlKCksIG9yaWdpbiwgb3JpZ2luVmVjKTtcbiAgICAgIC8vIHZlYzMuYWRkKHRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLCB0cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbiwgZGVsdGEpO1xuXG4gICAgICAvLyB1cGRhdGUgb3JpZ2luXG4gICAgICBvcmlnaW5WZWNbMF0gPSBvcmlnaW5bMF07XG4gICAgICBvcmlnaW5WZWNbMV0gPSBvcmlnaW5bMV07XG4gICAgICBvcmlnaW5WZWNbMl0gPSBvcmlnaW5bMl0gfHwgMDtcbiAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZShlbGVtZW50LCBkZWdyZWVzKSB7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgaWYgKHR5cGVvZiBkZWdyZWVzID09PSAnbnVtYmVyJykge1xuICAgICAgICBkZWdyZWVzID0gdmVjMy5mcm9tVmFsdWVzKGRlZ3JlZXMsIHksIHopO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwgfHwgIWVsZW1lbnQucGFyZW50Tm9kZS50cmFuc2Zvcm1hYmxlKSB7XG4gICAgICAgIHRoaXMucm90YXRlTG9jYWwoZWxlbWVudCwgZGVncmVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcm90YXRpb24gPSAkcXVhdCQxO1xuICAgICAgICBxdWF0JDEuZnJvbUV1bGVyKHJvdGF0aW9uLCBkZWdyZWVzWzBdLCBkZWdyZWVzWzFdLCBkZWdyZWVzWzJdKTtcbiAgICAgICAgdmFyIHJvdCA9IHRoaXMuZ2V0Um90YXRpb24oZWxlbWVudCk7XG4gICAgICAgIHZhciBwYXJlbnRSb3QgPSB0aGlzLmdldFJvdGF0aW9uKGVsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgICAgIHF1YXQkMS5jb3B5KCRyb3RhdGVfUGFyZW50SW52ZXJ0Um90YXRpb24sIHBhcmVudFJvdCk7XG4gICAgICAgIHF1YXQkMS5pbnZlcnQoJHJvdGF0ZV9QYXJlbnRJbnZlcnRSb3RhdGlvbiwgJHJvdGF0ZV9QYXJlbnRJbnZlcnRSb3RhdGlvbik7XG4gICAgICAgIHF1YXQkMS5tdWx0aXBseShyb3RhdGlvbiwgJHJvdGF0ZV9QYXJlbnRJbnZlcnRSb3RhdGlvbiwgcm90YXRpb24pO1xuICAgICAgICBxdWF0JDEubXVsdGlwbHkodHJhbnNmb3JtLmxvY2FsUm90YXRpb24sIHJvdGF0aW9uLCByb3QpO1xuICAgICAgICBxdWF0JDEubm9ybWFsaXplKHRyYW5zZm9ybS5sb2NhbFJvdGF0aW9uLCB0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbik7XG4gICAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGluIGxvY2FsIHNwYWNlXG4gICAgICogQHNlZSBAc2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3Mvd2luMzIvYXBpL2RpcmVjdHhtYXRoL25mLWRpcmVjdHhtYXRoLXhtcXVhdGVybmlvbnJvdGF0aW9ucm9sbHBpdGNoeWF3XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlTG9jYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlTG9jYWwoZWxlbWVudCwgZGVncmVlcykge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgeiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZGVncmVlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGVncmVlcyA9IHZlYzMuZnJvbVZhbHVlcyhkZWdyZWVzLCB5LCB6KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICBxdWF0JDEuZnJvbUV1bGVyKCRyb3RhdGVMb2NhbCwgZGVncmVlc1swXSwgZGVncmVlc1sxXSwgZGVncmVlc1syXSk7XG4gICAgICBxdWF0JDEubXVsKHRyYW5zZm9ybS5sb2NhbFJvdGF0aW9uLCB0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbiwgJHJvdGF0ZUxvY2FsKTtcbiAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGV1bGVyIGFuZ2xlcyhkZWdyZWVzKSBpbiB3b3JsZCBzcGFjZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEV1bGVyQW5nbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEV1bGVyQW5nbGVzKGVsZW1lbnQsIGRlZ3JlZXMpIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICBpZiAodHlwZW9mIGRlZ3JlZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRlZ3JlZXMgPSB2ZWMzLmZyb21WYWx1ZXMoZGVncmVlcywgeSwgeik7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZWxlbWVudC50cmFuc2Zvcm1hYmxlO1xuICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCB8fCAhZWxlbWVudC5wYXJlbnROb2RlLnRyYW5zZm9ybWFibGUpIHtcbiAgICAgICAgdGhpcy5zZXRMb2NhbEV1bGVyQW5nbGVzKGVsZW1lbnQsIGRlZ3JlZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVhdCQxLmZyb21FdWxlcih0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbiwgZGVncmVlc1swXSwgZGVncmVlc1sxXSwgZGVncmVlc1syXSk7XG4gICAgICAgIHZhciBwYXJlbnRSb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICAgICAgcXVhdCQxLmNvcHkoJHNldEV1bGVyQW5nbGVzX0ludlBhcmVudFJvdCwgcXVhdCQxLmludmVydCgkcXVhdCQxLCBwYXJlbnRSb3RhdGlvbikpO1xuICAgICAgICBxdWF0JDEubXVsKHRyYW5zZm9ybS5sb2NhbFJvdGF0aW9uLCB0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbiwgJHNldEV1bGVyQW5nbGVzX0ludlBhcmVudFJvdCk7XG4gICAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGV1bGVyIGFuZ2xlcyhkZWdyZWVzKSBpbiBsb2NhbCBzcGFjZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldExvY2FsRXVsZXJBbmdsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TG9jYWxFdWxlckFuZ2xlcyhlbGVtZW50LCBkZWdyZWVzKSB7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIGRpcnRpZnkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgICBpZiAodHlwZW9mIGRlZ3JlZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRlZ3JlZXMgPSB2ZWMzLmZyb21WYWx1ZXMoZGVncmVlcywgeSwgeik7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZWxlbWVudC50cmFuc2Zvcm1hYmxlO1xuICAgICAgcXVhdCQxLmZyb21FdWxlcih0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbiwgZGVncmVlc1swXSwgZGVncmVlc1sxXSwgZGVncmVlc1syXSk7XG4gICAgICBpZiAoZGlydGlmeSkge1xuICAgICAgICB0aGlzLmRpcnRpZnlMb2NhbChlbGVtZW50LCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyYW5zbGF0ZSBpbiBsb2NhbCBzcGFjZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiB0cmFuc2xhdGVMb2NhbCh4LCB5LCB6KVxuICAgICAqIHRyYW5zbGF0ZUxvY2FsKHZlYzMoeCwgeSwgeikpXG4gICAgICogYGBgXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNsYXRlTG9jYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlTG9jYWwoZWxlbWVudCwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICBpZiAodHlwZW9mIHRyYW5zbGF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICB0cmFuc2xhdGlvbiA9IHZlYzMuZnJvbVZhbHVlcyh0cmFuc2xhdGlvbiwgeSwgeik7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZWxlbWVudC50cmFuc2Zvcm1hYmxlO1xuICAgICAgaWYgKHZlYzMuZXF1YWxzKHRyYW5zbGF0aW9uLCAkdmVjM1plcm8pKSByZXR1cm47XG4gICAgICB2ZWMzLnRyYW5zZm9ybVF1YXQodHJhbnNsYXRpb24sIHRyYW5zbGF0aW9uLCB0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbik7XG4gICAgICB2ZWMzLmFkZCh0cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbiwgdHJhbnNmb3JtLmxvY2FsUG9zaXRpb24sIHRyYW5zbGF0aW9uKTtcbiAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbW92ZSB0byBwb3NpdGlvbiBpbiB3b3JsZCBzcGFjZVxuICAgICAqXG4gICAgICog5a+55bqUIGcg5Y6f54mI55qEIG1vdmUvbW92ZVRvXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW50dmlzL2cvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZy1iYXNlL3NyYy9hYnN0cmFjdC9lbGVtZW50LnRzI0w2ODQtTDY4OVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3Bvc2l0aW9uJDtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICAkc2V0UG9zaXRpb25fMVswXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgJHNldFBvc2l0aW9uXzFbMV0gPSBwb3NpdGlvblsxXTtcbiAgICAgICRzZXRQb3NpdGlvbl8xWzJdID0gKF9wb3NpdGlvbiQgPSBwb3NpdGlvblsyXSkgIT09IG51bGwgJiYgX3Bvc2l0aW9uJCAhPT0gdm9pZCAwID8gX3Bvc2l0aW9uJCA6IDA7XG4gICAgICBpZiAodmVjMy5lcXVhbHModGhpcy5nZXRQb3NpdGlvbihlbGVtZW50KSwgJHNldFBvc2l0aW9uXzEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZlYzMuY29weSh0cmFuc2Zvcm0ucG9zaXRpb24sICRzZXRQb3NpdGlvbl8xKTtcbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwgfHwgIWVsZW1lbnQucGFyZW50Tm9kZS50cmFuc2Zvcm1hYmxlKSB7XG4gICAgICAgIHZlYzMuY29weSh0cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbiwgJHNldFBvc2l0aW9uXzEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcmVudFRyYW5zZm9ybSA9IGVsZW1lbnQucGFyZW50Tm9kZS50cmFuc2Zvcm1hYmxlO1xuICAgICAgICBtYXQ0LmNvcHkoJHNldFBvc2l0aW9uX1BhcmVudEludmVydE1hdHJpeCwgcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgbWF0NC5pbnZlcnQoJHNldFBvc2l0aW9uX1BhcmVudEludmVydE1hdHJpeCwgJHNldFBvc2l0aW9uX1BhcmVudEludmVydE1hdHJpeCk7XG4gICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NCh0cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbiwgJHNldFBvc2l0aW9uXzEsICRzZXRQb3NpdGlvbl9QYXJlbnRJbnZlcnRNYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXJ0aWZ5TG9jYWwoZWxlbWVudCwgdHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRvIHBvc2l0aW9uIGluIGxvY2FsIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbFBvc2l0aW9uKGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3Bvc2l0aW9uJDI7XG4gICAgICB2YXIgZGlydGlmeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICAkc2V0TG9jYWxQb3NpdGlvblswXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgJHNldExvY2FsUG9zaXRpb25bMV0gPSBwb3NpdGlvblsxXTtcbiAgICAgICRzZXRMb2NhbFBvc2l0aW9uWzJdID0gKF9wb3NpdGlvbiQyID0gcG9zaXRpb25bMl0pICE9PSBudWxsICYmIF9wb3NpdGlvbiQyICE9PSB2b2lkIDAgPyBfcG9zaXRpb24kMiA6IDA7XG4gICAgICBpZiAodmVjMy5lcXVhbHModHJhbnNmb3JtLmxvY2FsUG9zaXRpb24sICRzZXRMb2NhbFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2ZWMzLmNvcHkodHJhbnNmb3JtLmxvY2FsUG9zaXRpb24sICRzZXRMb2NhbFBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXJ0aWZ5KSB7XG4gICAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2NhbGUgaW4gbG9jYWwgc3BhY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzY2FsZUxvY2FsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlTG9jYWwoZWxlbWVudCwgc2NhbGluZykge1xuICAgICAgdmFyIF9zY2FsaW5nJDtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICB2ZWMzLm11bHRpcGx5KHRyYW5zZm9ybS5sb2NhbFNjYWxlLCB0cmFuc2Zvcm0ubG9jYWxTY2FsZSwgdmVjMy5zZXQoJHZlYzMkMSwgc2NhbGluZ1swXSwgc2NhbGluZ1sxXSwgKF9zY2FsaW5nJCA9IHNjYWxpbmdbMl0pICE9PSBudWxsICYmIF9zY2FsaW5nJCAhPT0gdm9pZCAwID8gX3NjYWxpbmckIDogMSkpO1xuICAgICAgdGhpcy5kaXJ0aWZ5TG9jYWwoZWxlbWVudCwgdHJhbnNmb3JtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbFNjYWxlKGVsZW1lbnQsIHNjYWxpbmcpIHtcbiAgICAgIHZhciBfc2NhbGluZyQyO1xuICAgICAgdmFyIGRpcnRpZnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZWxlbWVudC50cmFuc2Zvcm1hYmxlO1xuICAgICAgdmVjMy5zZXQoJHZlYzMkMSwgc2NhbGluZ1swXSwgc2NhbGluZ1sxXSwgKF9zY2FsaW5nJDIgPSBzY2FsaW5nWzJdKSAhPT0gbnVsbCAmJiBfc2NhbGluZyQyICE9PSB2b2lkIDAgPyBfc2NhbGluZyQyIDogdHJhbnNmb3JtLmxvY2FsU2NhbGVbMl0pO1xuICAgICAgaWYgKHZlYzMuZXF1YWxzKCR2ZWMzJDEsIHRyYW5zZm9ybS5sb2NhbFNjYWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2ZWMzLmNvcHkodHJhbnNmb3JtLmxvY2FsU2NhbGUsICR2ZWMzJDEpO1xuICAgICAgaWYgKGRpcnRpZnkpIHtcbiAgICAgICAgdGhpcy5kaXJ0aWZ5TG9jYWwoZWxlbWVudCwgdHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2xhdGUgaW4gd29ybGQgc3BhY2VcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogdHJhbnNsYXRlKHgsIHksIHopXG4gICAgICogdHJhbnNsYXRlKHZlYzMoeCwgeSwgeikpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiDlr7nlupQgZyDljp/niYjnmoQgdHJhbnNsYXRlIDJEXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW50dmlzL2cvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZy1iYXNlL3NyYy9hYnN0cmFjdC9lbGVtZW50LnRzI0w2NjUtTDY3NlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUoZWxlbWVudCwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICBpZiAodHlwZW9mIHRyYW5zbGF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICB0cmFuc2xhdGlvbiA9IHZlYzMuc2V0KCR2ZWMzJDEsIHRyYW5zbGF0aW9uLCB5LCB6KTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZWMzLmVxdWFscyh0cmFuc2xhdGlvbiwgJHZlYzNaZXJvKSkgcmV0dXJuO1xuICAgICAgdmVjMy5hZGQoJHZlYzMkMSwgdGhpcy5nZXRQb3NpdGlvbihlbGVtZW50KSwgdHJhbnNsYXRpb24pO1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbihlbGVtZW50LCAkdmVjMyQxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Um90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Um90YXRpb24oZWxlbWVudCwgcm90YXRpb24sIHksIHosIHcpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICBpZiAodHlwZW9mIHJvdGF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICByb3RhdGlvbiA9IHF1YXQkMS5mcm9tVmFsdWVzKHJvdGF0aW9uLCB5LCB6LCB3KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwgfHwgIWVsZW1lbnQucGFyZW50Tm9kZS50cmFuc2Zvcm1hYmxlKSB7XG4gICAgICAgIHRoaXMuc2V0TG9jYWxSb3RhdGlvbihlbGVtZW50LCByb3RhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFyZW50Um90ID0gdGhpcy5nZXRSb3RhdGlvbihlbGVtZW50LnBhcmVudE5vZGUpO1xuICAgICAgICBxdWF0JDEuY29weSgkcXVhdCQxLCBwYXJlbnRSb3QpO1xuICAgICAgICBxdWF0JDEuaW52ZXJ0KCRxdWF0JDEsICRxdWF0JDEpO1xuICAgICAgICBxdWF0JDEubXVsdGlwbHkodHJhbnNmb3JtLmxvY2FsUm90YXRpb24sICRxdWF0JDEsIHJvdGF0aW9uKTtcbiAgICAgICAgcXVhdCQxLm5vcm1hbGl6ZSh0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbiwgdHJhbnNmb3JtLmxvY2FsUm90YXRpb24pO1xuICAgICAgICB0aGlzLmRpcnRpZnlMb2NhbChlbGVtZW50LCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb2NhbFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvY2FsUm90YXRpb24oZWxlbWVudCwgcm90YXRpb24sIHksIHosIHcpIHtcbiAgICAgIHZhciBkaXJ0aWZ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiByb3RhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcm90YXRpb24gPSBxdWF0JDEuc2V0KCRxdWF0JDEsIHJvdGF0aW9uLCB5LCB6LCB3KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICBxdWF0JDEuY29weSh0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbiwgcm90YXRpb24pO1xuICAgICAgaWYgKGRpcnRpZnkpIHtcbiAgICAgICAgdGhpcy5kaXJ0aWZ5TG9jYWwoZWxlbWVudCwgdHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxTa2V3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvY2FsU2tldyhlbGVtZW50LCBza2V3LCB5KSB7XG4gICAgICB2YXIgZGlydGlmeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygc2tldyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2tldyA9IHZlYzIuc2V0KCR2ZWMyLCBza2V3LCB5KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICB2ZWMyLmNvcHkodHJhbnNmb3JtLmxvY2FsU2tldywgc2tldyk7XG4gICAgICBpZiAoZGlydGlmeSkge1xuICAgICAgICB0aGlzLmRpcnRpZnlMb2NhbChlbGVtZW50LCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXJ0aWZ5TG9jYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlydGlmeUxvY2FsKGVsZW1lbnQsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKGlzSW5GcmFnbWVudChlbGVtZW50KSkgcmV0dXJuO1xuICAgICAgaWYgKCF0cmFuc2Zvcm0ubG9jYWxEaXJ0eUZsYWcpIHtcbiAgICAgICAgdHJhbnNmb3JtLmxvY2FsRGlydHlGbGFnID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0uZGlydHlGbGFnKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0aWZ5V29ybGQoZWxlbWVudCwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXJ0aWZ5V29ybGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlydGlmeVdvcmxkKGVsZW1lbnQsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0uZGlydHlGbGFnKSB7XG4gICAgICAgIHRoaXMudW5mcmVlemVQYXJlbnRUb1Jvb3QoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRpcnRpZnlXb3JsZEludGVybmFsKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG4gICAgICB0aGlzLmRpcnRpZnlUb1Jvb3QoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpcnRpZnlGcmFnbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXJ0aWZ5RnJhZ21lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtLmZyb3plbiA9IGZhbHNlO1xuICAgICAgICB0cmFuc2Zvcm0uZGlydHlGbGFnID0gdHJ1ZTtcbiAgICAgICAgdHJhbnNmb3JtLmxvY2FsRGlydHlGbGFnID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZW5kZXJhYmxlID0gZWxlbWVudC5yZW5kZXJhYmxlO1xuICAgICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgICAgcmVuZGVyYWJsZS5yZW5kZXJCb3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgICAgIHJlbmRlcmFibGUuYm91bmRzRGlydHkgPSB0cnVlO1xuICAgICAgICByZW5kZXJhYmxlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRpcnRpZnlGcmFnbWVudChlbGVtZW50LmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09IFNoYXBlLkZSQUdNRU5UKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0V2ZW50cy5zZXQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmlnZ2VyUGVuZGluZ0V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyUGVuZGluZ0V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgdHJpZ2dlcmVkID0gbmV3IFNldCgpO1xuICAgICAgdmFyIHRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGVsZW1lbnQsIGRldGFpbCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQuaXNDb25uZWN0ZWQgfHwgdHJpZ2dlcmVkLmhhcyhlbGVtZW50KSB8fCBlbGVtZW50Lm5vZGVOYW1lID09PSBTaGFwZS5GUkFHTUVOVCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5ib3VuZHNDaGFuZ2VkRXZlbnQuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgICBfdGhpcy5ib3VuZHNDaGFuZ2VkRXZlbnQudGFyZ2V0ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNNdXRhdGlvbk9ic2VydmVkKSB7XG4gICAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KF90aGlzLmJvdW5kc0NoYW5nZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmRpc3BhdGNoRXZlbnQoX3RoaXMuYm91bmRzQ2hhbmdlZEV2ZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyZWQuYWRkKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucGVuZGluZ0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhZmZlY3RDaGlsZHJlbiwgZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gU2hhcGUuRlJBR01FTlQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgJHRyaWdnZXJQZW5kaW5nRXZlbnRzX2RldGFpbC5hZmZlY3RDaGlsZHJlbiA9IGFmZmVjdENoaWxkcmVuO1xuICAgICAgICBpZiAoYWZmZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgICBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyaWdnZXIoZSwgJHRyaWdnZXJQZW5kaW5nRXZlbnRzX2RldGFpbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB0cmlnZ2VyKGVsZW1lbnQsICR0cmlnZ2VyUGVuZGluZ0V2ZW50c19kZXRhaWwpO1xuICAgICAgfSk7XG4gICAgICB0cmlnZ2VyZWQuY2xlYXIoKTtcbiAgICAgIHRoaXMuY2xlYXJQZW5kaW5nRXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyUGVuZGluZ0V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclBlbmRpbmdFdmVudHMoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdFdmVudHMuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlydGlmeVRvUm9vdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXJ0aWZ5VG9Sb290KGVsZW1lbnQpIHtcbiAgICAgIHZhciBhZmZlY3RDaGlsZHJlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgcCA9IGVsZW1lbnQ7XG5cbiAgICAgIC8vIG9ubHkgbmVlZCB0byByZS1yZW5kZXIgaXRzZWxmXG4gICAgICBpZiAocC5yZW5kZXJhYmxlKSB7XG4gICAgICAgIHAucmVuZGVyYWJsZS5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBtYXJrUmVuZGVyYWJsZURpcnR5KHApO1xuICAgICAgICBwID0gcC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKGFmZmVjdENoaWxkcmVuKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG1hcmtSZW5kZXJhYmxlRGlydHkoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmZvcm1EZXBlbmRlbnREaXNwbGF5T2JqZWN0cyhlbGVtZW50KTtcbiAgICAgIHRoaXMucGVuZGluZ0V2ZW50cy5zZXQoZWxlbWVudCwgYWZmZWN0Q2hpbGRyZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVEaXNwbGF5T2JqZWN0RGVwZW5kZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5T2JqZWN0RGVwZW5kZW5jeShuYW1lLCBvbGRQYXRoLCBuZXdQYXRoLCBvYmplY3QpIHtcbiAgICAgIC8vIGNsZWFyIHJlZiB0byBvbGQgY2xpcCBwYXRoXG4gICAgICBpZiAob2xkUGF0aCAmJiBvbGRQYXRoICE9PSBuZXdQYXRoKSB7XG4gICAgICAgIHZhciBvbGREZXBlbmRlbmN5TWFwID0gdGhpcy5kaXNwbGF5T2JqZWN0RGVwZW5kZW5jeU1hcC5nZXQob2xkUGF0aCk7XG4gICAgICAgIGlmIChvbGREZXBlbmRlbmN5TWFwICYmIG9sZERlcGVuZGVuY3lNYXBbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBvbGREZXBlbmRlbmN5TWFwW25hbWVdLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgICBvbGREZXBlbmRlbmN5TWFwW25hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdQYXRoKSB7XG4gICAgICAgIHZhciBuZXdEZXBlbmRlbmN5TWFwID0gdGhpcy5kaXNwbGF5T2JqZWN0RGVwZW5kZW5jeU1hcC5nZXQobmV3UGF0aCk7XG4gICAgICAgIGlmICghbmV3RGVwZW5kZW5jeU1hcCkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheU9iamVjdERlcGVuZGVuY3lNYXAuc2V0KG5ld1BhdGgsIHt9KTtcbiAgICAgICAgICBuZXdEZXBlbmRlbmN5TWFwID0gdGhpcy5kaXNwbGF5T2JqZWN0RGVwZW5kZW5jeU1hcC5nZXQobmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdEZXBlbmRlbmN5TWFwW25hbWVdKSB7XG4gICAgICAgICAgbmV3RGVwZW5kZW5jeU1hcFtuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RlcGVuZGVuY3lNYXBbbmFtZV0ucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmZvcm1EZXBlbmRlbnREaXNwbGF5T2JqZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvcm1EZXBlbmRlbnREaXNwbGF5T2JqZWN0cyhvYmplY3QpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGRlcGVuZGVuY3lNYXAgPSB0aGlzLmRpc3BsYXlPYmplY3REZXBlbmRlbmN5TWFwLmdldChvYmplY3QpO1xuICAgICAgaWYgKCFkZXBlbmRlbmN5TWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKGRlcGVuZGVuY3lNYXApLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZGVwZW5kZW5jeU1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICBfdGhpczIuZGlydGlmeVRvUm9vdCh0YXJnZXQsIHRydWUpO1xuICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBNdXRhdGlvbkV2ZW50KEVsZW1lbnRFdmVudC5BVFRSX01PRElGSUVELCB0YXJnZXQsIF90aGlzMiwgX3RoaXMyLCBuYW1lLCBNdXRhdGlvbkV2ZW50Lk1PRElGSUNBVElPTiwgX3RoaXMyLCBfdGhpczIpKTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmlzQ3VzdG9tRWxlbWVudCAmJiB0YXJnZXQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRhcmdldC5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgX3RoaXMyLCBfdGhpczIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIHJldHVybiBtYXQ0LmdldFRyYW5zbGF0aW9uKHRyYW5zZm9ybS5wb3NpdGlvbiwgdGhpcy5nZXRXb3JsZFRyYW5zZm9ybShlbGVtZW50LCB0cmFuc2Zvcm0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Um90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um90YXRpb24oZWxlbWVudCkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIHJldHVybiBtYXQ0LmdldFJvdGF0aW9uKHRyYW5zZm9ybS5yb3RhdGlvbiwgdGhpcy5nZXRXb3JsZFRyYW5zZm9ybShlbGVtZW50LCB0cmFuc2Zvcm0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIHJldHVybiBtYXQ0LmdldFNjYWxpbmcodHJhbnNmb3JtLnNjYWxpbmcsIHRoaXMuZ2V0V29ybGRUcmFuc2Zvcm0oZWxlbWVudCwgdHJhbnNmb3JtKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdvcmxkVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmxkVHJhbnNmb3JtKGVsZW1lbnQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIGlmICghdHJhbnNmb3JtLmxvY2FsRGlydHlGbGFnICYmICF0cmFuc2Zvcm0uZGlydHlGbGFnKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS50cmFuc2Zvcm1hYmxlKSB7XG4gICAgICAgIHRoaXMuZ2V0V29ybGRUcmFuc2Zvcm0oZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3luYyhlbGVtZW50LCB0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnRyYW5zZm9ybWFibGUubG9jYWxQb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFJvdGF0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnRyYW5zZm9ybWFibGUubG9jYWxSb3RhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFNjYWxlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnRyYW5zZm9ybWFibGUubG9jYWxTY2FsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxTa2V3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsU2tldyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50cmFuc2Zvcm1hYmxlLmxvY2FsU2tldztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY0xvY2FsVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNMb2NhbFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciBoYXNTa2V3ID0gdHJhbnNmb3JtLmxvY2FsU2tld1swXSAhPT0gMCB8fCB0cmFuc2Zvcm0ubG9jYWxTa2V3WzFdICE9PSAwO1xuICAgICAgaWYgKGhhc1NrZXcpIHtcbiAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKHRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybSwgdHJhbnNmb3JtLmxvY2FsUm90YXRpb24sIHRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLCB2ZWMzLmZyb21WYWx1ZXMoMSwgMSwgMSksIHRyYW5zZm9ybS5vcmlnaW4pO1xuXG4gICAgICAgIC8vIGFwcGx5IHNrZXcyRFxuICAgICAgICBpZiAodHJhbnNmb3JtLmxvY2FsU2tld1swXSAhPT0gMCB8fCB0cmFuc2Zvcm0ubG9jYWxTa2V3WzFdICE9PSAwKSB7XG4gICAgICAgICAgbWF0NC5pZGVudGl0eSgkbWF0NCk7XG4gICAgICAgICAgJG1hdDRbNF0gPSBNYXRoLnRhbih0cmFuc2Zvcm0ubG9jYWxTa2V3WzBdKTtcbiAgICAgICAgICAkbWF0NFsxXSA9IE1hdGgudGFuKHRyYW5zZm9ybS5sb2NhbFNrZXdbMV0pO1xuICAgICAgICAgIG1hdDQubXVsdGlwbHkodHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLCB0cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0sICRtYXQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGluZyA9IG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbigkbWF0NCwgcXVhdCQxLnNldCgkcXVhdCQxLCAwLCAwLCAwLCAxKSwgdmVjMy5zZXQoJHZlYzMkMSwgMSwgMSwgMSksIHRyYW5zZm9ybS5sb2NhbFNjYWxlLCB0cmFuc2Zvcm0ub3JpZ2luKTtcbiAgICAgICAgbWF0NC5tdWx0aXBseSh0cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0sIHRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybSwgc2NhbGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbG9jYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0sXG4gICAgICAgICAgbG9jYWxQb3NpdGlvbiA9IHRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLFxuICAgICAgICAgIGxvY2FsUm90YXRpb24gPSB0cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbixcbiAgICAgICAgICBsb2NhbFNjYWxlID0gdHJhbnNmb3JtLmxvY2FsU2NhbGUsXG4gICAgICAgICAgb3JpZ2luID0gdHJhbnNmb3JtLm9yaWdpbjtcbiAgICAgICAgdmFyIGhhc1Bvc2l0aW9uID0gbG9jYWxQb3NpdGlvblswXSAhPT0gMCB8fCBsb2NhbFBvc2l0aW9uWzFdICE9PSAwIHx8IGxvY2FsUG9zaXRpb25bMl0gIT09IDA7XG4gICAgICAgIHZhciBoYXNSb3RhdGlvbiA9IGxvY2FsUm90YXRpb25bM10gIT09IDEgfHwgbG9jYWxSb3RhdGlvblswXSAhPT0gMCB8fCBsb2NhbFJvdGF0aW9uWzFdICE9PSAwIHx8IGxvY2FsUm90YXRpb25bMl0gIT09IDA7XG4gICAgICAgIHZhciBoYXNTY2FsZSA9IGxvY2FsU2NhbGVbMF0gIT09IDEgfHwgbG9jYWxTY2FsZVsxXSAhPT0gMSB8fCBsb2NhbFNjYWxlWzJdICE9PSAxO1xuICAgICAgICB2YXIgaGFzT3JpZ2luID0gb3JpZ2luWzBdICE9PSAwIHx8IG9yaWdpblsxXSAhPT0gMCB8fCBvcmlnaW5bMl0gIT09IDA7XG4gICAgICAgIGlmICghaGFzUm90YXRpb24gJiYgIWhhc1NjYWxlICYmICFoYXNPcmlnaW4pIHtcbiAgICAgICAgICBpZiAoaGFzUG9zaXRpb24pIHtcbiAgICAgICAgICAgIG1hdDQuZnJvbVRyYW5zbGF0aW9uKGxvY2FsVHJhbnNmb3JtLCBsb2NhbFBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0NC5pZGVudGl0eShsb2NhbFRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Nzcy1tYXQ0L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKGxvY2FsVHJhbnNmb3JtLCBsb2NhbFJvdGF0aW9uLCBsb2NhbFBvc2l0aW9uLCBsb2NhbFNjYWxlLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExvY2FsVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsVHJhbnNmb3JtKGVsZW1lbnQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtZW50LnRyYW5zZm9ybWFibGU7XG4gICAgICBpZiAodHJhbnNmb3JtLmxvY2FsRGlydHlGbGFnKSB7XG4gICAgICAgIHRoaXMuY2FsY0xvY2FsVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHRyYW5zZm9ybS5sb2NhbERpcnR5RmxhZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TG9jYWxUcmFuc2Zvcm0oZWxlbWVudCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdCA9IG1hdDQuZ2V0VHJhbnNsYXRpb24oJHNldExvY2FsVHJhbnNmb3JtXzEsIHRyYW5zZm9ybSk7XG4gICAgICB2YXIgciA9IG1hdDQuZ2V0Um90YXRpb24oJHNldExvY2FsVHJhbnNmb3JtXzIsIHRyYW5zZm9ybSk7XG4gICAgICB2YXIgcyA9IG1hdDQuZ2V0U2NhbGluZygkc2V0TG9jYWxUcmFuc2Zvcm1fMywgdHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuc2V0TG9jYWxTY2FsZShlbGVtZW50LCBzLCBmYWxzZSk7XG4gICAgICB0aGlzLnNldExvY2FsUG9zaXRpb24oZWxlbWVudCwgdCwgZmFsc2UpO1xuICAgICAgdGhpcy5zZXRMb2NhbFJvdGF0aW9uKGVsZW1lbnQsIHIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIHRoaXMuZGlydGlmeUxvY2FsKGVsZW1lbnQsIGVsZW1lbnQudHJhbnNmb3JtYWJsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0TG9jYWxUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRMb2NhbFRyYW5zZm9ybShlbGVtZW50KSB7XG4gICAgICB0aGlzLnNldExvY2FsU2NhbGUoZWxlbWVudCwgJHZlYzNPbmUsIGZhbHNlKTtcbiAgICAgIHRoaXMuc2V0TG9jYWxQb3NpdGlvbihlbGVtZW50LCAkdmVjM1plcm8sIGZhbHNlKTtcbiAgICAgIHRoaXMuc2V0TG9jYWxFdWxlckFuZ2xlcyhlbGVtZW50LCAkdmVjM1plcm8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICB0aGlzLnNldExvY2FsU2tldyhlbGVtZW50LCAkdmVjMlplcm8sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgdGhpcy5kaXJ0aWZ5TG9jYWwoZWxlbWVudCwgZWxlbWVudC50cmFuc2Zvcm1hYmxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJhbnNmb3JtZWRHZW9tZXRyeUJvdW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZEdlb21ldHJ5Qm91bmRzKGVsZW1lbnQpIHtcbiAgICAgIHZhciByZW5kZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGV4aXN0ZWRBQUJCID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRHZW9tZXRyeUJvdW5kcyhlbGVtZW50LCByZW5kZXIpO1xuICAgICAgaWYgKCFBQUJCLmlzRW1wdHkoYm91bmRzKSkge1xuICAgICAgICB2YXIgYWFiYiA9IGV4aXN0ZWRBQUJCIHx8IG5ldyBBQUJCKCk7XG4gICAgICAgIGFhYmIuc2V0RnJvbVRyYW5zZm9ybWVkQUFCQihib3VuZHMsIHRoaXMuZ2V0V29ybGRUcmFuc2Zvcm0oZWxlbWVudCkpO1xuICAgICAgICByZXR1cm4gYWFiYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdvbid0IGFjY291bnQgZm9yIGNoaWxkcmVuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R2VvbWV0cnlCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R2VvbWV0cnlCb3VuZHMoZWxlbWVudCkge1xuICAgICAgdmFyIHJlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgX3JlZjMgPSBlbGVtZW50LFxuICAgICAgICBnZW9tZXRyeSA9IF9yZWYzLmdlb21ldHJ5O1xuICAgICAgaWYgKGdlb21ldHJ5LmRpcnR5KSB7XG4gICAgICAgIHJ1bnRpbWUuc3R5bGVWYWx1ZVJlZ2lzdHJ5LnVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIGJvdW5kcyA9IHJlbmRlciA/IGdlb21ldHJ5LnJlbmRlckJvdW5kcyA6IGdlb21ldHJ5LmNvbnRlbnRCb3VuZHMgfHwgbnVsbDtcbiAgICAgIC8vIHJldHVybiAoYm91bmRzICYmIG5ldyBBQUJCKGJvdW5kcy5jZW50ZXIsIGJvdW5kcy5oYWxmRXh0ZW50cykpIHx8IG5ldyBBQUJCKCk7XG4gICAgICByZXR1cm4gYm91bmRzIHx8IG5ldyBBQUJCKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWNjb3VudCBmb3IgY2hpbGRyZW4gaW4gd29ybGQgc3BhY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRzKGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIHJlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgX3JlZjQgPSBlbGVtZW50LFxuICAgICAgICByZW5kZXJhYmxlID0gX3JlZjQucmVuZGVyYWJsZTtcbiAgICAgIGlmICghcmVuZGVyYWJsZS5ib3VuZHNEaXJ0eSAmJiAhcmVuZGVyICYmIHJlbmRlcmFibGUuYm91bmRzKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJhYmxlLmJvdW5kcztcbiAgICAgIH1cbiAgICAgIGlmICghcmVuZGVyYWJsZS5yZW5kZXJCb3VuZHNEaXJ0eSAmJiByZW5kZXIgJiYgcmVuZGVyYWJsZS5yZW5kZXJCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmFibGUucmVuZGVyQm91bmRzO1xuICAgICAgfVxuXG4gICAgICAvLyByZXVzZSBleGlzdGVkIGlmIHBvc3NpYmxlXG4gICAgICB2YXIgZXhpc3RlZEFBQkIgPSByZW5kZXIgPyByZW5kZXJhYmxlLnJlbmRlckJvdW5kcyA6IHJlbmRlcmFibGUuYm91bmRzO1xuXG4gICAgICAvLyByZXNldCB3aXRoIGdlb21ldHJ5J3MgYWFiYlxuICAgICAgdmFyIGFhYmIgPSB0aGlzLmdldFRyYW5zZm9ybWVkR2VvbWV0cnlCb3VuZHMoZWxlbWVudCwgcmVuZGVyLCBleGlzdGVkQUFCQik7XG5cbiAgICAgIC8vIG1lcmdlIGNoaWxkcmVuJ3MgYWFiYnNcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kcyA9IF90aGlzMy5nZXRCb3VuZHMoY2hpbGQsIHJlbmRlcik7XG4gICAgICAgIGlmIChjaGlsZEJvdW5kcykge1xuICAgICAgICAgIGlmICghYWFiYikge1xuICAgICAgICAgICAgYWFiYiA9IGV4aXN0ZWRBQUJCIHx8IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICBhYWJiLnVwZGF0ZShjaGlsZEJvdW5kcy5jZW50ZXIsIGNoaWxkQm91bmRzLmhhbGZFeHRlbnRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWFiYi5hZGQoY2hpbGRCb3VuZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWFhYmIpIHtcbiAgICAgICAgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgIC8vIEZJWE1FOiBhY2NvdW50IGZvciBjbGlwIHBhdGhcbiAgICAgICAgdmFyIGNsaXBwZWQgPSBmaW5kQ2xvc2VzdENsaXBQYXRoVGFyZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgICAgIC8vIHVzZSBib3VuZHMgdW5kZXIgd29ybGQgc3BhY2VcbiAgICAgICAgICB2YXIgY2xpcFBhdGhCb3VuZHMgPSBjbGlwcGVkLnBhcnNlZFN0eWxlLmNsaXBQYXRoLmdldEJvdW5kcyhyZW5kZXIpO1xuICAgICAgICAgIGlmICghYWFiYikge1xuICAgICAgICAgICAgYWFiYi51cGRhdGUoY2xpcFBhdGhCb3VuZHMuY2VudGVyLCBjbGlwUGF0aEJvdW5kcy5oYWxmRXh0ZW50cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGlwUGF0aEJvdW5kcykge1xuICAgICAgICAgICAgYWFiYiA9IGNsaXBQYXRoQm91bmRzLmludGVyc2VjdGlvbihhYWJiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgcmVuZGVyYWJsZS5yZW5kZXJCb3VuZHMgPSBhYWJiO1xuICAgICAgICByZW5kZXJhYmxlLnJlbmRlckJvdW5kc0RpcnR5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJhYmxlLmJvdW5kcyA9IGFhYmI7XG4gICAgICAgIHJlbmRlcmFibGUuYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhYWJiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFjY291bnQgZm9yIGNoaWxkcmVuIGluIGxvY2FsIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9jYWxCb3VuZHMoZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50SW52ZXJ0ID0gJG1hdDRJZGVudGl0eTtcbiAgICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZS50cmFuc2Zvcm1hYmxlKSB7XG4gICAgICAgICAgcGFyZW50SW52ZXJ0ID0gbWF0NC5pbnZlcnQoJG1hdDQsIHRoaXMuZ2V0V29ybGRUcmFuc2Zvcm0oZWxlbWVudC5wYXJlbnROb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIUFBQkIuaXNFbXB0eShib3VuZHMpKSB7XG4gICAgICAgICAgdmFyIGxvY2FsQm91bmRzID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICBsb2NhbEJvdW5kcy5zZXRGcm9tVHJhbnNmb3JtZWRBQUJCKGJvdW5kcywgcGFyZW50SW52ZXJ0KTtcbiAgICAgICAgICByZXR1cm4gbG9jYWxCb3VuZHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyhlbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gICAgICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuICAgICAgdmFyIGFhYmI7XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRHZW9tZXRyeUJvdW5kcyhlbGVtZW50KTtcbiAgICAgIGlmICghQUFCQi5pc0VtcHR5KGJvdW5kcykpIHtcbiAgICAgICAgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgICAgIC8vIGFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGFhYmJcbiAgICAgICAgYWFiYi5zZXRGcm9tVHJhbnNmb3JtZWRBQUJCKGJvdW5kcywgdGhpcy5nZXRXb3JsZFRyYW5zZm9ybShlbGVtZW50KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGMgY29udGV4dCdzIG9mZnNldFxuICAgICAgdmFyIGJib3ggPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfZWxlbWVudCRvd25lckRvY3VtZW4gPT09IHZvaWQgMCB8fCAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gX2VsZW1lbnQkb3duZXJEb2N1bWVuLmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfZWxlbWVudCRvd25lckRvY3VtZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5nZXRDb250ZXh0U2VydmljZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGFhYmIpIHtcbiAgICAgICAgdmFyIF9hYWJiJGdldE1pbiA9IGFhYmIuZ2V0TWluKCksXG4gICAgICAgICAgX2FhYmIkZ2V0TWluMiA9IF9zbGljZWRUb0FycmF5KF9hYWJiJGdldE1pbiwgMiksXG4gICAgICAgICAgbGVmdCA9IF9hYWJiJGdldE1pbjJbMF0sXG4gICAgICAgICAgdG9wID0gX2FhYmIkZ2V0TWluMlsxXTtcbiAgICAgICAgdmFyIF9hYWJiJGdldE1heCA9IGFhYmIuZ2V0TWF4KCksXG4gICAgICAgICAgX2FhYmIkZ2V0TWF4MiA9IF9zbGljZWRUb0FycmF5KF9hYWJiJGdldE1heCwgMiksXG4gICAgICAgICAgcmlnaHQgPSBfYWFiYiRnZXRNYXgyWzBdLFxuICAgICAgICAgIGJvdHRvbSA9IF9hYWJiJGdldE1heDJbMV07XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQgKyAoKGJib3ggPT09IG51bGwgfHwgYmJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmJveC5sZWZ0KSB8fCAwKSwgdG9wICsgKChiYm94ID09PSBudWxsIHx8IGJib3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJib3gudG9wKSB8fCAwKSwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoKGJib3ggPT09IG51bGwgfHwgYmJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmJveC5sZWZ0KSB8fCAwLCAoYmJveCA9PT0gbnVsbCB8fCBiYm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiYm94LnRvcCkgfHwgMCwgMCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpcnRpZnlXb3JsZEludGVybmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpcnRpZnlXb3JsZEludGVybmFsKGVsZW1lbnQsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBpZiAoIXRyYW5zZm9ybS5kaXJ0eUZsYWcpIHtcbiAgICAgICAgdHJhbnNmb3JtLmRpcnR5RmxhZyA9IHRydWU7XG4gICAgICAgIHRyYW5zZm9ybS5mcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgdmFyIGNoaWxkVHJhbnNmb3JtID0gY2hpbGQudHJhbnNmb3JtYWJsZTtcbiAgICAgICAgICBpZiAoIWNoaWxkVHJhbnNmb3JtLmRpcnR5RmxhZykge1xuICAgICAgICAgICAgX3RoaXM0LmRpcnRpZnlXb3JsZEludGVybmFsKGNoaWxkLCBjaGlsZFRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9yZWY1ID0gZWxlbWVudCxcbiAgICAgICAgICByZW5kZXJhYmxlID0gX3JlZjUucmVuZGVyYWJsZTtcbiAgICAgICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgICAgICByZW5kZXJhYmxlLnJlbmRlckJvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICByZW5kZXJhYmxlLmJvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICByZW5kZXJhYmxlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW5jSGllcmFyY2h5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNIaWVyYXJjaHkoZWxlbWVudCkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsZW1lbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgIGlmICh0cmFuc2Zvcm0uZnJvemVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5mcm96ZW4gPSB0cnVlO1xuICAgICAgaWYgKHRyYW5zZm9ybS5sb2NhbERpcnR5RmxhZyB8fCB0cmFuc2Zvcm0uZGlydHlGbGFnKSB7XG4gICAgICAgIHRoaXMuc3luYyhlbGVtZW50LCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnN5bmNIaWVyYXJjaHkoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmMoZWxlbWVudCwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodHJhbnNmb3JtLmxvY2FsRGlydHlGbGFnKSB7XG4gICAgICAgIHRoaXMuY2FsY0xvY2FsVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHRyYW5zZm9ybS5sb2NhbERpcnR5RmxhZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5kaXJ0eUZsYWcpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHBhcmVudFRyYW5zZm9ybSA9IHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtYWJsZTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCAhcGFyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgICAgbWF0NC5jb3B5KHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgdHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2Ugc3VwcG9ydCBzY2FsZSBjb21wZW5zYXRpb24/XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGxheWNhbnZhcy9lbmdpbmUvaXNzdWVzLzEwNzcjaXNzdWVjb21tZW50LTM1OTc2NTU1N1xuICAgICAgICAgIG1hdDQubXVsdGlwbHkodHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBwYXJlbnRUcmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIHRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtLmRpcnR5RmxhZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmZyZWV6ZVBhcmVudFRvUm9vdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmZyZWV6ZVBhcmVudFRvUm9vdChjaGlsZCkge1xuICAgICAgdmFyIHAgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHAudHJhbnNmb3JtYWJsZTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIHRyYW5zZm9ybS5mcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgVEVYVF9NRVRSSUNTID0ge1xuICBNZXRyaWNzU3RyaW5nOiAnfMOJccOFJyxcbiAgQmFzZWxpbmVTeW1ib2w6ICdNJyxcbiAgQmFzZWxpbmVNdWx0aXBsaWVyOiAxLjQsXG4gIEhlaWdodE11bHRpcGxpZXI6IDIsXG4gIE5ld2xpbmVzOiBbMHgwMDBhLFxuICAvLyBsaW5lIGZlZWRcbiAgMHgwMDBkIC8vIGNhcnJpYWdlIHJldHVyblxuICBdLFxuICBCcmVha2luZ1NwYWNlczogWzB4MDAwOSxcbiAgLy8gY2hhcmFjdGVyIHRhYnVsYXRpb25cbiAgMHgwMDIwLFxuICAvLyBzcGFjZVxuICAweDIwMDAsXG4gIC8vIGVuIHF1YWRcbiAgMHgyMDAxLFxuICAvLyBlbSBxdWFkXG4gIDB4MjAwMixcbiAgLy8gZW4gc3BhY2VcbiAgMHgyMDAzLFxuICAvLyBlbSBzcGFjZVxuICAweDIwMDQsXG4gIC8vIHRocmVlLXBlci1lbSBzcGFjZVxuICAweDIwMDUsXG4gIC8vIGZvdXItcGVyLWVtIHNwYWNlXG4gIDB4MjAwNixcbiAgLy8gc2l4LXBlci1lbSBzcGFjZVxuICAweDIwMDgsXG4gIC8vIHB1bmN0dWF0aW9uIHNwYWNlXG4gIDB4MjAwOSxcbiAgLy8gdGhpbiBzcGFjZVxuICAweDIwMGEsXG4gIC8vIGhhaXIgc3BhY2VcbiAgMHgyMDVmLFxuICAvLyBtZWRpdW0gbWF0aGVtYXRpY2FsIHNwYWNlXG4gIDB4MzAwMCAvLyBpZGVvZ3JhcGhpYyBzcGFjZVxuICBdXG59O1xudmFyIExBVElOX1JFR0VYID0gL1thLXpBLVowLTlcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwZjZcXHUwMGY4LVxcdTAwZmYhXCIjJCUmJygpKissLS4vOjtdLztcblxuLy8gTGluZSBicmVha2luZyBydWxlcyBpbiBDSksgKEtpbnNva3UgU2hvcmkpXG4vLyBSZWZlciBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVfYnJlYWtpbmdfcnVsZXNfaW5fRWFzdF9Bc2lhbl9sYW5ndWFnZXNcbnZhciByZWdleENhbm5vdFN0YXJ0WmhDbiA9IC9bISUpLC46Oz9cXF19wqLCsMK3J1wiXCLigKDigKHigLrihIPiiLbjgIHjgILjgIPjgIbjgJXjgJfjgJ7vuZrvuZzvvIHvvILvvIXvvIfvvInvvIzvvI7vvJrvvJvvvJ/vvIHvvL3vvZ3vvZ5dLztcbnZhciByZWdleENhbm5vdEVuZFpoQ24gPSAvWyQowqPCpcK3J1wi44CI44CK44CM44CO44CQ44CU44CW44Cd77mZ77mb77yE77yI77yO77y7772b77+h77+lXS87XG52YXIgcmVnZXhDYW5ub3RTdGFydFpoVHcgPSAvWyEpLC46Oz9cXF19wqLCt+KAk+KAlCdcIuKAolwi44CB44CC44CG44Ce44CV44CJ44CL44CN77iw77ix77iy77iz77mQ77mR77mS77mT77mU77mV77mW77mY77ma77mc77yB77yJ77yM77yO77ya77yb77yf77i277i477i677i877i+77mA77mC77mX77y9772c772d772kXS87XG52YXIgcmVnZXhDYW5ub3RFbmRaaFR3ID0gL1soW3vCo8KlJ1wi4oC144CI44CK44CM44CO44CU44Cd77i077mZ77mb77yI772b77i177i377i577i777i977i/77mB77mD77mPXS87XG52YXIgcmVnZXhDYW5ub3RTdGFydEphSnAgPSAvWylcXF3vvZ3jgJXjgInjgIvjgI3jgI/jgJHjgJnjgJfjgJ8nXCLvvaDCu+ODveODvuODvOOCoeOCo+OCpeOCp+OCqeODg+ODo+ODpeODp+ODruODteODtuOBgeOBg+OBheOBh+OBieOBo+OCg+OCheOCh+OCjuOCleOCluOHsOOHseOHsuOHs+OHtOOHteOHtuOHt+OHuOOHueOHuuOHu+OHvOOHveOHvuOHv+OAheOAu+KAkOOCoOKAk+OAnD8h4oC84oGH4oGI4oGJ44O744CBOjss44CCLl0vO1xudmFyIHJlZ2V4Q2Fubm90RW5kSmFKcCA9IC9bKFvvvZvjgJTjgIjjgIrjgIzjgI7jgJDjgJjjgJbjgJ0nXCLvvZ/Cq+KAlC4uLuKApeOAs+OAtOOAtV0vO1xudmFyIHJlZ2V4Q2Fubm90U3RhcnRLb0tyID0gL1shJSksLjo7P1xcXX3CosKwJ1wi4oCg4oCh4oSD44CG44CI44CK44CM44CO44CV77yB77yF77yJ77yM77yO77ya77yb77yf77y9772dXS87XG52YXIgcmVnZXhDYW5ub3RFbmRLb0tyID0gL1skKFt7wqPCpSdcIuOAheOAh+OAieOAi+OAjeOAlO+8hO+8iO+8u++9m++9oO+/pe+/piNdLztcbnZhciByZWdleENhbm5vdFN0YXJ0ID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChyZWdleENhbm5vdFN0YXJ0WmhDbi5zb3VyY2UsIFwifFwiKS5jb25jYXQocmVnZXhDYW5ub3RTdGFydFpoVHcuc291cmNlLCBcInxcIikuY29uY2F0KHJlZ2V4Q2Fubm90U3RhcnRKYUpwLnNvdXJjZSwgXCJ8XCIpLmNvbmNhdChyZWdleENhbm5vdFN0YXJ0S29Lci5zb3VyY2UpKTtcbnZhciByZWdleENhbm5vdEVuZCA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQocmVnZXhDYW5ub3RFbmRaaENuLnNvdXJjZSwgXCJ8XCIpLmNvbmNhdChyZWdleENhbm5vdEVuZFpoVHcuc291cmNlLCBcInxcIikuY29uY2F0KHJlZ2V4Q2Fubm90RW5kSmFKcC5zb3VyY2UsIFwifFwiKS5jb25jYXQocmVnZXhDYW5ub3RFbmRLb0tyLnNvdXJjZSkpO1xuXG4vKipcbiAqIEJvcnJvdyBmcm9tIHBpeGkvcGFja2FnZXMvdGV4dC9zcmMvVGV4dE1ldHJpY3MudHNcbiAqL1xudmFyIFRleHRTZXJ2aWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGV4dFNlcnZpY2UocnVudGltZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRTZXJ2aWNlKTtcbiAgICAvKipcbiAgICAgKiBmb250IG1ldHJpY3MgY2FjaGVcbiAgICAgKi9cbiAgICB0aGlzLmZvbnRNZXRyaWNzQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnNob3VsZEJyZWFrQnlLaW5zb2t1U2hvcnVpID0gZnVuY3Rpb24gKF9jaGFyLCBuZXh0Q2hhcikge1xuICAgICAgaWYgKF90aGlzLmlzQnJlYWtpbmdTcGFjZShuZXh0Q2hhcikpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChfY2hhcikge1xuICAgICAgICAvLyBMaW5lIGJyZWFraW5nIHJ1bGVzIGluIENKSyAoS2luc29rdSBTaG9yaSlcbiAgICAgICAgaWYgKHJlZ2V4Q2Fubm90RW5kLmV4ZWMobmV4dENoYXIpIHx8IHJlZ2V4Q2Fubm90U3RhcnQuZXhlYyhfY2hhcikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy50cmltQnlLaW5zb2t1U2hvcnVpID0gZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgIHZhciBuZXh0ID0gX3RvQ29uc3VtYWJsZUFycmF5KHByZXYpO1xuICAgICAgdmFyIHByZXZMaW5lID0gbmV4dFtuZXh0Lmxlbmd0aCAtIDJdO1xuICAgICAgaWYgKCFwcmV2TGluZSkge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0Q2hhciA9IHByZXZMaW5lW3ByZXZMaW5lLmxlbmd0aCAtIDFdO1xuICAgICAgbmV4dFtuZXh0Lmxlbmd0aCAtIDJdID0gcHJldkxpbmUuc2xpY2UoMCwgLTEpO1xuICAgICAgbmV4dFtuZXh0Lmxlbmd0aCAtIDFdID0gbGFzdENoYXIgKyBuZXh0W25leHQubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUZXh0U2VydmljZSwgW3tcbiAgICBrZXk6IFwibWVhc3VyZUZvbnRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udC1zdHlsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFzdXJlRm9udChmb250LCBvZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIC8vIGFzIHRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHByZXBhcmluZyBhc3NldHMsIGRvbid0IHJlY2FsY3VsYXRlIHRoaW5ncyBpZiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICBpZiAodGhpcy5mb250TWV0cmljc0NhY2hlW2ZvbnRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRNZXRyaWNzQ2FjaGVbZm9udF07XG4gICAgICB9XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHtcbiAgICAgICAgYXNjZW50OiAwLFxuICAgICAgICBkZXNjZW50OiAwLFxuICAgICAgICBmb250U2l6ZTogMFxuICAgICAgfTtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLnJ1bnRpbWUub2Zmc2NyZWVuQ2FudmFzQ3JlYXRvci5nZXRPckNyZWF0ZUNhbnZhcyhvZmZzY3JlZW5DYW52YXMpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJ1bnRpbWUub2Zmc2NyZWVuQ2FudmFzQ3JlYXRvci5nZXRPckNyZWF0ZUNvbnRleHQob2Zmc2NyZWVuQ2FudmFzLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgICAgdmFyIG1ldHJpY3NTdHJpbmcgPSBURVhUX01FVFJJQ1MuTWV0cmljc1N0cmluZyArIFRFWFRfTUVUUklDUy5CYXNlbGluZVN5bWJvbDtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KG1ldHJpY3NTdHJpbmcpLndpZHRoKTtcbiAgICAgIHZhciBiYXNlbGluZSA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KFRFWFRfTUVUUklDUy5CYXNlbGluZVN5bWJvbCkud2lkdGgpO1xuICAgICAgdmFyIGhlaWdodCA9IFRFWFRfTUVUUklDUy5IZWlnaHRNdWx0aXBsaWVyICogYmFzZWxpbmU7XG4gICAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogVEVYVF9NRVRSSUNTLkJhc2VsaW5lTXVsdGlwbGllciB8IDA7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZjAwJztcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xuICAgICAgdmFyIGltYWdlZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoIHx8IDEsIGhlaWdodCB8fCAxKS5kYXRhO1xuICAgICAgdmFyIHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgbGluZSA9IHdpZHRoICogNDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgdmFyIHN0b3AgPSBmYWxzZTtcbiAgICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZTsgaiArPSA0KSB7XG4gICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XG4gICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICBpZHggKz0gbGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcGVydGllcy5hc2NlbnQgPSBiYXNlbGluZSAtIGk7XG4gICAgICBpZHggPSBwaXhlbHMgLSBsaW5lO1xuICAgICAgc3RvcCA9IGZhbHNlO1xuICAgICAgLy8gZGVzY2VudC4gc2NhbiBmcm9tIGJvdHRvbSB0byB0b3AgdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGxpbmU7IF9qICs9IDQpIHtcbiAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIF9qXSAhPT0gMjU1KSB7XG4gICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICBpZHggLT0gbGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xuICAgICAgcHJvcGVydGllcy5mb250U2l6ZSA9IHByb3BlcnRpZXMuYXNjZW50ICsgcHJvcGVydGllcy5kZXNjZW50O1xuICAgICAgdGhpcy5mb250TWV0cmljc0NhY2hlW2ZvbnRdID0gcHJvcGVydGllcztcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZWFzdXJlVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBwYXJzZWRTdHlsZSwgb2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICB2YXIgX3BhcnNlZFN0eWxlJGZvbnRTaXplID0gcGFyc2VkU3R5bGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRTaXplID0gX3BhcnNlZFN0eWxlJGZvbnRTaXplID09PSB2b2lkIDAgPyAxNiA6IF9wYXJzZWRTdHlsZSRmb250U2l6ZSxcbiAgICAgICAgX3BhcnNlZFN0eWxlJHdvcmRXcmFwID0gcGFyc2VkU3R5bGUud29yZFdyYXAsXG4gICAgICAgIHdvcmRXcmFwID0gX3BhcnNlZFN0eWxlJHdvcmRXcmFwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJzZWRTdHlsZSR3b3JkV3JhcCxcbiAgICAgICAgc3Ryb2tlSGVpZ2h0ID0gcGFyc2VkU3R5bGUubGluZUhlaWdodCxcbiAgICAgICAgX3BhcnNlZFN0eWxlJGxpbmVXaWR0ID0gcGFyc2VkU3R5bGUubGluZVdpZHRoLFxuICAgICAgICBsaW5lV2lkdGggPSBfcGFyc2VkU3R5bGUkbGluZVdpZHQgPT09IHZvaWQgMCA/IDEgOiBfcGFyc2VkU3R5bGUkbGluZVdpZHQsXG4gICAgICAgIF9wYXJzZWRTdHlsZSR0ZXh0QmFzZSA9IHBhcnNlZFN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gX3BhcnNlZFN0eWxlJHRleHRCYXNlID09PSB2b2lkIDAgPyAnYWxwaGFiZXRpYycgOiBfcGFyc2VkU3R5bGUkdGV4dEJhc2UsXG4gICAgICAgIF9wYXJzZWRTdHlsZSR0ZXh0QWxpZyA9IHBhcnNlZFN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEFsaWduID0gX3BhcnNlZFN0eWxlJHRleHRBbGlnID09PSB2b2lkIDAgPyAnc3RhcnQnIDogX3BhcnNlZFN0eWxlJHRleHRBbGlnLFxuICAgICAgICBfcGFyc2VkU3R5bGUkbGV0dGVyU3AgPSBwYXJzZWRTdHlsZS5sZXR0ZXJTcGFjaW5nLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nID0gX3BhcnNlZFN0eWxlJGxldHRlclNwID09PSB2b2lkIDAgPyAwIDogX3BhcnNlZFN0eWxlJGxldHRlclNwLFxuICAgICAgICB0ZXh0UGF0aCA9IHBhcnNlZFN0eWxlLnRleHRQYXRoO1xuICAgICAgICBwYXJzZWRTdHlsZS50ZXh0UGF0aFNpZGU7XG4gICAgICAgIHBhcnNlZFN0eWxlLnRleHRQYXRoU3RhcnRPZmZzZXQ7XG4gICAgICAgIHZhciBfcGFyc2VkU3R5bGUkbGVhZGluZyA9IHBhcnNlZFN0eWxlLmxlYWRpbmcsXG4gICAgICAgIGxlYWRpbmcgPSBfcGFyc2VkU3R5bGUkbGVhZGluZyA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRsZWFkaW5nO1xuICAgICAgdmFyIGZvbnQgPSB0b0ZvbnRTdHJpbmcocGFyc2VkU3R5bGUpO1xuICAgICAgdmFyIGZvbnRQcm9wZXJ0aWVzID0gdGhpcy5tZWFzdXJlRm9udChmb250LCBvZmZzY3JlZW5DYW52YXMpO1xuICAgICAgLy8gZmFsbGJhY2sgaW4gY2FzZSBVQSBkaXNhbGxvdyBjYW52YXMgZGF0YSBleHRyYWN0aW9uXG4gICAgICBpZiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgZm9udFByb3BlcnRpZXMuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gZm9udFNpemU7XG4gICAgICB9XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMucnVudGltZS5vZmZzY3JlZW5DYW52YXNDcmVhdG9yLmdldE9yQ3JlYXRlQ29udGV4dChvZmZzY3JlZW5DYW52YXMpO1xuICAgICAgY29udGV4dC5mb250ID0gZm9udDtcblxuICAgICAgLy8gbm8gb3ZlcmZsb3dpbmcgYnkgZGVmYXVsdFxuICAgICAgcGFyc2VkU3R5bGUuaXNPdmVyZmxvd2luZyA9IGZhbHNlO1xuICAgICAgdmFyIG91dHB1dFRleHQgPSB3b3JkV3JhcCA/IHRoaXMud29yZFdyYXAodGV4dCwgcGFyc2VkU3R5bGUsIG9mZnNjcmVlbkNhbnZhcykgOiB0ZXh0O1xuICAgICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG4gICAgICB2YXIgbGluZVdpZHRocyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG5cbiAgICAgIC8vIGFjY291bnQgZm9yIHRleHRQYXRoXG4gICAgICBpZiAodGV4dFBhdGgpIHtcbiAgICAgICAgdGV4dFBhdGguZ2V0VG90YWxMZW5ndGgoKTtcblxuICAgICAgICAvLyBjb25zdCBzdGFydGluZ1BvaW50ID0gdGV4dFBhdGguZ2V0UG9pbnQoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnRleHQubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoICsgKGxpbmVzW2ldLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZztcbiAgICAgICAgICAvLyBmb3IgKFxuICAgICAgICAgIC8vICAgbGV0IGkgPSByZXZlcnNlID8gbGluZXNbMF0ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgLy8gICByZXZlcnNlID8gaSA+PSAwIDogaSA8IGxpbmVzWzBdLmxlbmd0aDtcbiAgICAgICAgICAvLyAgIHJldmVyc2UgPyBpLS0gOiBpKytcbiAgICAgICAgICAvLyApIHtcbiAgICAgICAgICAvLyAgIGdyYXBoZW1lSW5mbyA9IGxpbmVCb3VuZHNbaV07XG4gICAgICAgICAgLy8gICBpZiAocG9zaXRpb25JblBhdGggPiB0b3RhbFBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAvLyAgICAgcG9zaXRpb25JblBhdGggJT0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIC8vICAgfSBlbHNlIGlmIChwb3NpdGlvbkluUGF0aCA8IDApIHtcbiAgICAgICAgICAvLyAgICAgcG9zaXRpb25JblBhdGggKz0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgLy8gaXQgd291bGQgcHJvYmFibHkgbXVjaCBmYXN0ZXIgdG8gc2VuZCBhbGwgdGhlIGdyYXBoZW1lIHBvc2l0aW9uIGZvciBhIGxpbmVcbiAgICAgICAgICAvLyAgIC8vIGFuZCBjYWxjdWxhdGUgcGF0aCBwb3NpdGlvbi9hbmdsZSBhdCBvbmNlLlxuICAgICAgICAgIC8vICAgdGhpcy5zZXRHcmFwaGVtZU9uUGF0aChcbiAgICAgICAgICAvLyAgICAgcG9zaXRpb25JblBhdGgsXG4gICAgICAgICAgLy8gICAgIGdyYXBoZW1lSW5mbyxcbiAgICAgICAgICAvLyAgICAgc3RhcnRpbmdQb2ludFxuICAgICAgICAgIC8vICAgKTtcbiAgICAgICAgICAvLyAgIHBvc2l0aW9uSW5QYXRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsaW5lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAvLyBjaGFyIHdpZHRoICsgbGV0dGVyU3BhY2luZ1xuICAgICAgICAgIHZhciBfbGluZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tfaV0pLndpZHRoICsgKGxpbmVzW19pXS5sZW5ndGggLSAxKSAqIGxldHRlclNwYWNpbmc7XG4gICAgICAgICAgbGluZVdpZHRoc1tfaV0gPSBfbGluZVdpZHRoO1xuICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgX2xpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF93aWR0aCA9IG1heExpbmVXaWR0aCArIGxpbmVXaWR0aDtcblxuICAgICAgICAvLyBpZiAoZHJvcFNoYWRvdykge1xuICAgICAgICAvLyAgIHdpZHRoICs9IGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgLy8gfVxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHN0cm9rZUhlaWdodCB8fCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIGxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgbGluZVdpZHRoKSArIChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgbGVhZGluZyk7XG4gICAgICAgIC8vIGlmIChkcm9wU2hhZG93KSB7XG4gICAgICAgIC8vICAgaGVpZ2h0ICs9IGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgLy8gfVxuICAgICAgICBsaW5lSGVpZ2h0ICs9IGxlYWRpbmc7XG5cbiAgICAgICAgLy8gaGFuZGxlIHZlcnRpY2FsIHRleHQgYmFzZWxpbmVcbiAgICAgICAgdmFyIG9mZnNldFkgPSAwO1xuICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICAgIG9mZnNldFkgPSAtaGVpZ2h0IC8gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdib3R0b20nIHx8IHRleHRCYXNlbGluZSA9PT0gJ2FscGhhYmV0aWMnIHx8IHRleHRCYXNlbGluZSA9PT0gJ2lkZW9ncmFwaGljJykge1xuICAgICAgICAgIG9mZnNldFkgPSAtaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ3RvcCcgfHwgdGV4dEJhc2VsaW5lID09PSAnaGFuZ2luZycpIHtcbiAgICAgICAgICBvZmZzZXRZID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBsaW5lczogbGluZXMsXG4gICAgICAgICAgbGluZVdpZHRoczogbGluZVdpZHRocyxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgIG1heExpbmVXaWR0aDogbWF4TGluZVdpZHRoLFxuICAgICAgICAgIGZvbnRQcm9wZXJ0aWVzOiBmb250UHJvcGVydGllcyxcbiAgICAgICAgICBsaW5lTWV0cmljczogbGluZVdpZHRocy5tYXAoZnVuY3Rpb24gKHdpZHRoLCBpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICAvLyBoYW5kbGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWduXG4gICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJyB8fCB0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgIG9mZnNldFggLT0gd2lkdGggLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcgfHwgdGV4dEFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgICBvZmZzZXRYIC09IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUob2Zmc2V0WCAtIGxpbmVXaWR0aCAvIDIsIG9mZnNldFkgKyBpICogbGluZUhlaWdodCwgd2lkdGggKyBsaW5lV2lkdGgsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndvcmRXcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdvcmRXcmFwKHRleHQsIHBhcnNlZFN0eWxlLCBvZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIF9wYXJzZWRTdHlsZSR3b3JkV3JhcDIgPSBwYXJzZWRTdHlsZS53b3JkV3JhcFdpZHRoLFxuICAgICAgICB3b3JkV3JhcFdpZHRoID0gX3BhcnNlZFN0eWxlJHdvcmRXcmFwMiA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSR3b3JkV3JhcDIsXG4gICAgICAgIF9wYXJzZWRTdHlsZSRsZXR0ZXJTcDIgPSBwYXJzZWRTdHlsZS5sZXR0ZXJTcGFjaW5nLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nID0gX3BhcnNlZFN0eWxlJGxldHRlclNwMiA9PT0gdm9pZCAwID8gMCA6IF9wYXJzZWRTdHlsZSRsZXR0ZXJTcDIsXG4gICAgICAgIF9wYXJzZWRTdHlsZSRtYXhMaW5lcyA9IHBhcnNlZFN0eWxlLm1heExpbmVzLFxuICAgICAgICBtYXhMaW5lcyA9IF9wYXJzZWRTdHlsZSRtYXhMaW5lcyA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfcGFyc2VkU3R5bGUkbWF4TGluZXMsXG4gICAgICAgIHRleHRPdmVyZmxvdyA9IHBhcnNlZFN0eWxlLnRleHRPdmVyZmxvdztcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5ydW50aW1lLm9mZnNjcmVlbkNhbnZhc0NyZWF0b3IuZ2V0T3JDcmVhdGVDb250ZXh0KG9mZnNjcmVlbkNhbnZhcyk7XG4gICAgICB2YXIgbWF4V2lkdGggPSB3b3JkV3JhcFdpZHRoICsgbGV0dGVyU3BhY2luZztcbiAgICAgIHZhciBlbGxpcHNpcyA9ICcnO1xuICAgICAgaWYgKHRleHRPdmVyZmxvdyA9PT0gJ2VsbGlwc2lzJykge1xuICAgICAgICBlbGxpcHNpcyA9ICcuLi4nO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0T3ZlcmZsb3cgJiYgdGV4dE92ZXJmbG93ICE9PSAnY2xpcCcpIHtcbiAgICAgICAgZWxsaXBzaXMgPSB0ZXh0T3ZlcmZsb3c7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICB2YXIgY3VycmVudExpbmVJbmRleCA9IDA7XG4gICAgICB2YXIgY3VycmVudExpbmVXaWR0aCA9IDA7XG4gICAgICB2YXIgcHJldkxpbmVMYXN0Q2hhckluZGV4ID0gMDtcbiAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgdmFyIGNhbGNXaWR0aCA9IGZ1bmN0aW9uIGNhbGNXaWR0aCh0eHQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5nZXRGcm9tQ2FjaGUodHh0LCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgdmFyIGVsbGlwc2lzV2lkdGggPSBjYWxjV2lkdGgoZWxsaXBzaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgdGV4dCBmcmFnbWVudHMgdGhhdCB3aWxsIHRha2UgdXAgYXMgbXVjaCBvZiB0aGUgZ2l2ZW4gbGluZSB3aWR0aCBhcyBwb3NzaWJsZSB3aGVuIHJlbmRlcmVkLlxuICAgICAgICpcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudHZpcy9HL2lzc3Vlcy8xODMzXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGxpbmVUeHQgLSBDdXJyZW50IGxpbmUgb2YgdGV4dFxuICAgICAgICogQHBhcmFtIHR4dExhc3RDaGFySW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IGxpbmUgaW4gdGhlIGVudGlyZSB0ZXh0XG4gICAgICAgKiBAcGFyYW0gdHh0U3RhcnRDaGFySW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0IGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBsaW5lIGluIHRoZSBlbnRpcmUgdGV4dFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBmaW5kQ2hhckluZGV4Q2xvc2VzdFdpZHRoVGhyZXNob2xkKGxpbmVUeHQsIHR4dExhc3RDaGFySW5kZXgsIHR4dFN0YXJ0Q2hhckluZGV4LCB3aWR0aFRocmVzaG9sZCkge1xuICAgICAgICB3aGlsZSAoY2FsY1dpZHRoKGxpbmVUeHQpIDwgd2lkdGhUaHJlc2hvbGQgJiYgdHh0TGFzdENoYXJJbmRleCA8IGNoYXJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAoc2VsZi5pc05ld2xpbmUoY2hhcnNbdHh0TGFzdENoYXJJbmRleCArIDFdKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR4dExhc3RDaGFySW5kZXggKz0gMTtcbiAgICAgICAgICBsaW5lVHh0ICs9IGNoYXJzW3R4dExhc3RDaGFySW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjYWxjV2lkdGgobGluZVR4dCkgPiB3aWR0aFRocmVzaG9sZCAmJiB0eHRMYXN0Q2hhckluZGV4ID4gdHh0U3RhcnRDaGFySW5kZXgpIHtcbiAgICAgICAgICB0eHRMYXN0Q2hhckluZGV4IC09IDE7XG4gICAgICAgICAgbGluZVR4dCA9IGxpbmVUeHQuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZVR4dDogbGluZVR4dCxcbiAgICAgICAgICB0eHRMYXN0Q2hhckluZGV4OiB0eHRMYXN0Q2hhckluZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcHBlbmRFbGxpcHNpcyhsaW5lSW5kZXgsIHRleHRDaGFySW5kZXgpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSB0byBkaXNwbGF5IHRoZSBzdHJpbmcgaXRzZWxmLCBpdCBpcyBjbGlwcGVkLlxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90ZXh0LW92ZXJmbG93I3ZhbHVlc1xuICAgICAgICBpZiAoZWxsaXBzaXNXaWR0aCA8PSAwIHx8IGVsbGlwc2lzV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgICBsaW5lc1tsaW5lSW5kZXhdID0gZWxsaXBzaXM7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmaW5kQ2hhckluZGV4Q2xvc2VzdFdpZHRoVGhyZXNob2xkKGxpbmVzW2xpbmVJbmRleF0sIHRleHRDaGFySW5kZXgsIHByZXZMaW5lTGFzdENoYXJJbmRleCArIDEsIG1heFdpZHRoIC0gZWxsaXBzaXNXaWR0aCk7XG4gICAgICAgIGxpbmVzW2xpbmVJbmRleF0gPSByZXN1bHQubGluZVR4dCArIGVsbGlwc2lzO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2NoYXIyID0gY2hhcnNbaV07XG4gICAgICAgIHZhciBwcmV2Q2hhciA9IGNoYXJzW2kgLSAxXTtcbiAgICAgICAgdmFyIG5leHRDaGFyID0gY2hhcnNbaSArIDFdO1xuICAgICAgICB2YXIgY2hhcldpZHRoID0gY2FsY1dpZHRoKF9jaGFyMik7XG4gICAgICAgIGlmICh0aGlzLmlzTmV3bGluZShfY2hhcjIpKSB7XG4gICAgICAgICAgLy8gZXhjZWVkIG1heExpbmVzLCBicmVhayBpbW1lZGlhdGVseVxuICAgICAgICAgIGlmIChjdXJyZW50TGluZUluZGV4ICsgMSA+PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgcGFyc2VkU3R5bGUuaXNPdmVyZmxvd2luZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaSA8IGNoYXJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgYXBwZW5kRWxsaXBzaXMoY3VycmVudExpbmVJbmRleCwgaSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZMaW5lTGFzdENoYXJJbmRleCA9IGkgLSAxO1xuICAgICAgICAgIGN1cnJlbnRMaW5lSW5kZXggKz0gMTtcbiAgICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gMDtcbiAgICAgICAgICBsaW5lc1tjdXJyZW50TGluZUluZGV4XSA9ICcnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoID4gMCAmJiBjdXJyZW50TGluZVdpZHRoICsgY2hhcldpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmluZENoYXJJbmRleENsb3Nlc3RXaWR0aFRocmVzaG9sZChsaW5lc1tjdXJyZW50TGluZUluZGV4XSwgaSAtIDEsIHByZXZMaW5lTGFzdENoYXJJbmRleCArIDEsIG1heFdpZHRoKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnR4dExhc3RDaGFySW5kZXggIT09IGkgLSAxKSB7XG4gICAgICAgICAgICBsaW5lc1tjdXJyZW50TGluZUluZGV4XSA9IHJlc3VsdC5saW5lVHh0O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eHRMYXN0Q2hhckluZGV4ID09PSBjaGFycy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IHJlc3VsdC50eHRMYXN0Q2hhckluZGV4ICsgMTtcbiAgICAgICAgICAgIF9jaGFyMiA9IGNoYXJzW2ldO1xuICAgICAgICAgICAgcHJldkNoYXIgPSBjaGFyc1tpIC0gMV07XG4gICAgICAgICAgICBuZXh0Q2hhciA9IGNoYXJzW2kgKyAxXTtcbiAgICAgICAgICAgIGNoYXJXaWR0aCA9IGNhbGNXaWR0aChfY2hhcjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudExpbmVJbmRleCArIDEgPj0gbWF4TGluZXMpIHtcbiAgICAgICAgICAgIHBhcnNlZFN0eWxlLmlzT3ZlcmZsb3dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYXBwZW5kRWxsaXBzaXMoY3VycmVudExpbmVJbmRleCwgaSAtIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZMaW5lTGFzdENoYXJJbmRleCA9IGkgLSAxO1xuICAgICAgICAgIGN1cnJlbnRMaW5lSW5kZXggKz0gMTtcbiAgICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gMDtcbiAgICAgICAgICBsaW5lc1tjdXJyZW50TGluZUluZGV4XSA9ICcnO1xuICAgICAgICAgIGlmICh0aGlzLmlzQnJlYWtpbmdTcGFjZShfY2hhcjIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbkJyZWFrSW5MYXN0Q2hhcihfY2hhcjIpKSB7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMudHJpbVRvQnJlYWthYmxlKGxpbmVzKTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLnN1bVRleHRXaWR0aEJ5Q2FjaGUobGluZXNbY3VycmVudExpbmVJbmRleF0gfHwgJycsIGNhbGNXaWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNob3VsZEJyZWFrQnlLaW5zb2t1U2hvcnVpKF9jaGFyMiwgbmV4dENoYXIpKSB7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMudHJpbUJ5S2luc29rdVNob3J1aShsaW5lcyk7XG4gICAgICAgICAgICBjdXJyZW50TGluZVdpZHRoICs9IGNhbGNXaWR0aChwcmV2Q2hhciB8fCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMaW5lV2lkdGggKz0gY2hhcldpZHRoO1xuICAgICAgICBsaW5lc1tjdXJyZW50TGluZUluZGV4XSA9IChsaW5lc1tjdXJyZW50TGluZUluZGV4XSB8fCAnJykgKyBfY2hhcjI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQnJlYWtpbmdTcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JyZWFraW5nU3BhY2UoX2NoYXIzKSB7XG4gICAgICBpZiAodHlwZW9mIF9jaGFyMyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRFWFRfTUVUUklDUy5CcmVha2luZ1NwYWNlcy5pbmRleE9mKF9jaGFyMy5jaGFyQ29kZUF0KDApKSA+PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc05ld2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOZXdsaW5lKF9jaGFyNCkge1xuICAgICAgaWYgKHR5cGVvZiBfY2hhcjQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBURVhUX01FVFJJQ1MuTmV3bGluZXMuaW5kZXhPZihfY2hhcjQuY2hhckNvZGVBdCgwKSkgPj0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJpbVRvQnJlYWthYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaW1Ub0JyZWFrYWJsZShwcmV2KSB7XG4gICAgICB2YXIgbmV4dCA9IF90b0NvbnN1bWFibGVBcnJheShwcmV2KTtcbiAgICAgIHZhciBwcmV2TGluZSA9IG5leHRbbmV4dC5sZW5ndGggLSAyXTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEJyZWFrYWJsZUluZGV4KHByZXZMaW5lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgIXByZXZMaW5lKSByZXR1cm4gbmV4dDtcbiAgICAgIHZhciB0cmltbWVkQ2hhciA9IHByZXZMaW5lLnNsaWNlKGluZGV4LCBpbmRleCArIDEpO1xuICAgICAgdmFyIGlzVHJpbW1lZFdpdGhTcGFjZSA9IHRoaXMuaXNCcmVha2luZ1NwYWNlKHRyaW1tZWRDaGFyKTtcbiAgICAgIHZhciB0cmltRnJvbSA9IGluZGV4ICsgMTtcbiAgICAgIHZhciB0cmltVG8gPSBpbmRleCArIChpc1RyaW1tZWRXaXRoU3BhY2UgPyAwIDogMSk7XG4gICAgICBuZXh0W25leHQubGVuZ3RoIC0gMV0gKz0gcHJldkxpbmUuc2xpY2UodHJpbUZyb20sIHByZXZMaW5lLmxlbmd0aCk7XG4gICAgICBuZXh0W25leHQubGVuZ3RoIC0gMl0gPSBwcmV2TGluZS5zbGljZSgwLCB0cmltVG8pO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbkJyZWFrSW5MYXN0Q2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5CcmVha0luTGFzdENoYXIoX2NoYXI1KSB7XG4gICAgICBpZiAoX2NoYXI1ICYmIExBVElOX1JFR0VYLnRlc3QoX2NoYXI1KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1bVRleHRXaWR0aEJ5Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VtVGV4dFdpZHRoQnlDYWNoZSh0ZXh0LCBjYWxjV2lkdGhXaXRoQ2FjaGUpIHtcbiAgICAgIHJldHVybiB0ZXh0LnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgYykge1xuICAgICAgICByZXR1cm4gc3VtICsgY2FsY1dpZHRoV2l0aENhY2hlKGMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRCcmVha2FibGVJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQnJlYWthYmxlSW5kZXgobGluZSkge1xuICAgICAgZm9yICh2YXIgaSA9IGxpbmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFMQVRJTl9SRUdFWC50ZXN0KGxpbmVbaV0pKSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnJvbUNhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgd2lkdGggPSBjYWNoZVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBrZXkubGVuZ3RoICogbGV0dGVyU3BhY2luZztcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGtleSk7XG4gICAgICAgIHdpZHRoID0gbWV0cmljcy53aWR0aCArIHNwYWNpbmc7XG4gICAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIHJ1bnRpbWUgPSB7fTtcbi8qKlxuICogUmVwbGFjZSB3aXRoIElvQyBjb250YWluZXJcbiAqL1xudmFyIGdlb21ldHJ5VXBkYXRlckZhY3RvcnkgPSBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmVjdFVwZGF0ZXIgPSBuZXcgUmVjdFVwZGF0ZXIoKTtcbiAgdmFyIHBvbHlsaW5lVXBkYXRlciA9IG5ldyBQb2x5bGluZVVwZGF0ZXIoKTtcbiAgcmV0dXJuIF9yZWYgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9yZWYsIFNoYXBlLkZSQUdNRU5ULCBudWxsKSwgU2hhcGUuQ0lSQ0xFLCBuZXcgQ2lyY2xlVXBkYXRlcigpKSwgU2hhcGUuRUxMSVBTRSwgbmV3IEVsbGlwc2VVcGRhdGVyKCkpLCBTaGFwZS5SRUNULCByZWN0VXBkYXRlciksIFNoYXBlLklNQUdFLCByZWN0VXBkYXRlciksIFNoYXBlLkdST1VQLCBuZXcgR3JvdXBVcGRhdGVyKCkpLCBTaGFwZS5MSU5FLCBuZXcgTGluZVVwZGF0ZXIoKSksIFNoYXBlLlRFWFQsIG5ldyBUZXh0VXBkYXRlcihydW50aW1lKSksIFNoYXBlLlBPTFlMSU5FLCBwb2x5bGluZVVwZGF0ZXIpLCBTaGFwZS5QT0xZR09OLCBwb2x5bGluZVVwZGF0ZXIpLCBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBTaGFwZS5QQVRILCBuZXcgUGF0aFVwZGF0ZXIoKSksIFNoYXBlLkhUTUwsIG5ldyBIVE1MVXBkYXRlcigpKSwgU2hhcGUuTUVTSCwgbnVsbCk7XG59KCk7XG52YXIgQ1NTUHJvcGVydHlTeW50YXhGYWN0b3J5ID0gZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciBjb2xvciA9IG5ldyBDU1NQcm9wZXJ0eUNvbG9yKCk7XG4gIHZhciBsZW5ndGggPSBuZXcgQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UoKTtcbiAgcmV0dXJuIF9yZWYyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgUHJvcGVydHlTeW50YXguUEVSQ0VOVEFHRSwgbnVsbCksIFByb3BlcnR5U3ludGF4Lk5VTUJFUiwgbmV3IENTU1Byb3BlcnR5TnVtYmVyKCkpLCBQcm9wZXJ0eVN5bnRheC5BTkdMRSwgbmV3IENTU1Byb3BlcnR5QW5nbGUoKSksIFByb3BlcnR5U3ludGF4LkRFRklORURfUEFUSCwgbmV3IENTU1Byb3BlcnR5Q2xpcFBhdGgoKSksIFByb3BlcnR5U3ludGF4LlBBSU5ULCBjb2xvciksIFByb3BlcnR5U3ludGF4LkNPTE9SLCBjb2xvciksIFByb3BlcnR5U3ludGF4LkZJTFRFUiwgbmV3IENTU1Byb3BlcnR5RmlsdGVyKCkpLCBQcm9wZXJ0eVN5bnRheC5MRU5HVEgsIGxlbmd0aCksIFByb3BlcnR5U3ludGF4LkxFTkdUSF9QRVJDRU5UQUdFLCBsZW5ndGgpLCBQcm9wZXJ0eVN5bnRheC5MRU5HVEhfUEVSQ0VOVEFHRV8xMiwgbmV3IENTU1Byb3BlcnR5TGVuZ3RoT3JQZXJjZW50YWdlMTIoKSksIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgUHJvcGVydHlTeW50YXguTEVOR1RIX1BFUkNFTlRBR0VfMTQsIG5ldyBDU1NQcm9wZXJ0eUxlbmd0aE9yUGVyY2VudGFnZTE0KCkpLCBQcm9wZXJ0eVN5bnRheC5DT09SRElOQVRFLCBuZXcgQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UoKSksIFByb3BlcnR5U3ludGF4Lk9GRlNFVF9ESVNUQU5DRSwgbmV3IENTU1Byb3BlcnR5T2Zmc2V0RGlzdGFuY2UoKSksIFByb3BlcnR5U3ludGF4Lk9QQUNJVFlfVkFMVUUsIG5ldyBDU1NQcm9wZXJ0eU9wYWNpdHkoKSksIFByb3BlcnR5U3ludGF4LlBBVEgsIG5ldyBDU1NQcm9wZXJ0eVBhdGgoKSksIFByb3BlcnR5U3ludGF4LkxJU1RfT0ZfUE9JTlRTLCBuZXcgQ1NTUHJvcGVydHlQb2ludHMoKSksIFByb3BlcnR5U3ludGF4LlNIQURPV19CTFVSLCBuZXcgQ1NTUHJvcGVydHlTaGFkb3dCbHVyKCkpLCBQcm9wZXJ0eVN5bnRheC5URVhULCBuZXcgQ1NTUHJvcGVydHlUZXh0KCkpLCBQcm9wZXJ0eVN5bnRheC5URVhUX1RSQU5TRk9STSwgbmV3IENTU1Byb3BlcnR5VGV4dFRyYW5zZm9ybSgpKSwgUHJvcGVydHlTeW50YXguVFJBTlNGT1JNLCBuZXcgQ1NTUHJvcGVydHlUcmFuc2Zvcm0oKSksIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9yZWYyLCBQcm9wZXJ0eVN5bnRheC5UUkFOU0ZPUk1fT1JJR0lOLCBuZXcgQ1NTUHJvcGVydHlUcmFuc2Zvcm1PcmlnaW4oKSksIFByb3BlcnR5U3ludGF4LlpfSU5ERVgsIG5ldyBDU1NQcm9wZXJ0eVpJbmRleCgpKSwgUHJvcGVydHlTeW50YXguTUFSS0VSLCBuZXcgQ1NTUHJvcGVydHlNYXJrZXIoKSk7XG59KCk7XG52YXIgZ2V0R2xvYmFsVGhpcyA9IGZ1bmN0aW9uIGdldEdsb2JhbFRoaXMoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBnbG9iYWxUaGlzO1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gc2VsZjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93O1xuICAvLyBAdHMtaWdub3JlXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGdsb2JhbDtcbiAgcmV0dXJuIHt9O1xuICAvLyBbIV0gRXJyb3I6IFRoZSAndGhpcycga2V5d29yZCBpcyBlcXVpdmFsZW50IHRvICd1bmRlZmluZWQnIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYW4gRVMgbW9kdWxlLCBhbmQgaGFzIGJlZW4gcmV3cml0dGVuXG4gIC8vIEBzZWUgaHR0cHM6Ly9yb2xsdXBqcy5vcmcvdHJvdWJsZXNob290aW5nLyNlcnJvci10aGlzLWlzLXVuZGVmaW5lZFxuICAvLyBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FtZXJhXG4gKiBgZy1jYW1lcmEtYXBpYCB3aWxsIHByb3ZpZGUgYW4gYWR2YW5jZWQgaW1wbGVtZW50YXRpb25cbiAqL1xucnVudGltZS5DYW1lcmFDb250cmlidXRpb24gPSBDYW1lcmE7XG5cbi8qKlxuICogYGctd2ViLWFuaW1hdGlvbnMtYXBpYCB3aWxsIHByb3ZpZGUgYW4gQW5pbWF0aW9uVGltZWxpbmVcbiAqL1xucnVudGltZS5BbmltYXRpb25UaW1lbGluZSA9IG51bGw7XG5ydW50aW1lLkVhc2luZ0Z1bmN0aW9uID0gbnVsbDtcbnJ1bnRpbWUub2Zmc2NyZWVuQ2FudmFzQ3JlYXRvciA9IG5ldyBPZmZzY3JlZW5DYW52YXNDcmVhdG9yKCk7XG5ydW50aW1lLnNjZW5lR3JhcGhTZWxlY3RvciA9IG5ldyBEZWZhdWx0U2NlbmVHcmFwaFNlbGVjdG9yKCk7XG5ydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlID0gbmV3IERlZmF1bHRTY2VuZUdyYXBoU2VydmljZShydW50aW1lKTtcbnJ1bnRpbWUudGV4dFNlcnZpY2UgPSBuZXcgVGV4dFNlcnZpY2UocnVudGltZSk7XG5ydW50aW1lLmdlb21ldHJ5VXBkYXRlckZhY3RvcnkgPSBnZW9tZXRyeVVwZGF0ZXJGYWN0b3J5O1xucnVudGltZS5DU1NQcm9wZXJ0eVN5bnRheEZhY3RvcnkgPSBDU1NQcm9wZXJ0eVN5bnRheEZhY3Rvcnk7XG5ydW50aW1lLnN0eWxlVmFsdWVSZWdpc3RyeSA9IG5ldyBEZWZhdWx0U3R5bGVWYWx1ZVJlZ2lzdHJ5KHJ1bnRpbWUpO1xucnVudGltZS5sYXlvdXRSZWdpc3RyeSA9IG51bGw7XG5ydW50aW1lLmdsb2JhbFRoaXMgPSBnZXRHbG9iYWxUaGlzKCk7XG5ydW50aW1lLmVuYWJsZVN0eWxlU3ludGF4ID0gdHJ1ZTtcbnJ1bnRpbWUuZW5hYmxlU2l6ZUF0dGVudWF0aW9uID0gZmFsc2U7XG5cbnZhciBlbnRpdHlDb3VudGVyID0gMDtcbmZ1bmN0aW9uIHJlc2V0RW50aXR5Q291bnRlcigpIHtcbiAgZW50aXR5Q291bnRlciA9IDA7XG59XG52YXIgaW5zZXJ0ZWRFdmVudCA9IG5ldyBNdXRhdGlvbkV2ZW50KEVsZW1lbnRFdmVudC5JTlNFUlRFRCwgbnVsbCwgJycsICcnLCAnJywgMCwgJycsICcnKTtcbnZhciByZW1vdmVkRXZlbnQgPSBuZXcgTXV0YXRpb25FdmVudChFbGVtZW50RXZlbnQuUkVNT1ZFRCwgbnVsbCwgJycsICcnLCAnJywgMCwgJycsICcnKTtcbnZhciBkZXN0cm95RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRWxlbWVudEV2ZW50LkRFU1RST1kpO1xuXG4vKipcbiAqIEhhcyBmb2xsb3dpbmcgY2FwYWJpbGl0aWVzOlxuICogKiBOb2RlIGluc2VydC9yZW1vdmUsIGVnLiBhcHBlbmRDaGlsZCwgcmVtb3ZlQ2hpbGQsIHJlbW92ZS4uLlxuICogKiBRdWVyeSBlZy4gcXVlcnlTZWxlY3RvciBnZXRFbGVtZW50QnlJZC4uLlxuICogKiBBbmltYXRpb25cbiAqL1xudmFyIEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIGZ1bmN0aW9uIEVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50KTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBFbGVtZW50LCBbXS5jb25jYXQoYXJncykpO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBpZC5cbiAgICAgKi9cbiAgICBfdGhpcy5lbnRpdHkgPSBlbnRpdHlDb3VudGVyKys7XG4gICAgX3RoaXMucmVuZGVyYWJsZSA9IHtcbiAgICAgIGJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgYm91bmRzRGlydHk6IHRydWUsXG4gICAgICByZW5kZXJCb3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlckJvdW5kc0RpcnR5OiB0cnVlLFxuICAgICAgZGlydHlSZW5kZXJCb3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgIGRpcnR5OiBmYWxzZVxuICAgIH07XG4gICAgX3RoaXMuY3VsbGFibGUgPSB7XG4gICAgICBzdHJhdGVneTogU3RyYXRlZ3kuU3RhbmRhcmQsXG4gICAgICB2aXNpYmlsaXR5UGxhbmVNYXNrOiAtMSxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9O1xuICAgIF90aGlzLnRyYW5zZm9ybWFibGUgPSB7XG4gICAgICBkaXJ0eUZsYWc6IGZhbHNlLFxuICAgICAgbG9jYWxEaXJ0eUZsYWc6IGZhbHNlLFxuICAgICAgZnJvemVuOiBmYWxzZSxcbiAgICAgIGxvY2FsUG9zaXRpb246IFswLCAwLCAwXSxcbiAgICAgIGxvY2FsUm90YXRpb246IFswLCAwLCAwLCAxXSxcbiAgICAgIGxvY2FsU2NhbGU6IFsxLCAxLCAxXSxcbiAgICAgIGxvY2FsVHJhbnNmb3JtOiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0sXG4gICAgICBsb2NhbFNrZXc6IFswLCAwXSxcbiAgICAgIHBvc2l0aW9uOiBbMCwgMCwgMF0sXG4gICAgICByb3RhdGlvbjogWzAsIDAsIDAsIDFdLFxuICAgICAgc2NhbGluZzogWzEsIDEsIDFdLFxuICAgICAgd29ybGRUcmFuc2Zvcm06IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSxcbiAgICAgIG9yaWdpbjogWzAsIDAsIDBdXG4gICAgfTtcbiAgICBfdGhpcy5zb3J0YWJsZSA9IHtcbiAgICAgIGRpcnR5OiBmYWxzZSxcbiAgICAgIHNvcnRlZDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyT3JkZXI6IDAsXG4gICAgICBkaXJ0eUNoaWxkcmVuOiBbXSxcbiAgICAgIGRpcnR5UmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIF90aGlzLmdlb21ldHJ5ID0ge1xuICAgICAgY29udGVudEJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyQm91bmRzOiB1bmRlZmluZWQsXG4gICAgICBkaXJ0eTogdHJ1ZVxuICAgIH07XG4gICAgX3RoaXMuckJ1c2hOb2RlID0ge1xuICAgICAgYWFiYjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvRWxlbWVudC9uYW1lc3BhY2VVUklcbiAgICAgKi9cbiAgICBfdGhpcy5uYW1lc3BhY2VVUkkgPSAnZyc7XG4gICAgX3RoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgX3RoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAvKipcbiAgICAgKiBXZSBkb24ndCBzdXBwb3J0IGJvcmRlciBub3dcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsaWVudFRvcFxuICAgICAqL1xuICAgIF90aGlzLmNsaWVudFRvcCA9IDA7XG4gICAgX3RoaXMuY2xpZW50TGVmdCA9IDA7XG4gICAgLyoqXG4gICAgICogaXMgZGVzdHJveWVkIG9yIG5vdFxuICAgICAqL1xuICAgIF90aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGNvbXBhdGlibGUgd2l0aCBgc3R5bGVgXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvc3R5bGVcbiAgICAgKi9cbiAgICBfdGhpcy5zdHlsZSA9IHt9O1xuICAgIF90aGlzLmNvbXB1dGVkU3R5bGUgPSB7fTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJlcnMgd2lsbCB1c2UgdGhlc2UgdXNlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgX3RoaXMucGFyc2VkU3R5bGUgPSB7XG4gICAgICAvLyBvcGFjaXR5OiAnJyxcbiAgICAgIC8vIGZpbGxPcGFjaXR5OiAnJyxcbiAgICAgIC8vIHN0cm9rZU9wYWNpdHk6ICcnLFxuICAgICAgLy8gdHJhbnNmb3JtT3JpZ2luOiAnJyxcbiAgICAgIC8vIHZpc2liaWxpdHk6ICcnLFxuICAgICAgLy8gcG9pbnRlckV2ZW50czogJycsXG4gICAgICAvLyBsaW5lV2lkdGg6ICcnLFxuICAgICAgLy8gbGluZUNhcDogJycsXG4gICAgICAvLyBsaW5lSm9pbjogJycsXG4gICAgICAvLyBpbmNyZWFzZWRMaW5lV2lkdGhGb3JIaXRUZXN0aW5nOiAnJyxcbiAgICAgIC8vIGZvbnRTaXplOiAnJyxcbiAgICAgIC8vIGZvbnRGYW1pbHk6ICcnLFxuICAgICAgLy8gZm9udFN0eWxlOiAnJyxcbiAgICAgIC8vIGZvbnRXZWlnaHQ6ICcnLFxuICAgICAgLy8gZm9udFZhcmlhbnQ6ICcnLFxuICAgICAgLy8gdGV4dEFsaWduOiAnJyxcbiAgICAgIC8vIHRleHRCYXNlbGluZTogJycsXG4gICAgICAvLyB0ZXh0VHJhbnNmb3JtOiAnJyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvYXR0cmlidXRlc1xuICAgICAqL1xuICAgIF90aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKEVsZW1lbnQsIF9Ob2RlKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFbGVtZW50LCBbe1xuICAgIGtleTogXCJjbGFzc05hbWVcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogdXNlZCB3aXRoIGBnZXRFbGVtZW50QnlJZCgpYFxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvaWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIHVzZWQgaW4gYGdldEVsZW1lbnRzQnlDbGFzc05hbWVgXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGluIGBnZXRFbGVtZW50c0J5TmFtZWBcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9nZXRFbGVtZW50c0J5TmFtZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsYXNzTGlzdFwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsYXNzTGlzdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZS5zcGxpdCgnICcpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyAhPT0gJyc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFnTmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZU5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkcmVuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZEVsZW1lbnRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0RWxlbWVudENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maXJzdENoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0RWxlbWVudENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudEVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRTaWJsaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tpbmRleCArIDFdIHx8IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tpbmRleCAtIDFdIHx8IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lTm9kZShkZWVwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRDaGlsZChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpcyRvd25lckRvY3VtZW50O1xuICAgICAgaWYgKGNoaWxkLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX0FQUEVORF9ERVNUUk9ZRURfRUxFTUVOVCk7XG4gICAgICB9XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmF0dGFjaChjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgICAgaWYgKChfdGhpcyRvd25lckRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfdGhpcyRvd25lckRvY3VtZW50ICE9PSB2b2lkIDAgJiYgX3RoaXMkb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgICBpZiAoIWlzSW5GcmFnbWVudCh0aGlzKSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gU2hhcGUuRlJBR01FTlQpIHtcbiAgICAgICAgICB0aGlzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcubW91bnRGcmFnbWVudChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm1vdW50Q2hpbGRyZW4oY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICh0aGlzLmlzTXV0YXRpb25PYnNlcnZlZCkge1xuICAgICAgICBpbnNlcnRlZEV2ZW50LnJlbGF0ZWROb2RlID0gdGhpcztcbiAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudChpbnNlcnRlZEV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdDaGlsZCwgcmVmQ2hpbGQpIHtcbiAgICAgIGlmICghcmVmQ2hpbGQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV3Q2hpbGQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIG5ld0NoaWxkLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKHJlZkNoaWxkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3Q2hpbGQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2Yob2xkQ2hpbGQpO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChvbGRDaGlsZCk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld0NoaWxkLCBpbmRleCk7XG4gICAgICByZXR1cm4gb2xkQ2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJG93bmVyRG9jdW1lbnQ7XG4gICAgICAvLyBzaG91bGQgZW1pdCBvbiBpdHNlbGYgYmVmb3JlIGRldGFjaFxuICAgICAgcmVtb3ZlZEV2ZW50LnJlbGF0ZWROb2RlID0gdGhpcztcbiAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQocmVtb3ZlZEV2ZW50KTtcbiAgICAgIGlmICgoX2NoaWxkJG93bmVyRG9jdW1lbnQgPSBjaGlsZC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfY2hpbGQkb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwICYmIF9jaGlsZCRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgICAgIGNoaWxkLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcudW5tb3VudENoaWxkcmVuKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGZyb20gc2NlbmUgZ3JhcGhcbiAgICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZGV0YWNoKGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGNoaWxkcmVuIHdoaWNoIGNhbiBiZSBhcHBlbmRlZCB0byBpdHMgb3JpZ2luYWwgcGFyZW50IGxhdGVyIGFnYWluLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGRlc3Ryb3kgYWxsIGNoaWxkcmVuIHdoaWNoIGNhbiBub3QgYmUgYXBwZW5kZWQgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBsYXRlciBhZ2Fpbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95Q2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveUNoaWxkcmVuKCkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaGlsZC5kZXN0cm95Q2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5tYXRjaGVzKHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudEJ5SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGlkKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsZW1lbnRzQnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlOYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1cXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIl1cIiksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiLmNvbmNhdChjbGFzc05hbWUpLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UucXVlcnlTZWxlY3RvckFsbCh0YWdOYW1lLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVlcnlTZWxlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKHNlbGVjdG9ycykge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UucXVlcnlTZWxlY3RvcihzZWxlY3RvcnMsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWVyeVNlbGVjdG9yQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIHRyYXZlcnNlcyB0aGUgZWxlbWVudCBhbmQgaXRzIHBhcmVudHMgKGhlYWRpbmcgdG93YXJkIHRoZSBkb2N1bWVudCByb290KVxuICAgICAqIHVudGlsIGl0IGZpbmRzIGEgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBDU1Mgc2VsZWN0b3IuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0I3BvbHlmaWxsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9ycykge1xuICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UubWF0Y2hlcyhzZWxlY3RvcnMsIGVsKSkgcmV0dXJuIGVsO1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWFyY2ggaW4gc2NlbmUgZ3JvdXAsIGJ1dCBzaG91bGQgbm90IGluY2x1ZGUgaXRzZWxmXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKGZpbHRlcikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgIT09IF90aGlzMiAmJiBmaWx0ZXIob2JqZWN0KSkge1xuICAgICAgICAgIHRhcmdldCA9IG9iamVjdDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFsbChmaWx0ZXIpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgIT09IF90aGlzMyAmJiBmaWx0ZXIob2JqZWN0KSkge1xuICAgICAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3RzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0VsZW1lbnQvYWZ0ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgbm9kZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgICAgdmFyIF90aGlzNCRwYXJlbnROb2RlO1xuICAgICAgICAgIHJldHVybiAoX3RoaXM0JHBhcmVudE5vZGUgPSBfdGhpczQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX3RoaXM0JHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzNCRwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUsIGluZGV4ICsgaSArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FbGVtZW50L2JlZm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgbm9kZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSBub2Rlc1swXSxcbiAgICAgICAgICByZXN0ID0gbm9kZXMuc2xpY2UoMSk7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChmaXJzdCwgaW5kZXgpO1xuICAgICAgICAoX3JlZiA9IGZpcnN0KS5hZnRlci5hcHBseShfcmVmLCBfdG9Db25zdW1hYmxlQXJyYXkocmVzdCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVwbGFjZVdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICAgIHRoaXMuYWZ0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvRWxlbWVudC9hcHBlbmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIG5vZGVzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FbGVtZW50L3ByZXBlbmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcmVwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgbm9kZXNbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5hcHBlbmRDaGlsZChub2RlLCBpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVwbGFjZUNoaWxkcmVuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZUNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZHJlbigpIHtcbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXMubGVuZ3RoICYmIHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVtb3ZlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAvLyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2FudHZpcy9HL2lzc3Vlcy8xODEzXG4gICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbigpO1xuXG4gICAgICAvLyBkZXN0cm95IGl0c2VsZiBiZWZvcmUgcmVtb3ZlXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZGVzdHJveUV2ZW50KTtcblxuICAgICAgLy8gcmVtb3ZlIGZyb20gc2NlbmVncmFwaCBmaXJzdFxuICAgICAgdGhpcy5yZW1vdmUoKTtcblxuICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdGhpcy5lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRHZW9tZXRyeUJvdW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHZW9tZXRyeUJvdW5kcygpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmdldEdlb21ldHJ5Qm91bmRzKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZW5kZXJCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyQm91bmRzKCkge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZ2V0Qm91bmRzKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBib3VuZHMgaW4gd29ybGQgc3BhY2UsIGFjY291bnQgZm9yIGNoaWxkcmVuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kcygpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmdldEJvdW5kcyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYm91bmRzIGluIGxvY2FsIHNwYWNlLCBhY2NvdW50IGZvciBjaGlsZHJlblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExvY2FsQm91bmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKCkge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZ2V0TG9jYWxCb3VuZHModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWNjb3VudCBmb3IgY29udGV4dCdzIGJvdW5kcyBpbiBjbGllbnQgc3BhY2UsXG4gICAgICogYnV0IG5vdCBhY2NvdW50aW5nIGZvciBjaGlsZHJlblxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldENsaWVudFJlY3RzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UmVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlZFN0eWxlTWFwXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jb21wdXRlZFN0eWxlTWFwXG4gICAgICogZWcuIGNpcmNsZS5jb21wdXRlZFN0eWxlTWFwKCkuZ2V0KCdmaWxsJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcHV0ZWRTdHlsZU1hcCgpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHRoaXMuY29tcHV0ZWRTdHlsZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRyaWJ1dGVOYW1lc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlTmFtZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVOYW1lcygpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnR2aXMvRy9pc3N1ZXMvMTI2N1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdCwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgZWl0aGVyIGJlIG51bGwgb3IgXCJcIlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9oYXNBdHRyaWJ1dGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoYXNBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQXR0cmlidXRlKHF1YWxpZmllZE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5hbWVzKCkuaW5jbHVkZXMocXVhbGlmaWVkTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9oYXNBdHRyaWJ1dGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNBdHRyaWJ1dGVzKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5nZXRBdHRyaWJ1dGVOYW1lcygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgdXNlIHJlbW92ZUF0dHJpYnV0ZSgpIGluc3RlYWQgb2Ygc2V0dGluZyB0aGUgYXR0cmlidXRlIHZhbHVlIHRvIG51bGwgZWl0aGVyIGRpcmVjdGx5IG9yIHVzaW5nIHNldEF0dHJpYnV0ZSgpLiBNYW55IGF0dHJpYnV0ZXMgd2lsbCBub3QgYmVoYXZlIGFzIGV4cGVjdGVkIGlmIHlvdSBzZXQgdGhlbSB0byBudWxsLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVtb3ZlQXR0cmlidXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBudWxsKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zZXRBdHRyaWJ1dGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBmb3JjZSwgbWVtb2l6ZSkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0dHJpYnV0ZU5TXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbG9jYWxOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRyaWJ1dGVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5vZGUocXVhbGlmaWVkTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXR0cmlidXRlTm9kZU5TXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5vZGVOUyhuYW1lc3BhY2UsIGxvY2FsTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQXR0cmlidXRlTlNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQXR0cmlidXRlTlMobmFtZXNwYWNlLCBsb2NhbE5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUF0dHJpYnV0ZU5TXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbG9jYWxOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBdHRyaWJ1dGVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZU5vZGUoYXR0cikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0cmlidXRlTlNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBxdWFsaWZpZWROYW1lLCB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0cmlidXRlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVOb2RlKGF0dHIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEF0dHJpYnV0ZU5vZGVOU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVOb2RlTlMoYXR0cikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlQXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUF0dHJpYnV0ZShxdWFsaWZpZWROYW1lLCBmb3JjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgICB9XG4gIH1dKTtcbn0oTm9kZSk7XG5cbmZ1bmN0aW9uIGlzRGlzcGxheU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZS5ub2RlTmFtZSk7XG59XG52YXIgUHJveHkgPSBydW50aW1lLmdsb2JhbFRoaXMuUHJveHkgPyBydW50aW1lLmdsb2JhbFRoaXMuUHJveHkgOiBmdW5jdGlvbiAoKSB7fTtcbnZhciBhdHRyTW9kaWZpZWRFdmVudCA9IG5ldyBNdXRhdGlvbkV2ZW50KEVsZW1lbnRFdmVudC5BVFRSX01PRElGSUVELCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBNdXRhdGlvbkV2ZW50Lk1PRElGSUNBVElPTiwgbnVsbCwgbnVsbCk7XG52YXIgJHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyICRxdWF0ID0gcXVhdCQxLmNyZWF0ZSgpO1xuXG4vKipcbiAqIHByb3RvdHlwZSBjaGFpbnM6IERpc3BsYXlPYmplY3QgLT4gRWxlbWVudCAtPiBOb2RlIC0+IEV2ZW50VGFyZ2V0XG4gKlxuICogbWl4aW5zOiBBbmltYXRhYmxlLCBUcmFuc2Zvcm1hYmxlLCBWaXNpYmxlXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YW5uZXJudGFubmVybi90cy1taXhlci9ibG9iL21hc3Rlci9SRUFETUUubWQjbWl4aW5nLWdlbmVyaWMtY2xhc3Nlc1xuICpcbiAqIFByb3ZpZGUgYWJpbGl0aWVzIGluIHNjZW5lIGdyYXBoLCBzdWNoIGFzOlxuICogKiB0cmFuc2Zvcm0gYHRyYW5zbGF0ZS9yb3RhdGUvc2NhbGVgXG4gKiAqIGFkZC9yZW1vdmUgY2hpbGRcbiAqICogdmlzaWJpbGl0eSBhbmQgei1pbmRleFxuICpcbiAqIFRob3NlIGFiaWxpdGllcyBhcmUgaW1wbGVtZW50ZWQgd2l0aCB0aG9zZSBjb21wb25lbnRzOiBgVHJhbnNmb3JtL1NvcnRhYmxlL1Zpc2libGVgLlxuICpcbiAqIEVtaXQgZm9sbG93aW5nIGV2ZW50czpcbiAqICogaW5pdFxuICogKiBkZXN0cm95XG4gKiAqIGF0dHJpYnV0ZUNoYW5nZWRcbiAqL1xudmFyIERpc3BsYXlPYmplY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIGZ1bmN0aW9uIERpc3BsYXlPYmplY3QoY29uZmlnKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwbGF5T2JqZWN0KTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgRGlzcGxheU9iamVjdCk7XG5cbiAgICAvLyBhc3NpZ24gbmFtZSwgaWQgdG8gY29uZmlnXG4gICAgLy8gZWcuIGdyb3VwLmdldCgnbmFtZScpXG4gICAgX3RoaXMuaXNDdXN0b21FbGVtZW50ID0gZmFsc2U7XG4gICAgX3RoaXMuaXNNdXRhdGlvbk9ic2VydmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogcHVzaCB0byBhY3RpdmUgYW5pbWF0aW9ucyBhZnRlciBjYWxsaW5nIGBhbmltYXRlKClgXG4gICAgICovXG4gICAgX3RoaXMuYWN0aXZlQW5pbWF0aW9ucyA9IFtdO1xuICAgIF90aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIC8vIGluaXQgc2NlbmUgZ3JhcGggbm9kZVxuICAgIF90aGlzLmlkID0gY29uZmlnLmlkIHx8ICcnO1xuICAgIF90aGlzLm5hbWUgPSBjb25maWcubmFtZSB8fCAnJztcbiAgICBpZiAoY29uZmlnLmNsYXNzTmFtZSB8fCBjb25maWdbXCJjbGFzc1wiXSkge1xuICAgICAgX3RoaXMuY2xhc3NOYW1lID0gY29uZmlnLmNsYXNzTmFtZSB8fCBjb25maWdbXCJjbGFzc1wiXTtcbiAgICB9XG4gICAgX3RoaXMubm9kZU5hbWUgPSBjb25maWcudHlwZSB8fCBTaGFwZS5HUk9VUDtcbiAgICBpZiAoY29uZmlnLmluaXRpYWxQYXJzZWRTdHlsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5wYXJzZWRTdHlsZSwgY29uZmlnLmluaXRpYWxQYXJzZWRTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgdG8gcHJvY2VzcyBhdHRyaWJ1dGVzXG4gICAgX3RoaXMuaW5pdEF0dHJpYnV0ZXMoY29uZmlnLnN0eWxlKTtcbiAgICBpZiAocnVudGltZS5lbmFibGVTdHlsZVN5bnRheCkge1xuICAgICAgX3RoaXMuc3R5bGUgPSBuZXcgUHJveHkoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB7XG4gICAgICAgIC8vIC4uLnRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgc2V0UHJvcGVydHk6IGZ1bmN0aW9uIHNldFByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWVcbiAgICAgICAgLy8gcHJpb3JpdHk/OiBzdHJpbmcsXG4gICAgICAgICkge1xuICAgICAgICAgIF90aGlzLnNldEF0dHJpYnV0ZShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0QXR0cmlidXRlKHByb3BlcnR5TmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVByb3BlcnR5OiBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbTogZnVuY3Rpb24gaXRlbSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgICAgaWYgKHRhcmdldFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZiAobmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KF8sIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgX3RoaXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoRGlzcGxheU9iamVjdCwgX0VsZW1lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERpc3BsYXlPYmplY3QsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9zdXBlclByb3BHZXQoRGlzcGxheU9iamVjdCwgXCJkZXN0cm95XCIsIHRoaXMsIDMpKFtdKTtcblxuICAgICAgLy8gc3RvcCBhbGwgYWN0aXZlIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW9ucygpLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lTm9kZShkZWVwLCBjdXN0b21DbG9uZUZ1bmMpIHtcbiAgICAgIHZhciBjbG9uZWRTdHlsZSA9IF9vYmplY3RTcHJlYWQoe30sIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICBmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGNsb25lZFN0eWxlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBjbG9uZWRTdHlsZVthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnR2aXMvRy9pc3N1ZXMvMTA5NVxuICAgICAgICBpZiAoaXNEaXNwbGF5T2JqZWN0KGF0dHJpYnV0ZSkgJiZcbiAgICAgICAgLy8gc2hhcmUgdGhlIHNhbWUgY2xpcFBhdGggaWYgcG9zc2libGVcbiAgICAgICAgYXR0cmlidXRlTmFtZSAhPT0gJ2NsaXBQYXRoJyAmJiBhdHRyaWJ1dGVOYW1lICE9PSAnb2Zmc2V0UGF0aCcgJiYgYXR0cmlidXRlTmFtZSAhPT0gJ3RleHRQYXRoJykge1xuICAgICAgICAgIGNsb25lZFN0eWxlW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlLmNsb25lTm9kZShkZWVwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBjbG9uZSBvdGhlciB0eXBlXG4gICAgICAgIGlmIChjdXN0b21DbG9uZUZ1bmMpIHtcbiAgICAgICAgICBjbG9uZWRTdHlsZVthdHRyaWJ1dGVOYW1lXSA9IGN1c3RvbUNsb25lRnVuYyhhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2xvbmVkID0gbmV3IHRoaXMuY29uc3RydWN0b3IoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbmZpZyksIHt9LCB7XG4gICAgICAgIHN0eWxlOiBjbG9uZWRTdHlsZVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBhcHBseSB0cmFuc2Zvcm1cbiAgICAgIGNsb25lZC5zZXRMb2NhbFRyYW5zZm9ybSh0aGlzLmdldExvY2FsVHJhbnNmb3JtKCkpO1xuICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIC8vIHNraXAgbWFya2VyXG4gICAgICAgICAgaWYgKCFjaGlsZC5zdHlsZS5pc01hcmtlcikge1xuICAgICAgICAgICAgdmFyIGNsb25lZENoaWxkID0gY2hpbGQuY2xvbmVOb2RlKGRlZXApO1xuICAgICAgICAgICAgY2xvbmVkLmFwcGVuZENoaWxkKGNsb25lZENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdEF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZm9yY2VVcGRhdGVHZW9tZXRyeTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJ1bnRpbWUuc3R5bGVWYWx1ZVJlZ2lzdHJ5LnByb2Nlc3NQcm9wZXJ0aWVzKHRoaXMsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyByZWRyYXcgYXQgbmV4dCBmcmFtZVxuICAgICAgdGhpcy5yZW5kZXJhYmxlLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBtZW1vaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgLy8gaWdub3JlIHVuZGVmaW5lZCB2YWx1ZVxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZm9yY2UgfHwgdmFsdWUgIT09IHRoaXMuYXR0cmlidXRlc1tuYW1lXSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgX3N1cGVyUHJvcEdldChEaXNwbGF5T2JqZWN0LCBcInNldEF0dHJpYnV0ZVwiLCB0aGlzLCAzKShbbmFtZSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiBhdHRyaWJ1dGVzIGdldCBjaGFuZ2VkIG9yIGluaXRpYWxpemVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJuYWxTZXRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJuYWxTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwYXJzZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICB2YXIgb2xkUGFyc2VkVmFsdWUgPSB0aGlzLnBhcnNlZFN0eWxlW25hbWVdO1xuICAgICAgcnVudGltZS5zdHlsZVZhbHVlUmVnaXN0cnkucHJvY2Vzc1Byb3BlcnRpZXModGhpcywgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSksIHBhcnNlT3B0aW9ucyk7XG5cbiAgICAgIC8vIHJlZHJhdyBhdCBuZXh0IGZyYW1lXG4gICAgICByZW5kZXJhYmxlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHZhciBuZXdQYXJzZWRWYWx1ZSA9IHRoaXMucGFyc2VkU3R5bGVbbmFtZV07XG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBhdHRyTW9kaWZpZWRFdmVudC5yZWxhdGVkTm9kZSA9IHRoaXM7XG4gICAgICAgIGF0dHJNb2RpZmllZEV2ZW50LnByZXZWYWx1ZSA9IG9sZFZhbHVlO1xuICAgICAgICBhdHRyTW9kaWZpZWRFdmVudC5uZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBhdHRyTW9kaWZpZWRFdmVudC5hdHRyTmFtZSA9IG5hbWU7XG4gICAgICAgIGF0dHJNb2RpZmllZEV2ZW50LnByZXZQYXJzZWRWYWx1ZSA9IG9sZFBhcnNlZFZhbHVlO1xuICAgICAgICBhdHRyTW9kaWZpZWRFdmVudC5uZXdQYXJzZWRWYWx1ZSA9IG5ld1BhcnNlZFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5pc011dGF0aW9uT2JzZXJ2ZWQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYXR0ck1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJNb2RpZmllZEV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmRpc3BhdGNoRXZlbnQoYXR0ck1vZGlmaWVkRXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0N1c3RvbUVsZW1lbnQgJiYgdGhpcy5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5pc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9hdHRyaWJ1dGVDaGFuZ2VkQ2FsbCwgX3JlZjtcbiAgICAgICAgKF9hdHRyaWJ1dGVDaGFuZ2VkQ2FsbCA9IChfcmVmID0gdGhpcykuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYXR0cmlidXRlQ2hhbmdlZENhbGwgPT09IHZvaWQgMCB8fCBfYXR0cmlidXRlQ2hhbmdlZENhbGwuY2FsbChfcmVmLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUsIG9sZFBhcnNlZFZhbHVlLCBuZXdQYXJzZWRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gI3JlZ2lvbiB0cmFuc2Zvcm1hYmxlXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBkaWZmZXJlbnQgdmFsdWVzIHRoYW4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFzIHRoZSBsYXR0ZXIgcmV0dXJucyB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdHcmFwaGljc0VsZW1lbnQvZ2V0QkJveFxuICAgICAqXG4gICAgICogRklYTUU6IEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IGdldEJCb3ggcmVzcG9uZHMgdG8gb3JpZ2luYWwgdW50cmFuc2Zvcm1lZCB2YWx1ZXMgb2YgYSBkcmF3biBvYmplY3QuXG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHL0lHL3Jlc291cmNlcy9zdmdwcmltZXIuaHRtbCNnZXRCQm94XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCQm94KCkge1xuICAgICAgdmFyIGFhYmIgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgdmFyIF9hYWJiJGdldE1pbiA9IGFhYmIuZ2V0TWluKCksXG4gICAgICAgIF9hYWJiJGdldE1pbjIgPSBfc2xpY2VkVG9BcnJheShfYWFiYiRnZXRNaW4sIDIpLFxuICAgICAgICBsZWZ0ID0gX2FhYmIkZ2V0TWluMlswXSxcbiAgICAgICAgdG9wID0gX2FhYmIkZ2V0TWluMlsxXTtcbiAgICAgIHZhciBfYWFiYiRnZXRNYXggPSBhYWJiLmdldE1heCgpLFxuICAgICAgICBfYWFiYiRnZXRNYXgyID0gX3NsaWNlZFRvQXJyYXkoX2FhYmIkZ2V0TWF4LCAyKSxcbiAgICAgICAgcmlnaHQgPSBfYWFiYiRnZXRNYXgyWzBdLFxuICAgICAgICBib3R0b20gPSBfYWFiYiRnZXRNYXgyWzFdO1xuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9yaWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnaW4ocG9zaXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnNldE9yaWdpbih0aGlzLCBjcmVhdGVWZWMzKHBvc2l0aW9uLCB5LCB6LCBmYWxzZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9yaWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5nZXRPcmlnaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHBvc2l0aW9uIGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnNldFBvc2l0aW9uKHRoaXMsIGNyZWF0ZVZlYzMocG9zaXRpb24sIHksIHosIGZhbHNlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcG9zaXRpb24gaW4gbG9jYWwgc3BhY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb2NhbFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvY2FsUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnNldExvY2FsUG9zaXRpb24odGhpcywgY3JlYXRlVmVjMyhwb3NpdGlvbiwgeSwgeiwgZmFsc2UpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyYW5zbGF0ZSBpbiB3b3JsZCBzcGFjZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUocG9zaXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnRyYW5zbGF0ZSh0aGlzLCBjcmVhdGVWZWMzKHBvc2l0aW9uLCB5LCB6LCBmYWxzZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJhbnNsYXRlIGluIGxvY2FsIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNsYXRlTG9jYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlTG9jYWwocG9zaXRpb24pIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnRyYW5zbGF0ZUxvY2FsKHRoaXMsIGNyZWF0ZVZlYzMocG9zaXRpb24sIHksIHosIGZhbHNlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5nZXRQb3NpdGlvbih0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZ2V0TG9jYWxQb3NpdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wYXRpYmxlIHdpdGggRyAzLjBcbiAgICAgKlxuICAgICAqIHNjYWxpbmcgaW4gbG9jYWwgc3BhY2VcbiAgICAgKiBzY2FsZSgxMCkgPSBzY2FsZSgxMCwgMTAsIDEwKVxuICAgICAqXG4gICAgICogd2UgY2FuJ3Qgc2V0IHNjYWxlIGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGUoc2NhbGluZywgeSwgeikge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVMb2NhbChzY2FsaW5nLCB5LCB6KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVMb2NhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FsZUxvY2FsKHNjYWxpbmcsIHksIHopIHtcbiAgICAgIGlmICh0eXBlb2Ygc2NhbGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgeSA9IHkgfHwgc2NhbGluZztcbiAgICAgICAgeiA9IHogfHwgc2NhbGluZztcbiAgICAgICAgc2NhbGluZyA9IGNyZWF0ZVZlYzMoc2NhbGluZywgeSwgeiwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5zY2FsZUxvY2FsKHRoaXMsIHNjYWxpbmcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHNjYWxpbmcgaW4gbG9jYWwgc3BhY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb2NhbFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvY2FsU2NhbGUoc2NhbGluZywgeSwgeikge1xuICAgICAgaWYgKHR5cGVvZiBzY2FsaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICB5ID0geSB8fCBzY2FsaW5nO1xuICAgICAgICB6ID0geiB8fCBzY2FsaW5nO1xuICAgICAgICBzY2FsaW5nID0gY3JlYXRlVmVjMyhzY2FsaW5nLCB5LCB6LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnNldExvY2FsU2NhbGUodGhpcywgc2NhbGluZyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc2NhbGluZyBpbiBsb2NhbCBzcGFjZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExvY2FsU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9jYWxTY2FsZSgpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmdldExvY2FsU2NhbGUodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHNjYWxpbmcgaW4gd29ybGQgc3BhY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmdldFNjYWxlKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9ubHkgcmV0dXJuIGRlZ3JlZXMgb2YgWiBheGlzIGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RXVsZXJBbmdsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXVsZXJBbmdsZXMoKSB7XG4gICAgICB2YXIgX2dldEV1bGVyID0gZ2V0RXVsZXIoJHZlYzMsIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZ2V0V29ybGRUcmFuc2Zvcm0odGhpcykpLFxuICAgICAgICBfZ2V0RXVsZXIyID0gX3NsaWNlZFRvQXJyYXkoX2dldEV1bGVyLCAzKSxcbiAgICAgICAgZXogPSBfZ2V0RXVsZXIyWzJdO1xuICAgICAgcmV0dXJuIHJhZDJkZWcoZXopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9ubHkgcmV0dXJuIGRlZ3JlZXMgb2YgWiBheGlzIGluIGxvY2FsIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxFdWxlckFuZ2xlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbEV1bGVyQW5nbGVzKCkge1xuICAgICAgdmFyIF9nZXRFdWxlcjMgPSBnZXRFdWxlcigkdmVjMywgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5nZXRMb2NhbFJvdGF0aW9uKHRoaXMpKSxcbiAgICAgICAgX2dldEV1bGVyNCA9IF9zbGljZWRUb0FycmF5KF9nZXRFdWxlcjMsIDMpLFxuICAgICAgICBleiA9IF9nZXRFdWxlcjRbMl07XG4gICAgICByZXR1cm4gcmFkMmRlZyhleik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGV1bGVyIGFuZ2xlcyhkZWdyZWVzKSBpbiB3b3JsZCBzcGFjZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEV1bGVyQW5nbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEV1bGVyQW5nbGVzKHopIHtcbiAgICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2Uuc2V0RXVsZXJBbmdsZXModGhpcywgMCwgMCwgeik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZXVsZXIgYW5nbGVzKGRlZ3JlZXMpIGluIGxvY2FsIHNwYWNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxFdWxlckFuZ2xlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbEV1bGVyQW5nbGVzKHopIHtcbiAgICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2Uuc2V0TG9jYWxFdWxlckFuZ2xlcyh0aGlzLCAwLCAwLCB6KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVMb2NhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVMb2NhbCh4LCB5LCB6KSB7XG4gICAgICBpZiAoaXNOaWwoeSkgJiYgaXNOaWwoeikpIHtcbiAgICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5yb3RhdGVMb2NhbCh0aGlzLCAwLCAwLCB4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2Uucm90YXRlTG9jYWwodGhpcywgeCwgeSwgeik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCB6KSB7XG4gICAgICBpZiAoaXNOaWwoeSkgJiYgaXNOaWwoeikpIHtcbiAgICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5yb3RhdGUodGhpcywgMCwgMCwgeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnJvdGF0ZSh0aGlzLCB4LCB5LCB6KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSb3RhdGlvbihyb3RhdGlvbiwgeSwgeiwgdykge1xuICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5zZXRSb3RhdGlvbih0aGlzLCByb3RhdGlvbiwgeSwgeiwgdyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbFJvdGF0aW9uKHJvdGF0aW9uLCB5LCB6LCB3KSB7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnNldExvY2FsUm90YXRpb24odGhpcywgcm90YXRpb24sIHksIHosIHcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExvY2FsU2tld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbFNrZXcoc2tldywgeSkge1xuICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5zZXRMb2NhbFNrZXcodGhpcywgc2tldywgeSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Um90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um90YXRpb24oKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5nZXRSb3RhdGlvbih0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFJvdGF0aW9uKCkge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuc2NlbmVHcmFwaFNlcnZpY2UuZ2V0TG9jYWxSb3RhdGlvbih0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxTa2V3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsU2tldygpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLmdldExvY2FsU2tldyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYWxUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5nZXRMb2NhbFRyYW5zZm9ybSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V29ybGRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5nZXRXb3JsZFRyYW5zZm9ybSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TG9jYWxUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICBydW50aW1lLnNjZW5lR3JhcGhTZXJ2aWNlLnNldExvY2FsVHJhbnNmb3JtKHRoaXMsIHRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRMb2NhbFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldExvY2FsVHJhbnNmb3JtKCkge1xuICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5yZXNldExvY2FsVHJhbnNmb3JtKHRoaXMpO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uIHRyYW5zZm9ybWFibGVcblxuICAgIC8vICNyZWdpb24gYW5pbWF0YWJsZVxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIEFuaW1hdGlvbiBvYmplY3RzIGFmZmVjdGluZyB0aGlzIGVsZW1lbnRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEFuaW1hdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbmltYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuaW1hdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVBbmltYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYW4gYW5pbWF0aW9uIHdpdGggV0FBUElcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FbGVtZW50L2FuaW1hdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGUoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMkb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciB0aW1lbGluZSA9IChfdGhpcyRvd25lckRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRvd25lckRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvd25lckRvY3VtZW50LnRpbWVsaW5lO1xuICAgICAgaWYgKHRpbWVsaW5lKSB7XG4gICAgICAgIHJldHVybiB0aW1lbGluZS5wbGF5KHRoaXMsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvbiBhbmltYXRhYmxlXG5cbiAgICAvLyAjcmVnaW9uIHZpc2libGVcbiAgICAvKipcbiAgICAgKiBzaG9ydGN1dCBmb3IgVXNlZCB2YWx1ZSBvZiBgdmlzaWJpbGl0eWBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc1Zpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWaXNpYmxlKCkge1xuICAgICAgdmFyIF90aGlzJHBhcnNlZFN0eWxlO1xuICAgICAgcmV0dXJuICgoX3RoaXMkcGFyc2VkU3R5bGUgPSB0aGlzLnBhcnNlZFN0eWxlKSA9PT0gbnVsbCB8fCBfdGhpcyRwYXJzZWRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyc2VkU3R5bGUudmlzaWJpbGl0eSkgIT09ICdoaWRkZW4nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcmFjdGl2ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYikge1xuICAgICAgdGhpcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gYiA/ICdhdXRvJyA6ICdub25lJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbnRlcmFjdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludGVyYWN0aXZlKCkge1xuICAgICAgdmFyIF90aGlzJHBhcnNlZFN0eWxlMjtcbiAgICAgIHJldHVybiAoKF90aGlzJHBhcnNlZFN0eWxlMiA9IHRoaXMucGFyc2VkU3R5bGUpID09PSBudWxsIHx8IF90aGlzJHBhcnNlZFN0eWxlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyc2VkU3R5bGUyLnBvaW50ZXJFdmVudHMpICE9PSAnbm9uZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ3VsbGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ3VsbGVkKCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuY3VsbGFibGUgJiYgdGhpcy5jdWxsYWJsZS5lbmFibGUgJiYgIXRoaXMuY3VsbGFibGUudmlzaWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYnJpbmcgdG8gZnJvbnQgaW4gY3VycmVudCBncm91cFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvRnJvbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Gcm9udCgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5zdHlsZS56SW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5wYXJlbnROb2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyKGNoaWxkLnN0eWxlLnpJbmRleCk7XG4gICAgICAgIH0pKSkgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VuZCB0byBiYWNrIGluIGN1cnJlbnQgZ3JvdXBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0JhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CYWNrKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLnN0eWxlLnpJbmRleCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBOdW1iZXIoY2hpbGQuc3R5bGUuekluZGV4KTtcbiAgICAgICAgfSkpKSAtIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvbiB2aXNpYmxlXG5cbiAgICAvLyAjcmVnaW9uIGRlcHJlY2F0ZWRcblxuICAgIC8qKlxuICAgICAqIGNvbXBhdGlibGUgd2l0aCBHIDMuMFxuICAgICAqIEBhbGlhcyBvYmplY3QuY29uZmlnXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uZmlnKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBzdHlsZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2lyY2xlLnN0eWxlLnIgPSAxMDtcbiAgICAgKiBjb25zdCByID0gY2lyY2xlLnN0eWxlO1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lID0gYXJnc1swXSxcbiAgICAgICAgdmFsdWUgPSBhcmdzWzFdO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobmFtZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgX3RoaXMyLnNldEF0dHJpYnV0ZShrZXksIG5hbWVba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gM3gzIG1hdHJpeCBpbiB3b3JsZCBzcGFjZVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hdHJpeCh0cmFuc2Zvcm1NYXQ0KSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0NCB8fCB0aGlzLmdldFdvcmxkVHJhbnNmb3JtKCk7XG4gICAgICB2YXIgX21hdDQkZ2V0VHJhbnNsYXRpb24gPSBtYXQ0LmdldFRyYW5zbGF0aW9uKCR2ZWMzLCB0cmFuc2Zvcm0pLFxuICAgICAgICBfbWF0NCRnZXRUcmFuc2xhdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfbWF0NCRnZXRUcmFuc2xhdGlvbiwgMiksXG4gICAgICAgIHR4ID0gX21hdDQkZ2V0VHJhbnNsYXRpb24yWzBdLFxuICAgICAgICB0eSA9IF9tYXQ0JGdldFRyYW5zbGF0aW9uMlsxXTtcbiAgICAgIHZhciBfbWF0NCRnZXRTY2FsaW5nID0gbWF0NC5nZXRTY2FsaW5nKCR2ZWMzLCB0cmFuc2Zvcm0pLFxuICAgICAgICBfbWF0NCRnZXRTY2FsaW5nMiA9IF9zbGljZWRUb0FycmF5KF9tYXQ0JGdldFNjYWxpbmcsIDIpLFxuICAgICAgICBzeCA9IF9tYXQ0JGdldFNjYWxpbmcyWzBdLFxuICAgICAgICBzeSA9IF9tYXQ0JGdldFNjYWxpbmcyWzFdO1xuICAgICAgdmFyIHJvdGF0aW9uID0gbWF0NC5nZXRSb3RhdGlvbigkcXVhdCwgdHJhbnNmb3JtKTtcbiAgICAgIHZhciBfZ2V0RXVsZXI1ID0gZ2V0RXVsZXIoJHZlYzMsIHJvdGF0aW9uKSxcbiAgICAgICAgX2dldEV1bGVyNiA9IF9zbGljZWRUb0FycmF5KF9nZXRFdWxlcjUsIDMpLFxuICAgICAgICBldXggPSBfZ2V0RXVsZXI2WzBdLFxuICAgICAgICBldXogPSBfZ2V0RXVsZXI2WzJdO1xuICAgICAgLy8gZ2ltYmFsIGxvY2sgYXQgOTAgZGVncmVlc1xuICAgICAgcmV0dXJuIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUoZXV4IHx8IGV1eiwgdHgsIHR5LCBzeCwgc3kpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiAzeDMgbWF0cml4IGluIGxvY2FsIHNwYWNlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb2NhbE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbE1hdHJpeCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeCh0aGlzLmdldExvY2FsVHJhbnNmb3JtKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCAzeDMgbWF0cml4IGluIHdvcmxkIHNwYWNlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRNYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWF0cml4KG1hdCkge1xuICAgICAgdmFyIF9kZWNvbXBvc2UgPSBkZWNvbXBvc2UobWF0KSxcbiAgICAgICAgX2RlY29tcG9zZTIgPSBfc2xpY2VkVG9BcnJheShfZGVjb21wb3NlLCA1KSxcbiAgICAgICAgdHggPSBfZGVjb21wb3NlMlswXSxcbiAgICAgICAgdHkgPSBfZGVjb21wb3NlMlsxXSxcbiAgICAgICAgc2NhbGluZ1ggPSBfZGVjb21wb3NlMlsyXSxcbiAgICAgICAgc2NhbGluZ1kgPSBfZGVjb21wb3NlMlszXSxcbiAgICAgICAgYW5nbGUgPSBfZGVjb21wb3NlMls0XTtcbiAgICAgIHRoaXMuc2V0RXVsZXJBbmdsZXMoYW5nbGUpLnNldFBvc2l0aW9uKHR4LCB0eSkuc2V0TG9jYWxTY2FsZShzY2FsaW5nWCwgc2NhbGluZ1kpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCAzeDMgbWF0cml4IGluIGxvY2FsIHNwYWNlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb2NhbE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbE1hdHJpeChtYXQpIHtcbiAgICAgIHZhciBfZGVjb21wb3NlMyA9IGRlY29tcG9zZShtYXQpLFxuICAgICAgICBfZGVjb21wb3NlNCA9IF9zbGljZWRUb0FycmF5KF9kZWNvbXBvc2UzLCA1KSxcbiAgICAgICAgdHggPSBfZGVjb21wb3NlNFswXSxcbiAgICAgICAgdHkgPSBfZGVjb21wb3NlNFsxXSxcbiAgICAgICAgc2NhbGluZ1ggPSBfZGVjb21wb3NlNFsyXSxcbiAgICAgICAgc2NhbGluZ1kgPSBfZGVjb21wb3NlNFszXSxcbiAgICAgICAgYW5nbGUgPSBfZGVjb21wb3NlNFs0XTtcbiAgICAgIHRoaXMuc2V0TG9jYWxFdWxlckFuZ2xlcyhhbmdsZSkuc2V0TG9jYWxQb3NpdGlvbih0eCwgdHkpLnNldExvY2FsU2NhbGUoc2NhbGluZ1gsIHNjYWxpbmdZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgYHZpc2liaWxpdHk6IHZpc2libGVgIGluc3RlYWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgdmlzaWJpbGl0eTogaGlkZGVuYCBpbnN0ZWFkLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgY2hpbGRFbGVtZW50Q291bnRgIGluc3RlYWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkRWxlbWVudENvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgcGFyZW50RWxlbWVudGAgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgY2hpbGRyZW5gIGluc3RlYWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgZmlyc3RFbGVtZW50Q2hpbGRgIGluc3RlYWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgbGFzdEVsZW1lbnRDaGlsZGAgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIGB0aGlzLmNoaWxkcmVuW2luZGV4XWAgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENoaWxkQnlJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBgYXBwZW5kQ2hpbGRgIGluc3RlYWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGNoaWxkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuY29uZmlnW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ1tuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgYHNldFBvc2l0aW9uYCBpbnN0ZWFkLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhwb3NpdGlvbikge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgeiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24sIHksIHopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIGBzZXRQb3NpdGlvbmAgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShwb3NpdGlvbikge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgeiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24sIHksIHopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIGB0aGlzLnN0eWxlLnpJbmRleGAgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFpJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRaSW5kZXgoekluZGV4KSB7XG4gICAgICB0aGlzLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vICNlbmRyZWdpb24gZGVwcmVjYXRlZFxuICB9XSk7XG59KEVsZW1lbnQpO1xuRGlzcGxheU9iamVjdC5QQVJTRURfU1RZTEVfTElTVCA9IG5ldyBTZXQoWydjbGFzcycsICdjbGFzc05hbWUnLCAnY2xpcFBhdGgnLCAnY3Vyc29yJywgJ2Rpc3BsYXknLCAnZHJhZ2dhYmxlJywgJ2Ryb3BwYWJsZScsICdmaWxsJywgJ2ZpbGxPcGFjaXR5JywgJ2ZpbGxSdWxlJywgJ2ZpbHRlcicsICdpbmNyZWFzZWRMaW5lV2lkdGhGb3JIaXRUZXN0aW5nJywgJ2xpbmVDYXAnLCAnbGluZURhc2gnLCAnbGluZURhc2hPZmZzZXQnLCAnbGluZUpvaW4nLCAnbGluZVdpZHRoJywgJ21pdGVyTGltaXQnLCAnaGl0QXJlYScsICdvZmZzZXREaXN0YW5jZScsICdvZmZzZXRQYXRoJywgJ29mZnNldFgnLCAnb2Zmc2V0WScsICdvcGFjaXR5JywgJ3BvaW50ZXJFdmVudHMnLCAnc2hhZG93Q29sb3InLCAnc2hhZG93VHlwZScsICdzaGFkb3dCbHVyJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WScsICdzdHJva2UnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdzdHJva2VMaW5lY2FwJywgJ3N0cm9rZUxpbmVKb2luJywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VEYXNob2Zmc2V0JywgJ3RyYW5zZm9ybScsICd0cmFuc2Zvcm1PcmlnaW4nLCAndGV4dFRyYW5zZm9ybScsICd2aXNpYmlsaXR5JywgJ3pJbmRleCddKTtcblxudmFyIENpcmNsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBDaXJjbGUsIFtfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHR5cGU6IFNoYXBlLkNJUkNMRVxuICAgIH0sIG9wdGlvbnMpXSk7XG4gIH1cbiAgX2luaGVyaXRzKENpcmNsZSwgX0Rpc3BsYXlPYmplY3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENpcmNsZSk7XG59KERpc3BsYXlPYmplY3QpO1xuQ2lyY2xlLlBBUlNFRF9TVFlMRV9MSVNUID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KERpc3BsYXlPYmplY3QuUEFSU0VEX1NUWUxFX0xJU1QpLCBbJ2N4JywgJ2N5JywgJ2N6JywgJ3InLCAnaXNCaWxsYm9hcmQnLCAnaXNTaXplQXR0ZW51YXRpb24nXSkpO1xuXG52YXIgX2V4Y2x1ZGVkJDYgPSBbXCJzdHlsZVwiXTtcbi8qKlxuICogc2hhZG93IHJvb3RcbiAqIEBzZWUgaHR0cHM6Ly95dXF1ZS5hbnRmaW4taW5jLmNvbS9hbnR2L2N6cXZnNS9wZ3FpcGdcbiAqL1xudmFyIEN1c3RvbUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIC8vIHByaXZhdGUgc2hhZG93Tm9kZXM6IERpc3BsYXlPYmplY3RbXSA9IFtdO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbUVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDYpO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21FbGVtZW50KTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ3VzdG9tRWxlbWVudCwgW19vYmplY3RTcHJlYWQoe1xuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfSwgcmVzdCldKTtcbiAgICBfdGhpcy5pc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBmaXJlZCBhZnRlciBlbGVtZW50IGluc2VydCBpbnRvIERPTSB0cmVlXG4gICAqL1xuICBfaW5oZXJpdHMoQ3VzdG9tRWxlbWVudCwgX0Rpc3BsYXlPYmplY3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEN1c3RvbUVsZW1lbnQpO1xufShEaXNwbGF5T2JqZWN0KTtcbkN1c3RvbUVsZW1lbnQuUEFSU0VEX1NUWUxFX0xJU1QgPSBuZXcgU2V0KFsnY2xhc3MnLCAnY2xhc3NOYW1lJywgJ2NsaXBQYXRoJywgJ2N1cnNvcicsICdkcmFnZ2FibGUnLCAnZHJvcHBhYmxlJywgJ29wYWNpdHknLCAncG9pbnRlckV2ZW50cycsICd0cmFuc2Zvcm0nLCAndHJhbnNmb3JtT3JpZ2luJywgJ3pJbmRleCcsICd2aXNpYmlsaXR5J10pO1xuXG52YXIgRWxsaXBzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgZnVuY3Rpb24gRWxsaXBzZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsbGlwc2UpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVsbGlwc2UsIFtfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHR5cGU6IFNoYXBlLkVMTElQU0VcbiAgICB9LCBvcHRpb25zKV0pO1xuICB9XG4gIF9pbmhlcml0cyhFbGxpcHNlLCBfRGlzcGxheU9iamVjdCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWxsaXBzZSk7XG59KERpc3BsYXlPYmplY3QpO1xuRWxsaXBzZS5QQVJTRURfU1RZTEVfTElTVCA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShEaXNwbGF5T2JqZWN0LlBBUlNFRF9TVFlMRV9MSVNUKSwgWydjeCcsICdjeScsICdjeicsICdyeCcsICdyeScsICdpc0JpbGxib2FyZCcsICdpc1NpemVBdHRlbnVhdGlvbiddKSk7XG5cbi8qKlxuICog6IqC54K554mH5q6177yM55So5LqO5YyF6KO55aSa5Liq6IqC54K55bm25om56YeP5pON5L2cXG4gKlxuICogIOWQkSBGcmFnbWVudCDmiJbogIXmoLnoioLngrnkuLogRnJhZ21lbnQg55qE6IqC54K55re75Yqg5a2Q6IqC54K55pe277yM5LiN5Lya6Kem5Y+R5riy5p+T5ZKM5LqL5Lu244CCXG4gKlxuICog5b2TIEZyYWdtZW50IOiiq+aMgui9veWIsCBDYW52YXMg5Lit55qE6IqC54K55pe277yM5YW25a2Q6IqC54K55Lya5LiA5qyh5oCn6KKr5riy5p+T77yM5bm26Kem5Y+R5ZCI5bm25LqL5Lu244CCXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRGcmFnbWVudFxuICovXG52YXIgRnJhZ21lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEZyYWdtZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFnbWVudCk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRnJhZ21lbnQsIFt7XG4gICAgICB0eXBlOiBTaGFwZS5GUkFHTUVOVFxuICAgIH1dKTtcbiAgfVxuICBfaW5oZXJpdHMoRnJhZ21lbnQsIF9EaXNwbGF5T2JqZWN0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhGcmFnbWVudCk7XG59KERpc3BsYXlPYmplY3QpO1xuRnJhZ21lbnQuUEFSU0VEX1NUWUxFX0xJU1QgPSBuZXcgU2V0KFsnY2xhc3MnLCAnY2xhc3NOYW1lJ10pO1xuXG4vKipcbiAqIGl0cyBhdHRyaWJ1dGVzIGFyZSBpbmhlcml0ZWQgYnkgaXRzIGNoaWxkcmVuLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9TVkcvRWxlbWVudC9nXG4gKiBcbiAqIEBleGFtcGxlXG4gKiA8ZyBmaWxsPVwid2hpdGVcIiBzdHJva2U9XCJncmVlblwiIHN0cm9rZS13aWR0aD1cIjVcIj5cbiAgICA8Y2lyY2xlIGN4PVwiNDBcIiBjeT1cIjQwXCIgcj1cIjI1XCIgLz5cbiAgICA8Y2lyY2xlIGN4PVwiNjBcIiBjeT1cIjYwXCIgcj1cIjI1XCIgLz5cbiAgPC9nPlxuICovXG52YXIgR3JvdXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXApO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEdyb3VwLCBbX29iamVjdFNwcmVhZCh7XG4gICAgICB0eXBlOiBTaGFwZS5HUk9VUFxuICAgIH0sIG9wdGlvbnMpXSk7XG4gIH1cbiAgX2luaGVyaXRzKEdyb3VwLCBfRGlzcGxheU9iamVjdCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoR3JvdXApO1xufShEaXNwbGF5T2JqZWN0KTtcbkdyb3VwLlBBUlNFRF9TVFlMRV9MSVNUID0gbmV3IFNldChbJ2NsYXNzJywgJ2NsYXNzTmFtZScsICdjbGlwUGF0aCcsICdjdXJzb3InLCAnZHJhZ2dhYmxlJywgJ2Ryb3BwYWJsZScsICdvcGFjaXR5JywgJ3BvaW50ZXJFdmVudHMnLCAndHJhbnNmb3JtJywgJ3RyYW5zZm9ybU9yaWdpbicsICd6SW5kZXgnLCAndmlzaWJpbGl0eSddKTtcblxudmFyIF9leGNsdWRlZCQ1ID0gW1wic3R5bGVcIl07XG4vKipcbiAqIEhUTUwgY29udGFpbmVyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvZHJlaSNodG1sXG4gKi9cbnZhciBIVE1MID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlzcGxheU9iamVjdCkge1xuICBmdW5jdGlvbiBIVE1MKCkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQ1KTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEhUTUwsIFtfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHR5cGU6IFNoYXBlLkhUTUwsXG4gICAgICBzdHlsZTogc3R5bGVcbiAgICB9LCByZXN0KV0pO1xuICAgIF90aGlzLmN1bGxhYmxlLmVuYWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gd3JhcHBlciBIVE1MRWxlbWVudFxuICAgKiAqIDxkaXY+IGluIGctd2ViZ2wvY2FudmFzXG4gICAqICogPGZvcmVpZ25PYmplY3Q+IGluIGctc3ZnXG4gICAqL1xuICBfaW5oZXJpdHMoSFRNTCwgX0Rpc3BsYXlPYmplY3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEhUTUwsIFt7XG4gICAga2V5OiBcImdldERvbUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RG9tRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlZFN0eWxlLiRlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvdmVycmlkZSB3aXRoICRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAqXG4gICAgICogISBUaGUgY2FsY3VsYXRpb24gbG9naWMgb2YgdGhlIGh0bWwgZWxlbWVudCBzaG91bGQgYmUgY29uc2lzdGVudCB3aXRoIHRoYXQgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6IFJlY3RhbmdsZSB7XG4gICAgLy8gICBpZiAodGhpcy5wYXJzZWRTdHlsZS4kZWwpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMucGFyc2VkU3R5bGUuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vICAgfSBlbHNlIHtcbiAgICAvLyAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnBhcnNlZFN0eWxlO1xuICAgIC8vICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UmVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCldO1xuICAgIH1cblxuICAgIC8vIGdldEJvdW5kcygpIHtcbiAgICAvLyAgIGNvbnN0IGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vICAgLy8gY2FsYyBjb250ZXh0J3Mgb2Zmc2V0XG4gICAgLy8gICAvLyBAdHMtaWdub3JlXG4gICAgLy8gICBjb25zdCBjYW52YXNSZWN0ID0gdGhpcy5vd25lckRvY3VtZW50Py5kZWZhdWx0Vmlld1xuICAgIC8vICAgICA/LmdldENvbnRleHRTZXJ2aWNlKClcbiAgICAvLyAgICAgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgLy8gICBjb25zdCBhYWJiID0gbmV3IEFBQkIoKTtcbiAgICAvLyAgIGNvbnN0IG1pblggPSBjbGllbnRSZWN0LmxlZnQgLSAoY2FudmFzUmVjdD8ubGVmdCB8fCAwKTtcbiAgICAvLyAgIGNvbnN0IG1pblkgPSBjbGllbnRSZWN0LnRvcCAtIChjYW52YXNSZWN0Py50b3AgfHwgMCk7XG4gICAgLy8gICBhYWJiLnNldE1pbk1heChcbiAgICAvLyAgICAgW21pblgsIG1pblksIDBdLFxuICAgIC8vICAgICBbbWluWCArIGNsaWVudFJlY3Qud2lkdGgsIG1pblkgKyBjbGllbnRSZWN0LmhlaWdodCwgMF0sXG4gICAgLy8gICApO1xuICAgIC8vICAgcmV0dXJuIGFhYmI7XG4gICAgLy8gfVxuICB9LCB7XG4gICAga2V5OiBcImdldExvY2FsQm91bmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2FsQm91bmRzKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50SW52ZXJ0ID0gbWF0NC5pbnZlcnQobWF0NC5jcmVhdGUoKSwgdGhpcy5wYXJlbnROb2RlLmdldFdvcmxkVHJhbnNmb3JtKCkpO1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFBQUJCLmlzRW1wdHkoYm91bmRzKSkge1xuICAgICAgICAgIHZhciBsb2NhbEJvdW5kcyA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgbG9jYWxCb3VuZHMuc2V0RnJvbVRyYW5zZm9ybWVkQUFCQihib3VuZHMsIHBhcmVudEludmVydCk7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsQm91bmRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICB9XG4gIH1dKTtcbn0oRGlzcGxheU9iamVjdCk7XG5IVE1MLlBBUlNFRF9TVFlMRV9MSVNUID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KERpc3BsYXlPYmplY3QuUEFSU0VEX1NUWUxFX0xJU1QpLCBbJ3gnLCAneScsICckZWwnLCAnaW5uZXJIVE1MJywgJ3dpZHRoJywgJ2hlaWdodCddKSk7XG5cbnZhciBJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgSW1hZ2UsIFtfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHR5cGU6IFNoYXBlLklNQUdFXG4gICAgfSwgb3B0aW9ucyldKTtcbiAgfVxuICBfaW5oZXJpdHMoSW1hZ2UsIF9EaXNwbGF5T2JqZWN0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJbWFnZSk7XG59KERpc3BsYXlPYmplY3QpO1xuSW1hZ2UuUEFSU0VEX1NUWUxFX0xJU1QgPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoRGlzcGxheU9iamVjdC5QQVJTRURfU1RZTEVfTElTVCksIFsneCcsICd5JywgJ3onLCAnc3JjJywgJ3dpZHRoJywgJ2hlaWdodCcsICdpc0JpbGxib2FyZCcsICdiaWxsYm9hcmRSb3RhdGlvbicsICdpc1NpemVBdHRlbnVhdGlvbicsICdrZWVwQXNwZWN0UmF0aW8nXSkpO1xuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJzdHlsZVwiXTtcbi8qKlxuICogQ3JlYXRlIGEgbGluZSBjb25uZWN0aW5nIHR3byBwb2ludHMuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L2xpbmVcbiAqXG4gKiBBbHNvIHN1cHBvcnQgZm9yIHVzaW5nIG1hcmtlci5cbiAqL1xudmFyIExpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIGZ1bmN0aW9uIExpbmUoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDQpO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgTGluZSwgW19vYmplY3RTcHJlYWQoe1xuICAgICAgdHlwZTogU2hhcGUuTElORSxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4MjogMCxcbiAgICAgICAgeTI6IDAsXG4gICAgICAgIHoxOiAwLFxuICAgICAgICB6MjogMFxuICAgICAgfSwgc3R5bGUpXG4gICAgfSwgcmVzdCldKTtcbiAgICBfdGhpcy5tYXJrZXJTdGFydEFuZ2xlID0gMDtcbiAgICBfdGhpcy5tYXJrZXJFbmRBbmdsZSA9IDA7XG4gICAgdmFyIF90aGlzJHBhcnNlZFN0eWxlID0gX3RoaXMucGFyc2VkU3R5bGUsXG4gICAgICBtYXJrZXJTdGFydCA9IF90aGlzJHBhcnNlZFN0eWxlLm1hcmtlclN0YXJ0LFxuICAgICAgbWFya2VyRW5kID0gX3RoaXMkcGFyc2VkU3R5bGUubWFya2VyRW5kO1xuICAgIGlmIChtYXJrZXJTdGFydCAmJiBpc0Rpc3BsYXlPYmplY3QobWFya2VyU3RhcnQpKSB7XG4gICAgICBfdGhpcy5tYXJrZXJTdGFydEFuZ2xlID0gbWFya2VyU3RhcnQuZ2V0TG9jYWxFdWxlckFuZ2xlcygpO1xuICAgICAgX3RoaXMuYXBwZW5kQ2hpbGQobWFya2VyU3RhcnQpO1xuICAgIH1cbiAgICBpZiAobWFya2VyRW5kICYmIGlzRGlzcGxheU9iamVjdChtYXJrZXJFbmQpKSB7XG4gICAgICBfdGhpcy5tYXJrZXJFbmRBbmdsZSA9IG1hcmtlckVuZC5nZXRMb2NhbEV1bGVyQW5nbGVzKCk7XG4gICAgICBfdGhpcy5hcHBlbmRDaGlsZChtYXJrZXJFbmQpO1xuICAgIH1cbiAgICBfdGhpcy50cmFuc2Zvcm1NYXJrZXIodHJ1ZSk7XG4gICAgX3RoaXMudHJhbnNmb3JtTWFya2VyKGZhbHNlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKExpbmUsIF9EaXNwbGF5T2JqZWN0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMaW5lLCBbe1xuICAgIGtleTogXCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHByZXZQYXJzZWRWYWx1ZSwgbmV3UGFyc2VkVmFsdWUpIHtcbiAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3gxJyB8fCBhdHRyTmFtZSA9PT0gJ3kxJyB8fCBhdHRyTmFtZSA9PT0gJ3gyJyB8fCBhdHRyTmFtZSA9PT0gJ3kyJyB8fCBhdHRyTmFtZSA9PT0gJ21hcmtlclN0YXJ0T2Zmc2V0JyB8fCBhdHRyTmFtZSA9PT0gJ21hcmtlckVuZE9mZnNldCcpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXJrZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWFya2VyKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09ICdtYXJrZXJTdGFydCcpIHtcbiAgICAgICAgaWYgKHByZXZQYXJzZWRWYWx1ZSAmJiBpc0Rpc3BsYXlPYmplY3QocHJldlBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgIHRoaXMubWFya2VyU3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgcHJldlBhcnNlZFZhbHVlLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ1NTS2V5d29yZCAndW5zZXQnXG4gICAgICAgIGlmIChuZXdQYXJzZWRWYWx1ZSAmJiBpc0Rpc3BsYXlPYmplY3QobmV3UGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5tYXJrZXJTdGFydEFuZ2xlID0gbmV3UGFyc2VkVmFsdWUuZ2V0TG9jYWxFdWxlckFuZ2xlcygpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3UGFyc2VkVmFsdWUpO1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtTWFya2VyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSAnbWFya2VyRW5kJykge1xuICAgICAgICBpZiAocHJldlBhcnNlZFZhbHVlICYmIGlzRGlzcGxheU9iamVjdChwcmV2UGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5tYXJrZXJFbmRBbmdsZSA9IDA7XG4gICAgICAgICAgcHJldlBhcnNlZFZhbHVlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdQYXJzZWRWYWx1ZSAmJiBpc0Rpc3BsYXlPYmplY3QobmV3UGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5tYXJrZXJFbmRBbmdsZSA9IG5ld1BhcnNlZFZhbHVlLmdldExvY2FsRXVsZXJBbmdsZXMoKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld1BhcnNlZFZhbHVlKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybU1hcmtlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtTWFya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybU1hcmtlcihpc1N0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMkcGFyc2VkU3R5bGUyID0gdGhpcy5wYXJzZWRTdHlsZSxcbiAgICAgICAgbWFya2VyU3RhcnQgPSBfdGhpcyRwYXJzZWRTdHlsZTIubWFya2VyU3RhcnQsXG4gICAgICAgIG1hcmtlckVuZCA9IF90aGlzJHBhcnNlZFN0eWxlMi5tYXJrZXJFbmQsXG4gICAgICAgIG1hcmtlclN0YXJ0T2Zmc2V0ID0gX3RoaXMkcGFyc2VkU3R5bGUyLm1hcmtlclN0YXJ0T2Zmc2V0LFxuICAgICAgICBtYXJrZXJFbmRPZmZzZXQgPSBfdGhpcyRwYXJzZWRTdHlsZTIubWFya2VyRW5kT2Zmc2V0LFxuICAgICAgICB4MSA9IF90aGlzJHBhcnNlZFN0eWxlMi54MSxcbiAgICAgICAgeDIgPSBfdGhpcyRwYXJzZWRTdHlsZTIueDIsXG4gICAgICAgIHkxID0gX3RoaXMkcGFyc2VkU3R5bGUyLnkxLFxuICAgICAgICB5MiA9IF90aGlzJHBhcnNlZFN0eWxlMi55MjtcbiAgICAgIHZhciBtYXJrZXIgPSBpc1N0YXJ0ID8gbWFya2VyU3RhcnQgOiBtYXJrZXJFbmQ7XG4gICAgICBpZiAoIW1hcmtlciB8fCAhaXNEaXNwbGF5T2JqZWN0KG1hcmtlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJhZCA9IDA7XG4gICAgICB2YXIgeDtcbiAgICAgIHZhciB5O1xuICAgICAgdmFyIG94O1xuICAgICAgdmFyIG95O1xuICAgICAgdmFyIG9mZnNldDtcbiAgICAgIHZhciBvcmlnaW5hbEFuZ2xlO1xuICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgb3ggPSB4MTtcbiAgICAgICAgb3kgPSB5MTtcbiAgICAgICAgeCA9IHgyIC0geDE7XG4gICAgICAgIHkgPSB5MiAtIHkxO1xuICAgICAgICBvZmZzZXQgPSBtYXJrZXJTdGFydE9mZnNldCB8fCAwO1xuICAgICAgICBvcmlnaW5hbEFuZ2xlID0gdGhpcy5tYXJrZXJTdGFydEFuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ggPSB4MjtcbiAgICAgICAgb3kgPSB5MjtcbiAgICAgICAgeCA9IHgxIC0geDI7XG4gICAgICAgIHkgPSB5MSAtIHkyO1xuICAgICAgICBvZmZzZXQgPSBtYXJrZXJFbmRPZmZzZXQgfHwgMDtcbiAgICAgICAgb3JpZ2luYWxBbmdsZSA9IHRoaXMubWFya2VyRW5kQW5nbGU7XG4gICAgICB9XG4gICAgICByYWQgPSBNYXRoLmF0YW4yKHksIHgpO1xuXG4gICAgICAvLyBhY2NvdW50IGZvciBtYXJrZXJPZmZzZXRcbiAgICAgIG1hcmtlci5zZXRMb2NhbEV1bGVyQW5nbGVzKHJhZCAqIDE4MCAvIE1hdGguUEkgKyBvcmlnaW5hbEFuZ2xlKTtcbiAgICAgIG1hcmtlci5zZXRMb2NhbFBvc2l0aW9uKG94ICsgTWF0aC5jb3MocmFkKSAqIG9mZnNldCwgb3kgKyBNYXRoLnNpbihyYWQpICogb2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocmF0aW8pIHtcbiAgICAgIHZhciBpbldvcmxkU3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgLy8gVE9ETzogYWNjb3VudCBmb3IgejEvejIgaW4gM0QgbGluZVxuICAgICAgdmFyIF90aGlzJHBhcnNlZFN0eWxlMyA9IHRoaXMucGFyc2VkU3R5bGUsXG4gICAgICAgIHgxID0gX3RoaXMkcGFyc2VkU3R5bGUzLngxLFxuICAgICAgICB5MSA9IF90aGlzJHBhcnNlZFN0eWxlMy55MSxcbiAgICAgICAgeDIgPSBfdGhpcyRwYXJzZWRTdHlsZTMueDIsXG4gICAgICAgIHkyID0gX3RoaXMkcGFyc2VkU3R5bGUzLnkyO1xuICAgICAgdmFyIF9saW5lUG9pbnRBdCA9IGxpbmVQb2ludEF0KHgxLCB5MSwgeDIsIHkyLCByYXRpbyksXG4gICAgICAgIHggPSBfbGluZVBvaW50QXQueCxcbiAgICAgICAgeSA9IF9saW5lUG9pbnRBdC55O1xuICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdmVjMy50cmFuc2Zvcm1NYXQ0KHZlYzMuY3JlYXRlKCksIHZlYzMuZnJvbVZhbHVlcyh4LCB5LCAwKSwgaW5Xb3JsZFNwYWNlID8gdGhpcy5nZXRXb3JsZFRyYW5zZm9ybSgpIDogdGhpcy5nZXRMb2NhbFRyYW5zZm9ybSgpKTtcblxuICAgICAgLy8gYXBwbHkgbG9jYWwgdHJhbnNmb3JtYXRpb25cbiAgICAgIHJldHVybiBuZXcgUG9pbnQodHJhbnNmb3JtZWRbMF0sIHRyYW5zZm9ybWVkWzFdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRBdExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludEF0TGVuZ3RoKGRpc3RhbmNlKSB7XG4gICAgICB2YXIgaW5Xb3JsZFNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldFBvaW50KGRpc3RhbmNlIC8gdGhpcy5nZXRUb3RhbExlbmd0aCgpLCBpbldvcmxkU3BhY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbExlbmd0aCgpIHtcbiAgICAgIC8vIFRPRE86IGFjY291bnQgZm9yIHoxL3oyIGluIDNEIGxpbmVcbiAgICAgIHZhciBfdGhpcyRwYXJzZWRTdHlsZTQgPSB0aGlzLnBhcnNlZFN0eWxlLFxuICAgICAgICB4MSA9IF90aGlzJHBhcnNlZFN0eWxlNC54MSxcbiAgICAgICAgeTEgPSBfdGhpcyRwYXJzZWRTdHlsZTQueTEsXG4gICAgICAgIHgyID0gX3RoaXMkcGFyc2VkU3R5bGU0LngyLFxuICAgICAgICB5MiA9IF90aGlzJHBhcnNlZFN0eWxlNC55MjtcbiAgICAgIHJldHVybiBsaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gIH1dKTtcbn0oRGlzcGxheU9iamVjdCk7XG5MaW5lLlBBUlNFRF9TVFlMRV9MSVNUID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KERpc3BsYXlPYmplY3QuUEFSU0VEX1NUWUxFX0xJU1QpLCBbJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJywgJ3oxJywgJ3oyJywgJ2lzQmlsbGJvYXJkJywgJ2lzU2l6ZUF0dGVudWF0aW9uJywgJ21hcmtlclN0YXJ0JywgJ21hcmtlckVuZCcsICdtYXJrZXJTdGFydE9mZnNldCcsICdtYXJrZXJFbmRPZmZzZXQnXSkpO1xuXG52YXIgX2V4Y2x1ZGVkJDMgPSBbXCJzdHlsZVwiXTtcbnZhciBQYXRoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlzcGxheU9iamVjdCkge1xuICBmdW5jdGlvbiBQYXRoKCkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQzKTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGF0aCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFBhdGgsIFtfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHR5cGU6IFNoYXBlLlBBVEgsXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBpbml0aWFsUGFyc2VkU3R5bGU6IHtcbiAgICAgICAgbWl0ZXJMaW1pdDogNCxcbiAgICAgICAgZDogX29iamVjdFNwcmVhZCh7fSwgRU1QVFlfUEFSU0VEX1BBVEgpXG4gICAgICB9XG4gICAgfSwgcmVzdCldKTtcbiAgICBfdGhpcy5tYXJrZXJTdGFydEFuZ2xlID0gMDtcbiAgICBfdGhpcy5tYXJrZXJFbmRBbmdsZSA9IDA7XG4gICAgLyoqXG4gICAgICogbWFya2VycyBwbGFjZWQgYXQgdGhlIG1pZFxuICAgICAqL1xuICAgIF90aGlzLm1hcmtlck1pZExpc3QgPSBbXTtcbiAgICB2YXIgX3RoaXMkcGFyc2VkU3R5bGUgPSBfdGhpcy5wYXJzZWRTdHlsZSxcbiAgICAgIG1hcmtlclN0YXJ0ID0gX3RoaXMkcGFyc2VkU3R5bGUubWFya2VyU3RhcnQsXG4gICAgICBtYXJrZXJFbmQgPSBfdGhpcyRwYXJzZWRTdHlsZS5tYXJrZXJFbmQsXG4gICAgICBtYXJrZXJNaWQgPSBfdGhpcyRwYXJzZWRTdHlsZS5tYXJrZXJNaWQ7XG4gICAgaWYgKG1hcmtlclN0YXJ0ICYmIGlzRGlzcGxheU9iamVjdChtYXJrZXJTdGFydCkpIHtcbiAgICAgIF90aGlzLm1hcmtlclN0YXJ0QW5nbGUgPSBtYXJrZXJTdGFydC5nZXRMb2NhbEV1bGVyQW5nbGVzKCk7XG4gICAgICBfdGhpcy5hcHBlbmRDaGlsZChtYXJrZXJTdGFydCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJNaWQgJiYgaXNEaXNwbGF5T2JqZWN0KG1hcmtlck1pZCkpIHtcbiAgICAgIF90aGlzLnBsYWNlTWFya2VyTWlkKG1hcmtlck1pZCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJFbmQgJiYgaXNEaXNwbGF5T2JqZWN0KG1hcmtlckVuZCkpIHtcbiAgICAgIF90aGlzLm1hcmtlckVuZEFuZ2xlID0gbWFya2VyRW5kLmdldExvY2FsRXVsZXJBbmdsZXMoKTtcbiAgICAgIF90aGlzLmFwcGVuZENoaWxkKG1hcmtlckVuZCk7XG4gICAgfVxuICAgIF90aGlzLnRyYW5zZm9ybU1hcmtlcih0cnVlKTtcbiAgICBfdGhpcy50cmFuc2Zvcm1NYXJrZXIoZmFsc2UpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoUGF0aCwgX0Rpc3BsYXlPYmplY3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBhdGgsIFt7XG4gICAga2V5OiBcImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgcHJldlBhcnNlZFZhbHVlLCBuZXdQYXJzZWRWYWx1ZSkge1xuICAgICAgaWYgKGF0dHJOYW1lID09PSAnZCcpIHtcbiAgICAgICAgLy8gcmVjYWxjIG1hcmtlcnNcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXJrZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWFya2VyKGZhbHNlKTtcbiAgICAgICAgdGhpcy5wbGFjZU1hcmtlck1pZCh0aGlzLnBhcnNlZFN0eWxlLm1hcmtlck1pZCk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSAnbWFya2VyU3RhcnRPZmZzZXQnIHx8IGF0dHJOYW1lID09PSAnbWFya2VyRW5kT2Zmc2V0Jykge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hcmtlcih0cnVlKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXJrZXIoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gJ21hcmtlclN0YXJ0Jykge1xuICAgICAgICBpZiAocHJldlBhcnNlZFZhbHVlICYmIGlzRGlzcGxheU9iamVjdChwcmV2UGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5tYXJrZXJTdGFydEFuZ2xlID0gMDtcbiAgICAgICAgICBwcmV2UGFyc2VkVmFsdWUucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDU1NLZXl3b3JkICd1bnNldCdcbiAgICAgICAgaWYgKG5ld1BhcnNlZFZhbHVlICYmIGlzRGlzcGxheU9iamVjdChuZXdQYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlclN0YXJ0QW5nbGUgPSBuZXdQYXJzZWRWYWx1ZS5nZXRMb2NhbEV1bGVyQW5nbGVzKCk7XG4gICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdQYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXJrZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09ICdtYXJrZXJFbmQnKSB7XG4gICAgICAgIGlmIChwcmV2UGFyc2VkVmFsdWUgJiYgaXNEaXNwbGF5T2JqZWN0KHByZXZQYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlckVuZEFuZ2xlID0gMDtcbiAgICAgICAgICBwcmV2UGFyc2VkVmFsdWUucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1BhcnNlZFZhbHVlICYmIGlzRGlzcGxheU9iamVjdChuZXdQYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlckVuZEFuZ2xlID0gbmV3UGFyc2VkVmFsdWUuZ2V0TG9jYWxFdWxlckFuZ2xlcygpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3UGFyc2VkVmFsdWUpO1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtTWFya2VyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gJ21hcmtlck1pZCcpIHtcbiAgICAgICAgdGhpcy5wbGFjZU1hcmtlck1pZChuZXdQYXJzZWRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybU1hcmtlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1NYXJrZXIoaXNTdGFydCkge1xuICAgICAgdmFyIF90aGlzJHBhcnNlZFN0eWxlMiA9IHRoaXMucGFyc2VkU3R5bGUsXG4gICAgICAgIG1hcmtlclN0YXJ0ID0gX3RoaXMkcGFyc2VkU3R5bGUyLm1hcmtlclN0YXJ0LFxuICAgICAgICBtYXJrZXJFbmQgPSBfdGhpcyRwYXJzZWRTdHlsZTIubWFya2VyRW5kLFxuICAgICAgICBtYXJrZXJTdGFydE9mZnNldCA9IF90aGlzJHBhcnNlZFN0eWxlMi5tYXJrZXJTdGFydE9mZnNldCxcbiAgICAgICAgbWFya2VyRW5kT2Zmc2V0ID0gX3RoaXMkcGFyc2VkU3R5bGUyLm1hcmtlckVuZE9mZnNldDtcbiAgICAgIHZhciBtYXJrZXIgPSBpc1N0YXJ0ID8gbWFya2VyU3RhcnQgOiBtYXJrZXJFbmQ7XG4gICAgICBpZiAoIW1hcmtlciB8fCAhaXNEaXNwbGF5T2JqZWN0KG1hcmtlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJhZCA9IDA7XG4gICAgICB2YXIgeDtcbiAgICAgIHZhciB5O1xuICAgICAgdmFyIG94O1xuICAgICAgdmFyIG95O1xuICAgICAgdmFyIG9mZnNldDtcbiAgICAgIHZhciBvcmlnaW5hbEFuZ2xlO1xuICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldFN0YXJ0VGFuZ2VudCA9IHRoaXMuZ2V0U3RhcnRUYW5nZW50KCksXG4gICAgICAgICAgX3RoaXMkZ2V0U3RhcnRUYW5nZW50MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGdldFN0YXJ0VGFuZ2VudCwgMiksXG4gICAgICAgICAgcDEgPSBfdGhpcyRnZXRTdGFydFRhbmdlbnQyWzBdLFxuICAgICAgICAgIHAyID0gX3RoaXMkZ2V0U3RhcnRUYW5nZW50MlsxXTtcbiAgICAgICAgb3ggPSBwMlswXTtcbiAgICAgICAgb3kgPSBwMlsxXTtcbiAgICAgICAgeCA9IHAxWzBdIC0gcDJbMF07XG4gICAgICAgIHkgPSBwMVsxXSAtIHAyWzFdO1xuICAgICAgICBvZmZzZXQgPSBtYXJrZXJTdGFydE9mZnNldCB8fCAwO1xuICAgICAgICBvcmlnaW5hbEFuZ2xlID0gdGhpcy5tYXJrZXJTdGFydEFuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJGdldEVuZFRhbmdlbnQgPSB0aGlzLmdldEVuZFRhbmdlbnQoKSxcbiAgICAgICAgICBfdGhpcyRnZXRFbmRUYW5nZW50MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGdldEVuZFRhbmdlbnQsIDIpLFxuICAgICAgICAgIF9wID0gX3RoaXMkZ2V0RW5kVGFuZ2VudDJbMF0sXG4gICAgICAgICAgX3AyID0gX3RoaXMkZ2V0RW5kVGFuZ2VudDJbMV07XG4gICAgICAgIG94ID0gX3AyWzBdO1xuICAgICAgICBveSA9IF9wMlsxXTtcbiAgICAgICAgeCA9IF9wWzBdIC0gX3AyWzBdO1xuICAgICAgICB5ID0gX3BbMV0gLSBfcDJbMV07XG4gICAgICAgIG9mZnNldCA9IG1hcmtlckVuZE9mZnNldCB8fCAwO1xuICAgICAgICBvcmlnaW5hbEFuZ2xlID0gdGhpcy5tYXJrZXJFbmRBbmdsZTtcbiAgICAgIH1cbiAgICAgIHJhZCA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICAgIC8vIGFjY291bnQgZm9yIG1hcmtlck9mZnNldFxuICAgICAgbWFya2VyLnNldExvY2FsRXVsZXJBbmdsZXMocmFkICogMTgwIC8gTWF0aC5QSSArIG9yaWdpbmFsQW5nbGUpO1xuICAgICAgbWFya2VyLnNldExvY2FsUG9zaXRpb24ob3ggKyBNYXRoLmNvcyhyYWQpICogb2Zmc2V0LCBveSArIE1hdGguc2luKHJhZCkgKiBvZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGFjZU1hcmtlck1pZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGFjZU1hcmtlck1pZChtYXJrZXIpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMucGFyc2VkU3R5bGUuZC5zZWdtZW50cztcbiAgICAgIC8vIGNsZWFyIGFsbCBleGlzdGVkIG1hcmtlcnNcbiAgICAgIHRoaXMubWFya2VyTWlkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgbWFya2VyLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAobWFya2VyICYmIGlzRGlzcGxheU9iamVjdChtYXJrZXIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2VnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9zZWdtZW50cyRpJGN1cnJlbnRQbyA9IF9zbGljZWRUb0FycmF5KHNlZ21lbnRzW2ldLmN1cnJlbnRQb2ludCwgMiksXG4gICAgICAgICAgICBveCA9IF9zZWdtZW50cyRpJGN1cnJlbnRQb1swXSxcbiAgICAgICAgICAgIG95ID0gX3NlZ21lbnRzJGkkY3VycmVudFBvWzFdO1xuICAgICAgICAgIHZhciBjbG9uZWQgPSBpID09PSAxID8gbWFya2VyIDogbWFya2VyLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICB0aGlzLm1hcmtlck1pZExpc3QucHVzaChjbG9uZWQpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2xvbmVkKTtcbiAgICAgICAgICBjbG9uZWQuc2V0TG9jYWxQb3NpdGlvbihveCwgb3kpO1xuICAgICAgICAgIC8vIFRPRE86IG9yaWVudCBvZiBtYXJrZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgcGF0aC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdHZW9tZXRyeUVsZW1lbnQvZ2V0VG90YWxMZW5ndGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbExlbmd0aCgpIHtcbiAgICAgIHJldHVybiBnZXRPckNhbGN1bGF0ZVBhdGhUb3RhbExlbmd0aCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBhdCBhIGdpdmVuIGRpc3RhbmNlIGFsb25nIHRoZSBwYXRoLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dlb21ldHJ5RWxlbWVudC9nZXRQb2ludEF0TGVuZ3RoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRBdExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludEF0TGVuZ3RoJDEoZGlzdGFuY2UpIHtcbiAgICAgIHZhciBpbldvcmxkU3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGFic29sdXRlUGF0aCA9IHRoaXMucGFyc2VkU3R5bGUuZC5hYnNvbHV0ZVBhdGg7XG4gICAgICB2YXIgX2dldFBvaW50QXRMZW5ndGgyID0gZ2V0UG9pbnRBdExlbmd0aChhYnNvbHV0ZVBhdGgsIGRpc3RhbmNlKSxcbiAgICAgICAgeCA9IF9nZXRQb2ludEF0TGVuZ3RoMi54LFxuICAgICAgICB5ID0gX2dldFBvaW50QXRMZW5ndGgyLnk7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSB2ZWMzLnRyYW5zZm9ybU1hdDQodmVjMy5jcmVhdGUoKSwgdmVjMy5mcm9tVmFsdWVzKHgsIHksIDApLCBpbldvcmxkU3BhY2UgPyB0aGlzLmdldFdvcmxkVHJhbnNmb3JtKCkgOiB0aGlzLmdldExvY2FsVHJhbnNmb3JtKCkpO1xuXG4gICAgICAvLyBhcHBseSBsb2NhbCB0cmFuc2Zvcm1hdGlvblxuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0cmFuc2Zvcm1lZFswXSwgdHJhbnNmb3JtZWRbMV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGF0IGEgZ2l2ZW4gcmF0aW8gb2YgdGhlIHRvdGFsIGxlbmd0aCBpbiBwYXRoLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHJhdGlvKSB7XG4gICAgICB2YXIgaW5Xb3JsZFNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldFBvaW50QXRMZW5ndGgocmF0aW8gKiBnZXRPckNhbGN1bGF0ZVBhdGhUb3RhbExlbmd0aCh0aGlzKSwgaW5Xb3JsZFNwYWNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3RhcnQgdGFuZ2VudCB2ZWN0b3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGFydFRhbmdlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnRUYW5nZW50KCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5wYXJzZWRTdHlsZS5kLnNlZ21lbnRzO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzZWdtZW50c1swXS5jdXJyZW50UG9pbnQ7XG4gICAgICAgIHZhciBlbmRQb2ludCA9IHNlZ21lbnRzWzFdLmN1cnJlbnRQb2ludDtcbiAgICAgICAgdmFyIHRhbmdlbnQgPSBzZWdtZW50c1sxXS5zdGFydFRhbmdlbnQ7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGFuZ2VudCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtzdGFydFBvaW50WzBdIC0gdGFuZ2VudFswXSwgc3RhcnRQb2ludFsxXSAtIHRhbmdlbnRbMV1dKTtcbiAgICAgICAgICByZXN1bHQucHVzaChbc3RhcnRQb2ludFswXSwgc3RhcnRQb2ludFsxXV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtlbmRQb2ludFswXSwgZW5kUG9pbnRbMV1dKTtcbiAgICAgICAgICByZXN1bHQucHVzaChbc3RhcnRQb2ludFswXSwgc3RhcnRQb2ludFsxXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlbmQgdGFuZ2VudCB2ZWN0b3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbmRUYW5nZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVuZFRhbmdlbnQoKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnBhcnNlZFN0eWxlLmQuc2VnbWVudHM7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzZWdtZW50c1tsZW5ndGggLSAyXS5jdXJyZW50UG9pbnQ7XG4gICAgICAgIHZhciBlbmRQb2ludCA9IHNlZ21lbnRzW2xlbmd0aCAtIDFdLmN1cnJlbnRQb2ludDtcbiAgICAgICAgdmFyIHRhbmdlbnQgPSBzZWdtZW50c1tsZW5ndGggLSAxXS5lbmRUYW5nZW50O1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRhbmdlbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbZW5kUG9pbnRbMF0gLSB0YW5nZW50WzBdLCBlbmRQb2ludFsxXSAtIHRhbmdlbnRbMV1dKTtcbiAgICAgICAgICByZXN1bHQucHVzaChbZW5kUG9pbnRbMF0sIGVuZFBvaW50WzFdXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW3N0YXJ0UG9pbnRbMF0sIHN0YXJ0UG9pbnRbMV1dKTtcbiAgICAgICAgICByZXN1bHQucHVzaChbZW5kUG9pbnRbMF0sIGVuZFBvaW50WzFdXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG59KERpc3BsYXlPYmplY3QpO1xuUGF0aC5QQVJTRURfU1RZTEVfTElTVCA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShEaXNwbGF5T2JqZWN0LlBBUlNFRF9TVFlMRV9MSVNUKSwgWydkJywgJ21hcmtlclN0YXJ0JywgJ21hcmtlck1pZCcsICdtYXJrZXJFbmQnLCAnbWFya2VyU3RhcnRPZmZzZXQnLCAnbWFya2VyRW5kT2Zmc2V0JywgJ2lzQmlsbGJvYXJkJywgJ2lzU2l6ZUF0dGVudWF0aW9uJ10pKTtcblxudmFyIF9leGNsdWRlZCQyID0gW1wic3R5bGVcIl07XG52YXIgUG9seWdvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgZnVuY3Rpb24gUG9seWdvbigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkMik7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbHlnb24pO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBQb2x5Z29uLCBbX29iamVjdFNwcmVhZCh7XG4gICAgICB0eXBlOiBTaGFwZS5QT0xZR09OLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgaW5pdGlhbFBhcnNlZFN0eWxlOiB7XG4gICAgICAgIHBvaW50czoge1xuICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgdG90YWxMZW5ndGg6IDAsXG4gICAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIG1pdGVyTGltaXQ6IDQsXG4gICAgICAgIGlzQ2xvc2VkOiB0cnVlXG4gICAgICB9XG4gICAgfSwgcmVzdCldKTtcbiAgICBfdGhpcy5tYXJrZXJTdGFydEFuZ2xlID0gMDtcbiAgICBfdGhpcy5tYXJrZXJFbmRBbmdsZSA9IDA7XG4gICAgLyoqXG4gICAgICogbWFya2VycyBwbGFjZWQgYXQgdGhlIG1pZFxuICAgICAqL1xuICAgIF90aGlzLm1hcmtlck1pZExpc3QgPSBbXTtcbiAgICB2YXIgX3RoaXMkcGFyc2VkU3R5bGUgPSBfdGhpcy5wYXJzZWRTdHlsZSxcbiAgICAgIG1hcmtlclN0YXJ0ID0gX3RoaXMkcGFyc2VkU3R5bGUubWFya2VyU3RhcnQsXG4gICAgICBtYXJrZXJFbmQgPSBfdGhpcyRwYXJzZWRTdHlsZS5tYXJrZXJFbmQsXG4gICAgICBtYXJrZXJNaWQgPSBfdGhpcyRwYXJzZWRTdHlsZS5tYXJrZXJNaWQ7XG4gICAgaWYgKG1hcmtlclN0YXJ0ICYmIGlzRGlzcGxheU9iamVjdChtYXJrZXJTdGFydCkpIHtcbiAgICAgIF90aGlzLm1hcmtlclN0YXJ0QW5nbGUgPSBtYXJrZXJTdGFydC5nZXRMb2NhbEV1bGVyQW5nbGVzKCk7XG4gICAgICBfdGhpcy5hcHBlbmRDaGlsZChtYXJrZXJTdGFydCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJNaWQgJiYgaXNEaXNwbGF5T2JqZWN0KG1hcmtlck1pZCkpIHtcbiAgICAgIF90aGlzLnBsYWNlTWFya2VyTWlkKG1hcmtlck1pZCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJFbmQgJiYgaXNEaXNwbGF5T2JqZWN0KG1hcmtlckVuZCkpIHtcbiAgICAgIF90aGlzLm1hcmtlckVuZEFuZ2xlID0gbWFya2VyRW5kLmdldExvY2FsRXVsZXJBbmdsZXMoKTtcbiAgICAgIF90aGlzLmFwcGVuZENoaWxkKG1hcmtlckVuZCk7XG4gICAgfVxuICAgIF90aGlzLnRyYW5zZm9ybU1hcmtlcih0cnVlKTtcbiAgICBfdGhpcy50cmFuc2Zvcm1NYXJrZXIoZmFsc2UpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoUG9seWdvbiwgX0Rpc3BsYXlPYmplY3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBvbHlnb24sIFt7XG4gICAga2V5OiBcImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgcHJldlBhcnNlZFZhbHVlLCBuZXdQYXJzZWRWYWx1ZSkge1xuICAgICAgaWYgKGF0dHJOYW1lID09PSAncG9pbnRzJykge1xuICAgICAgICAvLyByZWNhbGMgbWFya2Vyc1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hcmtlcih0cnVlKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXJrZXIoZmFsc2UpO1xuICAgICAgICB0aGlzLnBsYWNlTWFya2VyTWlkKHRoaXMucGFyc2VkU3R5bGUubWFya2VyTWlkKTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09ICdtYXJrZXJTdGFydE9mZnNldCcgfHwgYXR0ck5hbWUgPT09ICdtYXJrZXJFbmRPZmZzZXQnKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWFya2VyKHRydWUpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hcmtlcihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSAnbWFya2VyU3RhcnQnKSB7XG4gICAgICAgIGlmIChwcmV2UGFyc2VkVmFsdWUgJiYgaXNEaXNwbGF5T2JqZWN0KHByZXZQYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlclN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgIHByZXZQYXJzZWRWYWx1ZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENTU0tleXdvcmQgJ3Vuc2V0J1xuICAgICAgICBpZiAobmV3UGFyc2VkVmFsdWUgJiYgaXNEaXNwbGF5T2JqZWN0KG5ld1BhcnNlZFZhbHVlKSkge1xuICAgICAgICAgIHRoaXMubWFya2VyU3RhcnRBbmdsZSA9IG5ld1BhcnNlZFZhbHVlLmdldExvY2FsRXVsZXJBbmdsZXMoKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld1BhcnNlZFZhbHVlKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybU1hcmtlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gJ21hcmtlckVuZCcpIHtcbiAgICAgICAgaWYgKHByZXZQYXJzZWRWYWx1ZSAmJiBpc0Rpc3BsYXlPYmplY3QocHJldlBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgIHRoaXMubWFya2VyRW5kQW5nbGUgPSAwO1xuICAgICAgICAgIHByZXZQYXJzZWRWYWx1ZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3UGFyc2VkVmFsdWUgJiYgaXNEaXNwbGF5T2JqZWN0KG5ld1BhcnNlZFZhbHVlKSkge1xuICAgICAgICAgIHRoaXMubWFya2VyRW5kQW5nbGUgPSBuZXdQYXJzZWRWYWx1ZS5nZXRMb2NhbEV1bGVyQW5nbGVzKCk7XG4gICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXdQYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXJrZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSAnbWFya2VyTWlkJykge1xuICAgICAgICB0aGlzLnBsYWNlTWFya2VyTWlkKG5ld1BhcnNlZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtTWFya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybU1hcmtlcihpc1N0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMkcGFyc2VkU3R5bGUyID0gdGhpcy5wYXJzZWRTdHlsZSxcbiAgICAgICAgbWFya2VyU3RhcnQgPSBfdGhpcyRwYXJzZWRTdHlsZTIubWFya2VyU3RhcnQsXG4gICAgICAgIG1hcmtlckVuZCA9IF90aGlzJHBhcnNlZFN0eWxlMi5tYXJrZXJFbmQsXG4gICAgICAgIG1hcmtlclN0YXJ0T2Zmc2V0ID0gX3RoaXMkcGFyc2VkU3R5bGUyLm1hcmtlclN0YXJ0T2Zmc2V0LFxuICAgICAgICBtYXJrZXJFbmRPZmZzZXQgPSBfdGhpcyRwYXJzZWRTdHlsZTIubWFya2VyRW5kT2Zmc2V0LFxuICAgICAgICBQID0gX3RoaXMkcGFyc2VkU3R5bGUyLnBvaW50cztcbiAgICAgIHZhciBfcmVmMiA9IFAgfHwge30sXG4gICAgICAgIHBvaW50cyA9IF9yZWYyLnBvaW50cztcbiAgICAgIHZhciBtYXJrZXIgPSBpc1N0YXJ0ID8gbWFya2VyU3RhcnQgOiBtYXJrZXJFbmQ7XG4gICAgICBpZiAoIW1hcmtlciB8fCAhaXNEaXNwbGF5T2JqZWN0KG1hcmtlcikgfHwgIXBvaW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmFkID0gMDtcbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgb3g7XG4gICAgICB2YXIgb3k7XG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgdmFyIG9yaWdpbmFsQW5nbGU7XG4gICAgICBveCA9IHBvaW50c1swXVswXTtcbiAgICAgIG95ID0gcG9pbnRzWzBdWzFdO1xuICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgeCA9IHBvaW50c1sxXVswXSAtIHBvaW50c1swXVswXTtcbiAgICAgICAgeSA9IHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXTtcbiAgICAgICAgb2Zmc2V0ID0gbWFya2VyU3RhcnRPZmZzZXQgfHwgMDtcbiAgICAgICAgb3JpZ2luYWxBbmdsZSA9IHRoaXMubWFya2VyU3RhcnRBbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkU3R5bGUuaXNDbG9zZWQpIHtcbiAgICAgICAgICBveCA9IHBvaW50c1tsZW5ndGggLSAxXVswXTtcbiAgICAgICAgICBveSA9IHBvaW50c1tsZW5ndGggLSAxXVsxXTtcbiAgICAgICAgICB4ID0gcG9pbnRzW2xlbmd0aCAtIDJdWzBdIC0gcG9pbnRzW2xlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgIHkgPSBwb2ludHNbbGVuZ3RoIC0gMl1bMV0gLSBwb2ludHNbbGVuZ3RoIC0gMV1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHBvaW50c1tsZW5ndGggLSAxXVswXSAtIHBvaW50c1swXVswXTtcbiAgICAgICAgICB5ID0gcG9pbnRzW2xlbmd0aCAtIDFdWzFdIC0gcG9pbnRzWzBdWzFdO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IG1hcmtlckVuZE9mZnNldCB8fCAwO1xuICAgICAgICBvcmlnaW5hbEFuZ2xlID0gdGhpcy5tYXJrZXJFbmRBbmdsZTtcbiAgICAgIH1cbiAgICAgIHJhZCA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICAgIC8vIGFjY291bnQgZm9yIG1hcmtlck9mZnNldFxuICAgICAgbWFya2VyLnNldExvY2FsRXVsZXJBbmdsZXMocmFkICogMTgwIC8gTWF0aC5QSSArIG9yaWdpbmFsQW5nbGUpO1xuICAgICAgbWFya2VyLnNldExvY2FsUG9zaXRpb24ob3ggKyBNYXRoLmNvcyhyYWQpICogb2Zmc2V0LCBveSArIE1hdGguc2luKHJhZCkgKiBvZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGFjZU1hcmtlck1pZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGFjZU1hcmtlck1pZChtYXJrZXIpIHtcbiAgICAgIHZhciBQID0gdGhpcy5wYXJzZWRTdHlsZS5wb2ludHM7XG4gICAgICB2YXIgX3JlZjMgPSBQIHx8IHt9LFxuICAgICAgICBwb2ludHMgPSBfcmVmMy5wb2ludHM7XG5cbiAgICAgIC8vIGNsZWFyIGFsbCBleGlzdGVkIG1hcmtlcnNcbiAgICAgIHRoaXMubWFya2VyTWlkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgbWFya2VyLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcmtlck1pZExpc3QgPSBbXTtcbiAgICAgIGlmIChtYXJrZXIgJiYgaXNEaXNwbGF5T2JqZWN0KG1hcmtlcikgJiYgcG9pbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgKHRoaXMucGFyc2VkU3R5bGUuaXNDbG9zZWQgPyBwb2ludHMubGVuZ3RoIDogcG9pbnRzLmxlbmd0aCAtIDEpOyBpKyspIHtcbiAgICAgICAgICB2YXIgb3ggPSBwb2ludHNbaV1bMF07XG4gICAgICAgICAgdmFyIG95ID0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgIHZhciBjbG9uZWQgPSBpID09PSAxID8gbWFya2VyIDogbWFya2VyLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICB0aGlzLm1hcmtlck1pZExpc3QucHVzaChjbG9uZWQpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2xvbmVkKTtcbiAgICAgICAgICBjbG9uZWQuc2V0TG9jYWxQb3NpdGlvbihveCwgb3kpO1xuXG4gICAgICAgICAgLy8gVE9ETzogb3JpZW50IG9mIG1hcmtlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KERpc3BsYXlPYmplY3QpO1xuUG9seWdvbi5QQVJTRURfU1RZTEVfTElTVCA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShEaXNwbGF5T2JqZWN0LlBBUlNFRF9TVFlMRV9MSVNUKSwgWydwb2ludHMnLCAnbWFya2VyU3RhcnQnLCAnbWFya2VyTWlkJywgJ21hcmtlckVuZCcsICdtYXJrZXJTdGFydE9mZnNldCcsICdtYXJrZXJFbmRPZmZzZXQnLCAnaXNDbG9zZWQnLCAnaXNCaWxsYm9hcmQnLCAnaXNTaXplQXR0ZW51YXRpb24nXSkpO1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJzdHlsZVwiXTtcbi8qKlxuICogUG9seWxpbmUgaW5oZXJpdHMgdGhlIG1hcmtlci1yZWxhdGVkIGNhcGFiaWxpdGllcyBvZiBQb2x5Z29uLlxuICovXG52YXIgUG9seWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb2x5Z29uKSB7XG4gIGZ1bmN0aW9uIFBvbHlsaW5lKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDEpO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5bGluZSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUG9seWxpbmUsIFtfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHR5cGU6IFNoYXBlLlBPTFlMSU5FLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgaW5pdGlhbFBhcnNlZFN0eWxlOiB7XG4gICAgICAgIHBvaW50czoge1xuICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgdG90YWxMZW5ndGg6IDAsXG4gICAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIG1pdGVyTGltaXQ6IDQsXG4gICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgfVxuICAgIH0sIHJlc3QpXSk7XG4gIH1cbiAgX2luaGVyaXRzKFBvbHlsaW5lLCBfUG9seWdvbik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUG9seWxpbmUsIFt7XG4gICAga2V5OiBcImdldFRvdGFsTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdGFsTGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIGdldE9yQ2FsY3VsYXRlUG9seWxpbmVUb3RhbExlbmd0aCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRBdExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludEF0TGVuZ3RoKGRpc3RhbmNlKSB7XG4gICAgICB2YXIgaW5Xb3JsZFNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldFBvaW50KGRpc3RhbmNlIC8gdGhpcy5nZXRUb3RhbExlbmd0aCgpLCBpbldvcmxkU3BhY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChyYXRpbykge1xuICAgICAgdmFyIGluV29ybGRTcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wYXJzZWRTdHlsZS5wb2ludHMucG9pbnRzO1xuICAgICAgaWYgKHRoaXMucGFyc2VkU3R5bGUucG9pbnRzLnNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIHRlbXBMZW5ndGggPSAwO1xuICAgICAgICB2YXIgc2VnbWVudFQ7XG4gICAgICAgIHZhciBzZWdtZW50TDtcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIGlmIChwb2ludHNbaSArIDFdKSB7XG4gICAgICAgICAgICBzZWdtZW50VCA9IFswLCAwXTtcbiAgICAgICAgICAgIHNlZ21lbnRUWzBdID0gdGVtcExlbmd0aCAvIHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgc2VnbWVudEwgPSBsaW5lTGVuZ3RoKHBbMF0sIHBbMV0sIHBvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV0pO1xuICAgICAgICAgICAgdGVtcExlbmd0aCArPSBzZWdtZW50TDtcbiAgICAgICAgICAgIHNlZ21lbnRUWzFdID0gdGVtcExlbmd0aCAvIHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50VCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJzZWRTdHlsZS5wb2ludHMuc2VnbWVudHMgPSBzZWdtZW50cztcbiAgICAgIH1cbiAgICAgIHZhciBzdWJ0ID0gMDtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB0aGlzLnBhcnNlZFN0eWxlLnBvaW50cy5zZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIGlmIChyYXRpbyA+PSB2WzBdICYmIHJhdGlvIDw9IHZbMV0pIHtcbiAgICAgICAgICBzdWJ0ID0gKHJhdGlvIC0gdlswXSkgLyAodlsxXSAtIHZbMF0pO1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgX2xpbmVQb2ludEF0ID0gbGluZVBvaW50QXQocG9pbnRzW2luZGV4XVswXSwgcG9pbnRzW2luZGV4XVsxXSwgcG9pbnRzW2luZGV4ICsgMV1bMF0sIHBvaW50c1tpbmRleCArIDFdWzFdLCBzdWJ0KSxcbiAgICAgICAgeCA9IF9saW5lUG9pbnRBdC54LFxuICAgICAgICB5ID0gX2xpbmVQb2ludEF0Lnk7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSB2ZWMzLnRyYW5zZm9ybU1hdDQodmVjMy5jcmVhdGUoKSwgdmVjMy5mcm9tVmFsdWVzKHgsIHksIDApLCBpbldvcmxkU3BhY2UgPyB0aGlzLmdldFdvcmxkVHJhbnNmb3JtKCkgOiB0aGlzLmdldExvY2FsVHJhbnNmb3JtKCkpO1xuXG4gICAgICAvLyBhcHBseSBsb2NhbCB0cmFuc2Zvcm1hdGlvblxuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0cmFuc2Zvcm1lZFswXSwgdHJhbnNmb3JtZWRbMV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGFydFRhbmdlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnRUYW5nZW50KCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucGFyc2VkU3R5bGUucG9pbnRzLnBvaW50cztcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHJlc3VsdC5wdXNoKFtwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXV0pO1xuICAgICAgcmVzdWx0LnB1c2goW3BvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdXSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbmRUYW5nZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVuZFRhbmdlbnQoKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wYXJzZWRTdHlsZS5wb2ludHMucG9pbnRzO1xuICAgICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHJlc3VsdC5wdXNoKFtwb2ludHNbbCAtIDFdWzBdLCBwb2ludHNbbCAtIDFdWzFdXSk7XG4gICAgICByZXN1bHQucHVzaChbcG9pbnRzW2xdWzBdLCBwb2ludHNbbF1bMV1dKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG59KFBvbHlnb24pO1xuUG9seWxpbmUuUEFSU0VEX1NUWUxFX0xJU1QgPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoUG9seWdvbi5QQVJTRURfU1RZTEVfTElTVCksIFsncG9pbnRzJywgJ21hcmtlclN0YXJ0JywgJ21hcmtlck1pZCcsICdtYXJrZXJFbmQnLCAnbWFya2VyU3RhcnRPZmZzZXQnLCAnbWFya2VyRW5kT2Zmc2V0JywgJ2lzQmlsbGJvYXJkJ10pKTtcblxudmFyIFJlY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIGZ1bmN0aW9uIFJlY3QoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWN0KTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBSZWN0LCBbX29iamVjdFNwcmVhZCh7XG4gICAgICB0eXBlOiBTaGFwZS5SRUNUXG4gICAgfSwgb3B0aW9ucyldKTtcbiAgfVxuICBfaW5oZXJpdHMoUmVjdCwgX0Rpc3BsYXlPYmplY3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlY3QpO1xufShEaXNwbGF5T2JqZWN0KTtcblJlY3QuUEFSU0VEX1NUWUxFX0xJU1QgPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoRGlzcGxheU9iamVjdC5QQVJTRURfU1RZTEVfTElTVCksIFsneCcsICd5JywgJ3onLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2lzQmlsbGJvYXJkJywgJ2lzU2l6ZUF0dGVudWF0aW9uJywgJ3JhZGl1cyddKSk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJzdHlsZVwiXTtcbi8qKlxuICogPHRleHQ+IEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR1RleHRFbGVtZW50XG4gKi9cbnZhciBUZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlzcGxheU9iamVjdCkge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHVGV4dENvbnRlbnRFbGVtZW50I2NvbnN0YW50c1xuICAgKi9cbiAgLy8gTEVOR1RIQURKVVNUX1NQQUNJTkc6IG51bWJlciA9IDE7XG4gIC8vIExFTkdUSEFESlVTVF9TUEFDSU5HQU5ER0xZUEhTOiBudW1iZXIgPSAyO1xuICAvLyBMRU5HVEhBREpVU1RfVU5LTk9XTjogbnVtYmVyID0gMDtcblxuICBmdW5jdGlvbiBUZXh0KCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgVGV4dCwgW19vYmplY3RTcHJlYWQoe1xuICAgICAgdHlwZTogU2hhcGUuVEVYVCxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZmlsbDogJ2JsYWNrJ1xuICAgICAgfSwgc3R5bGUpXG4gICAgfSwgcmVzdCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdUZXh0Q29udGVudEVsZW1lbnRcbiAgICovXG4gIF9pbmhlcml0cyhUZXh0LCBfRGlzcGxheU9iamVjdCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6IFwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbXB1dGVkVGV4dExlbmd0aCgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJzZWRTdHlsZSRtZXQ7XG4gICAgICB0aGlzLmdldEdlb21ldHJ5Qm91bmRzKCk7XG4gICAgICByZXR1cm4gKChfdGhpcyRwYXJzZWRTdHlsZSRtZXQgPSB0aGlzLnBhcnNlZFN0eWxlLm1ldHJpY3MpID09PSBudWxsIHx8IF90aGlzJHBhcnNlZFN0eWxlJG1ldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyc2VkU3R5bGUkbWV0Lm1heExpbmVXaWR0aCkgfHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGluZUJvdW5kaW5nUmVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZUJvdW5kaW5nUmVjdHMoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFyc2VkU3R5bGUkbWV0MjtcbiAgICAgIHRoaXMuZ2V0R2VvbWV0cnlCb3VuZHMoKTtcbiAgICAgIHJldHVybiAoKF90aGlzJHBhcnNlZFN0eWxlJG1ldDIgPSB0aGlzLnBhcnNlZFN0eWxlLm1ldHJpY3MpID09PSBudWxsIHx8IF90aGlzJHBhcnNlZFN0eWxlJG1ldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBhcnNlZFN0eWxlJG1ldDIubGluZU1ldHJpY3MpIHx8IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc092ZXJmbG93aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmZsb3dpbmcoKSB7XG4gICAgICB0aGlzLmdldEdlb21ldHJ5Qm91bmRzKCk7XG4gICAgICByZXR1cm4gISF0aGlzLnBhcnNlZFN0eWxlLmlzT3ZlcmZsb3dpbmc7XG4gICAgfVxuICB9XSk7XG59KERpc3BsYXlPYmplY3QpO1xuVGV4dC5QQVJTRURfU1RZTEVfTElTVCA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShEaXNwbGF5T2JqZWN0LlBBUlNFRF9TVFlMRV9MSVNUKSwgWyd4JywgJ3knLCAneicsICdpc0JpbGxib2FyZCcsICdiaWxsYm9hcmRSb3RhdGlvbicsICdpc1NpemVBdHRlbnVhdGlvbicsICd0ZXh0JywgJ3RleHRBbGlnbicsICd0ZXh0QmFzZWxpbmUnLCAnZm9udFN0eWxlJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLCAnZm9udFdlaWdodCcsICdmb250VmFyaWFudCcsICdsaW5lSGVpZ2h0JywgJ2xldHRlclNwYWNpbmcnLCAnbGVhZGluZycsICd3b3JkV3JhcCcsICd3b3JkV3JhcFdpZHRoJywgJ21heExpbmVzJywgJ3RleHRPdmVyZmxvdycsICdpc092ZXJmbG93aW5nJywgJ3RleHRQYXRoJywgJ3RleHREZWNvcmF0aW9uTGluZScsICd0ZXh0RGVjb3JhdGlvbkNvbG9yJywgJ3RleHREZWNvcmF0aW9uU3R5bGUnLCAndGV4dFBhdGhTaWRlJywgJ3RleHRQYXRoU3RhcnRPZmZzZXQnLCAnbWV0cmljcycsICdkeCcsICdkeSddKSk7XG5cbi8qKlxuICogY2FudmFzLmN1c3RvbUVsZW1lbnRzXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5XG4gKi9cbnZhciBDdXN0b21FbGVtZW50UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXN0b21FbGVtZW50UmVnaXN0cnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSk7XG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuZGVmaW5lKFNoYXBlLkNJUkNMRSwgQ2lyY2xlKTtcbiAgICB0aGlzLmRlZmluZShTaGFwZS5FTExJUFNFLCBFbGxpcHNlKTtcbiAgICB0aGlzLmRlZmluZShTaGFwZS5SRUNULCBSZWN0KTtcbiAgICB0aGlzLmRlZmluZShTaGFwZS5JTUFHRSwgSW1hZ2UpO1xuICAgIHRoaXMuZGVmaW5lKFNoYXBlLkxJTkUsIExpbmUpO1xuICAgIHRoaXMuZGVmaW5lKFNoYXBlLkdST1VQLCBHcm91cCk7XG4gICAgdGhpcy5kZWZpbmUoU2hhcGUuUEFUSCwgUGF0aCk7XG4gICAgdGhpcy5kZWZpbmUoU2hhcGUuUE9MWUdPTiwgUG9seWdvbik7XG4gICAgdGhpcy5kZWZpbmUoU2hhcGUuUE9MWUxJTkUsIFBvbHlsaW5lKTtcbiAgICB0aGlzLmRlZmluZShTaGFwZS5URVhULCBUZXh0KTtcbiAgICB0aGlzLmRlZmluZShTaGFwZS5IVE1MLCBIVE1MKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEN1c3RvbUVsZW1lbnRSZWdpc3RyeSwgW3tcbiAgICBrZXk6IFwiZGVmaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmluZShuYW1lLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5yZWdpc3RyeVtuYW1lXSA9IGNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS9nZXRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W25hbWVdO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTUy9SZWdpc3RlclByb3BlcnR5I3BhcmFtZXRlcnNcbiAqL1xuXG4vKipcbiAqIGhvbGRzIHVzZWZ1bCBDU1MtcmVsYXRlZCBtZXRob2RzLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ1NTXG4gKlxuICogKiBDU1MgVHlwZWQgT00gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ1NTL2ZhY3RvcnlfZnVuY3Rpb25zXG4gKiAqIHJlZ2lzdGVyIHByb3BlcnR5IEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTUy9SZWdpc3RlclByb3BlcnR5XG4gKiAqIENTUyBMYXlvdXQgQVBJXG4gKi9cbnZhciBDU1MgPSB7XG4gIC8qKlxuICAgKiA8bnVtYmVyPlxuICAgKiBAc2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTQvI251bWJlci12YWx1ZVxuICAgKi9cbiAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIobikge1xuICAgIHJldHVybiBuZXcgQ1NTVW5pdFZhbHVlKG4pO1xuICB9LFxuICAvKipcbiAgICogPHBlcmNlbnRhZ2U+XG4gICAqIEBzZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtNC8jcGVyY2VudGFnZS12YWx1ZVxuICAgKi9cbiAgcGVyY2VudDogZnVuY3Rpb24gcGVyY2VudChuKSB7XG4gICAgcmV0dXJuIG5ldyBDU1NVbml0VmFsdWUobiwgJyUnKTtcbiAgfSxcbiAgLyoqXG4gICAqIDxsZW5ndGg+XG4gICAqL1xuICBweDogZnVuY3Rpb24gcHgobikge1xuICAgIHJldHVybiBuZXcgQ1NTVW5pdFZhbHVlKG4sICdweCcpO1xuICB9LFxuICAvKipcbiAgICogPGxlbmd0aD5cbiAgICovXG4gIGVtOiBmdW5jdGlvbiBlbShuKSB7XG4gICAgcmV0dXJuIG5ldyBDU1NVbml0VmFsdWUobiwgJ2VtJyk7XG4gIH0sXG4gIHJlbTogZnVuY3Rpb24gcmVtKG4pIHtcbiAgICByZXR1cm4gbmV3IENTU1VuaXRWYWx1ZShuLCAncmVtJyk7XG4gIH0sXG4gIC8qKlxuICAgKiA8YW5nbGU+XG4gICAqL1xuICBkZWc6IGZ1bmN0aW9uIGRlZyhuKSB7XG4gICAgcmV0dXJuIG5ldyBDU1NVbml0VmFsdWUobiwgJ2RlZycpO1xuICB9LFxuICAvKipcbiAgICogPGFuZ2xlPlxuICAgKi9cbiAgZ3JhZDogZnVuY3Rpb24gZ3JhZChuKSB7XG4gICAgcmV0dXJuIG5ldyBDU1NVbml0VmFsdWUobiwgJ2dyYWQnKTtcbiAgfSxcbiAgLyoqXG4gICAqIDxhbmdsZT5cbiAgICovXG4gIHJhZDogZnVuY3Rpb24gcmFkKG4pIHtcbiAgICByZXR1cm4gbmV3IENTU1VuaXRWYWx1ZShuLCAncmFkJyk7XG4gIH0sXG4gIC8qKlxuICAgKiA8YW5nbGU+XG4gICAqL1xuICB0dXJuOiBmdW5jdGlvbiB0dXJuKG4pIHtcbiAgICByZXR1cm4gbmV3IENTU1VuaXRWYWx1ZShuLCAndHVybicpO1xuICB9LFxuICAvKipcbiAgICogPHRpbWU+XG4gICAqL1xuICBzOiBmdW5jdGlvbiBzKG4pIHtcbiAgICByZXR1cm4gbmV3IENTU1VuaXRWYWx1ZShuLCAncycpO1xuICB9LFxuICAvKipcbiAgICogPHRpbWU+XG4gICAqL1xuICBtczogZnVuY3Rpb24gbXMobikge1xuICAgIHJldHVybiBuZXcgQ1NTVW5pdFZhbHVlKG4sICdtcycpO1xuICB9LFxuICAvKipcbiAgICogQ1NTIFByb3BlcnRpZXMgJiBWYWx1ZXMgQVBJXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTU19Qcm9wZXJ0aWVzX2FuZF9WYWx1ZXNfQVBJXG4gICAqIEBzZWUgaHR0cHM6Ly9kcmFmdHMuY3NzLWhvdWRpbmkub3JnL2Nzcy1wcm9wZXJ0aWVzLXZhbHVlcy1hcGkvI3JlZ2lzdGVyaW5nLWN1c3RvbS1wcm9wZXJ0aWVzXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTUy9SZWdpc3RlclByb3BlcnR5XG4gICAqL1xuICByZWdpc3RlclByb3BlcnR5OiBmdW5jdGlvbiByZWdpc3RlclByb3BlcnR5KGRlZmluaXRpb24pIHtcbiAgICB2YXIgbmFtZSA9IGRlZmluaXRpb24ubmFtZSxcbiAgICAgIGluaGVyaXRzID0gZGVmaW5pdGlvbi5pbmhlcml0cyxcbiAgICAgIGludGVycG9sYWJsZSA9IGRlZmluaXRpb24uaW50ZXJwb2xhYmxlLFxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmaW5pdGlvbi5pbml0aWFsVmFsdWUsXG4gICAgICBzeW50YXggPSBkZWZpbml0aW9uLnN5bnRheDtcbiAgICBydW50aW1lLnN0eWxlVmFsdWVSZWdpc3RyeS5yZWdpc3Rlck1ldGFkYXRhKHtcbiAgICAgIG46IG5hbWUsXG4gICAgICBpbmg6IGluaGVyaXRzLFxuICAgICAgXCJpbnRcIjogaW50ZXJwb2xhYmxlLFxuICAgICAgZDogaW5pdGlhbFZhbHVlLFxuICAgICAgc3ludGF4OiBzeW50YXhcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENTUyBMYXlvdXQgQVBJXG4gICAqIHJlZ2lzdGVyIGxheW91dFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvY3NzLWhvdWRpbmktZHJhZnRzL2Jsb2IvbWFpbi9jc3MtbGF5b3V0LWFwaS9FWFBMQUlORVIubWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9Ib3VkaW5pI2Nzc19sYXlvdXRfYXBpXG4gICAqL1xuICByZWdpc3RlckxheW91dDogZnVuY3Rpb24gcmVnaXN0ZXJMYXlvdXQobmFtZSwgY2xhenopIHtcbiAgICBydW50aW1lLmxheW91dFJlZ2lzdHJ5LnJlZ2lzdGVyTGF5b3V0KG5hbWUsIGNsYXp6KTtcbiAgfVxufTtcblxuLyoqXG4gKiB0aGUgZW50cnkgb2YgRE9NIHRyZWVcbiAqIERvY3VtZW50IC0+IE5vZGUgLT4gRXZlbnRUYXJnZXRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50XG4gKi9cbnZhciBEb2N1bWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgZnVuY3Rpb24gRG9jdW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIERvY3VtZW50KTtcbiAgICAvKipcbiAgICAgKiBvbmx5IGRvY3VtZW50IGhhcyBkZWZhdWx0VmlldywgcG9pbnRzIHRvIGNhbnZhcyxcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9kZWZhdWx0Vmlld1xuICAgICAqL1xuICAgIF90aGlzLmRlZmF1bHRWaWV3ID0gbnVsbDtcbiAgICBfdGhpcy5vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgICBfdGhpcy5ub2RlTmFtZSA9ICdkb2N1bWVudCc7XG5cbiAgICAvLyBjcmVhdGUgdGltZWxpbmVcbiAgICB0cnkge1xuICAgICAgX3RoaXMudGltZWxpbmUgPSBuZXcgcnVudGltZS5BbmltYXRpb25UaW1lbGluZShfdGhpcyk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge31cblxuICAgIC8qKlxuICAgICAqIGZvciBpbmhlcml0ZWQgcHJvcGVydGllcywgdGhlIGluaXRpYWwgdmFsdWUgaXMgdXNlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9ubHksXG4gICAgICogYXMgbG9uZyBhcyBubyBzcGVjaWZpZWQgdmFsdWUgaXMgc3VwcGxpZWQuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvaW5pdGlhbF92YWx1ZVxuICAgICAqL1xuICAgIHZhciBpbml0aWFsU3R5bGUgPSB7fTtcbiAgICBCVUlMVF9JTl9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuID0gX3JlZi5uLFxuICAgICAgICBpbmggPSBfcmVmLmluaCxcbiAgICAgICAgZCA9IF9yZWYuZDtcbiAgICAgIGlmIChpbmggJiYgZCkge1xuICAgICAgICBpbml0aWFsU3R5bGVbbl0gPSBpc0Z1bmN0aW9uKGQpID8gZChTaGFwZS5HUk9VUCkgOiBkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbGlrZSA8aHRtbD4gaW4gRE9NIHRyZWVcbiAgICBfdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBuZXcgR3JvdXAoe1xuICAgICAgaWQ6ICdnLXJvb3QnLFxuICAgICAgc3R5bGU6IGluaXRpYWxTdHlsZVxuICAgIH0pO1xuICAgIF90aGlzLmRvY3VtZW50RWxlbWVudC5vd25lckRvY3VtZW50ID0gX3RoaXM7XG4gICAgX3RoaXMuZG9jdW1lbnRFbGVtZW50LnBhcmVudE5vZGUgPSBfdGhpcztcbiAgICBfdGhpcy5jaGlsZE5vZGVzID0gW190aGlzLmRvY3VtZW50RWxlbWVudF07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhEb2N1bWVudCwgX05vZGUpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERvY3VtZW50LCBbe1xuICAgIGtleTogXCJjaGlsZHJlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRFbGVtZW50Q291bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdEVsZW1lbnRDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlyc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdEVsZW1lbnRDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdENoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVFbGVtZW50XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQGV4YW1wbGUgY29uc3QgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2lyY2xlJywgeyBzdHlsZTogeyByOiAxMCB9IH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgb3B0aW9ucykge1xuICAgICAgLy8gQG9ic2VydmFibGVocS9wbG90IHdpbGwgY3JlYXRlIDxzdmc+XG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBkMyB3aWxsIHVzZSA8dHNwYW4+XG4gICAgICB2YXIgY2xhenogPSB0aGlzLmRlZmF1bHRWaWV3LmN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKTtcbiAgICAgIGlmICghY2xhenopIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCB0YWdOYW1lOiAnLCB0YWdOYW1lKTtcbiAgICAgICAgY2xhenogPSB0YWdOYW1lID09PSAndHNwYW4nID8gVGV4dCA6IEdyb3VwO1xuICAgICAgfVxuICAgICAgdmFyIHNoYXBlID0gbmV3IGNsYXp6KG9wdGlvbnMpO1xuICAgICAgc2hhcGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUVsZW1lbnROU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0YWdOYW1lLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVOb2RlKGRlZXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50LmRlc3Ryb3lDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmRlc3Ryb3koKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2tpbmcgMkQgZ3JhcGhpY3Mgd2l0aCBSQnVzaCBiYXNlZCBvbiBCQm94LCBmYXN0IGJ1dCBpbmFjY3VyYXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVsZW1lbnRzRnJvbUJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudHNGcm9tQkJveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKSB7XG4gICAgICB2YXIgckJ1c2ggPSB0aGlzLmRlZmF1bHRWaWV3LmNvbnRleHQuckJ1c2hSb290O1xuICAgICAgdmFyIHJCdXNoTm9kZXMgPSByQnVzaC5zZWFyY2goe1xuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICBtYXhZOiBtYXhZXG4gICAgICB9KTtcbiAgICAgIHZhciBoaXRUZXN0TGlzdCA9IFtdO1xuICAgICAgckJ1c2hOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgZGlzcGxheU9iamVjdCA9IF9yZWYyLmRpc3BsYXlPYmplY3Q7XG4gICAgICAgIHZhciBfZGlzcGxheU9iamVjdCRwYXJzZWQgPSBkaXNwbGF5T2JqZWN0LnBhcnNlZFN0eWxlLnBvaW50ZXJFdmVudHMsXG4gICAgICAgICAgcG9pbnRlckV2ZW50cyA9IF9kaXNwbGF5T2JqZWN0JHBhcnNlZCA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX2Rpc3BsYXlPYmplY3QkcGFyc2VkO1xuXG4gICAgICAgIC8vIGFjY291bnQgZm9yIGB2aXNpYmlsaXR5YFxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb2ludGVyLWV2ZW50c1xuICAgICAgICB2YXIgaXNWaXNpYmlsaXR5QWZmZWN0ZWQgPSBbJ2F1dG8nLCAndmlzaWJsZXBhaW50ZWQnLCAndmlzaWJsZWZpbGwnLCAndmlzaWJsZXN0cm9rZScsICd2aXNpYmxlJ10uaW5jbHVkZXMocG9pbnRlckV2ZW50cyk7XG4gICAgICAgIGlmICgoIWlzVmlzaWJpbGl0eUFmZmVjdGVkIHx8IGlzVmlzaWJpbGl0eUFmZmVjdGVkICYmIGRpc3BsYXlPYmplY3QuaXNWaXNpYmxlKCkpICYmICFkaXNwbGF5T2JqZWN0LmlzQ3VsbGVkKCkgJiYgZGlzcGxheU9iamVjdC5pc0ludGVyYWN0aXZlKCkpIHtcbiAgICAgICAgICBoaXRUZXN0TGlzdC5wdXNoKGRpc3BsYXlPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIGZpbmQgZ3JvdXAgd2l0aCBtYXggei1pbmRleFxuICAgICAgaGl0VGVzdExpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5zb3J0YWJsZS5yZW5kZXJPcmRlciAtIGEuc29ydGFibGUucmVuZGVyT3JkZXI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoaXRUZXN0TGlzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWxlbWVudEZyb21Qb2ludFN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludFN5bmMoeCwgeSkge1xuICAgICAgdmFyIF90aGlzJGRlZmF1bHRWaWV3JGNhbiA9IHRoaXMuZGVmYXVsdFZpZXcuY2FudmFzMlZpZXdwb3J0KHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSksXG4gICAgICAgIHZpZXdwb3J0WCA9IF90aGlzJGRlZmF1bHRWaWV3JGNhbi54LFxuICAgICAgICB2aWV3cG9ydFkgPSBfdGhpcyRkZWZhdWx0VmlldyRjYW4ueTtcbiAgICAgIHZhciBfdGhpcyRkZWZhdWx0VmlldyRnZXQgPSB0aGlzLmRlZmF1bHRWaWV3LmdldENvbmZpZygpLFxuICAgICAgICB3aWR0aCA9IF90aGlzJGRlZmF1bHRWaWV3JGdldC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkZGVmYXVsdFZpZXckZ2V0LmhlaWdodDtcbiAgICAgIC8vIG91dHNpZGUgY2FudmFzJyB2aWV3cG9ydFxuICAgICAgaWYgKHZpZXdwb3J0WCA8IDAgfHwgdmlld3BvcnRZIDwgMCB8fCB2aWV3cG9ydFggPiB3aWR0aCB8fCB2aWV3cG9ydFkgPiBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkZGVmYXVsdFZpZXckdmllID0gdGhpcy5kZWZhdWx0Vmlldy52aWV3cG9ydDJDbGllbnQoe1xuICAgICAgICAgIHg6IHZpZXdwb3J0WCxcbiAgICAgICAgICB5OiB2aWV3cG9ydFlcbiAgICAgICAgfSksXG4gICAgICAgIGNsaWVudFggPSBfdGhpcyRkZWZhdWx0VmlldyR2aWUueCxcbiAgICAgICAgY2xpZW50WSA9IF90aGlzJGRlZmF1bHRWaWV3JHZpZS55O1xuICAgICAgdmFyIF90aGlzJGRlZmF1bHRWaWV3JGdldDIgPSB0aGlzLmRlZmF1bHRWaWV3LmdldFJlbmRlcmluZ1NlcnZpY2UoKS5ob29rcy5waWNrU3luYy5jYWxsKHtcbiAgICAgICAgICB0b3Btb3N0OiB0cnVlLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHZpZXdwb3J0WDogdmlld3BvcnRYLFxuICAgICAgICAgICAgdmlld3BvcnRZOiB2aWV3cG9ydFksXG4gICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGlja2VkOiBbXVxuICAgICAgICB9KSxcbiAgICAgICAgcGlja2VkID0gX3RoaXMkZGVmYXVsdFZpZXckZ2V0Mi5waWNrZWQ7XG4gICAgICByZXR1cm4gcGlja2VkICYmIHBpY2tlZFswXSB8fCB0aGlzLmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBwaWNraW5nIHdpdGggQVBJIGluc3RlYWQgb2YgdHJpZ2dlcmluZyBpbnRlcmFjdGl2ZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9lbGVtZW50RnJvbVBvaW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZWxlbWVudEZyb21Qb2ludFwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9lbGVtZW50RnJvbVBvaW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoeCwgeSkge1xuICAgICAgICB2YXIgX3RoaXMkZGVmYXVsdFZpZXckY2FuMiwgdmlld3BvcnRYLCB2aWV3cG9ydFksIF90aGlzJGRlZmF1bHRWaWV3JGdldDMsIHdpZHRoLCBoZWlnaHQsIF90aGlzJGRlZmF1bHRWaWV3JHZpZTIsIGNsaWVudFgsIGNsaWVudFksIF95aWVsZCR0aGlzJGRlZmF1bHRWaSwgcGlja2VkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfdGhpcyRkZWZhdWx0VmlldyRjYW4yID0gdGhpcy5kZWZhdWx0Vmlldy5jYW52YXMyVmlld3BvcnQoe1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICB9KSwgdmlld3BvcnRYID0gX3RoaXMkZGVmYXVsdFZpZXckY2FuMi54LCB2aWV3cG9ydFkgPSBfdGhpcyRkZWZhdWx0VmlldyRjYW4yLnk7XG4gICAgICAgICAgICAgIF90aGlzJGRlZmF1bHRWaWV3JGdldDMgPSB0aGlzLmRlZmF1bHRWaWV3LmdldENvbmZpZygpLCB3aWR0aCA9IF90aGlzJGRlZmF1bHRWaWV3JGdldDMud2lkdGgsIGhlaWdodCA9IF90aGlzJGRlZmF1bHRWaWV3JGdldDMuaGVpZ2h0OyAvLyBvdXRzaWRlIGNhbnZhcycgdmlld3BvcnRcbiAgICAgICAgICAgICAgaWYgKCEodmlld3BvcnRYIDwgMCB8fCB2aWV3cG9ydFkgPCAwIHx8IHZpZXdwb3J0WCA+IHdpZHRoIHx8IHZpZXdwb3J0WSA+IGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfdGhpcyRkZWZhdWx0VmlldyR2aWUyID0gdGhpcy5kZWZhdWx0Vmlldy52aWV3cG9ydDJDbGllbnQoe1xuICAgICAgICAgICAgICAgIHg6IHZpZXdwb3J0WCxcbiAgICAgICAgICAgICAgICB5OiB2aWV3cG9ydFlcbiAgICAgICAgICAgICAgfSksIGNsaWVudFggPSBfdGhpcyRkZWZhdWx0VmlldyR2aWUyLngsIGNsaWVudFkgPSBfdGhpcyRkZWZhdWx0VmlldyR2aWUyLnk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Vmlldy5nZXRSZW5kZXJpbmdTZXJ2aWNlKCkuaG9va3MucGljay5wcm9taXNlKHtcbiAgICAgICAgICAgICAgICB0b3Btb3N0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgIHZpZXdwb3J0WDogdmlld3BvcnRYLFxuICAgICAgICAgICAgICAgICAgdmlld3BvcnRZOiB2aWV3cG9ydFksXG4gICAgICAgICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGlja2VkOiBbXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZGVmYXVsdFZpID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgcGlja2VkID0gX3lpZWxkJHRoaXMkZGVmYXVsdFZpLnBpY2tlZDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBwaWNrZWQgJiYgcGlja2VkWzBdIHx8IHRoaXMuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX2VsZW1lbnRGcm9tUG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50RnJvbVBvaW50O1xuICAgIH0oKSlcbiAgfSwge1xuICAgIGtleTogXCJlbGVtZW50c0Zyb21Qb2ludFN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudHNGcm9tUG9pbnRTeW5jKHgsIHkpIHtcbiAgICAgIHZhciBfdGhpcyRkZWZhdWx0VmlldyRjYW4zID0gdGhpcy5kZWZhdWx0Vmlldy5jYW52YXMyVmlld3BvcnQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KSxcbiAgICAgICAgdmlld3BvcnRYID0gX3RoaXMkZGVmYXVsdFZpZXckY2FuMy54LFxuICAgICAgICB2aWV3cG9ydFkgPSBfdGhpcyRkZWZhdWx0VmlldyRjYW4zLnk7XG4gICAgICB2YXIgX3RoaXMkZGVmYXVsdFZpZXckZ2V0NCA9IHRoaXMuZGVmYXVsdFZpZXcuZ2V0Q29uZmlnKCksXG4gICAgICAgIHdpZHRoID0gX3RoaXMkZGVmYXVsdFZpZXckZ2V0NC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkZGVmYXVsdFZpZXckZ2V0NC5oZWlnaHQ7XG4gICAgICAvLyBvdXRzaWRlIGNhbnZhcycgdmlld3BvcnRcbiAgICAgIGlmICh2aWV3cG9ydFggPCAwIHx8IHZpZXdwb3J0WSA8IDAgfHwgdmlld3BvcnRYID4gd2lkdGggfHwgdmlld3BvcnRZID4gaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRkZWZhdWx0VmlldyR2aWUzID0gdGhpcy5kZWZhdWx0Vmlldy52aWV3cG9ydDJDbGllbnQoe1xuICAgICAgICAgIHg6IHZpZXdwb3J0WCxcbiAgICAgICAgICB5OiB2aWV3cG9ydFlcbiAgICAgICAgfSksXG4gICAgICAgIGNsaWVudFggPSBfdGhpcyRkZWZhdWx0VmlldyR2aWUzLngsXG4gICAgICAgIGNsaWVudFkgPSBfdGhpcyRkZWZhdWx0VmlldyR2aWUzLnk7XG4gICAgICB2YXIgX3RoaXMkZGVmYXVsdFZpZXckZ2V0NSA9IHRoaXMuZGVmYXVsdFZpZXcuZ2V0UmVuZGVyaW5nU2VydmljZSgpLmhvb2tzLnBpY2tTeW5jLmNhbGwoe1xuICAgICAgICAgIHRvcG1vc3Q6IGZhbHNlLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHZpZXdwb3J0WDogdmlld3BvcnRYLFxuICAgICAgICAgICAgdmlld3BvcnRZOiB2aWV3cG9ydFksXG4gICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGlja2VkOiBbXVxuICAgICAgICB9KSxcbiAgICAgICAgcGlja2VkID0gX3RoaXMkZGVmYXVsdFZpZXckZ2V0NS5waWNrZWQ7XG4gICAgICBpZiAocGlja2VkW3BpY2tlZC5sZW5ndGggLSAxXSAhPT0gdGhpcy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgcGlja2VkLnB1c2godGhpcy5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpY2tlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBwaWNraW5nIHdpdGggQVBJIGluc3RlYWQgb2YgdHJpZ2dlcmluZyBpbnRlcmFjdGl2ZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9lbGVtZW50c0Zyb21Qb2ludFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVsZW1lbnRzRnJvbVBvaW50XCIsXG4gICAgdmFsdWU6IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2VsZW1lbnRzRnJvbVBvaW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHgsIHkpIHtcbiAgICAgICAgdmFyIF90aGlzJGRlZmF1bHRWaWV3JGNhbjQsIHZpZXdwb3J0WCwgdmlld3BvcnRZLCBfdGhpcyRkZWZhdWx0VmlldyRnZXQ2LCB3aWR0aCwgaGVpZ2h0LCBfdGhpcyRkZWZhdWx0VmlldyR2aWU0LCBjbGllbnRYLCBjbGllbnRZLCBfeWllbGQkdGhpcyRkZWZhdWx0VmkyLCBwaWNrZWQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfdGhpcyRkZWZhdWx0VmlldyRjYW40ID0gdGhpcy5kZWZhdWx0Vmlldy5jYW52YXMyVmlld3BvcnQoe1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICB9KSwgdmlld3BvcnRYID0gX3RoaXMkZGVmYXVsdFZpZXckY2FuNC54LCB2aWV3cG9ydFkgPSBfdGhpcyRkZWZhdWx0VmlldyRjYW40Lnk7XG4gICAgICAgICAgICAgIF90aGlzJGRlZmF1bHRWaWV3JGdldDYgPSB0aGlzLmRlZmF1bHRWaWV3LmdldENvbmZpZygpLCB3aWR0aCA9IF90aGlzJGRlZmF1bHRWaWV3JGdldDYud2lkdGgsIGhlaWdodCA9IF90aGlzJGRlZmF1bHRWaWV3JGdldDYuaGVpZ2h0OyAvLyBvdXRzaWRlIGNhbnZhcycgdmlld3BvcnRcbiAgICAgICAgICAgICAgaWYgKCEodmlld3BvcnRYIDwgMCB8fCB2aWV3cG9ydFkgPCAwIHx8IHZpZXdwb3J0WCA+IHdpZHRoIHx8IHZpZXdwb3J0WSA+IGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfdGhpcyRkZWZhdWx0VmlldyR2aWU0ID0gdGhpcy5kZWZhdWx0Vmlldy52aWV3cG9ydDJDbGllbnQoe1xuICAgICAgICAgICAgICAgIHg6IHZpZXdwb3J0WCxcbiAgICAgICAgICAgICAgICB5OiB2aWV3cG9ydFlcbiAgICAgICAgICAgICAgfSksIGNsaWVudFggPSBfdGhpcyRkZWZhdWx0VmlldyR2aWU0LngsIGNsaWVudFkgPSBfdGhpcyRkZWZhdWx0VmlldyR2aWU0Lnk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFZpZXcuZ2V0UmVuZGVyaW5nU2VydmljZSgpLmhvb2tzLnBpY2sucHJvbWlzZSh7XG4gICAgICAgICAgICAgICAgdG9wbW9zdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgdmlld3BvcnRYOiB2aWV3cG9ydFgsXG4gICAgICAgICAgICAgICAgICB2aWV3cG9ydFk6IHZpZXdwb3J0WSxcbiAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGNsaWVudFgsXG4gICAgICAgICAgICAgICAgICBjbGllbnRZOiBjbGllbnRZXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwaWNrZWQ6IFtdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfeWllbGQkdGhpcyRkZWZhdWx0VmkyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgIHBpY2tlZCA9IF95aWVsZCR0aGlzJGRlZmF1bHRWaTIucGlja2VkO1xuICAgICAgICAgICAgICBpZiAocGlja2VkW3BpY2tlZC5sZW5ndGggLSAxXSAhPT0gdGhpcy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwaWNrZWQucHVzaCh0aGlzLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcGlja2VkKTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZWxlbWVudHNGcm9tUG9pbnQoX3gzLCBfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9lbGVtZW50c0Zyb21Qb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRzRnJvbVBvaW50O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIGVnLiBVbmNhdWdodCBET01FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdhcHBlbmRDaGlsZCcgb24gJ05vZGUnOiBPbmx5IG9uZSBlbGVtZW50IG9uIGRvY3VtZW50IGFsbG93ZWQuXG4gICAgICovXG4gICAgKVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZENoaWxkKG5ld0NoaWxkLCBpbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19VU0VfRE9DVU1FTlRfRUxFTUVOVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUobmV3Q2hpbGQsIHJlZkNoaWxkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX1VTRV9ET0NVTUVOVF9FTEVNRU5UKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hpbGQob2xkQ2hpbGQsIGRlc3Ryb3kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfVVNFX0RPQ1VNRU5UX0VMRU1FTlQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCwgZGVzdHJveSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19VU0VfRE9DVU1FTlRfRUxFTUVOVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHX1VTRV9ET0NVTUVOVF9FTEVNRU5UKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwZW5kKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19VU0VfRE9DVU1FTlRfRUxFTUVOVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBxdWVyeSBvbiBkb2N1bWVudEVsZW1lbnQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudEJ5SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsZW1lbnRzQnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlOYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWVyeVNlbGVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWVyeVNlbGVjdG9yQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQoZmlsdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQuZmluZChmaWx0ZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBbGwoZmlsdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQuZmluZEFsbChmaWx0ZXIpO1xuICAgIH1cbiAgfV0pO1xufShOb2RlKTtcblxuLyoqXG4gKiBhcHBseSBmb2xsb3dpbmcgcnVsZXM6XG4gKiAxLiBgdmlzaWJpbGl0eWAgaW4gc2NlbmVncmFwaCBub2RlXG4gKiAyLiBvdGhlciBjdXN0b20gY3VsbGluZyBzdHJhdGVnaWVzLCBlZy4gZnJ1c3R1bSBjdWxsaW5nXG4gKi9cbnZhciBDdWxsaW5nUGx1Z2luID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VsbGluZ1BsdWdpbihzdHJhdGVnaWVzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1bGxpbmdQbHVnaW4pO1xuICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDdWxsaW5nUGx1Z2luLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjb250ZXh0KSB7XG4gICAgICB2YXIgY2FtZXJhID0gY29udGV4dC5jYW1lcmEsXG4gICAgICAgIHJlbmRlcmluZ1NlcnZpY2UgPSBjb250ZXh0LnJlbmRlcmluZ1NlcnZpY2UsXG4gICAgICAgIHJlbmRlcmluZ0NvbnRleHQgPSBjb250ZXh0LnJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICB2YXIgc3RyYXRlZ2llcyA9IHRoaXMuc3RyYXRlZ2llcztcbiAgICAgIHJlbmRlcmluZ1NlcnZpY2UuaG9va3MuY3VsbC50YXAoQ3VsbGluZ1BsdWdpbi50YWcsIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgIHZhciBjdWxsYWJsZSA9IG9iamVjdC5jdWxsYWJsZTtcbiAgICAgICAgICAvLyBjdWxsYWJsZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAvLyBjb25zdCByZW5kZXJCb3VuZHMgPSBvYmplY3QuZ2V0UmVuZGVyQm91bmRzKCk7XG4gICAgICAgICAgLy8gaWYgKEFBQkIuaXNFbXB0eShyZW5kZXJCb3VuZHMpKSB7XG4gICAgICAgICAgLy8gICBjdWxsYWJsZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIGNvbnN0IGlzU2hhcGUyRCA9IHNoYXBlMkQuaW5kZXhPZihvYmplY3Qubm9kZU5hbWUgYXMgU2hhcGUpID4gLTE7XG4gICAgICAgICAgLy8gICBjb25zdCBbcDAsIHAxLCBwMiwgcDNdID0gY2FtZXJhLmdldEZydXN0dW0oKS5wbGFuZXM7XG4gICAgICAgICAgLy8gICB0bXBBQUJCLnNldE1pbk1heChbLXAxLmRpc3RhbmNlLCAtcDMuZGlzdGFuY2UsIDBdLCBbcDAuZGlzdGFuY2UsIHAyLmRpc3RhbmNlLCAwXSk7XG5cbiAgICAgICAgICAvLyAgIGN1bGxhYmxlLnZpc2libGUgPSBpc1NoYXBlMkQgPyByZW5kZXJCb3VuZHMuaW50ZXJzZWN0cyh0bXBBQUJCKSA6IHRydWU7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgaWYgKHN0cmF0ZWdpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjdWxsYWJsZS52aXNpYmxlID0gcmVuZGVyaW5nQ29udGV4dC51bmN1bGxlZEVudGl0aWVzLmluZGV4T2Yob2JqZWN0LmVudGl0eSkgPiAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWcuIGltcGxlbWVudGVkIGJ5IGctd2ViZ2woZnJ1c3R1bSBjdWxsaW5nKVxuICAgICAgICAgICAgY3VsbGFibGUudmlzaWJsZSA9IHN0cmF0ZWdpZXMuZXZlcnkoZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJhdGVneS5pc1Zpc2libGUoY2FtZXJhLCBvYmplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb2JqZWN0LmlzQ3VsbGVkKCkgJiYgb2JqZWN0LmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiAodGhpcy5yZW5kZXJpbmdDb250ZXh0LnJlbmRlckxpc3RMYXN0RnJhbWUuaW5kZXhPZihvYmplY3QpID4gLTEpIHtcbiAgICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRWxlbWVudEV2ZW50LkNVTExFRCkpO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICAgIHJlbmRlcmluZ1NlcnZpY2UuaG9va3MuYWZ0ZXJSZW5kZXIudGFwKEN1bGxpbmdQbHVnaW4udGFnLCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5jdWxsYWJsZS52aXNpYmlsaXR5UGxhbmVNYXNrID0gLTE7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbkN1bGxpbmdQbHVnaW4udGFnID0gJ0N1bGxpbmcnO1xuXG4vKipcbiAqIHN1cHBvcnQgbW91c2UgJiB0b3VjaCBldmVudHNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvZGV2L3BhY2thZ2VzL2ludGVyYWN0aW9uL1JFQURNRS5tZFxuICpcbiAqIGFsc28gcHJvdmlkZSBzb21lIGV4dHJhIGV2ZW50cyBzdWNoIGFzIGBkcmFnYFxuICovXG52YXIgRXZlbnRQbHVnaW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudFBsdWdpbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudFBsdWdpbik7XG4gICAgdGhpcy5hdXRvUHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RQb2ludGVyRXZlbnQgPSBuZXcgRmVkZXJhdGVkUG9pbnRlckV2ZW50KG51bGwpO1xuICAgIHRoaXMucm9vdFdoZWVsRXZlbnQgPSBuZXcgRmVkZXJhdGVkV2hlZWxFdmVudChudWxsKTtcbiAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0JHJlbmRlcmk7XG4gICAgICB2YXIgY2FudmFzID0gKF90aGlzJGNvbnRleHQkcmVuZGVyaSA9IF90aGlzLmNvbnRleHQucmVuZGVyaW5nQ29udGV4dC5yb290KSA9PT0gbnVsbCB8fCBfdGhpcyRjb250ZXh0JHJlbmRlcmkgPT09IHZvaWQgMCB8fCAoX3RoaXMkY29udGV4dCRyZW5kZXJpID0gX3RoaXMkY29udGV4dCRyZW5kZXJpLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF90aGlzJGNvbnRleHQkcmVuZGVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkY29udGV4dCRyZW5kZXJpLmRlZmF1bHRWaWV3O1xuICAgICAgaWYgKGNhbnZhcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG5hdGl2ZUV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSByZXR1cm47XG4gICAgICB2YXIgbm9ybWFsaXplZEV2ZW50cyA9IF90aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckV2ZW50KG5hdGl2ZUV2ZW50LCBjYW52YXMpO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5vcm1hbGl6ZWRFdmVudHMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBldmVudCA9IF90aGlzLmJvb3RzdHJhcEV2ZW50KF90aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudCwgY2FudmFzLCBuYXRpdmVFdmVudCk7XG4gICAgICAgICAgX3RoaXMuY29udGV4dC5ldmVudFNlcnZpY2UubWFwRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5zZXRDdXJzb3IoX3RoaXMuY29udGV4dC5ldmVudFNlcnZpY2UuY3Vyc29yKTtcbiAgICB9O1xuICAgIHRoaXMub25DbGljayA9IGZ1bmN0aW9uIChuYXRpdmVFdmVudCkge1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQkcmVuZGVyaTI7XG4gICAgICB2YXIgY2FudmFzID0gKF90aGlzJGNvbnRleHQkcmVuZGVyaTIgPSBfdGhpcy5jb250ZXh0LnJlbmRlcmluZ0NvbnRleHQucm9vdCkgPT09IG51bGwgfHwgX3RoaXMkY29udGV4dCRyZW5kZXJpMiA9PT0gdm9pZCAwIHx8IChfdGhpcyRjb250ZXh0JHJlbmRlcmkyID0gX3RoaXMkY29udGV4dCRyZW5kZXJpMi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRjb250ZXh0JHJlbmRlcmkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0JHJlbmRlcmkyLmRlZmF1bHRWaWV3O1xuICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudHMgPSBfdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJFdmVudChuYXRpdmVFdmVudCwgY2FudmFzKTtcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobm9ybWFsaXplZEV2ZW50cyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBfdGhpcy5ib290c3RyYXBFdmVudChfdGhpcy5yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnQsIGNhbnZhcywgbmF0aXZlRXZlbnQpO1xuICAgICAgICAgIF90aGlzLmNvbnRleHQuZXZlbnRTZXJ2aWNlLm1hcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5zZXRDdXJzb3IoX3RoaXMuY29udGV4dC5ldmVudFNlcnZpY2UuY3Vyc29yKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXZlbnRQbHVnaW4sIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciByZW5kZXJpbmdTZXJ2aWNlID0gY29udGV4dC5yZW5kZXJpbmdTZXJ2aWNlO1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY29udGV4dC5yZW5kZXJpbmdDb250ZXh0LnJvb3Qub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIHRoaXMuY29udGV4dC5ldmVudFNlcnZpY2Uuc2V0UGlja0hhbmRsZXIoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpczIkY29udGV4dCRyZW5kZXIgPSBfdGhpczIuY29udGV4dC5yZW5kZXJpbmdTZXJ2aWNlLmhvb2tzLnBpY2tTeW5jLmNhbGwoe1xuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgcGlja2VkOiBbXSxcbiAgICAgICAgICAgIHRvcG1vc3Q6IHRydWUgLy8gd2Ugb25seSBjb25jZXJuIHRoZSB0b3Btb3N0IGVsZW1lbnRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwaWNrZWQgPSBfdGhpczIkY29udGV4dCRyZW5kZXIucGlja2VkO1xuICAgICAgICByZXR1cm4gcGlja2VkWzBdIHx8IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHJlbmRlcmluZ1NlcnZpY2UuaG9va3MucG9pbnRlcldoZWVsLnRhcChFdmVudFBsdWdpbi50YWcsIGZ1bmN0aW9uIChuYXRpdmVFdmVudCkge1xuICAgICAgICB2YXIgd2hlZWxFdmVudCA9IF90aGlzMi5ub3JtYWxpemVXaGVlbEV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICAgICAgX3RoaXMyLmNvbnRleHQuZXZlbnRTZXJ2aWNlLm1hcEV2ZW50KHdoZWVsRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICByZW5kZXJpbmdTZXJ2aWNlLmhvb2tzLnBvaW50ZXJEb3duLnRhcChFdmVudFBsdWdpbi50YWcsIGZ1bmN0aW9uIChuYXRpdmVFdmVudCkge1xuICAgICAgICBpZiAoY2FudmFzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgbmF0aXZlRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHJldHVybjtcbiAgICAgICAgdmFyIGV2ZW50cyA9IF90aGlzMi5ub3JtYWxpemVUb1BvaW50ZXJFdmVudChuYXRpdmVFdmVudCwgY2FudmFzKTtcbiAgICAgICAgaWYgKF90aGlzMi5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnRzWzBdLmlzTm9ybWFsaXplZCkge1xuICAgICAgICAgIHZhciBjYW5jZWxhYmxlID0gbmF0aXZlRXZlbnQuY2FuY2VsYWJsZSB8fCAhKCdjYW5jZWxhYmxlJyBpbiBuYXRpdmVFdmVudCk7XG4gICAgICAgICAgaWYgKGNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZXZlbnRzKSxcbiAgICAgICAgICBfc3RlcDM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBmZWRlcmF0ZWRFdmVudCA9IF90aGlzMi5ib290c3RyYXBFdmVudChfdGhpczIucm9vdFBvaW50ZXJFdmVudCwgZXZlbnQsIGNhbnZhcywgbmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMyLmNvbnRleHQuZXZlbnRTZXJ2aWNlLm1hcEV2ZW50KGZlZGVyYXRlZEV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMi5zZXRDdXJzb3IoX3RoaXMyLmNvbnRleHQuZXZlbnRTZXJ2aWNlLmN1cnNvcik7XG4gICAgICB9KTtcbiAgICAgIHJlbmRlcmluZ1NlcnZpY2UuaG9va3MucG9pbnRlclVwLnRhcChFdmVudFBsdWdpbi50YWcsIGZ1bmN0aW9uIChuYXRpdmVFdmVudCkge1xuICAgICAgICBpZiAoY2FudmFzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgbmF0aXZlRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHJldHVybjtcblxuICAgICAgICAvLyBhY2NvdW50IGZvciBlbGVtZW50IGluIFNWR1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSBfdGhpczIuY29udGV4dC5jb250ZXh0U2VydmljZS5nZXREb21FbGVtZW50KCk7XG4gICAgICAgIHZhciBpc05hdGl2ZUV2ZW50RnJvbUNhbnZhcyA9IF90aGlzMi5jb250ZXh0LmV2ZW50U2VydmljZS5pc05hdGl2ZUV2ZW50RnJvbUNhbnZhcygkZWxlbWVudCwgbmF0aXZlRXZlbnQpO1xuICAgICAgICB2YXIgb3V0c2lkZSA9ICFpc05hdGl2ZUV2ZW50RnJvbUNhbnZhcyA/ICdvdXRzaWRlJyA6ICcnO1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50cyA9IF90aGlzMi5ub3JtYWxpemVUb1BvaW50ZXJFdmVudChuYXRpdmVFdmVudCwgY2FudmFzKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihub3JtYWxpemVkRXZlbnRzKSxcbiAgICAgICAgICBfc3RlcDQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkRXZlbnQgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBfdGhpczIuYm9vdHN0cmFwRXZlbnQoX3RoaXMyLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudCwgY2FudmFzLCBuYXRpdmVFdmVudCk7XG4gICAgICAgICAgICBldmVudC50eXBlICs9IG91dHNpZGU7XG4gICAgICAgICAgICBfdGhpczIuY29udGV4dC5ldmVudFNlcnZpY2UubWFwRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLnNldEN1cnNvcihfdGhpczIuY29udGV4dC5ldmVudFNlcnZpY2UuY3Vyc29yKTtcbiAgICAgIH0pO1xuICAgICAgcmVuZGVyaW5nU2VydmljZS5ob29rcy5wb2ludGVyTW92ZS50YXAoRXZlbnRQbHVnaW4udGFnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgcmVuZGVyaW5nU2VydmljZS5ob29rcy5wb2ludGVyT3Zlci50YXAoRXZlbnRQbHVnaW4udGFnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgcmVuZGVyaW5nU2VydmljZS5ob29rcy5wb2ludGVyT3V0LnRhcChFdmVudFBsdWdpbi50YWcsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICByZW5kZXJpbmdTZXJ2aWNlLmhvb2tzLmNsaWNrLnRhcChFdmVudFBsdWdpbi50YWcsIHRoaXMub25DbGljayk7XG4gICAgICByZW5kZXJpbmdTZXJ2aWNlLmhvb2tzLnBvaW50ZXJDYW5jZWwudGFwKEV2ZW50UGx1Z2luLnRhZywgZnVuY3Rpb24gKG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkRXZlbnRzID0gX3RoaXMyLm5vcm1hbGl6ZVRvUG9pbnRlckV2ZW50KG5hdGl2ZUV2ZW50LCBjYW52YXMpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5vcm1hbGl6ZWRFdmVudHMpLFxuICAgICAgICAgIF9zdGVwNTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudCA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IF90aGlzMi5ib290c3RyYXBFdmVudChfdGhpczIucm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50LCBjYW52YXMsIG5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIF90aGlzMi5jb250ZXh0LmV2ZW50U2VydmljZS5tYXBFdmVudChldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczIuc2V0Q3Vyc29yKF90aGlzMi5jb250ZXh0LmV2ZW50U2VydmljZS5jdXJzb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJvb3RzdHJhcEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvb3RzdHJhcEV2ZW50KGV2ZW50LCBub3JtYWxpemVkRXZlbnQsIHZpZXcsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICBldmVudC52aWV3ID0gdmlldztcbiAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBudWxsO1xuICAgICAgZXZlbnQubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgIGV2ZW50LnBvaW50ZXJJZCA9IG5vcm1hbGl6ZWRFdmVudC5wb2ludGVySWQ7XG4gICAgICBldmVudC53aWR0aCA9IG5vcm1hbGl6ZWRFdmVudC53aWR0aDtcbiAgICAgIGV2ZW50LmhlaWdodCA9IG5vcm1hbGl6ZWRFdmVudC5oZWlnaHQ7XG4gICAgICBldmVudC5pc1ByaW1hcnkgPSBub3JtYWxpemVkRXZlbnQuaXNQcmltYXJ5O1xuICAgICAgZXZlbnQucG9pbnRlclR5cGUgPSBub3JtYWxpemVkRXZlbnQucG9pbnRlclR5cGU7XG4gICAgICBldmVudC5wcmVzc3VyZSA9IG5vcm1hbGl6ZWRFdmVudC5wcmVzc3VyZTtcbiAgICAgIGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IG5vcm1hbGl6ZWRFdmVudC50YW5nZW50aWFsUHJlc3N1cmU7XG4gICAgICBldmVudC50aWx0WCA9IG5vcm1hbGl6ZWRFdmVudC50aWx0WDtcbiAgICAgIGV2ZW50LnRpbHRZID0gbm9ybWFsaXplZEV2ZW50LnRpbHRZO1xuICAgICAgZXZlbnQudHdpc3QgPSBub3JtYWxpemVkRXZlbnQudHdpc3Q7XG4gICAgICB0aGlzLnRyYW5zZmVyTW91c2VEYXRhKGV2ZW50LCBub3JtYWxpemVkRXZlbnQpO1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQkZXZlbnRTZSA9IHRoaXMuY29udGV4dC5ldmVudFNlcnZpY2UuY2xpZW50MlZpZXdwb3J0KHtcbiAgICAgICAgICB4OiBub3JtYWxpemVkRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBub3JtYWxpemVkRXZlbnQuY2xpZW50WVxuICAgICAgICB9KSxcbiAgICAgICAgeCA9IF90aGlzJGNvbnRleHQkZXZlbnRTZS54LFxuICAgICAgICB5ID0gX3RoaXMkY29udGV4dCRldmVudFNlLnk7XG4gICAgICBldmVudC52aWV3cG9ydC54ID0geDtcbiAgICAgIGV2ZW50LnZpZXdwb3J0LnkgPSB5O1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQkZXZlbnRTZTIgPSB0aGlzLmNvbnRleHQuZXZlbnRTZXJ2aWNlLnZpZXdwb3J0MkNhbnZhcyhldmVudC52aWV3cG9ydCksXG4gICAgICAgIGNhbnZhc1ggPSBfdGhpcyRjb250ZXh0JGV2ZW50U2UyLngsXG4gICAgICAgIGNhbnZhc1kgPSBfdGhpcyRjb250ZXh0JGV2ZW50U2UyLnk7XG4gICAgICBldmVudC5jYW52YXMueCA9IGNhbnZhc1g7XG4gICAgICBldmVudC5jYW52YXMueSA9IGNhbnZhc1k7XG4gICAgICBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuY2FudmFzKTtcbiAgICAgIGV2ZW50Lm9mZnNldC5jb3B5RnJvbShldmVudC5jYW52YXMpO1xuICAgICAgZXZlbnQuaXNUcnVzdGVkID0gbmF0aXZlRXZlbnQuaXNUcnVzdGVkO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwb2ludGVybGVhdmUnKSB7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAncG9pbnRlcm91dCc7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKCdtb3VzZScpKSB7XG4gICAgICAgIGV2ZW50LnR5cGUgPSBldmVudC50eXBlLnJlcGxhY2UoJ21vdXNlJywgJ3BvaW50ZXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoJ3RvdWNoJykpIHtcbiAgICAgICAgZXZlbnQudHlwZSA9IFRPVUNIX1RPX1BPSU5URVJbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplV2hlZWxFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVXaGVlbEV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLnJvb3RXaGVlbEV2ZW50O1xuICAgICAgdGhpcy50cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpO1xuICAgICAgZXZlbnQuZGVsdGFNb2RlID0gbmF0aXZlRXZlbnQuZGVsdGFNb2RlO1xuICAgICAgZXZlbnQuZGVsdGFYID0gbmF0aXZlRXZlbnQuZGVsdGFYO1xuICAgICAgZXZlbnQuZGVsdGFZID0gbmF0aXZlRXZlbnQuZGVsdGFZO1xuICAgICAgZXZlbnQuZGVsdGFaID0gbmF0aXZlRXZlbnQuZGVsdGFaO1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQkZXZlbnRTZTMgPSB0aGlzLmNvbnRleHQuZXZlbnRTZXJ2aWNlLmNsaWVudDJWaWV3cG9ydCh7XG4gICAgICAgICAgeDogbmF0aXZlRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBuYXRpdmVFdmVudC5jbGllbnRZXG4gICAgICAgIH0pLFxuICAgICAgICB4ID0gX3RoaXMkY29udGV4dCRldmVudFNlMy54LFxuICAgICAgICB5ID0gX3RoaXMkY29udGV4dCRldmVudFNlMy55O1xuICAgICAgZXZlbnQudmlld3BvcnQueCA9IHg7XG4gICAgICBldmVudC52aWV3cG9ydC55ID0geTtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0JGV2ZW50U2U0ID0gdGhpcy5jb250ZXh0LmV2ZW50U2VydmljZS52aWV3cG9ydDJDYW52YXMoZXZlbnQudmlld3BvcnQpLFxuICAgICAgICBjYW52YXNYID0gX3RoaXMkY29udGV4dCRldmVudFNlNC54LFxuICAgICAgICBjYW52YXNZID0gX3RoaXMkY29udGV4dCRldmVudFNlNC55O1xuICAgICAgZXZlbnQuY2FudmFzLnggPSBjYW52YXNYO1xuICAgICAgZXZlbnQuY2FudmFzLnkgPSBjYW52YXNZO1xuICAgICAgZXZlbnQuZ2xvYmFsLmNvcHlGcm9tKGV2ZW50LmNhbnZhcyk7XG4gICAgICBldmVudC5vZmZzZXQuY29weUZyb20oZXZlbnQuY2FudmFzKTtcbiAgICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICBldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlcnMgYmFzZSAmIG1vdXNlIGV2ZW50IGRhdGEgZnJvbSB0aGUgbmF0aXZlRXZlbnQgdG8gdGhlIGZlZGVyYXRlZCBldmVudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zlck1vdXNlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICAgIGV2ZW50LmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZDtcbiAgICAgIGV2ZW50LnNyY0VsZW1lbnQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50O1xuICAgICAgZXZlbnQudGltZVN0YW1wID0gY2xvY2subm93KCk7XG4gICAgICBldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcbiAgICAgIGV2ZW50LmFsdEtleSA9IG5hdGl2ZUV2ZW50LmFsdEtleTtcbiAgICAgIGV2ZW50Lm1ldGFLZXkgPSBuYXRpdmVFdmVudC5tZXRhS2V5O1xuICAgICAgZXZlbnQuc2hpZnRLZXkgPSBuYXRpdmVFdmVudC5zaGlmdEtleTtcbiAgICAgIGV2ZW50LmN0cmxLZXkgPSBuYXRpdmVFdmVudC5jdHJsS2V5O1xuICAgICAgZXZlbnQuYnV0dG9uID0gbmF0aXZlRXZlbnQuYnV0dG9uO1xuICAgICAgZXZlbnQuYnV0dG9ucyA9IG5hdGl2ZUV2ZW50LmJ1dHRvbnM7XG4gICAgICBldmVudC5jbGllbnQueCA9IG5hdGl2ZUV2ZW50LmNsaWVudFg7XG4gICAgICBldmVudC5jbGllbnQueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFk7XG4gICAgICBldmVudC5tb3ZlbWVudC54ID0gbmF0aXZlRXZlbnQubW92ZW1lbnRYO1xuICAgICAgZXZlbnQubW92ZW1lbnQueSA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WTtcbiAgICAgIGV2ZW50LnBhZ2UueCA9IG5hdGl2ZUV2ZW50LnBhZ2VYO1xuICAgICAgZXZlbnQucGFnZS55ID0gbmF0aXZlRXZlbnQucGFnZVk7XG4gICAgICBldmVudC5zY3JlZW4ueCA9IG5hdGl2ZUV2ZW50LnNjcmVlblg7XG4gICAgICBldmVudC5zY3JlZW4ueSA9IG5hdGl2ZUV2ZW50LnNjcmVlblk7XG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnNvcihjdXJzb3IpIHtcbiAgICAgIHRoaXMuY29udGV4dC5jb250ZXh0U2VydmljZS5hcHBseUN1cnNvclN0eWxlKGN1cnNvciB8fCB0aGlzLmNvbnRleHQuY29uZmlnLmN1cnNvciB8fCAnZGVmYXVsdCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVUb1BvaW50ZXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVUb1BvaW50ZXJFdmVudChldmVudCwgY2FudmFzKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZEV2ZW50cyA9IFtdO1xuICAgICAgaWYgKGNhbnZhcy5pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXTtcblxuICAgICAgICAgIC8vIHVzZSBjaGFuZ2VkVG91Y2hlcyBpbnN0ZWFkIG9mIHRvdWNoZXMgc2luY2UgdG91Y2hlbmQgaGFzIG5vIHRvdWNoZXNcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDA3OTA3NlxuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0b3VjaC5idXR0b24pKSB0b3VjaC5idXR0b24gPSAwO1xuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0b3VjaC5idXR0b25zKSkgdG91Y2guYnV0dG9ucyA9IDE7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvdWNoLmlzUHJpbWFyeSkpIHtcbiAgICAgICAgICAgIHRvdWNoLmlzUHJpbWFyeSA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvdWNoLndpZHRoKSkgdG91Y2gud2lkdGggPSB0b3VjaC5yYWRpdXNYIHx8IDE7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvdWNoLmhlaWdodCkpIHRvdWNoLmhlaWdodCA9IHRvdWNoLnJhZGl1c1kgfHwgMTtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodG91Y2gudGlsdFgpKSB0b3VjaC50aWx0WCA9IDA7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvdWNoLnRpbHRZKSkgdG91Y2gudGlsdFkgPSAwO1xuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0b3VjaC5wb2ludGVyVHlwZSkpIHRvdWNoLnBvaW50ZXJUeXBlID0gJ3RvdWNoJztcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9Ub3VjaC9pZGVudGlmaWVyXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvdWNoLnBvaW50ZXJJZCkpIHRvdWNoLnBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXIgfHwgMDtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodG91Y2gucHJlc3N1cmUpKSB0b3VjaC5wcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodG91Y2gudHdpc3QpKSB0b3VjaC50d2lzdCA9IDA7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSkpIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XG4gICAgICAgICAgdG91Y2guaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICB0b3VjaC50eXBlID0gZXZlbnQudHlwZTtcbiAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhbnZhcy5pc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIHZhciB0ZW1wRXZlbnQgPSBldmVudDtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRlbXBFdmVudC5pc1ByaW1hcnkpKSB0ZW1wRXZlbnQuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRlbXBFdmVudC53aWR0aCkpIHRlbXBFdmVudC53aWR0aCA9IDE7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0ZW1wRXZlbnQuaGVpZ2h0KSkgdGVtcEV2ZW50LmhlaWdodCA9IDE7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0ZW1wRXZlbnQudGlsdFgpKSB0ZW1wRXZlbnQudGlsdFggPSAwO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGVtcEV2ZW50LnRpbHRZKSkgdGVtcEV2ZW50LnRpbHRZID0gMDtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRlbXBFdmVudC5wb2ludGVyVHlwZSkpIHRlbXBFdmVudC5wb2ludGVyVHlwZSA9ICdtb3VzZSc7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0ZW1wRXZlbnQucG9pbnRlcklkKSkgdGVtcEV2ZW50LnBvaW50ZXJJZCA9IE1PVVNFX1BPSU5URVJfSUQ7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0ZW1wRXZlbnQucHJlc3N1cmUpKSB0ZW1wRXZlbnQucHJlc3N1cmUgPSAwLjU7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0ZW1wRXZlbnQudHdpc3QpKSB0ZW1wRXZlbnQudHdpc3QgPSAwO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSkpIHRlbXBFdmVudC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgICB0ZW1wRXZlbnQuaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRlbXBFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFdmVudHM7XG4gICAgfVxuICB9XSk7XG59KCk7XG5FdmVudFBsdWdpbi50YWcgPSAnRXZlbnQnO1xuXG4vLyBncm91cCBpcyBub3QgYSAyZCBzaGFwZVxudmFyIHNoYXBlMkQgPSBbU2hhcGUuQ0lSQ0xFLCBTaGFwZS5FTExJUFNFLCBTaGFwZS5JTUFHRSwgU2hhcGUuUkVDVCwgU2hhcGUuTElORSwgU2hhcGUuUE9MWUxJTkUsIFNoYXBlLlBPTFlHT04sIFNoYXBlLlRFWFQsIFNoYXBlLlBBVEgsIFNoYXBlLkhUTUxdO1xudmFyIEZydXN0dW1DdWxsaW5nU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcnVzdHVtQ3VsbGluZ1N0cmF0ZWd5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcnVzdHVtQ3VsbGluZ1N0cmF0ZWd5KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZydXN0dW1DdWxsaW5nU3RyYXRlZ3ksIFt7XG4gICAga2V5OiBcImlzVmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Zpc2libGUoY2FtZXJhLCBvYmplY3QpIHtcbiAgICAgIHZhciBfb2JqZWN0JHBhcmVudE5vZGU7XG4gICAgICAvLyByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIGN1bGxhYmxlID0gb2JqZWN0LmN1bGxhYmxlO1xuICAgICAgaWYgKCFjdWxsYWJsZS5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVuZGVyQm91bmRzID0gb2JqZWN0LmdldFJlbmRlckJvdW5kcygpO1xuICAgICAgaWYgKEFBQkIuaXNFbXB0eShyZW5kZXJCb3VuZHMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IFZQIG1hdHJpeCBmcm9tIGNhbWVyYVxuICAgICAgdmFyIGZydXN0dW0gPSBjYW1lcmEuZ2V0RnJ1c3R1bSgpO1xuICAgICAgdmFyIHBhcmVudFZpc2liaWxpdHlQbGFuZU1hc2sgPSAoX29iamVjdCRwYXJlbnROb2RlID0gb2JqZWN0LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9vYmplY3QkcGFyZW50Tm9kZSA9PT0gdm9pZCAwIHx8IChfb2JqZWN0JHBhcmVudE5vZGUgPSBfb2JqZWN0JHBhcmVudE5vZGUuY3VsbGFibGUpID09PSBudWxsIHx8IF9vYmplY3QkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29iamVjdCRwYXJlbnROb2RlLnZpc2liaWxpdHlQbGFuZU1hc2s7XG4gICAgICBjdWxsYWJsZS52aXNpYmlsaXR5UGxhbmVNYXNrID0gdGhpcy5jb21wdXRlVmlzaWJpbGl0eVdpdGhQbGFuZU1hc2sob2JqZWN0LCByZW5kZXJCb3VuZHMsIHBhcmVudFZpc2liaWxpdHlQbGFuZU1hc2sgfHwgTWFzay5JTkRFVEVSTUlOQVRFLCBmcnVzdHVtLnBsYW5lcyk7XG4gICAgICBjdWxsYWJsZS52aXNpYmxlID0gY3VsbGFibGUudmlzaWJpbGl0eVBsYW5lTWFzayAhPT0gTWFzay5PVVRTSURFO1xuICAgICAgcmV0dXJuIGN1bGxhYmxlLnZpc2libGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc2Vl44CMT3B0aW1pemVkIFZpZXcgRnJ1c3R1bSBDdWxsaW5nIEFsZ29yaXRobXMgZm9yIEJvdW5kaW5nIEJveGVz44CNXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW50dmlzL0dXZWJHUFVFbmdpbmUvaXNzdWVzLzNcbiAgICAgKlxuICAgICAqICog5Z+656GA55u45Lqk5rWL6K+VIHRoZSBiYXNpYyBpbnRlcnNlY3Rpb24gdGVzdFxuICAgICAqICog5qCH6K6wIG1hc2tpbmcgQHNlZSBodHRwczovL2Nlc2l1bS5jb20vYmxvZy8yMDE1LzA4LzA0L2Zhc3QtaGllcmFyY2hpY2FsLWN1bGxpbmcvXG4gICAgICogKiBUT0RPOiDlubPpnaLkuIDoh7TmgKfmtYvor5UgdGhlIHBsYW5lLWNvaGVyZW5jeSB0ZXN0XG4gICAgICogKiBUT0RPOiDmlK/mjIEgbWVzaCDmjIflrproh6rouqvnmoTliZTpmaTnrZbnlaXvvIzlj4LogIMgQmFieWxvbi5qcyBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vaG93X3RvL29wdGltaXppbmdfeW91cl9zY2VuZSNjaGFuZ2luZy1tZXNoLWN1bGxpbmctc3RyYXRlZ3lcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYWJiIGFhYmJcbiAgICAgKiBAcGFyYW0gcGFyZW50UGxhbmVNYXNrIG1hc2sgb2YgcGFyZW50XG4gICAgICogQHBhcmFtIHBsYW5lcyBwbGFuZXMgb2YgZnJ1c3R1bVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbXB1dGVWaXNpYmlsaXR5V2l0aFBsYW5lTWFza1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlVmlzaWJpbGl0eVdpdGhQbGFuZU1hc2sob2JqZWN0LCBhYWJiLCBwYXJlbnRQbGFuZU1hc2ssIHBsYW5lcykge1xuICAgICAgaWYgKHBhcmVudFBsYW5lTWFzayA9PT0gTWFzay5PVVRTSURFIHx8IHBhcmVudFBsYW5lTWFzayA9PT0gTWFzay5JTlNJREUpIHtcbiAgICAgICAgLy8g54i26IqC54K55a6M5YWo5L2N5LqO6KeG6ZSl5YaF5oiW6ICF5aSW6YOo77yM55u05o6l6L+U5ZueXG4gICAgICAgIHJldHVybiBwYXJlbnRQbGFuZU1hc2s7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IHdpdGggTUFTS19JTlNJREUgKGFsbCB6ZXJvcykgc28gdGhhdCBhZnRlciB0aGUgbG9vcCwgdGhlIHJldHVybiB2YWx1ZSBjYW4gYmUgY29tcGFyZWQgd2l0aCBNQVNLX0lOU0lERS5cbiAgICAgIC8vIChCZWNhdXNlIGlmIHRoZXJlIGFyZSBmZXdlciB0aGFuIDMxIHBsYW5lcywgdGhlIHVwcGVyIGJpdHMgd29udCBiZSBjaGFuZ2VkLilcbiAgICAgIHZhciBtYXNrID0gTWFzay5JTlNJREU7XG4gICAgICB2YXIgaXNTaGFwZTJEID0gc2hhcGUyRC5pbmRleE9mKG9iamVjdC5ub2RlTmFtZSkgPiAtMTtcblxuICAgICAgLy8gVXNlIHZpZXdwb3J0IGN1bGxpbmcgZm9yIDJEIHNoYXBlc1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW50dmlzL2cvaXNzdWVzLzkxNFxuICAgICAgZm9yICh2YXIgayA9IDAsIGxlbiA9IHBsYW5lcy5sZW5ndGg7IGsgPCBsZW47ICsraykge1xuICAgICAgICAvLyBGb3IgayBncmVhdGVyIHRoYW4gMzEgKHNpbmNlIDMxIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBJTlNJREUvSU5URVJTRUNUSU5HIGJpdHMgd2UgY2FuIHN0b3JlKSwgc2tpcCB0aGUgb3B0aW1pemF0aW9uLlxuICAgICAgICB2YXIgZmxhZyA9IDEgPDwgaztcbiAgICAgICAgaWYgKChwYXJlbnRQbGFuZU1hc2sgJiBmbGFnKSA9PT0gMCkge1xuICAgICAgICAgIC8vIOeItuiKgueCueWkhOS6juW9k+WJjemdouWGhemDqO+8jOWPr+S7pei3s+i/h1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBuZWFyICYgZmFyIHBsYW5lcyB3aGVuIHRlc3RpbmcgMkQgc2hhcGVzXG4gICAgICAgIGlmIChpc1NoYXBlMkQgJiYgKGsgPT09IDQgfHwgayA9PT0gNSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHAtdmVydGV4IG4tdmVydGV4IDwtfHBsYW5lIHAtdmVydGV4IG4tdmVydGV4XG4gICAgICAgIC8vIOS9v+eUqCBwLXZlcnRleCDlkowgbi12ZXJ0ZXgg5Yqg6YCf77yM6YG/5YWN6L+b6KGM5bmz6Z2i5ZKMIGFhYmIg5YWo6YOo6aG254K555qE55u45Lqk5qOA5rWLXG4gICAgICAgIHZhciBfcGxhbmVzJGsgPSBwbGFuZXNba10sXG4gICAgICAgICAgbm9ybWFsID0gX3BsYW5lcyRrLm5vcm1hbCxcbiAgICAgICAgICBkaXN0YW5jZSA9IF9wbGFuZXMkay5kaXN0YW5jZTtcbiAgICAgICAgaWYgKHZlYzMuZG90KG5vcm1hbCwgYWFiYi5nZXRQb3NpdGl2ZUZhclBvaW50KHBsYW5lc1trXSkpICsgZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIE1hc2suT1VUU0lERTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVjMy5kb3Qobm9ybWFsLCBhYWJiLmdldE5lZ2F0aXZlRmFyUG9pbnQocGxhbmVzW2tdKSkgKyBkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAvLyDlkozlvZPliY3pnaLnm7jkuqTvvIzlr7nlupTkvY3nva7kuLox77yM57un57ut5qOA5rWL5LiL5LiA5Liq6Z2iXG4gICAgICAgICAgbWFzayB8PSBmbGFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFzaztcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIFByZXBhcmVSZW5kZXJlclBsdWdpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByZXBhcmVSZW5kZXJlclBsdWdpbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJlcGFyZVJlbmRlcmVyUGx1Z2luKTtcbiAgICB0aGlzLnN5bmNUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmlzRmlyc3RUaW1lUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN5bmNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmlyc3RUaW1lUmVuZGVyaW5nRmluaXNoZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFByZXBhcmVSZW5kZXJlclBsdWdpbiwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgX3J1bnRpbWUkZ2xvYmFsVGhpcyRyO1xuICAgICAgdmFyIHJlbmRlcmluZ1NlcnZpY2UgPSBjb250ZXh0LnJlbmRlcmluZ1NlcnZpY2UsXG4gICAgICAgIHJlbmRlcmluZ0NvbnRleHQgPSBjb250ZXh0LnJlbmRlcmluZ0NvbnRleHQsXG4gICAgICAgIHJCdXNoUm9vdCA9IGNvbnRleHQuckJ1c2hSb290O1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmluZ0NvbnRleHQucm9vdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgdGhpcy5yQnVzaCA9IHJCdXNoUm9vdDtcbiAgICAgIHZhciBoYW5kbGVBdHRyaWJ1dGVDaGFuZ2VkID0gZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlQ2hhbmdlZChlKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBlLnRhcmdldDtcbiAgICAgICAgb2JqZWN0LnJlbmRlcmFibGUuZGlydHkgPSB0cnVlO1xuICAgICAgICByZW5kZXJpbmdTZXJ2aWNlLmRpcnRpZnkoKTtcbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlQm91bmRzQ2hhbmdlZCA9IGZ1bmN0aW9uIGhhbmRsZUJvdW5kc0NoYW5nZWQoZSkge1xuICAgICAgICBfdGhpcy5zeW5jVGFza3Muc2V0KGUudGFyZ2V0LCBlLmRldGFpbC5hZmZlY3RDaGlsZHJlbik7XG4gICAgICAgIHJlbmRlcmluZ1NlcnZpY2UuZGlydGlmeSgpO1xuICAgICAgfTtcbiAgICAgIHZhciBoYW5kbGVNb3VudGVkID0gZnVuY3Rpb24gaGFuZGxlTW91bnRlZChlKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKHJ1bnRpbWUuZW5hYmxlU2l6ZUF0dGVudWF0aW9uKSB7XG4gICAgICAgICAgcnVudGltZS5zdHlsZVZhbHVlUmVnaXN0cnkudXBkYXRlU2l6ZUF0dGVudWF0aW9uKG9iamVjdCwgY2FudmFzLmdldENhbWVyYSgpLmdldFpvb20oKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlVW5tb3VudGVkID0gZnVuY3Rpb24gaGFuZGxlVW5tb3VudGVkKGUpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgckJ1c2hOb2RlID0gb2JqZWN0LnJCdXNoTm9kZTtcbiAgICAgICAgaWYgKHJCdXNoTm9kZS5hYWJiKSB7XG4gICAgICAgICAgX3RoaXMuckJ1c2gucmVtb3ZlKHJCdXNoTm9kZS5hYWJiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zeW5jVGFza3NbXCJkZWxldGVcIl0ob2JqZWN0KTtcbiAgICAgICAgcnVudGltZS5zY2VuZUdyYXBoU2VydmljZS5kaXJ0aWZ5VG9Sb290KG9iamVjdCk7XG4gICAgICAgIHJlbmRlcmluZ1NlcnZpY2UuZGlydGlmeSgpO1xuICAgICAgfTtcbiAgICAgIHJlbmRlcmluZ1NlcnZpY2UuaG9va3MuaW5pdC50YXAoUHJlcGFyZVJlbmRlcmVyUGx1Z2luLnRhZywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihFbGVtZW50RXZlbnQuTU9VTlRFRCwgaGFuZGxlTW91bnRlZCk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKEVsZW1lbnRFdmVudC5VTk1PVU5URUQsIGhhbmRsZVVubW91bnRlZCk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKEVsZW1lbnRFdmVudC5BVFRSX01PRElGSUVELCBoYW5kbGVBdHRyaWJ1dGVDaGFuZ2VkKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoRWxlbWVudEV2ZW50LkJPVU5EU19DSEFOR0VELCBoYW5kbGVCb3VuZHNDaGFuZ2VkKTtcbiAgICAgIH0pO1xuICAgICAgcmVuZGVyaW5nU2VydmljZS5ob29rcy5kZXN0cm95LnRhcChQcmVwYXJlUmVuZGVyZXJQbHVnaW4udGFnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKEVsZW1lbnRFdmVudC5NT1VOVEVELCBoYW5kbGVNb3VudGVkKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRWxlbWVudEV2ZW50LlVOTU9VTlRFRCwgaGFuZGxlVW5tb3VudGVkKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRWxlbWVudEV2ZW50LkFUVFJfTU9ESUZJRUQsIGhhbmRsZUF0dHJpYnV0ZUNoYW5nZWQpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFbGVtZW50RXZlbnQuQk9VTkRTX0NIQU5HRUQsIGhhbmRsZUJvdW5kc0NoYW5nZWQpO1xuICAgICAgICBfdGhpcy5zeW5jVGFza3MuY2xlYXIoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJpYyA9IChfcnVudGltZSRnbG9iYWxUaGlzJHIgPSBydW50aW1lLmdsb2JhbFRoaXMucmVxdWVzdElkbGVDYWxsYmFjaykgIT09IG51bGwgJiYgX3J1bnRpbWUkZ2xvYmFsVGhpcyRyICE9PSB2b2lkIDAgPyBfcnVudGltZSRnbG9iYWxUaGlzJHIgOiByYWYuYmluZChydW50aW1lLmdsb2JhbFRoaXMpO1xuICAgICAgcmVuZGVyaW5nU2VydmljZS5ob29rcy5lbmRGcmFtZS50YXAoUHJlcGFyZVJlbmRlcmVyUGx1Z2luLnRhZywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuaXNGaXJzdFRpbWVSZW5kZXJpbmcpIHtcbiAgICAgICAgICBfdGhpcy5pc0ZpcnN0VGltZVJlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLnN5bmNpbmcgPSB0cnVlO1xuICAgICAgICAgIHJpYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zeW5jUlRyZWUodHJ1ZSk7XG4gICAgICAgICAgICBfdGhpcy5pc0ZpcnN0VGltZVJlbmRlcmluZ0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zeW5jUlRyZWUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bmNOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNOb2RlKG5vZGUpIHtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBpZiAoIW5vZGUuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICAgIHZhciByQnVzaE5vZGUgPSBub2RlLnJCdXNoTm9kZTtcblxuICAgICAgLy8gY2xlYXIgZGlydHkgbm9kZVxuICAgICAgaWYgKHJCdXNoTm9kZS5hYWJiKSB0aGlzLnJCdXNoLnJlbW92ZShyQnVzaE5vZGUuYWFiYik7XG4gICAgICB2YXIgcmVuZGVyQm91bmRzID0gbm9kZS5nZXRSZW5kZXJCb3VuZHMoKTtcbiAgICAgIGlmIChyZW5kZXJCb3VuZHMpIHtcbiAgICAgICAgdmFyIHJlbmRlcmFibGUgPSBub2RlLnJlbmRlcmFibGU7XG4gICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgIGlmICghcmVuZGVyYWJsZS5kaXJ0eVJlbmRlckJvdW5kcykge1xuICAgICAgICAgICAgcmVuZGVyYWJsZS5kaXJ0eVJlbmRlckJvdW5kcyA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNhdmUgbGFzdCBkaXJ0eSBhYWJiXG4gICAgICAgICAgcmVuZGVyYWJsZS5kaXJ0eVJlbmRlckJvdW5kcy51cGRhdGUocmVuZGVyQm91bmRzLmNlbnRlciwgcmVuZGVyQm91bmRzLmhhbGZFeHRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3JlbmRlckJvdW5kcyRnZXRNaW4gPSByZW5kZXJCb3VuZHMuZ2V0TWluKCksXG4gICAgICAgICAgX3JlbmRlckJvdW5kcyRnZXRNaW4yID0gX3NsaWNlZFRvQXJyYXkoX3JlbmRlckJvdW5kcyRnZXRNaW4sIDIpLFxuICAgICAgICAgIG1pblggPSBfcmVuZGVyQm91bmRzJGdldE1pbjJbMF0sXG4gICAgICAgICAgbWluWSA9IF9yZW5kZXJCb3VuZHMkZ2V0TWluMlsxXTtcbiAgICAgICAgdmFyIF9yZW5kZXJCb3VuZHMkZ2V0TWF4ID0gcmVuZGVyQm91bmRzLmdldE1heCgpLFxuICAgICAgICAgIF9yZW5kZXJCb3VuZHMkZ2V0TWF4MiA9IF9zbGljZWRUb0FycmF5KF9yZW5kZXJCb3VuZHMkZ2V0TWF4LCAyKSxcbiAgICAgICAgICBtYXhYID0gX3JlbmRlckJvdW5kcyRnZXRNYXgyWzBdLFxuICAgICAgICAgIG1heFkgPSBfcmVuZGVyQm91bmRzJGdldE1heDJbMV07XG4gICAgICAgIGlmICghckJ1c2hOb2RlLmFhYmIpIHtcbiAgICAgICAgICByQnVzaE5vZGUuYWFiYiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJCdXNoTm9kZS5hYWJiLmRpc3BsYXlPYmplY3QgPSBub2RlO1xuICAgICAgICByQnVzaE5vZGUuYWFiYi5taW5YID0gbWluWDtcbiAgICAgICAgckJ1c2hOb2RlLmFhYmIubWluWSA9IG1pblk7XG4gICAgICAgIHJCdXNoTm9kZS5hYWJiLm1heFggPSBtYXhYO1xuICAgICAgICByQnVzaE5vZGUuYWFiYi5tYXhZID0gbWF4WTtcbiAgICAgIH1cbiAgICAgIGlmIChyQnVzaE5vZGUuYWFiYikge1xuICAgICAgICAvLyBUT0RPOiBOYU4gb2NjdXJzIHdoZW4gd2lkdGgvaGVpZ2h0IG9mIFJlY3QgaXMgMFxuICAgICAgICBpZiAoIWlzTmFOKHJCdXNoTm9kZS5hYWJiLm1heFgpICYmICFpc05hTihyQnVzaE5vZGUuYWFiYi5tYXhYKSAmJiAhaXNOYU4ockJ1c2hOb2RlLmFhYmIubWluWCkgJiYgIWlzTmFOKHJCdXNoTm9kZS5hYWJiLm1pblkpKSB7XG4gICAgICAgICAgcmV0dXJuIHJCdXNoTm9kZS5hYWJiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bmNSVHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jUlRyZWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICBpZiAoIWZvcmNlICYmICh0aGlzLnN5bmNpbmcgfHwgdGhpcy5zeW5jVGFza3Muc2l6ZSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zeW5jaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gYm91bmRzIGNoYW5nZWQsIG5lZWQgcmUtaW5zZXJ0aW5nIGl0cyBjaGlsZHJlblxuICAgICAgdmFyIGJ1bGsgPSBbXTtcbiAgICAgIHZhciBzeW5jZWQgPSBuZXcgU2V0KCk7XG4gICAgICB2YXIgc3luYyA9IGZ1bmN0aW9uIHN5bmMobm9kZSkge1xuICAgICAgICBpZiAoIXN5bmNlZC5oYXMobm9kZSkgJiYgbm9kZS5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgdmFyIGFhYmIgPSBfdGhpczIuc3luY05vZGUobm9kZSwgZm9yY2UpO1xuICAgICAgICAgIGlmIChhYWJiKSB7XG4gICAgICAgICAgICBidWxrLnB1c2goYWFiYik7XG4gICAgICAgICAgICBzeW5jZWQuYWRkKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuc3luY1Rhc2tzLmZvckVhY2goZnVuY3Rpb24gKGFmZmVjdENoaWxkcmVuLCBub2RlKSB7XG4gICAgICAgIGlmIChhZmZlY3RDaGlsZHJlbikge1xuICAgICAgICAgIG5vZGUuZm9yRWFjaChzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgIHN5bmMocGFyZW50KTtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIHVzZSBidWxrIGluc2VydGluZywgd2hpY2ggaXMgfjItMyB0aW1lcyBmYXN0ZXJcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjYnVsay1pbnNlcnRpbmctZGF0YVxuICAgICAgdGhpcy5yQnVzaC5sb2FkKGJ1bGspO1xuICAgICAgYnVsay5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5zeW5jaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XSk7XG59KCk7XG5QcmVwYXJlUmVuZGVyZXJQbHVnaW4udGFnID0gJ1ByZXBhcmUnO1xuXG5mdW5jdGlvbiBpc0NhbnZhcyh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZS5kb2N1bWVudDtcbn1cbnZhciBDYW52YXNFdmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQ2FudmFzRXZlbnQpIHtcbiAgQ2FudmFzRXZlbnRbXCJSRUFEWVwiXSA9IFwicmVhZHlcIjtcbiAgQ2FudmFzRXZlbnRbXCJCRUZPUkVfUkVOREVSXCJdID0gXCJiZWZvcmVyZW5kZXJcIjtcbiAgQ2FudmFzRXZlbnRbXCJSRVJFTkRFUlwiXSA9IFwicmVyZW5kZXJcIjtcbiAgQ2FudmFzRXZlbnRbXCJBRlRFUl9SRU5ERVJcIl0gPSBcImFmdGVycmVuZGVyXCI7XG4gIENhbnZhc0V2ZW50W1wiQkVGT1JFX0RFU1RST1lcIl0gPSBcImJlZm9yZWRlc3Ryb3lcIjtcbiAgQ2FudmFzRXZlbnRbXCJBRlRFUl9ERVNUUk9ZXCJdID0gXCJhZnRlcmRlc3Ryb3lcIjtcbiAgQ2FudmFzRXZlbnRbXCJSRVNJWkVcIl0gPSBcInJlc2l6ZVwiO1xuICBDYW52YXNFdmVudFtcIkRJUlRZX1JFQ1RBTkdMRVwiXSA9IFwiZGlydHlyZWN0YW5nbGVcIjtcbiAgQ2FudmFzRXZlbnRbXCJSRU5ERVJFUl9DSEFOR0VEXCJdID0gXCJyZW5kZXJlcmNoYW5nZWRcIjtcbiAgcmV0dXJuIENhbnZhc0V2ZW50O1xufSh7fSk7XG52YXIgREVGQVVMVF9DQU1FUkFfWiA9IDUwMDtcbnZhciBERUZBVUxUX0NBTUVSQV9ORUFSID0gMC4xO1xudmFyIERFRkFVTFRfQ0FNRVJBX0ZBUiA9IDEwMDA7XG5cbi8qKlxuICogcmV1c2UgY3VzdG9tIGV2ZW50IHByZXZlbnRpbmcgZnJvbSByZS1jcmVhdGUgdGhlbSBpbiBldmVyeSBmcmFtZVxuICovXG52YXIgbW91bnRlZEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVsZW1lbnRFdmVudC5NT1VOVEVEKTtcbnZhciB1bm1vdW50ZWRFdmVudCA9IG5ldyBDdXN0b21FdmVudChFbGVtZW50RXZlbnQuVU5NT1VOVEVEKTtcbnZhciBiZWZvcmVSZW5kZXJFdmVudCA9IG5ldyBDdXN0b21FdmVudChDYW52YXNFdmVudC5CRUZPUkVfUkVOREVSKTtcbnZhciByZXJlbmRlckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KENhbnZhc0V2ZW50LlJFUkVOREVSKTtcbnZhciBhZnRlclJlbmRlckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KENhbnZhc0V2ZW50LkFGVEVSX1JFTkRFUik7XG5cbi8qKlxuICogY2FuIGJlIHRyZWF0ZWQgbGlrZSBXaW5kb3cgaW4gRE9NXG4gKiBwcm92aWRlIHNvbWUgZXh0cmEgbWV0aG9kcyBsaWtlIGB3aW5kb3dgLCBzdWNoIGFzOlxuICogKiBgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqICogYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYFxuICpcbiAqIHByb3RvdHlwZSBjaGFpbnM6IENhbnZhcyhXaW5kb3cpIC0+IEV2ZW50VGFyZ2V0XG4gKlxuICogQGRvY3MgaHR0cHM6Ly9nLmFudHYuYW50Z3JvdXAuY29tL2FwaS9jYW52YXMvaW50cm9cbiAqL1xudmFyIENhbnZhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIENhbnZhcyhjb25maWcpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhcyk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhbnZhcyk7XG4gICAgLy8gI3JlZ2lvbiBlbnZpcm9ubWVudFxuICAgIC8qKlxuICAgICAqIHdpbmRvdy5kb2N1bWVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnRcbiAgICAgKi9cbiAgICBfdGhpcy5FbGVtZW50ID0gRGlzcGxheU9iamVjdDtcbiAgICBfdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5jb250ZXh0ID0ge307XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIsXG4gICAgICBjYW52YXMgPSBjb25maWcuY2FudmFzLFxuICAgICAgcmVuZGVyZXIgPSBjb25maWcucmVuZGVyZXIsXG4gICAgICB3aWR0aCA9IGNvbmZpZy53aWR0aCxcbiAgICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQsXG4gICAgICBiYWNrZ3JvdW5kID0gY29uZmlnLmJhY2tncm91bmQsXG4gICAgICBjdXJzb3IgPSBjb25maWcuY3Vyc29yLFxuICAgICAgc3VwcG9ydHNNdXRpcGxlQ2FudmFzZXNJbk9uZUNvbnRhaW5lciA9IGNvbmZpZy5zdXBwb3J0c011dGlwbGVDYW52YXNlc0luT25lQ29udGFpbmVyLFxuICAgICAgX2NvbmZpZyRjbGVhblVwT25EZXN0ID0gY29uZmlnLmNsZWFuVXBPbkRlc3Ryb3ksXG4gICAgICBjbGVhblVwT25EZXN0cm95ID0gX2NvbmZpZyRjbGVhblVwT25EZXN0ID09PSB2b2lkIDAgPyB0cnVlIDogX2NvbmZpZyRjbGVhblVwT25EZXN0LFxuICAgICAgb2Zmc2NyZWVuQ2FudmFzID0gY29uZmlnLm9mZnNjcmVlbkNhbnZhcyxcbiAgICAgIGRldmljZVBpeGVsUmF0aW8gPSBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGNvbmZpZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IGNvbmZpZy5jYW5jZWxBbmltYXRpb25GcmFtZSxcbiAgICAgIGNyZWF0ZUltYWdlID0gY29uZmlnLmNyZWF0ZUltYWdlLFxuICAgICAgc3VwcG9ydHNUb3VjaEV2ZW50cyA9IGNvbmZpZy5zdXBwb3J0c1RvdWNoRXZlbnRzLFxuICAgICAgc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gY29uZmlnLnN1cHBvcnRzUG9pbnRlckV2ZW50cyxcbiAgICAgIGlzVG91Y2hFdmVudCA9IGNvbmZpZy5pc1RvdWNoRXZlbnQsXG4gICAgICBpc01vdXNlRXZlbnQgPSBjb25maWcuaXNNb3VzZUV2ZW50LFxuICAgICAgZGJsQ2xpY2tTcGVlZCA9IGNvbmZpZy5kYmxDbGlja1NwZWVkO1xuICAgIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIGRwciA9IGRldmljZVBpeGVsUmF0aW8gfHwgaXNCcm93c2VyICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgZHByID0gZHByID49IDEgPyBNYXRoLmNlaWwoZHByKSA6IDE7XG5cbiAgICAvLyB1c2UgdXNlci1kZWZpbmVkIDxjYW52YXM+IG9yIE9mZnNjcmVlbkNhbnZhc1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIC8vIGluZmVyIHdpZHRoICYgaGVpZ2h0IHdpdGggZHByXG4gICAgICBjYW52YXNXaWR0aCA9IHdpZHRoIHx8IGdldFdpZHRoKGNhbnZhcykgfHwgY2FudmFzLndpZHRoIC8gZHByO1xuICAgICAgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0IHx8IGdldEhlaWdodChjYW52YXMpIHx8IGNhbnZhcy5oZWlnaHQgLyBkcHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW1wbGVtZW50cyBgV2luZG93YCBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBfdGhpcy5jdXN0b21FbGVtZW50cyA9IG5ldyBDdXN0b21FbGVtZW50UmVnaXN0cnkoKTtcbiAgICBfdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICAgIF90aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gbnVsbCAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IHZvaWQgMCA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHJhZi5iaW5kKHJ1bnRpbWUuZ2xvYmFsVGhpcyk7XG4gICAgX3RoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gbnVsbCAmJiBjYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gdm9pZCAwID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjYWYuYmluZChydW50aW1lLmdsb2JhbFRoaXMpO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgZmVhdHVyZS1kZXRlY3QgZnJvbSBoYW1tZXIuanNcbiAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oYW1tZXJqcy9oYW1tZXIuanMvYmxvYi9tYXN0ZXIvc3JjL2lucHV0anMvaW5wdXQtY29uc3RzLmpzI0w1XG4gICAgX3RoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyA9IHN1cHBvcnRzVG91Y2hFdmVudHMgIT09IG51bGwgJiYgc3VwcG9ydHNUb3VjaEV2ZW50cyAhPT0gdm9pZCAwID8gc3VwcG9ydHNUb3VjaEV2ZW50cyA6ICdvbnRvdWNoc3RhcnQnIGluIHJ1bnRpbWUuZ2xvYmFsVGhpcztcbiAgICBfdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSBzdXBwb3J0c1BvaW50ZXJFdmVudHMgIT09IG51bGwgJiYgc3VwcG9ydHNQb2ludGVyRXZlbnRzICE9PSB2b2lkIDAgPyBzdXBwb3J0c1BvaW50ZXJFdmVudHMgOiAhIXJ1bnRpbWUuZ2xvYmFsVGhpcy5Qb2ludGVyRXZlbnQ7XG4gICAgX3RoaXMuaXNUb3VjaEV2ZW50ID0gaXNUb3VjaEV2ZW50ICE9PSBudWxsICYmIGlzVG91Y2hFdmVudCAhPT0gdm9pZCAwID8gaXNUb3VjaEV2ZW50IDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gX3RoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIHJ1bnRpbWUuZ2xvYmFsVGhpcy5Ub3VjaEV2ZW50O1xuICAgIH07XG4gICAgX3RoaXMuaXNNb3VzZUV2ZW50ID0gaXNNb3VzZUV2ZW50ICE9PSBudWxsICYmIGlzTW91c2VFdmVudCAhPT0gdm9pZCAwID8gaXNNb3VzZUV2ZW50IDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gIXJ1bnRpbWUuZ2xvYmFsVGhpcy5Nb3VzZUV2ZW50IHx8IGV2ZW50IGluc3RhbmNlb2YgcnVudGltZS5nbG9iYWxUaGlzLk1vdXNlRXZlbnQgJiYgKCFfdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgfHwgIShldmVudCBpbnN0YW5jZW9mIHJ1bnRpbWUuZ2xvYmFsVGhpcy5Qb2ludGVyRXZlbnQpKTtcbiAgICB9O1xuXG4gICAgLy8gb3ZlcnJpZGUgaXQgaW4gcnVudGltZVxuICAgIGlmIChvZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJ1bnRpbWUub2Zmc2NyZWVuQ2FudmFzID0gb2Zmc2NyZWVuQ2FudmFzO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBkb2N1bWVudFxuICAgIF90aGlzLmRvY3VtZW50ID0gbmV3IERvY3VtZW50KCk7XG4gICAgX3RoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgPSBfdGhpcztcbiAgICBpZiAoIXN1cHBvcnRzTXV0aXBsZUNhbnZhc2VzSW5PbmVDb250YWluZXIpIHtcbiAgICAgIGNsZWFuRXhpc3RlZENhbnZhcyhjb250YWluZXIsIF90aGlzLCBjbGVhblVwT25EZXN0cm95KTtcbiAgICB9XG4gICAgX3RoaXMuaW5pdFJlbmRlcmluZ0NvbnRleHQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb25maWcpLCB7fSwge1xuICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXNIZWlnaHQsXG4gICAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kICE9PSBudWxsICYmIGJhY2tncm91bmQgIT09IHZvaWQgMCA/IGJhY2tncm91bmQgOiAndHJhbnNwYXJlbnQnLFxuICAgICAgY3Vyc29yOiBjdXJzb3IgIT09IG51bGwgJiYgY3Vyc29yICE9PSB2b2lkIDAgPyBjdXJzb3IgOiAnZGVmYXVsdCcsXG4gICAgICBjbGVhblVwT25EZXN0cm95OiBjbGVhblVwT25EZXN0cm95LFxuICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogZHByLFxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBfdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogX3RoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUsXG4gICAgICBzdXBwb3J0c1RvdWNoRXZlbnRzOiBfdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzLFxuICAgICAgc3VwcG9ydHNQb2ludGVyRXZlbnRzOiBfdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMsXG4gICAgICBpc1RvdWNoRXZlbnQ6IF90aGlzLmlzVG91Y2hFdmVudCxcbiAgICAgIGlzTW91c2VFdmVudDogX3RoaXMuaXNNb3VzZUV2ZW50LFxuICAgICAgZGJsQ2xpY2tTcGVlZDogZGJsQ2xpY2tTcGVlZCAhPT0gbnVsbCAmJiBkYmxDbGlja1NwZWVkICE9PSB2b2lkIDAgPyBkYmxDbGlja1NwZWVkIDogMjAwLFxuICAgICAgY3JlYXRlSW1hZ2U6IGNyZWF0ZUltYWdlICE9PSBudWxsICYmIGNyZWF0ZUltYWdlICE9PSB2b2lkIDAgPyBjcmVhdGVJbWFnZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgX3RoaXMuaW5pdERlZmF1bHRDYW1lcmEoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgcmVuZGVyZXIuY2xpcFNwYWNlTmVhclopO1xuICAgIF90aGlzLmluaXRSZW5kZXJlcihyZW5kZXJlciwgdHJ1ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhDYW52YXMsIF9FdmVudFRhcmdldCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ2FudmFzLCBbe1xuICAgIGtleTogXCJpbml0UmVuZGVyaW5nQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UmVuZGVyaW5nQ29udGV4dChtZXJnZWRDb25maWcpIHtcbiAgICAgIHRoaXMuY29udGV4dC5jb25maWcgPSBtZXJnZWRDb25maWc7XG5cbiAgICAgIC8vIGJpbmQgcmVuZGVyaW5nIGNvbnRleHQsIHNoYXJlZCBieSBhbGwgcmVuZGVyZXJzXG4gICAgICB0aGlzLmNvbnRleHQucmVuZGVyaW5nQ29udGV4dCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSByb290IG5vZGUgaW4gc2NlbmUgZ3JhcGhcbiAgICAgICAgICovXG4gICAgICAgIHJvb3Q6IHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICByZW5kZXJMaXN0Q3VycmVudEZyYW1lOiBbXSxcbiAgICAgICAgdW5jdWxsZWRFbnRpdGllczogW10sXG4gICAgICAgIHJlbmRlclJlYXNvbnM6IG5ldyBTZXQoKSxcbiAgICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgICBkaXJ0eTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXREZWZhdWx0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXREZWZhdWx0Q2FtZXJhKHdpZHRoLCBoZWlnaHQsIGNsaXBTcGFjZU5lYXJaKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIHNldCBhIGRlZmF1bHQgb3J0aG8gY2FtZXJhXG4gICAgICB2YXIgY2FtZXJhID0gbmV3IHJ1bnRpbWUuQ2FtZXJhQ29udHJpYnV0aW9uKCk7XG4gICAgICBjYW1lcmEuY2xpcFNwYWNlTmVhclogPSBjbGlwU3BhY2VOZWFyWjtcbiAgICAgIGNhbWVyYS5zZXRUeXBlKENhbWVyYVR5cGUuRVhQTE9SSU5HLCBDYW1lcmFUcmFja2luZ01vZGUuREVGQVVMVCkuc2V0UG9zaXRpb24od2lkdGggLyAyLCBoZWlnaHQgLyAyLCBERUZBVUxUX0NBTUVSQV9aKS5zZXRGb2NhbFBvaW50KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgMCkuc2V0T3J0aG9ncmFwaGljKHdpZHRoIC8gLTIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgaGVpZ2h0IC8gLTIsIERFRkFVTFRfQ0FNRVJBX05FQVIsIERFRkFVTFRfQ0FNRVJBX0ZBUik7XG5cbiAgICAgIC8vIGtlZXAgcmVmIHNpbmNlIGl0IHdpbGwgdXNlIHJhZiBpbiBjYW1lcmEgYW5pbWF0aW9uXG4gICAgICBjYW1lcmEuY2FudmFzID0gdGhpcztcblxuICAgICAgLy8gcmVkcmF3IHdoZW4gY2FtZXJhIGNoYW5nZWRcbiAgICAgIGNhbWVyYS5ldmVudEVtaXR0ZXIub24oQ2FtZXJhRXZlbnQuVVBEQVRFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuY29udGV4dC5yZW5kZXJpbmdDb250ZXh0LnJlbmRlclJlYXNvbnMuYWRkKFJlbmRlclJlYXNvbi5DQU1FUkFfQ0hBTkdFRCk7XG4gICAgICAgIGlmIChydW50aW1lLmVuYWJsZVNpemVBdHRlbnVhdGlvbiAmJiBfdGhpczIuZ2V0Q29uZmlnKCkucmVuZGVyZXIuZ2V0Q29uZmlnKCkuZW5hYmxlU2l6ZUF0dGVudWF0aW9uKSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZVNpemVBdHRlbnVhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gYmluZCBjYW1lcmFcbiAgICAgIHRoaXMuY29udGV4dC5jYW1lcmEgPSBjYW1lcmE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNpemVBdHRlbnVhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaXplQXR0ZW51YXRpb24oKSB7XG4gICAgICB2YXIgem9vbSA9IHRoaXMuZ2V0Q2FtZXJhKCkuZ2V0Wm9vbSgpO1xuICAgICAgdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBydW50aW1lLnN0eWxlVmFsdWVSZWdpc3RyeS51cGRhdGVTaXplQXR0ZW51YXRpb24obm9kZSwgem9vbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcm9vdCBkaXNwbGF5T2JqZWN0IGluIHNjZW5lZ3JhcGhcbiAgICAgKiBAYWxpYXMgdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRSb290XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjYW1lcmEgb2YgY2FudmFzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbWVyYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY2FtZXJhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0U2VydmljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0U2VydmljZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29udGV4dFNlcnZpY2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEV2ZW50U2VydmljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFdmVudFNlcnZpY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmV2ZW50U2VydmljZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVuZGVyaW5nU2VydmljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW5kZXJpbmdTZXJ2aWNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZW5kZXJpbmdTZXJ2aWNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZW5kZXJpbmdDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlcmluZ0NvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJlbmRlcmluZ0NvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyaW5nU2VydmljZSgpLmdldFN0YXRzKCk7XG4gICAgfVxuXG4gICAgLy8gLyoqXG4gICAgLy8gICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvV2luZG93L2dldENvbXB1dGVkU3R5bGVcbiAgICAvLyAgKi9cbiAgICAvLyBnZXRDb21wdXRlZFN0eWxlKG5vZGU6IERpc3BsYXlPYmplY3QpIHtcbiAgICAvLyAgIHJldHVybiBub2RlLmNvbXB1dGVkU3R5bGU7XG4gICAgLy8gfVxuICB9LCB7XG4gICAga2V5OiBcInJlYWR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5yZWFkeVByb21pc2UpIHtcbiAgICAgICAgdGhpcy5yZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIF90aGlzMy5yZXNvbHZlUmVhZHlQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfdGhpczMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pbml0ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlc29sdmVSZWFkeVByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjbGVhblVwIC0gd2hldGhlciB0byBjbGVhbiB1cCBhbGwgdGhlIGludGVybmFsIHNlcnZpY2VzIG9mIENhbnZhc1xuICAgICAqIEBwYXJhbSBza2lwVHJpZ2dlckV2ZW50IC0gd2hldGhlciB0byBza2lwIHRyaWdnZXIgZGVzdHJveSBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBjbGVhblVwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdmFyIHNraXBUcmlnZ2VyRXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIG1lbW9pemUuY2xlYXJDYWNoZSgpO1xuICAgICAgaWYgKCFza2lwVHJpZ2dlckV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoQ2FudmFzRXZlbnQuQkVGT1JFX0RFU1RST1kpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYW1lSWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgfVxuXG4gICAgICAvLyB1bm1vdW50IGFsbCBjaGlsZHJlblxuICAgICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcbiAgICAgIGlmIChjbGVhblVwKSB7XG4gICAgICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHJvb3QpO1xuICAgICAgICAvLyBkZXN0cm95IERvY3VtZW50XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmdldEV2ZW50U2VydmljZSgpLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVzdHJveSBzZXJ2aWNlc1xuICAgICAgdGhpcy5nZXRSZW5kZXJpbmdTZXJ2aWNlKCkuZGVzdHJveSgpO1xuICAgICAgdGhpcy5nZXRDb250ZXh0U2VydmljZSgpLmRlc3Ryb3koKTtcblxuICAgICAgLy8gY2xlYXIgcm9vdCBhZnRlciByZW5kZXIgc2VydmljZSBkZXN0cm95ZWRcbiAgICAgIGlmICh0aGlzLmNvbnRleHQuckJ1c2hSb290KSB7XG4gICAgICAgIC8vIGNsZWFyIHJidXNoXG4gICAgICAgIHRoaXMuY29udGV4dC5yQnVzaFJvb3QuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcFRyaWdnZXJFdmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KENhbnZhc0V2ZW50LkFGVEVSX0RFU1RST1kpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbGVhckV2ZW50UmV0YWluID0gZnVuY3Rpb24gY2xlYXJFdmVudFJldGFpbihldmVudCkge1xuICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgZXZlbnQubWFuYWdlciA9IG51bGw7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgICAgIGV2ZW50LnJlbGF0ZWROb2RlID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjbGVhckV2ZW50UmV0YWluKG1vdW50ZWRFdmVudCk7XG4gICAgICBjbGVhckV2ZW50UmV0YWluKHVubW91bnRlZEV2ZW50KTtcbiAgICAgIGNsZWFyRXZlbnRSZXRhaW4oYmVmb3JlUmVuZGVyRXZlbnQpO1xuICAgICAgY2xlYXJFdmVudFJldGFpbihyZXJlbmRlckV2ZW50KTtcbiAgICAgIGNsZWFyRXZlbnRSZXRhaW4oYWZ0ZXJSZW5kZXJFdmVudCk7XG4gICAgICBjbGVhckV2ZW50UmV0YWluKGF0dHJNb2RpZmllZEV2ZW50KTtcbiAgICAgIGNsZWFyRXZlbnRSZXRhaW4oaW5zZXJ0ZWRFdmVudCk7XG4gICAgICBjbGVhckV2ZW50UmV0YWluKHJlbW92ZWRFdmVudCk7XG4gICAgICBjbGVhckV2ZW50UmV0YWluKGRlc3Ryb3lFdmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcGF0aWJsZSB3aXRoIEcgMy4wXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYWxpYXMgcmVzaXplXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbmdlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIHVwZGF0ZSBjYW52YXMnIGNvbmZpZ1xuICAgICAgdmFyIGNhbnZhc0NvbmZpZyA9IHRoaXMuY29udGV4dC5jb25maWc7XG4gICAgICBjYW52YXNDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhc0NvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIC8vIHJlc2l6ZSBjb250ZXh0XG4gICAgICB0aGlzLmdldENvbnRleHRTZXJ2aWNlKCkucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAvLyByZXNpemUgY2FtZXJhXG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5jb250ZXh0LmNhbWVyYTtcbiAgICAgIHZhciBwcm9qZWN0aW9uTW9kZSA9IGNhbWVyYS5nZXRQcm9qZWN0aW9uTW9kZSgpO1xuICAgICAgY2FtZXJhLnNldFBvc2l0aW9uKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgREVGQVVMVF9DQU1FUkFfWikuc2V0Rm9jYWxQb2ludCh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDApO1xuICAgICAgaWYgKHByb2plY3Rpb25Nb2RlID09PSBDYW1lcmFQcm9qZWN0aW9uTW9kZS5PUlRIT0dSQVBISUMpIHtcbiAgICAgICAgY2FtZXJhLnNldE9ydGhvZ3JhcGhpYyh3aWR0aCAvIC0yLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIGhlaWdodCAvIC0yLCBjYW1lcmEuZ2V0TmVhcigpLCBjYW1lcmEuZ2V0RmFyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FtZXJhLnNldEFzcGVjdCh3aWR0aCAvIGhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KENhbnZhc0V2ZW50LlJFU0laRSwge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gcHJveHkgdG8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQ2hpbGQoY2hpbGQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdDaGlsZCwgcmVmQ2hpbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIHJlZkNoaWxkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjaGlsZHJlbiB3aGljaCBjYW4gYmUgYXBwZW5kZWQgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBsYXRlciBhZ2Fpbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbigpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZGVzdHJveSBhbGwgY2hpbGRyZW4gd2hpY2ggY2FuIG5vdCBiZSBhcHBlbmRlZCB0byBpdHMgb3JpZ2luYWwgcGFyZW50IGxhdGVyIGFnYWluLlxuICAgICAqIEJ1dCB0aGUgY2FudmFzIHJlbWFpbnMgcnVubmluZyB3aGljaCBtZWFucyBkaXNwbGF5IG9iamVjdHMgY2FuIGJlIGFwcGVuZGVkIGxhdGVyLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95Q2hpbGRyZW4oKSB7XG4gICAgICB0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXN0cm95Q2hpbGRyZW4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihmcmFtZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAvLyBjb25zb2xlLmxvZygncmVuZGVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBiZWZvcmVSZW5kZXJFdmVudC5kZXRhaWwgPSBmcmFtZTtcbiAgICAgICAgYWZ0ZXJSZW5kZXJFdmVudC5kZXRhaWwgPSBmcmFtZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChiZWZvcmVSZW5kZXJFdmVudCk7XG4gICAgICB2YXIgcmVuZGVyaW5nU2VydmljZSA9IHRoaXMuZ2V0UmVuZGVyaW5nU2VydmljZSgpO1xuICAgICAgcmVuZGVyaW5nU2VydmljZS5yZW5kZXIodGhpcy5nZXRDb25maWcoKSwgZnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBhY3R1YWwgcmVyZW5kZXIgZXZlbnRcbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW50dmlzL0cvaXNzdWVzLzEyNjhcbiAgICAgICAgX3RoaXM0LmRpc3BhdGNoRXZlbnQocmVyZW5kZXJFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChhZnRlclJlbmRlckV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIF90aWNrID0gZnVuY3Rpb24gdGljayh0aW1lLCBmcmFtZSkge1xuICAgICAgICBfdGhpczUucmVuZGVyKGZyYW1lKTtcbiAgICAgICAgX3RoaXM1LmZyYW1lSWQgPSBfdGhpczUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aWNrKTtcbiAgICAgIH07XG4gICAgICBfdGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0UmVuZGVyZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBmaXJzdENvbnRlbnRmdWxsUGFpbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVyIGlzIHJlcXVpcmVkLicpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldFxuICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBGSVhNRTogc2hvdWxkIHJlLWNyZWF0ZSBoZXJlP1xuICAgICAgdGhpcy5jb250ZXh0LnJCdXNoUm9vdCA9IG5ldyBSQnVzaCgpO1xuXG4gICAgICAvLyByZXNldCByZW5kZXJpbmcgcGx1Z2luc1xuICAgICAgdGhpcy5jb250ZXh0LnJlbmRlcmluZ1BsdWdpbnMgPSBbXTtcbiAgICAgIHRoaXMuY29udGV4dC5yZW5kZXJpbmdQbHVnaW5zLnB1c2gobmV3IEV2ZW50UGx1Z2luKCksIG5ldyBQcmVwYXJlUmVuZGVyZXJQbHVnaW4oKSxcbiAgICAgIC8vIG5ldyBEaXJ0eUNoZWNrUGx1Z2luKCksXG4gICAgICBuZXcgQ3VsbGluZ1BsdWdpbihbbmV3IEZydXN0dW1DdWxsaW5nU3RyYXRlZ3koKV0pKTtcblxuICAgICAgLy9cbiAgICAgIHRoaXMubG9hZFJlbmRlcmVyQ29udGFpbmVyTW9kdWxlKHJlbmRlcmVyKTtcblxuICAgICAgLy8gaW5pdCBjb250ZXh0IHNlcnZpY2VcbiAgICAgIHRoaXMuY29udGV4dC5jb250ZXh0U2VydmljZSA9IG5ldyB0aGlzLmNvbnRleHQuQ29udGV4dFNlcnZpY2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBydW50aW1lKSwgdGhpcy5jb250ZXh0KSk7XG5cbiAgICAgIC8vIGluaXQgcmVuZGVyaW5nIHNlcnZpY2VcbiAgICAgIHRoaXMuY29udGV4dC5yZW5kZXJpbmdTZXJ2aWNlID0gbmV3IFJlbmRlcmluZ1NlcnZpY2UocnVudGltZSwgdGhpcy5jb250ZXh0KTtcblxuICAgICAgLy8gaW5pdCBldmVudCBzZXJ2aWNlXG4gICAgICB0aGlzLmNvbnRleHQuZXZlbnRTZXJ2aWNlID0gbmV3IEV2ZW50U2VydmljZShydW50aW1lLCB0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5jb250ZXh0LmV2ZW50U2VydmljZS5pbml0KCk7XG4gICAgICBpZiAodGhpcy5jb250ZXh0LmNvbnRleHRTZXJ2aWNlLmluaXQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNvbnRleHRTZXJ2aWNlLmluaXQoKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyaW5nU2VydmljZShyZW5kZXJlciwgZmlyc3RDb250ZW50ZnVsbFBhaW50LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5jb250ZXh0U2VydmljZS5pbml0QXN5bmMoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYuaW5pdFJlbmRlcmluZ1NlcnZpY2UocmVuZGVyZXIsIGZpcnN0Q29udGVudGZ1bGxQYWludCk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRSZW5kZXJpbmdTZXJ2aWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRSZW5kZXJpbmdTZXJ2aWNlKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgIHZhciBmaXJzdENvbnRlbnRmdWxsUGFpbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGFzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHRoaXMuY29udGV4dC5yZW5kZXJpbmdTZXJ2aWNlLmluaXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczcuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZpcnN0Q29udGVudGZ1bGxQYWludCkge1xuICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgX3RoaXM3LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzNy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChDYW52YXNFdmVudC5SRUFEWSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChDYW52YXNFdmVudC5SRUFEWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczcuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoQ2FudmFzRXZlbnQuUkVOREVSRVJfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczcucmVhZHlQcm9taXNlKSB7XG4gICAgICAgICAgX3RoaXM3LnJlc29sdmVSZWFkeVByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpcnN0Q29udGVudGZ1bGxQYWludCkge1xuICAgICAgICAgIF90aGlzNy5nZXRSb290KCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBub2RlLFxuICAgICAgICAgICAgICByZW5kZXJhYmxlID0gX3JlZi5yZW5kZXJhYmxlO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZS5yZW5kZXJCb3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUuYm91bmRzRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICByZW5kZXJhYmxlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgY3VycmVudCBzY2VuZWdyYXBoIHVuY2hhbmdlZCwganVzdCB0cmlnZ2VyIG1vdW50ZWQgZXZlbnRcbiAgICAgICAgX3RoaXM3Lm1vdW50Q2hpbGRyZW4oX3RoaXM3LmdldFJvb3QoKSk7XG4gICAgICAgIGlmIChyZW5kZXJlci5nZXRDb25maWcoKS5lbmFibGVBdXRvUmVuZGVyaW5nKSB7XG4gICAgICAgICAgX3RoaXM3LnJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFJlbmRlcmVyQ29udGFpbmVyTW9kdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRSZW5kZXJlckNvbnRhaW5lck1vZHVsZShyZW5kZXJlcikge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICAvLyBsb2FkIG90aGVyIGNvbnRhaW5lciBtb2R1bGVzIHByb3ZpZGVkIGJ5IGctY2FudmFzL2ctc3ZnL2ctd2ViZ2xcbiAgICAgIHZhciBwbHVnaW5zID0gcmVuZGVyZXIuZ2V0UGx1Z2lucygpO1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcGx1Z2luLmNvbnRleHQgPSBfdGhpczguY29udGV4dDtcbiAgICAgICAgcGx1Z2luLmluaXQocnVudGltZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UmVuZGVyZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgIC8vIHVwZGF0ZSBjYW52YXMnIGNvbmZpZ1xuICAgICAgdmFyIGNhbnZhc0NvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICBpZiAoY2FudmFzQ29uZmlnLnJlbmRlcmVyID09PSByZW5kZXJlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2xkUmVuZGVyZXIgPSBjYW52YXNDb25maWcucmVuZGVyZXI7XG4gICAgICBjYW52YXNDb25maWcucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgICAgLy8ga2VlcCBhbGwgY2hpbGRyZW4gdW5kZXN0cm95ZWRcbiAgICAgIHRoaXMuZGVzdHJveShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgIC8vIGRlc3Ryb3kgYWxsIHBsdWdpbnMsIHJldmVyc2Ugd2lsbCBtdXRhdGUgb3JpZ2luIGFycmF5XG4gICAgICBfdG9Db25zdW1hYmxlQXJyYXkoKG9sZFJlbmRlcmVyID09PSBudWxsIHx8IG9sZFJlbmRlcmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRSZW5kZXJlci5nZXRQbHVnaW5zKCkpIHx8IFtdKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHBsdWdpbi5kZXN0cm95KHJ1bnRpbWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmluaXRSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgICB2YXIgY2FudmFzQ29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgIGNhbnZhc0NvbmZpZy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICB0aGlzLmdldENvbnRleHRTZXJ2aWNlKCkuYXBwbHlDdXJzb3JTdHlsZShjdXJzb3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bm1vdW50Q2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5tb3VudENoaWxkcmVuKHBhcmVudCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgICAvLyB1bm1vdW50Q2hpbGRyZW4gcmVjdXJzaXZlbHlcbiAgICAgIHBhcmVudC5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIF90aGlzOS51bm1vdW50Q2hpbGRyZW4oY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pbml0ZWQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5pc011dGF0aW9uT2JzZXJ2ZWQpIHtcbiAgICAgICAgICBwYXJlbnQuZGlzcGF0Y2hFdmVudCh1bm1vdW50ZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5tb3VudGVkRXZlbnQudGFyZ2V0ID0gcGFyZW50O1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh1bm1vdW50ZWRFdmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2lwIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIHBhcmVudC5vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBhZnRlciB1bm1vdW50ZWRcbiAgICAgIGlmIChwYXJlbnQuaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICBwYXJlbnQuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VudENoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50Q2hpbGRyZW4oY2hpbGQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgIHZhciBza2lwVHJpZ2dlckV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpc0luRnJhZ21lbnQoY2hpbGQpO1xuICAgICAgaWYgKHRoaXMuaW5pdGVkKSB7XG4gICAgICAgIGlmICghY2hpbGQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICBjaGlsZC5vd25lckRvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgICBjaGlsZC5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFza2lwVHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNNdXRhdGlvbk9ic2VydmVkKSB7XG4gICAgICAgICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQobW91bnRlZEV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1vdW50ZWRFdmVudC50YXJnZXQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG1vdW50ZWRFdmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbZ106IFlvdSBhcmUgdHJ5aW5nIHRvIGNhbGwgYGNhbnZhcy5hcHBlbmRDaGlsZGAgYmVmb3JlIGNhbnZhcycgaW5pdGlhbGl6YXRpb24gZmluaXNoZWQuIFlvdSBjYW4gZWl0aGVyIGF3YWl0IGBjYW52YXMucmVhZHlgIG9yIGxpc3RlbiB0byBgQ2FudmFzRXZlbnQuUkVBRFlgIG1hbnVhbGx5LlwiLCAnYXBwZW5kZWQgY2hpbGQ6ICcsIGNoaWxkLm5vZGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVjdXJzaXZlbHkgbW91bnQgY2hpbGRyZW5cbiAgICAgIGNoaWxkLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBfdGhpczEwLm1vdW50Q2hpbGRyZW4oYywgc2tpcFRyaWdnZXJFdmVudCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gdHJpZ2dlciBhZnRlciBtb3VudGVkXG4gICAgICBpZiAoY2hpbGQuaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgIGlmIChjaGlsZC5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgIGNoaWxkLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91bnRGcmFnbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VudEZyYWdtZW50KGNoaWxkKSB7XG4gICAgICB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGQsIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xpZW50MlZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWVudDJWaWV3cG9ydChjbGllbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50U2VydmljZSgpLmNsaWVudDJWaWV3cG9ydChjbGllbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3cG9ydDJDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlld3BvcnQyQ2xpZW50KGNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnRTZXJ2aWNlKCkudmlld3BvcnQyQ2xpZW50KGNhbnZhcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0MkNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3cG9ydDJDYW52YXModmlld3BvcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50U2VydmljZSgpLnZpZXdwb3J0MkNhbnZhcyh2aWV3cG9ydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbnZhczJWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXMyVmlld3BvcnQoY2FudmFzKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFdmVudFNlcnZpY2UoKS5jYW52YXMyVmlld3BvcnQoY2FudmFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBhbGlhcyBjbGllbnQyVmlld3BvcnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludEJ5Q2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50QnlDbGllbnQoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50MlZpZXdwb3J0KHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYWxpYXMgdmlld3BvcnQyQ2xpZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpZW50QnlQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRCeVBvaW50KHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0MkNsaWVudCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufShFdmVudFRhcmdldCk7XG5cbmV4cG9ydCB7IEFBQkIsIEFic3RyYWN0UmVuZGVyZXIsIEFic3RyYWN0UmVuZGVyZXJQbHVnaW4sIEJVSUxUX0lOX1BST1BFUlRJRVMsIENTUywgQ1NTR3JhZGllbnRWYWx1ZSwgQ1NTS2V5d29yZFZhbHVlLCBDU1NSR0IsIENTU1N0eWxlVmFsdWUsIENTU1VuaXRWYWx1ZSwgQ2FtZXJhLCBDYW1lcmFFdmVudCwgQ2FtZXJhUHJvamVjdGlvbk1vZGUsIENhbWVyYVRyYWNraW5nTW9kZSwgQ2FtZXJhVHlwZSwgQ2FudmFzLCBDYW52YXNFdmVudCwgQ2lyY2xlLCBDaXJjbGVVcGRhdGVyLCBDbGlwU3BhY2VOZWFyWiwgQ3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LCBDdXN0b21FdmVudCwgRGVmYXVsdFNjZW5lR3JhcGhTZWxlY3RvciwgRGVmYXVsdFNjZW5lR3JhcGhTZXJ2aWNlLCBEaXNwbGF5T2JqZWN0LCBEb2N1bWVudCwgRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsIEVsZW1lbnQsIEVsZW1lbnRFdmVudCwgRWxsaXBzZSwgRWxsaXBzZVVwZGF0ZXIsIEV2ZW50U2VydmljZSwgRXZlbnRUYXJnZXQsIEZlZGVyYXRlZEV2ZW50LCBGZWRlcmF0ZWRNb3VzZUV2ZW50LCBGZWRlcmF0ZWRQb2ludGVyRXZlbnQsIEZlZGVyYXRlZFdoZWVsRXZlbnQsIEZyYWdtZW50LCBGcnVzdHVtLCBHcmFkaWVudFR5cGUsIEdyb3VwLCBHcm91cFVwZGF0ZXIsIEhUTUwsIEhUTUxVcGRhdGVyLCBJbWFnZSwgTGluZSwgTGluZVVwZGF0ZXIsIE1hc2ssIE11dGF0aW9uRXZlbnQsIE5vZGUsIE9mZnNjcmVlbkNhbnZhc0NyZWF0b3IsIFBhdGgsIFBhdGhVcGRhdGVyLCBQbGFuZSwgUG9pbnQsIFBvbHlnb24sIFBvbHlsaW5lLCBQb2x5bGluZVVwZGF0ZXIsIFByb3BlcnR5U3ludGF4LCBSQnVzaCwgUmVjdCwgUmVjdFVwZGF0ZXIsIFJlY3RhbmdsZSwgUmVuZGVyUmVhc29uLCBSZW5kZXJpbmdTZXJ2aWNlLCBTaGFwZSwgU29ydFJlYXNvbiwgU3RyYXRlZ3ksIFRleHQsIFRleHRTZXJ2aWNlLCBUZXh0VXBkYXRlciwgVW5pdFR5cGUsIGF0dHJNb2RpZmllZEV2ZW50LCBjb21wdXRlTGluZWFyR3JhZGllbnQsIGNvbXB1dGVSYWRpYWxHcmFkaWVudCwgY29udmVydFRvUGF0aCwgY3JlYXRlVmVjMywgZGVjb21wb3NlLCBkZWZpbmVkUHJvcHMsIGRlZzJyYWQsIGRlZzJ0dXJuLCBkZXN0cm95RXZlbnQsIGZpbmRDbG9zZXN0Q2xpcFBhdGhUYXJnZXQsIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUsIGdldEFuZ2xlLCBnZXRFdWxlciwgZ2V0T3JDYWxjdWxhdGVQYXRoVG90YWxMZW5ndGgsIGdyYWQyZGVnLCBpbnNlcnRlZEV2ZW50LCBpc0Jyb3dzZXIsIGlzQ1NTR3JhZGllbnRWYWx1ZSwgaXNDU1NSR0IsIGlzQ2FudmFzLCBpc0Rpc3BsYXlPYmplY3QsIGlzRmVkZXJhdGVkRXZlbnQsIGlzRmlsbE9yU3Ryb2tlQWZmZWN0ZWQsIGlzUGF0dGVybiwgbWVyZ2VDb2xvcnMsIHBhcnNlQ29sb3IsIHBhcnNlTGVuZ3RoLCBwYXJzZVBhdGgsIHBhcnNlVHJhbnNmb3JtLCBwYXJzZWRUcmFuc2Zvcm1Ub01hdDQsIHByb3BlcnR5TWV0YWRhdGFDYWNoZSwgcmFkMmRlZywgcmVtb3ZlZEV2ZW50LCByZXNldEVudGl0eUNvdW50ZXIsIHJ1bnRpbWUsIHNldERPTVNpemUsIHRyYW5zbGF0ZVBhdGhUb1N0cmluZywgdHVybjJkZWcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfb2JqZWN0U3ByZWFkIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NyZWF0ZUNsYXNzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2NhbGxTdXBlciIsIl9pbmhlcml0cyIsIl9zbGljZWRUb0FycmF5IiwiRXZlbnRFbWl0dGVyIiwidmVjMyIsInZlYzQiLCJtYXQ0IiwibWF0MyIsInF1YXQiLCJxdWF0JDEiLCJ2ZWMyIiwiaXNOdW1iZXIiLCJkaXN0YW5jZVNxdWFyZVJvb3QiLCJpc1N0cmluZyIsImlzTmlsIiwiY2xhbXAiLCJnZXRUb3RhbExlbmd0aCIsIm1pbiIsIm1heCIsImlzTnVtYmVyRXF1YWwiLCJtb2QiLCJub3JtYWxpemVQYXRoIiwicGF0aDJDdXJ2ZSIsImVxdWFsaXplU2VnbWVudHMiLCJnZXREcmF3RGlyZWN0aW9uIiwicmV2ZXJzZUN1cnZlIiwiY2xvbmVQYXRoIiwiZ2V0Um90YXRlZEN1cnZlIiwiaXNVbmRlZmluZWQiLCJpc0FycmF5IiwiaXNCb29sZWFuIiwiaXNGdW5jdGlvbiIsImlzT2JqZWN0IiwiZ2V0UG9pbnRBdExlbmd0aCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9zdXBlclByb3BHZXQiLCJwb2x5bGluZUxlbmd0aCIsImFyY0JveCIsImN1YmljQm94IiwicXVhZEJveCIsImxpbmVQb2ludEF0IiwibGluZUxlbmd0aCIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsInJidXNoIiwiZXhwb3J0cyIsIm1vZHVsZSIsImZhY3RvcnkiLCJxdWlja3NlbGVjdCIsImFyciIsImsiLCJsZWZ0IiwicmlnaHQiLCJjb21wYXJlIiwicXVpY2tzZWxlY3RTdGVwIiwibGVuZ3RoIiwiZGVmYXVsdENvbXBhcmUiLCJuIiwibSIsInoiLCJNYXRoIiwibG9nIiwicyIsImV4cCIsInNkIiwic3FydCIsIm5ld0xlZnQiLCJmbG9vciIsIm5ld1JpZ2h0IiwidCIsImkiLCJqIiwic3dhcCIsInRtcCIsImEiLCJiIiwiUkJ1c2giLCJtYXhFbnRyaWVzIiwiX21heEVudHJpZXMiLCJfbWluRW50cmllcyIsImNlaWwiLCJjbGVhciIsInByb3RvdHlwZSIsImFsbCIsIl9hbGwiLCJkYXRhIiwic2VhcmNoIiwiYmJveCIsIm5vZGUiLCJyZXN1bHQiLCJpbnRlcnNlY3RzIiwidG9CQm94Iiwibm9kZXNUb1NlYXJjaCIsImNoaWxkcmVuIiwiY2hpbGQiLCJjaGlsZEJCb3giLCJsZWFmIiwicHVzaCIsImNvbnRhaW5zIiwicG9wIiwiY29sbGlkZXMiLCJsb2FkIiwiaW5zZXJ0IiwiX2J1aWxkIiwic2xpY2UiLCJoZWlnaHQiLCJfc3BsaXRSb290IiwidG1wTm9kZSIsIl9pbnNlcnQiLCJpdGVtIiwiY3JlYXRlTm9kZSIsInJlbW92ZSIsImVxdWFsc0ZuIiwicGF0aCIsImluZGV4ZXMiLCJwYXJlbnQiLCJnb2luZ1VwIiwiaW5kZXgiLCJmaW5kSXRlbSIsInNwbGljZSIsIl9jb25kZW5zZSIsImNvbXBhcmVNaW5YIiwibWluWCIsImNvbXBhcmVNaW5ZIiwibWluWSIsInRvSlNPTiIsImZyb21KU09OIiwiYXBwbHkiLCJpdGVtcyIsIk4iLCJNIiwiY2FsY0JCb3giLCJwb3ciLCJOMiIsIk4xIiwibXVsdGlTZWxlY3QiLCJyaWdodDIiLCJyaWdodDMiLCJfY2hvb3NlU3VidHJlZSIsImxldmVsIiwibWluQXJlYSIsIkluZmluaXR5IiwibWluRW5sYXJnZW1lbnQiLCJ0YXJnZXROb2RlIiwiYXJlYSIsImJib3hBcmVhIiwiZW5sYXJnZW1lbnQiLCJlbmxhcmdlZEFyZWEiLCJpc05vZGUiLCJpbnNlcnRQYXRoIiwiZXh0ZW5kIiwiX3NwbGl0IiwiX2FkanVzdFBhcmVudEJCb3hlcyIsIl9jaG9vc2VTcGxpdEF4aXMiLCJzcGxpdEluZGV4IiwiX2Nob29zZVNwbGl0SW5kZXgiLCJuZXdOb2RlIiwibWluT3ZlcmxhcCIsImJib3gxIiwiZGlzdEJCb3giLCJiYm94MiIsIm92ZXJsYXAiLCJpbnRlcnNlY3Rpb25BcmVhIiwiY29tcGFyZU5vZGVNaW5YIiwiY29tcGFyZU5vZGVNaW5ZIiwieE1hcmdpbiIsIl9hbGxEaXN0TWFyZ2luIiwieU1hcmdpbiIsInNvcnQiLCJsZWZ0QkJveCIsInJpZ2h0QkJveCIsIm1hcmdpbiIsImJib3hNYXJnaW4iLCJpJDEiLCJjaGlsZCQxIiwic2libGluZ3MiLCJpbmRleE9mIiwicCIsImRlc3ROb2RlIiwibWF4WCIsIm1heFkiLCJzdGFjayIsIm1pZCIsIlNoYXBlIiwiQ2xpcFNwYWNlTmVhcloiLCJBYnN0cmFjdFJlbmRlcmVyUGx1Z2luIiwicGx1Z2lucyIsImtleSIsInZhbHVlIiwiYWRkUmVuZGVyaW5nUGx1Z2luIiwicGx1Z2luIiwiY29udGV4dCIsInJlbmRlcmluZ1BsdWdpbnMiLCJyZW1vdmVBbGxSZW5kZXJpbmdQbHVnaW5zIiwiX3RoaXMiLCJmb3JFYWNoIiwiQWJzdHJhY3RSZW5kZXJlciIsImNvbmZpZyIsImNsaXBTcGFjZU5lYXJaIiwiTkVHQVRJVkVfT05FIiwiZW5hYmxlRGlydHlDaGVjayIsImVuYWJsZUN1bGxpbmciLCJlbmFibGVBdXRvUmVuZGVyaW5nIiwiZW5hYmxlRGlydHlSZWN0YW5nbGVSZW5kZXJpbmciLCJlbmFibGVEaXJ0eVJlY3RhbmdsZVJlbmRlcmluZ0RlYnVnIiwiZW5hYmxlU2l6ZUF0dGVudWF0aW9uIiwiZW5hYmxlUmVuZGVyaW5nT3B0aW1pemF0aW9uIiwicmVnaXN0ZXJQbHVnaW4iLCJmaW5kSW5kZXgiLCJ1bnJlZ2lzdGVyUGx1Z2luIiwiZ2V0UGx1Z2lucyIsImdldFBsdWdpbiIsIm5hbWUiLCJmaW5kIiwiZ2V0Q29uZmlnIiwic2V0Q29uZmlnIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkVmVjMyIsImFkZCIsImNvcHlWZWMzIiwiY29weSIsIm1heFZlYzMiLCJtaW5WZWMzIiwic2NhbGVWZWMzIiwic2NhbGUiLCJzdWJWZWMzIiwic3ViIiwiQUFCQiIsImNlbnRlciIsImhhbGZFeHRlbnRzIiwidXBkYXRlIiwic2V0TWluTWF4IiwiZ2V0TWluIiwiZ2V0TWF4IiwiYWFiYiIsImlzRW1wdHkiLCJ0YyIsInRjeCIsInRjeSIsInRjeiIsInRoIiwidGh4IiwidGh5IiwidGh6IiwidG1pbngiLCJ0bWF4eCIsInRtaW55IiwidG1heHkiLCJ0bWlueiIsInRtYXh6Iiwib2MiLCJvY3giLCJvY3kiLCJvY3oiLCJvaCIsIm9oeCIsIm9oeSIsIm9oeiIsIm9taW54Iiwib21heHgiLCJvbWlueSIsIm9tYXh5Iiwib21pbnoiLCJvbWF4eiIsInNldEZyb21UcmFuc2Zvcm1lZEFBQkIiLCJiYyIsImJyIiwiYWMiLCJhciIsIm14MCIsIm14MSIsIm14MiIsIm15MCIsIm15MSIsIm15MiIsIm16MCIsIm16MSIsIm16MiIsIm14MGEiLCJhYnMiLCJteDFhIiwibXgyYSIsIm15MGEiLCJteTFhIiwibXkyYSIsIm16MGEiLCJtejFhIiwibXoyYSIsImFNYXgiLCJhTWluIiwiYk1heCIsImJNaW4iLCJpbnRlcnNlY3Rpb24iLCJnZXROZWdhdGl2ZUZhclBvaW50IiwicGxhbmUiLCJwblZlcnRleEZsYWciLCJnZXRQb3NpdGl2ZUZhclBvaW50IiwiUGxhbmUiLCJkaXN0YW5jZSIsIm5vcm1hbCIsImZyb21WYWx1ZXMiLCJ1cGRhdGVQTlZlcnRleEZsYWciLCJOdW1iZXIiLCJkaXN0YW5jZVRvUG9pbnQiLCJwb2ludCIsImRvdCIsIm5vcm1hbGl6ZSIsImludkxlbiIsImxlbiIsImludGVyc2VjdHNMaW5lIiwic3RhcnQiLCJlbmQiLCJkMCIsImQxIiwibGVycCIsIk1hc2siLCJGcnVzdHVtIiwicGxhbmVzIiwiZXh0cmFjdEZyb21WUE1hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJfcHJvamVjdGlvbk1hdHJpeCIsIm0wIiwibTEiLCJtMiIsIm0zIiwibTQiLCJtNSIsIm02IiwibTciLCJtOCIsIm05IiwibTEwIiwibTExIiwibTEyIiwibTEzIiwibTE0IiwibTE1Iiwic2V0IiwiUG9pbnQiLCJ4IiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwieSIsImNsb25lIiwiY29weUZyb20iLCJSZWN0YW5nbGUiLCJ3aWR0aCIsInRvcCIsImJvdHRvbSIsImZyb21SZWN0IiwicmVjdCIsImFwcGx5VHJhbnNmb3JtIiwibWF0cml4IiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwidHJhbnNmb3JtZWRUb3BMZWZ0IiwiY3JlYXRlIiwidHJhbnNmb3JtZWRUb3BSaWdodCIsInRyYW5zZm9ybWVkQm90dG9tTGVmdCIsInRyYW5zZm9ybWVkQm90dG9tUmlnaHQiLCJ0cmFuc2Zvcm1NYXQ0IiwiRVJST1JfTVNHX01FVEhPRF9OT1RfSU1QTEVNRU5URUQiLCJFUlJPUl9NU0dfVVNFX0RPQ1VNRU5UX0VMRU1FTlQiLCJFUlJPUl9NU0dfQVBQRU5EX0RFU1RST1lFRF9FTEVNRU5UIiwiZ2V0QW5nbGUiLCJhbmdsZSIsIiR2ZWMzJDIiLCJjcmVhdGVWZWMzIiwiQXJyYXkiLCJERUdfUkFEIiwiUEkiLCJkZWcycmFkIiwiZGVnIiwiUkFEX0RFRyIsInJhZDJkZWciLCJyYWQiLCJHUkFEX0RFRyIsImdyYWQyZGVnIiwiZ3JhZHMiLCJkZWcydHVybiIsInR1cm4yZGVnIiwidHVybiIsIkhBTEZfUEkiLCJnZXRFdWxlckZyb21RdWF0Iiwib3V0IiwidyIsIngyIiwieTIiLCJ6MiIsIncyIiwidW5pdCIsInRlc3QiLCJhdGFuMiIsImFzaW4iLCJnZXRFdWxlckZyb21NYXQ0IiwiX21hdDQkZ2V0U2NhbGluZyIsImdldFNjYWxpbmciLCJfbWF0NCRnZXRTY2FsaW5nMiIsInN4Iiwic3kiLCJzeiIsImdldEV1bGVyIiwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSIsInJvdGF0aW9uIiwic2NhbGVYIiwic2NhbGVZIiwiY29zIiwic2luIiwibWFrZVBlcnNwZWN0aXZlIiwibmVhciIsImZhciIsInplcm8iLCJ0d29OZWFyIiwicmlnaHRNaW51c0xlZnQiLCJ0b3BNaW51c0JvdHRvbSIsImMiLCJkIiwiZmFyTWludXNOZWFyIiwiZmFyTXVsTmVhciIsImRlY29tcG9zZSIsIm1hdCIsInJvdzB4Iiwicm93MHkiLCJyb3cxeCIsInJvdzF5Iiwic2NhbGluZ1giLCJzY2FsaW5nWSIsImRldGVybWluYW50IiwiaW52U2NhbGluZ1giLCJpbnZTY2FsaW5nWSIsInBlcnNwZWN0aXZlTWF0cml4IiwidG1wVmVjNCIsInJvdyIsInBkdW0zIiwiZGVjb21wb3NlTWF0NCIsInRyYW5zbGF0aW9uIiwic2tldyIsInBlcnNwZWN0aXZlIiwicXVhdGVybmlvbiIsImEwMyIsImExMyIsImEyMyIsImEzMCIsImEzMSIsImEzMiIsImEzMyIsInJldCIsImludmVydCIsInRyYW5zcG9zZSIsIm1hdDNmcm9tNCIsImNvbWJpbmUiLCJjcm9zcyIsIm00NCIsIm1hdDR4NCIsInNjYWxlMSIsInNjYWxlMiIsIkNhbWVyYVR5cGUiLCJDYW1lcmFUcmFja2luZ01vZGUiLCJDYW1lcmFQcm9qZWN0aW9uTW9kZSIsIkNhbWVyYUV2ZW50IiwiVVBEQVRFRCIsIk1JTl9ESVNUQU5DRSIsIkNhbWVyYSIsImV2ZW50RW1pdHRlciIsInVwIiwiZm9yd2FyZCIsInBvc2l0aW9uIiwiZm9jYWxQb2ludCIsImRpc3RhbmNlVmVjdG9yIiwiYXppbXV0aCIsImVsZXZhdGlvbiIsInJvbGwiLCJyZWxBemltdXRoIiwicmVsRWxldmF0aW9uIiwicmVsUm9sbCIsImRvbGx5aW5nU3RlcCIsIm1heERpc3RhbmNlIiwibWluRGlzdGFuY2UiLCJ6b29tIiwicm90YXRlV29ybGQiLCJmb3YiLCJhc3BlY3QiLCJwcm9qZWN0aW9uTWF0cml4SW52ZXJzZSIsImppdHRlcmVkUHJvamVjdGlvbk1hdHJpeCIsImVuYWJsZVVwZGF0ZSIsInR5cGUiLCJFWFBMT1JJTkciLCJ0cmFja2luZ01vZGUiLCJERUZBVUxUIiwicHJvamVjdGlvbk1vZGUiLCJQRVJTUEVDVElWRSIsImZydXN0dW0iLCJvcnRob01hdHJpeCIsImlzT3J0aG8iLCJPUlRIT0dSQVBISUMiLCJnZXRQcm9qZWN0aW9uTW9kZSIsImdldFBlcnNwZWN0aXZlIiwiZ2V0UGVyc3BlY3RpdmVJbnZlcnNlIiwiZ2V0RnJ1c3R1bSIsImdldFBvc2l0aW9uIiwiZ2V0Rm9jYWxQb2ludCIsImdldERvbGx5aW5nU3RlcCIsImdldE5lYXIiLCJnZXRGYXIiLCJnZXRab29tIiwiZ2V0T3J0aG9NYXRyaXgiLCJnZXRWaWV3IiwidmlldyIsInNldEVuYWJsZVVwZGF0ZSIsImVuYWJsZWQiLCJzZXRUeXBlIiwic2V0V29ybGRSb3RhdGlvbiIsIl9nZXRBbmdsZXMiLCJUUkFDS0lORyIsInNldFRyYWNraW5nTW9kZSIsInNldFByb2plY3Rpb25Nb2RlIiwiRXJyb3IiLCJmbGFnIiwiZ2V0Vmlld1RyYW5zZm9ybSIsImdldFdvcmxkVHJhbnNmb3JtIiwiaml0dGVyUHJvamVjdGlvbk1hdHJpeCIsImZyb21UcmFuc2xhdGlvbiIsIm11bHRpcGx5IiwiY2xlYXJKaXR0ZXJQcm9qZWN0aW9uTWF0cml4Iiwic2V0TWF0cml4IiwiX3VwZGF0ZSIsInNldFByb2plY3Rpb25NYXRyaXgiLCJzZXRGb3YiLCJzZXRQZXJzcGVjdGl2ZSIsInNldEFzcGVjdCIsInNldE5lYXIiLCJzZXRPcnRob2dyYXBoaWMiLCJycmlnaHQiLCJzZXRGYXIiLCJzZXRWaWV3T2Zmc2V0IiwiZnVsbFdpZHRoIiwiZnVsbEhlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY2xlYXJWaWV3T2Zmc2V0Iiwic2V0Wm9vbSIsInNldFpvb21CeVZpZXdwb3J0UG9pbnQiLCJ2aWV3cG9ydFBvaW50IiwiX3RoaXMkY2FudmFzJHZpZXdwb3J0IiwiY2FudmFzIiwidmlld3BvcnQyQ2FudmFzIiwib3giLCJveSIsInJvdGF0ZSIsInNldFBvc2l0aW9uIiwic2V0Rm9jYWxQb2ludCIsIl90aGlzJGNhbnZhcyR2aWV3cG9ydDIiLCJjeCIsImN5IiwiZHZlYyIsImR4IiwiZHkiLCJfdGhpcyRnZXRQb3NpdGlvbiIsIl90aGlzJGdldFBvc2l0aW9uMiIsInB4IiwicHkiLCJfdGhpcyRnZXRGb2NhbFBvaW50IiwiX3RoaXMkZ2V0Rm9jYWxQb2ludDIiLCJmeCIsImZ5IiwiX3RoaXMkdmlldyIsInRhbiIsIlpFUk8iLCJ0cmlnZ2VyVXBkYXRlIiwibCIsInIiLCJfdGhpcyR2aWV3MiIsInNjYWxlVyIsInNjYWxlSCIsIm9ydGhvIiwib3J0aG9aTyIsIl9nZXRPcnRob01hdHJpeCIsIl9zZXRQb3NpdGlvbiIsIkNJTkVNQVRJQyIsInN1YnRyYWN0IiwiZWwiLCJheiIsInJvdGF0ZVkiLCJyb3RhdGVYIiwibG9va0F0IiwiX2dldEF4ZXMiLCJfZ2V0RGlzdGFuY2UiLCJnZXREaXN0YW5jZSIsImdldERpc3RhbmNlVmVjdG9yIiwic2V0RGlzdGFuY2UiLCJwb3MiLCJmIiwic2V0TWF4RGlzdGFuY2UiLCJzZXRNaW5EaXN0YW5jZSIsInNldEF6aW11dGgiLCJjb21wdXRlTWF0cml4IiwiT1JCSVRJTkciLCJfZ2V0UG9zaXRpb24iLCJfZ2V0Rm9jYWxQb2ludCIsImdldEF6aW11dGgiLCJzZXRFbGV2YXRpb24iLCJnZXRFbGV2YXRpb24iLCJzZXRSb2xsIiwiZ2V0Um9sbCIsInJvdFoiLCJzZXRBeGlzQW5nbGUiLCJpZGVudGl0eSIsInJvdFgiLCJyb3RZIiwicm90USIsInJvdE1hdHJpeCIsImZyb21RdWF0IiwidHJhbnNsYXRlIiwidHJhbnNmb3JtTWF0MyIsImZyb21NYXQ0IiwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsInZpZXdNYXRyaXgiLCJ2cE1hdHJpeCIsImVtaXQiLCJwYW4iLCJ0eCIsInR5IiwiZG9sbHkiLCJjcmVhdGVMYW5kbWFyayIsInBhcmFtcyIsImdvdG9MYW5kbWFyayIsIm9wdGlvbnMiLCJjYW5jZWxMYW5kbWFya0FuaW1hdGlvbiIsIlN0cmF0ZWd5IiwiU29ydFJlYXNvbiIsIkVNUFRZX1BBUlNFRF9QQVRIIiwiYWJzb2x1dGVQYXRoIiwiaGFzQXJjIiwic2VnbWVudHMiLCJwb2x5Z29ucyIsInBvbHlsaW5lcyIsImN1cnZlIiwidG90YWxMZW5ndGgiLCJQcm9wZXJ0eVN5bnRheCIsImRlZmluZSIsImNvbnN0cnVjdG9yIiwiZGVmaW5pdGlvbiIsIkNvbG9yIiwiZGFya2VyIiwiYnJpZ2h0ZXIiLCJyZUkiLCJyZU4iLCJyZVAiLCJyZUhleCIsInJlUmdiSW50ZWdlciIsIlJlZ0V4cCIsInJlUmdiUGVyY2VudCIsInJlUmdiYUludGVnZXIiLCJyZVJnYmFQZXJjZW50IiwicmVIc2xQZXJjZW50IiwicmVIc2xhUGVyY2VudCIsIm5hbWVkIiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJjb2xvciIsImNoYW5uZWxzIiwiZGlzcGxheWFibGUiLCJyZ2IiLCJoZXgiLCJjb2xvcl9mb3JtYXRIZXgiLCJmb3JtYXRIZXgiLCJmb3JtYXRIZXg4IiwiY29sb3JfZm9ybWF0SGV4OCIsImZvcm1hdEhzbCIsImNvbG9yX2Zvcm1hdEhzbCIsImZvcm1hdFJnYiIsImNvbG9yX2Zvcm1hdFJnYiIsInRvU3RyaW5nIiwiaHNsQ29udmVydCIsImZvcm1hdCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImV4ZWMiLCJwYXJzZUludCIsInJnYm4iLCJSZ2IiLCJyZ2JhIiwiaHNsYSIsImhhc093blByb3BlcnR5IiwiTmFOIiwiZyIsInJnYkNvbnZlcnQiLCJvIiwib3BhY2l0eSIsImNsYW1waSIsImNsYW1wYSIsInJnYl9mb3JtYXRIZXgiLCJyZ2JfZm9ybWF0SGV4OCIsInJnYl9mb3JtYXRSZ2IiLCJpc05hTiIsInJvdW5kIiwiaCIsIkhzbCIsImhzbCIsImhzbDJyZ2IiLCJjbGFtcGgiLCJjbGFtcHQiLCJtZW1vaXplIiwiZnVuYyIsInJlc29sdmVyIiwiVHlwZUVycm9yIiwiX21lbW9pemVkIiwibWVtb2l6ZWQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjYWNoZSIsImhhcyIsImdldCIsIkNhY2hlIiwiTWFwIiwiY2FjaGVMaXN0IiwiY2xlYXJDYWNoZSIsIlVuaXRUeXBlIiwiVW5pdENhdGVnb3J5IiwiTmVzdGVkIiwiUGFyZW5MZXNzIiwidW5pdF90eXBlIiwia0VtcyIsImtQaXhlbHMiLCJrRGVncmVlcyIsImtSYWRpYW5zIiwia0dyYWRpYW5zIiwia01pbGxpc2Vjb25kcyIsImtTZWNvbmRzIiwia1JlbXMiLCJrVHVybnMiLCJDU1NTdHlsZVZhbHVlVHlwZSIsInN0cmluZ1RvVW5pdFR5cGUiLCJ1bml0RnJvbU5hbWUiLCJrVW5rbm93biIsImtOdW1iZXIiLCJrUGVyY2VudGFnZSIsInVuaXRUeXBlVG9Vbml0Q2F0ZWdvcnkiLCJrSW50ZWdlciIsImtVTnVtYmVyIiwia1VQZXJjZW50Iiwia1VMZW5ndGgiLCJrVVRpbWUiLCJrVUFuZ2xlIiwia1VPdGhlciIsImNhbm9uaWNhbFVuaXRUeXBlRm9yQ2F0ZWdvcnkiLCJjYXRlZ29yeSIsImNvbnZlcnNpb25Ub0Nhbm9uaWNhbFVuaXRzU2NhbGVGYWN0b3IiLCJmYWN0b3IiLCJ1bml0VHlwZVRvU3RyaW5nIiwiQ1NTU3R5bGVWYWx1ZSIsImJ1aWxkQ1NTVGV4dCIsImtObyIsImlzTnVtZXJpY1ZhbHVlIiwiZ2V0VHlwZSIsImtVbml0VHlwZSIsImtDbGFtcFR5cGUiLCJpc0FuZ2xlIiwiaXNMZW5ndGgiLCJpc1JlbGF0aXZlVW5pdCIsImlzVGltZSIsIkNTU0NvbG9yVmFsdWUiLCJfQ1NTU3R5bGVWYWx1ZSIsImNvbG9yU3BhY2UiLCJrQ29sb3JUeXBlIiwidG8iLCJHcmFkaWVudFR5cGUiLCJDU1NHcmFkaWVudFZhbHVlIiwiQ1NTS2V5d29yZFZhbHVlIiwia0tleXdvcmRUeXBlIiwiZm9ybWF0SW5maW5pdHlPck5hTiIsIm51bWJlciIsInN1ZmZpeCIsImlzRmluaXRlIiwidG9DYW5vbmljYWxVbml0IiwiQ1NTVW5pdFZhbHVlIiwidW5pdE9yTmFtZSIsImVxdWFscyIsIm90aGVyIiwib3RoZXJfdW5pdF92YWx1ZSIsImNvbnZlcnRUbyIsInRhcmdldF91bml0IiwiY2Fub25pY2FsX3VuaXQiLCJzY2FsZV9mYWN0b3IiLCJ0ZXh0IiwidG9GaXhlZCIsImtNaW5JbnRlZ2VyIiwia01heEludGVnZXIiLCJfdW5pdCIsImNvbmNhdCIsIk9weCIsIk9kZWciLCJDU1NSR0IiLCJfQ1NTQ29sb3JWYWx1ZSIsImFscGhhIiwiaXNOb25lIiwidW5zZXRLZXl3b3JkVmFsdWUiLCJpbml0aWFsS2V5d29yZFZhbHVlIiwiaW5oZXJpdEtleXdvcmRWYWx1ZSIsImtleXdvcmRDYWNoZSIsInVuc2V0IiwiaW5pdGlhbCIsImluaGVyaXQiLCJnZXRPckNyZWF0ZUtleXdvcmQiLCJub25lQ29sb3IiLCJ0cmFuc3BhcmVudENvbG9yIiwiZ2V0T3JDcmVhdGVSR0JBIiwiZ2V0T3JDcmVhdGVVbml0VmFsdWUiLCJjb2xvclN0b3BUb1N0cmluZyIsImNvbG9yU3RvcCIsImpvaW4iLCJwYXJzZUdyYWRpZW50JDEiLCJ0b2tlbnMiLCJsaW5lYXJHcmFkaWVudCIsInJlcGVhdGluZ0xpbmVhckdyYWRpZW50IiwicmFkaWFsR3JhZGllbnQiLCJyZXBlYXRpbmdSYWRpYWxHcmFkaWVudCIsImNvbmljR3JhZGllbnQiLCJzaWRlT3JDb3JuZXIiLCJleHRlbnRLZXl3b3JkcyIsInBvc2l0aW9uS2V5d29yZHMiLCJwaXhlbFZhbHVlIiwicGVyY2VudGFnZVZhbHVlIiwiZW1WYWx1ZSIsImFuZ2xlVmFsdWUiLCJzdGFydENhbGwiLCJlbmRDYWxsIiwiY29tbWEiLCJoZXhDb2xvciIsImxpdGVyYWxDb2xvciIsInJnYkNvbG9yIiwicmdiYUNvbG9yIiwiaW5wdXQiLCJlcnJvciIsIm1zZyIsImdldEFTVCIsImFzdCIsIm1hdGNoTGlzdERlZmluaXRpb25zIiwibWF0Y2hMaXN0aW5nIiwibWF0Y2hEZWZpbml0aW9uIiwibWF0Y2hHcmFkaWVudCIsIm1hdGNoTGluZWFyT3JpZW50YXRpb24iLCJtYXRjaExpc3RSYWRpYWxPcmllbnRhdGlvbnMiLCJncmFkaWVudFR5cGUiLCJwYXR0ZXJuIiwib3JpZW50YXRpb25NYXRjaGVyIiwibWF0Y2hDYWxsIiwiY2FwdHVyZXMiLCJvcmllbnRhdGlvbiIsInNjYW4iLCJjb2xvclN0b3BzIiwibWF0Y2hDb2xvclN0b3AiLCJjYWxsYmFjayIsIm1hdGNoU2lkZU9yQ29ybmVyIiwibWF0Y2hBbmdsZSIsIm1hdGNoIiwicmFkaWFsT3JpZW50YXRpb25zIiwicmFkaWFsT3JpZW50YXRpb24iLCJtYXRjaFJhZGlhbE9yaWVudGF0aW9uIiwibG9va2FoZWFkQ2FjaGUiLCJyYWRpYWxUeXBlIiwibWF0Y2hDaXJjbGUiLCJtYXRjaEVsbGlwc2UiLCJhdCIsIm1hdGNoQXRQb3NpdGlvbiIsImV4dGVudCIsIm1hdGNoRXh0ZW50S2V5d29yZCIsInBvc2l0aW9uQXQiLCJkZWZhdWx0UG9zaXRpb24iLCJtYXRjaFBvc2l0aW9uaW5nIiwiY2lyY2xlIiwic3R5bGUiLCJtYXRjaExlbmd0aCIsImVsbGlwc2UiLCJtYXRjaERpc3RhbmNlIiwicG9zaXRpb25pbmciLCJsb2NhdGlvbiIsIm1hdGNoQ29vcmRpbmF0ZXMiLCJtYXRjaGVyIiwibWF0Y2hDb2xvciIsIm1hdGNoSGV4Q29sb3IiLCJtYXRjaFJHQkFDb2xvciIsIm1hdGNoUkdCQ29sb3IiLCJtYXRjaExpdGVyYWxDb2xvciIsIm1hdGNoTnVtYmVyIiwibWF0Y2hQb3NpdGlvbktleXdvcmQiLCJjYXB0dXJlSW5kZXgiLCJyZWdleHAiLCJibGFua0NhcHR1cmVzIiwiY29uc3VtZSIsInNpemUiLCJzdWJzdHJpbmciLCJjb2RlIiwiY29tcHV0ZUxpbmVhckdyYWRpZW50IiwicngiLCJyeSIsInJjeCIsInJjeSIsIngxIiwieTEiLCJjb21wdXRlUmFkaWFsR3JhZGllbnQiLCJyZWdleExHIiwicmVnZXhSRyIsInJlZ2V4UFIiLCJyZWdleENvbG9yU3RvcCIsInNwYWNlQ29sb3JTdG9wcyIsIl9jb2xvclN0b3BzJGxlbmd0aCIsIl9jb2xvclN0b3BzJDAkbGVuZ3RoIiwicHJldmlvdXNJbmRleCIsInByZXZpb3VzT2Zmc2V0IiwiX2NvbG9yU3RvcHMkaSRsZW5ndGgiLCJvZmZzZXQiLCJTaWRlT3JDb3JuZXJUb0RlZ01hcCIsImFuZ2xlVG9EZWciLCJwb3NpdG9uVG9DU1NVbml0VmFsdWUiLCJ1bml0WCIsInVuaXRZIiwiX3Bvc2l0aW9uJHZhbHVlIiwicGFyc2VHcmFkaWVudCIsImNvbG9yU3RyIiwibWFwIiwiX3JlZiIsInN0ZXBzIiwiTGluZWFyR3JhZGllbnQiLCJfcG9zaXRvblRvQ1NTVW5pdFZhbHUiLCJfb3JpZW50YXRpb24kMCRzdHlsZSIsIl90eXBlIiwiUmFkaWFsR3JhZGllbnQiLCJfYXJyJDIkbWF0Y2giLCJzdG9wIiwic3BsaXQiLCJwYXJzZUZsb2F0IiwiX3JlZjIiLCJfcmVmMyIsInBhcnNlZFJhZGlhbEdyYWRpZW50IiwicGFyc2VSYWRpYWxHcmFkaWVudCIsInBhcnNlUGF0dGVybiIsImdyYWRpZW50U3RyIiwiX2FyciQ0JG1hdGNoIiwiX3JlZjQiLCJfcmVmNSIsInBhdHRlcm5TdHIiLCJyZXBldGl0aW9uIiwic3JjIiwiaW1hZ2UiLCJpc0NTU0dyYWRpZW50VmFsdWUiLCJvYmplY3QiLCJpc1BhdHRlcm4iLCJpc0NTU1JHQiIsInBhcnNlQ29sb3IiLCJjb2xvciQxIiwibWVyZ2VDb2xvcnMiLCJwYXJzZURpbWVuc2lvbiIsInVuaXRSZWdFeHAiLCJzdHJpbmciLCJtYXRjaGVkVW5pdHMiLCJyZXBsYWNlIiwidGFnZ2VkVW5pdFJlZ0V4cCIsInNvdXJjZSIsInBhcnNlTGVuZ3RoVW5tZW1vaXplIiwiY3NzIiwicGFyc2VMZW5ndGgiLCJwYXJzZXJQZXJjZW50YWdlVW5tZW1vaXplIiwicGFyc2VMZW5ndGhPclBlcmNlbnRhZ2VVbm1lbW9pemUiLCJwYXJzZUxlbmd0aE9yUGVyY2VudGFnZSIsInBhcnNlQW5nbGVVbm1lbW9pemUiLCJwYXJzZUFuZ2xlIiwibWVyZ2VEaW1lbnNpb25zIiwidGFyZ2V0Iiwibm9uTmVnYXRpdmUiLCJsZWZ0VmFsdWUiLCJyaWdodFZhbHVlIiwiY2Fub25pY2FsVW5pdCIsImxlZnRDYW5vbmljYWxVbml0VmFsdWUiLCJyaWdodENhbm9uaWNhbFVuaXRWYWx1ZSIsImNvbnZlcnRQZXJjZW50VW5pdCIsImNvbnZlcnRBbmdsZVVuaXQiLCJwYXJzZURpbWVuc2lvbkFycmF5Rm9ybWF0IiwicGFyc2VkIiwic2VnbWVudCIsInZhbHVlV2l0aFVuaXQiLCJ2ZWMzSW5kZXgiLCJ1c2VNaW4iLCJib3VuZHMiLCJub2RlTmFtZSIsIkdST1VQIiwiZ2V0TG9jYWxCb3VuZHMiLCJnZXRHZW9tZXRyeUJvdW5kcyIsInBhcnNlUGFyYW0iLCJzdXBwb3J0ZWRGaWx0ZXJzIiwicGFyc2VGaWx0ZXIiLCJmaWx0ZXJTdHIiLCJmaWx0ZXJSZWdFeHAiLCJwcmV2TGFzdEluZGV4IiwibGFzdEluZGV4IiwibnVtYmVyVG9TdHJpbmciLCJwYXJzZU51bWJlclVubWVtb2l6ZSIsInBhcnNlTnVtYmVyIiwibWVyZ2VOdW1iZXJzIiwiY2xhbXBlZE1lcmdlTnVtYmVycyIsIm1lcmdlTnVtYmVyTGlzdHMiLCJudW1iZXJMaXN0IiwiZ2V0T3JDYWxjdWxhdGVQYXRoVG90YWxMZW5ndGgiLCJwYXJzZWRTdHlsZSIsImdldE9yQ2FsY3VsYXRlUG9seWxpbmVUb3RhbExlbmd0aCIsInBvbHlsaW5lIiwicG9pbnRzIiwicmVtb3ZlUmVkdW5kYW50TUNvbW1hbmQiLCJwcmV2U2VnbWVudCIsImNtZCIsInByZXZDbWQiLCJzcmNQb2ludCIsImRlc3RQb2ludCIsImlzU2FtZVBvaW50IiwiaGFzQXJjT3JCZXppZXIiLCJjb3VudCIsImV4dHJhY3RQb2x5Z29ucyIsInBhdGhBcnJheSIsInBvaW50MSIsInBvaW50MiIsImdldFBhdGhCQm94IiwibGluZVdpZHRoIiwieEFyciIsInlBcnIiLCJzZWdtZW50c1dpdGhBbmdsZSIsImN1cnJlbnRQb2ludCIsInByZVBvaW50IiwiYm94IiwiY29tbWFuZCIsImFyY1BhcmFtcyIsInhSb3RhdGlvbiIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsIm5leHRQb2ludCIsImZpbHRlciIsIl9pIiwiX3NlZ21lbnQiLCJfY3VycmVudFBvaW50IiwiZXh0cmEiLCJnZXRFeHRyYUZyb21TZWdtZW50V2l0aEFuZ2xlIiwieEV4dHJhIiwieUV4dHJhIiwiY3VycmVudEFuZFByZSIsImN1cnJlbnRBbmROZXh0IiwicHJlQW5kTmV4dCIsImN1cnJlbnRBbmdsZSIsImFjb3MiLCJ4QW5nbGUiLCJ5QW5nbGUiLCJ0b1N5bW1ldHJ5IiwiYW5nbGVCZXR3ZWVuIiwidjAiLCJ2MSIsInNpZ24iLCJwb2ludE9uRWxsaXB0aWNhbEFyYyIsInAwIiwieEF4aXNSb3RhdGlvbiIsImxhcmdlQXJjRmxhZyIsInN3ZWVwRmxhZyIsInAxIiwieEF4aXNSb3RhdGlvblJhZGlhbnMiLCJlbGxpcHRpY2FsQXJjQW5nbGUiLCJ0cmFuc2Zvcm1lZFBvaW50IiwicmFkaWlDaGVjayIsImNTcXVhcmVOdW1lcmF0b3IiLCJjU3F1YXJlUm9vdERlbm9tIiwiY1JhZGljYW5kIiwiY0NvZWYiLCJ0cmFuc2Zvcm1lZENlbnRlciIsInN0YXJ0VmVjdG9yIiwiZW5kVmVjdG9yIiwic3dlZXBBbmdsZSIsImVsbGlwc2VDb21wb25lbnRYIiwiZWxsaXBzZUNvbXBvbmVudFkiLCJlbGxpcHRpY2FsQXJjU3RhcnRBbmdsZSIsImVsbGlwdGljYWxBcmNFbmRBbmdsZSIsImVsbGlwdGljYWxBcmNDZW50ZXIiLCJyZXN1bHRhbnRSeCIsInJlc3VsdGFudFJ5IiwicGF0aDJTZWdtZW50cyIsIm5leHRQYXJhbXMiLCJzdGFydE1vdmVQb2ludCIsImxhc3RTdGFydE1vdmVQb2ludEluZGV4Iiwic3RhcnRUYW5nZW50IiwiZW5kVGFuZ2VudCIsImN1YmljUGFyYW1zIiwiZ2V0QXJjUGFyYW1zIiwiaW5jbHVkZXMiLCJjcCIsInByZVNlZ21lbnQiLCJfY3AiLCJjcDEiLCJjcDIiLCJfcHJlU2VnbWVudCIsIl9jcDIiLCJfY3AzIiwiX2dldFRhbmdlbnRBdFJhdGlvIiwiZ2V0VGFuZ2VudEF0UmF0aW8iLCJkeDEiLCJkeTEiLCJfZ2V0VGFuZ2VudEF0UmF0aW8yIiwiZHgyIiwiZHkyIiwicmF0aW8iLCJfc2VnbWVudCRhcmNQYXJhbXMiLCJfc2VnbWVudCRhcmNQYXJhbXMkcngiLCJfc2VnbWVudCRhcmNQYXJhbXMkcnkiLCJhcmNGbGFnIiwicDIiLCJ4RGlzdCIsInlEaXN0IiwiZGlzdCIsInZNYWciLCJ2IiwidlJhdGlvIiwidSIsInZBbmdsZSIsInN0YXJ0UG9pbnQiLCJ4cCIsInlwIiwibGFtYmRhIiwiZGlmZiIsImN4cCIsImN5cCIsInRoZXRhIiwiZFRoZXRhIiwiY29tbWFuZHNUb1BhdGhTdHJpbmciLCJjb21tYW5kcyIsInRyYW5zZm9ybSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJwMyIsIl9wIiwiX3AyIiwibGluZVRvQ29tbWFuZHMiLCJlbGxpcHNlVG9Db21tYW5kcyIsInBvbHlnb25Ub0NvbW1hbmRzIiwiY2xvc2VkIiwicmVjdFRvQ29tbWFuZHMiLCJyYWRpdXMiLCJfcmFkaXVzIiwidGxyIiwidHJyIiwiYnJyIiwiYmxyIiwic2lnblgiLCJzaWduWSIsImNvbnZlcnRUb1BhdGgiLCJnZXRMb2NhbFRyYW5zZm9ybSIsIkxJTkUiLCJfcGFyc2VkU3R5bGUiLCJfcGFyc2VkU3R5bGUkeCIsIl9wYXJzZWRTdHlsZSR5IiwiX3BhcnNlZFN0eWxlJHgyIiwiX3BhcnNlZFN0eWxlJHkyIiwiQ0lSQ0xFIiwiX3BhcnNlZFN0eWxlMiIsIl9wYXJzZWRTdHlsZTIkciIsIl9wYXJzZWRTdHlsZTIkY3giLCJfcGFyc2VkU3R5bGUyJGN5IiwiRUxMSVBTRSIsIl9wYXJzZWRTdHlsZTMiLCJfcGFyc2VkU3R5bGUzJHJ4IiwiX3BhcnNlZFN0eWxlMyRyeSIsIl9wYXJzZWRTdHlsZTMkY3giLCJfY3giLCJfcGFyc2VkU3R5bGUzJGN5IiwiX2N5IiwiUE9MWUxJTkUiLCJQT0xZR09OIiwiUkVDVCIsIl9wYXJzZWRTdHlsZTQiLCJfcGFyc2VkU3R5bGU0JHdpZHRoIiwiX3BhcnNlZFN0eWxlNCRoZWlnaHQiLCJfcGFyc2VkU3R5bGU0JHgiLCJfcGFyc2VkU3R5bGU0JHkiLCJoYXNSYWRpdXMiLCJzb21lIiwiUEFUSCIsInRyYW5zbGF0ZVBhdGhUb1N0cmluZyIsInN0YXJ0T2Zmc2V0WCIsInN0YXJ0T2Zmc2V0WSIsImVuZE9mZnNldFgiLCJlbmRPZmZzZXRZIiwibmV3VmFsdWUiLCJuZXh0U2VnbWVudCIsInVzZVN0YXJ0T2Zmc2V0IiwidXNlRW5kT2Zmc2V0Iiwic3RhcnRPZmZzZXRYVGVtcCIsInN0YXJ0T2Zmc2V0WVRlbXAiLCJlbmRPZmZzZXRYVGVtcCIsImVuZE9mZnNldFlUZW1wIiwiaW50ZXJuYWxQYXJzZVBhdGgiLCJfdW51c2VkIiwiY29uc29sZSIsIl9leHRyYWN0UG9seWdvbnMiLCJfZ2V0UGF0aEJCb3giLCJtZW1vaXplZFBhcnNlUGF0aCIsInBhcnNlUGF0aCIsIm1lcmdlUGF0aHMiLCJjdXJ2ZTEiLCJjdXJ2ZTIiLCJjdXJ2ZXMiLCJjdXJ2ZTAiLCJwYXJzZVBvaW50cyIsInBvaW50c09yU3RyIiwicG9pbnRTdHIiLCJfcG9pbnRTdHIkc3BsaXQiLCJfcG9pbnRTdHIkc3BsaXQyIiwibWVyZ2VQb2ludHMiLCJfIiwiVFJBTlNGT1JNX1JFR0VYUCIsImNhc3QiLCJjb250ZW50cyIsImlkIiwidHJhbnNmb3JtRnVuY3Rpb25zIiwibWF0cml4M2QiLCJyb3RhdGVaIiwicm90YXRlM2QiLCJzY2FsZVoiLCJzY2FsZTNkIiwic2tld1giLCJza2V3WSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidHJhbnNsYXRlWiIsInRyYW5zbGF0ZTNkIiwicGFyc2VBcnJheVRyYW5zZm9ybSIsImZ1bmN0aW9uRGF0YSIsInBhcnNlZEFyZ3MiLCJwYXJzZVRyYW5zZm9ybSIsImZ1bmN0aW9uTmFtZSIsImFyZ1R5cGVzIiwiYXJnIiwicGFyc2VkQXJnIiwiQSIsIlQiLCJMIiwidG9VcHBlckNhc2UiLCJwYXJzZVRyYW5zZm9ybVVubWVtb2l6ZSIsImNvbnZlcnRJdGVtVG9NYXRyaXgiLCJzcXJMZW5ndGgiLCJzYyIsInNxIiwibXVsdGlwbHlNYXRyaWNlcyIsImNvbnZlcnRUb01hdHJpeCIsInRyYW5zZm9ybUxpc3QiLCJtYWtlTWF0cml4RGVjb21wb3NpdGlvbiIsImNvbXBvc2VNYXRyaXgiLCJpczJEIiwidGVtcCIsIl9pMiIsIl9qIiwibnVtYmVyVG9Mb25nU3RyaW5nIiwibWVyZ2VNYXRyaWNlcyIsImxlZnRBcmdzIiwicmlnaHRBcmdzIiwiZGVjb21wb3NpdGlvblBhaXIiLCJsaXN0IiwicSIsInN0cmluZ2lmaWVkQXJncyIsInYyIiwiZnJvbVEiLCJ0b1EiLCJwcm9kdWN0IiwidHlwZVRvMkQiLCJ0eXBlVG8zRCIsImlzTWF0cml4T3JQZXJzcGVjdGl2ZSIsImx0IiwicnQiLCJtZXJnZVRyYW5zZm9ybXMiLCJmbGlwUmVzdWx0cyIsIl9sb29wIiwiX2xlZnQkaSIsImRlZmF1bHRWYWx1ZSIsImxlZnRSZXN1bHQiLCJyaWdodFJlc3VsdCIsInR5cGVzIiwibWVyZ2VkIiwiX2kzIiwibGVmdFR5cGUiLCJyaWdodFR5cGUiLCJsZWZ0RnVuY3Rpb25EYXRhIiwicmlnaHRGdW5jdGlvbkRhdGEiLCJfbWVyZ2VkIiwiX21lcmdlZDIiLCJsZWZ0QXJnc0NvcHkiLCJyaWdodEFyZ3NDb3B5Iiwic3RyaW5nQ29udmVyc2lvbnMiLCJfbWVyZ2VkMyIsInBhcnNlVHJhbnNmb3JtT3JpZ2luIiwidmFsdWVzIiwiY29udmVydEtleXdvcmQyUGVyY2VudCIsImtleXdvcmQiLCJCVUlMVF9JTl9QUk9QRVJUSUVTIiwiaW5oIiwic3ludGF4IiwiT1BBQ0lUWV9WQUxVRSIsIlBBSU5UIiwiQ09MT1IiLCJMRU5HVEhfUEVSQ0VOVEFHRSIsIlNIQURPV19CTFVSIiwiTEVOR1RIX1BFUkNFTlRBR0VfMTIiLCJERUZJTkVEX1BBVEgiLCJPRkZTRVRfRElTVEFOQ0UiLCJpbmQiLCJaX0lOREVYIiwiRklMVEVSIiwiVFJBTlNGT1JNIiwiVFJBTlNGT1JNX09SSUdJTiIsIkNPT1JESU5BVEUiLCJMRU5HVEhfUEVSQ0VOVEFHRV8xNCIsIkxJU1RfT0ZfUE9JTlRTIiwiVEVYVCIsIlRFWFRfVFJBTlNGT1JNIiwiTEVOR1RIIiwiTlVNQkVSIiwiTUFSS0VSIiwiR0VPTUVUUllfQVRUUklCVVRFX05BTUVTIiwiU2V0IiwicHJvcGVydHlNZXRhZGF0YUNhY2hlIiwiRGVmYXVsdFN0eWxlVmFsdWVSZWdpc3RyeSIsInJ1bnRpbWUiLCJwcm9wZXJ0eSIsInJlZ2lzdGVyTWV0YWRhdGEiLCJtZXRhZGF0YSIsImdldFByb3BlcnR5U3ludGF4IiwiQ1NTUHJvcGVydHlTeW50YXhGYWN0b3J5IiwicHJvY2Vzc1Byb3BlcnRpZXMiLCJhdHRyaWJ1dGVzIiwic2tpcFVwZGF0ZUF0dHJpYnV0ZSIsInNraXBQYXJzZSIsImZvcmNlVXBkYXRlR2VvbWV0cnkiLCJ1c2VkQXR0cmlidXRlcyIsIm9sZENsaXBQYXRoIiwiY2xpcFBhdGgiLCJvbGRPZmZzZXRQYXRoIiwib2Zmc2V0UGF0aCIsImFzc2lnblBhcnNlZFN0eWxlIiwibmVlZFVwZGF0ZUdlb21ldHJ5IiwiZ2V0UGFyc2VkU3R5bGVMaXN0T2YiLCJmaWxsIiwic3Ryb2tlIiwic2hhZG93Q29sb3IiLCJsaW5lRGFzaCIsInRleHRUcmFuc2Zvcm0iLCJjYWxjdWxhdG9yIiwidHJhbnNmb3JtT3JpZ2luIiwibWFya2VyU3RhcnQiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJ6SW5kZXgiLCJwb3N0UHJvY2Vzc29yIiwib2Zmc2V0RGlzdGFuY2UiLCJnZW9tZXRyeSIsImRpcnR5IiwicmVuZGVyYWJsZSIsImJvdW5kc0RpcnR5IiwicmVuZGVyQm91bmRzRGlydHkiLCJzY2VuZUdyYXBoU2VydmljZSIsImRpcnRpZnlUb1Jvb3QiLCJ1cGRhdGVHZW9tZXRyeSIsImdlb21ldHJ5VXBkYXRlciIsImdlb21ldHJ5VXBkYXRlckZhY3RvcnkiLCJjb250ZW50Qm91bmRzIiwicmVuZGVyQm91bmRzIiwiX2dlb21ldHJ5VXBkYXRlciR1cGRhIiwiX2dlb21ldHJ5VXBkYXRlciR1cGRhMiIsIl9nZW9tZXRyeVVwZGF0ZXIkdXBkYTMiLCJfZ2VvbWV0cnlVcGRhdGVyJHVwZGE0IiwiY3oiLCJfZ2VvbWV0cnlVcGRhdGVyJHVwZGE1IiwiaHdpZHRoIiwiX2dlb21ldHJ5VXBkYXRlciR1cGRhNiIsImhoZWlnaHQiLCJfZ2VvbWV0cnlVcGRhdGVyJHVwZGE3IiwiaGRlcHRoIiwiX3BhcnNlZFN0eWxlJGxpbmVXaWR0IiwiX3BhcnNlZFN0eWxlJGluY3JlYXNlIiwiaW5jcmVhc2VkTGluZVdpZHRoRm9ySGl0VGVzdGluZyIsIl9wYXJzZWRTdHlsZSRzaGFkb3dUeSIsInNoYWRvd1R5cGUiLCJfcGFyc2VkU3R5bGUkZmlsdGVyIiwiZXhwYW5zaW9uIiwiU1FSVDIiLCJoYXNTdHJva2UiLCJoYWxmTGluZVdpZHRoIiwiX2dlb21ldHJ5JHJlbmRlckJvdW5kIiwic2hhZG93Qmx1ciIsInNoYWRvd09mZnNldFgiLCJzaGFkb3dPZmZzZXRZIiwic2hhZG93Qmx1ckluUGl4ZWxzIiwic2hhZG93T2Zmc2V0WEluUGl4ZWxzIiwic2hhZG93T2Zmc2V0WUluUGl4ZWxzIiwic2hhZG93TGVmdCIsInNoYWRvd1JpZ2h0Iiwic2hhZG93VG9wIiwic2hhZG93Qm90dG9tIiwiYmx1clJhZGl1cyIsIl9zaGFkb3dPZmZzZXRYIiwiX3NoYWRvd09mZnNldFkiLCJfc2hhZG93Qmx1ciIsIl9nZW9tZXRyeSRyZW5kZXJCb3VuZDIiLCJfbWluIiwiX21heCIsIl9zaGFkb3dMZWZ0IiwiX3NoYWRvd1JpZ2h0IiwiX3NoYWRvd1RvcCIsIl9zaGFkb3dCb3R0b20iLCJmbGlwWSIsImZsaXBYIiwidXNlZE9yaWdpblhWYWx1ZSIsInVzZWRPcmlnaW5ZVmFsdWUiLCJzZXRPcmlnaW4iLCJ1cGRhdGVTaXplQXR0ZW51YXRpb24iLCJpc1NpemVBdHRlbnVhdGlvbiIsInJhd0xpbmVXaWR0aCIsInJhd1IiLCJQQVJTRURfU1RZTEVfTElTVCIsIkNTU1Byb3BlcnR5QW5nbGUiLCJtaXhlciIsIm9sZFBhcnNlZCIsIkNTU1Byb3BlcnR5Q2xpcFBhdGgiLCJvbGRQYXRoIiwibmV3UGF0aCIsInVwZGF0ZURpc3BsYXlPYmplY3REZXBlbmRlbmN5IiwiY2hpbGROb2RlcyIsIkNTU1Byb3BlcnR5Q29sb3IiLCJwYXJzZXIiLCJDU1NQcm9wZXJ0eUZpbHRlciIsImdldEZvbnRTaXplIiwiZm9udFNpemUiLCJDU1NQcm9wZXJ0eUxlbmd0aE9yUGVyY2VudGFnZSIsImNvbXB1dGVkIiwicGFyZW50Tm9kZSIsIl9vYmplY3Qkb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJfZm9udFNpemUiLCJDU1NQcm9wZXJ0eUxlbmd0aE9yUGVyY2VudGFnZTEyIiwiQ1NTUHJvcGVydHlMZW5ndGhPclBlcmNlbnRhZ2UxNCIsIkNTU1Byb3BlcnR5TWFya2VyIiwib2xkTWFya2VyIiwibmV3TWFya2VyIiwiX25ld01hcmtlciIsImNsb25lZCIsImNsb25lTm9kZSIsImlzTWFya2VyIiwiQ1NTUHJvcGVydHlOdW1iZXIiLCJDU1NQcm9wZXJ0eU9mZnNldERpc3RhbmNlIiwiX29iamVjdCRwYXJzZWRTdHlsZSIsImdldFBvaW50Iiwic2V0TG9jYWxQb3NpdGlvbiIsIkNTU1Byb3BlcnR5T3BhY2l0eSIsIkNTU1Byb3BlcnR5UGF0aCIsIkNTU1Byb3BlcnR5UG9pbnRzIiwiQ1NTUHJvcGVydHlTaGFkb3dCbHVyIiwiX0NTU1Byb3BlcnR5TGVuZ3RoT3JQIiwiQ1NTUHJvcGVydHlUZXh0Iiwibm9kZVZhbHVlIiwiQ1NTUHJvcGVydHlUZXh0VHJhbnNmb3JtIiwicmF3VGV4dCIsImdldEF0dHJpYnV0ZSIsInRyYW5zZm9ybWVkVGV4dCIsImNoYXJBdCIsImRlZmluZWRQcm9wcyIsIm9iaiIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIkNBTlZBU19NYXAiLCJXZWFrTWFwIiwiY2xlYW5FeGlzdGVkQ2FudmFzIiwiY29udGFpbmVyIiwiY2xlYW5VcCIsIiRkb20iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZGVzdHJveSIsImlzQnJvd3NlciIsImlzRWxlbWVudCIsInNvcnRlZEluZGV4IiwiYXJyYXkiLCJsb3ciLCJoaWdoIiwic29ydEJ5WkluZGV4IiwibzEiLCJvMiIsInpJbmRleDEiLCJ6SW5kZXgyIiwiZmluZENsb3Nlc3RDbGlwUGF0aFRhcmdldCIsIl9lbCRwYXJzZWRTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJQWF9TVUZGSVgiLCJzZXRET01TaXplIiwiJGVsIiwiZ2V0U3R5bGUiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0V2lkdGgiLCJvZmZzZXRXaWR0aCIsImdldEhlaWdodCIsIm9mZnNldEhlaWdodCIsIk1PVVNFX1BPSU5URVJfSUQiLCJUT1VDSF9UT19QT0lOVEVSIiwidG91Y2hzdGFydCIsInRvdWNoZW5kIiwidG91Y2hlbmRvdXRzaWRlIiwidG91Y2htb3ZlIiwidG91Y2hjYW5jZWwiLCJjbG9jayIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsImlzSW5GcmFnbWVudCIsIkZSQUdNRU5UIiwiZ2V0Um9vdE5vZGUiLCJpc0ZpbGxPclN0cm9rZUFmZmVjdGVkIiwicG9pbnRlckV2ZW50cyIsImhhc0ZpbGwiLCJpc0ZpbGxPdGhlclRoYW5Ob25lIiwiaXNTdHJva2VPdGhlclRoYW5Ob25lIiwidUlkIiwidW5pcXVlSWQiLCJyb290Iiwibm93T2Zmc2V0IiwicG5vdyIsInJlc2VydmVkQ0JzIiwibGFzdFRpbWUiLCJwb2x5ZmlsbFJhZiIsImN1cnJlbnRUaW1lIiwiZ2FwIiwiZGVsYXkiLCJrZXlzIiwic2V0VGltZW91dCIsImNvcGllZCIsInBvbHlmaWxsQ2FmIiwidmVuZG9yUHJlZml4ZXMiLCJnZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ2cCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldENhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJwcmVkaWNhdGUiLCJyYWYiLCJjYWYiLCJBc3luY1BhcmFsbGVsSG9vayIsImNhbGxiYWNrcyIsImdldENhbGxiYWNrc051bSIsInRhcFByb21pc2UiLCJmbiIsInByb21pc2UiLCJQcm9taXNlIiwiQXN5bmNTZXJpZXNXYXRlcmZhbGxIb29rIiwiX3Byb21pc2UiLCJtYXJrIiwiX2NhbGxlZSIsIl90aGlzJGNhbGxiYWNrcyIsIl9hcmdzIiwid3JhcCIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJuZXh0Iiwic2VudCIsImFicnVwdCIsIlN5bmNIb29rIiwidGFwIiwiY2FsbCIsImFyZ3NBcnIiLCJTeW5jV2F0ZXJmYWxsSG9vayIsImdlbmVyaWNGb250RmFtaWxpZXMiLCJzdHJpbmdSZWdFeHAiLCJ0b0ZvbnRTdHJpbmciLCJfYXR0cmlidXRlcyRmb250U2l6ZSIsIl9hdHRyaWJ1dGVzJGZvbnRGYW1pbCIsImZvbnRGYW1pbHkiLCJfYXR0cmlidXRlcyRmb250U3R5bGUiLCJmb250U3R5bGUiLCJfYXR0cmlidXRlcyRmb250VmFyaWEiLCJmb250VmFyaWFudCIsIl9hdHRyaWJ1dGVzJGZvbnRXZWlnaCIsImZvbnRXZWlnaHQiLCJmb250U2l6ZVN0cmluZyIsImZvbnRGYW1pbGllcyIsIl9mb250RmFtaWx5IiwiY3JlYXRlU2tld01hdHJpeCIsInNrZXdNYXRyaXgiLCIkbWF0NF8xIiwiJG1hdDRfMiIsImZyb21TY2FsaW5nIiwiZnJvbVpSb3RhdGlvbiIsImZyb21YUm90YXRpb24iLCJmcm9tWVJvdGF0aW9uIiwiZnJvbVJvdGF0aW9uIiwiJHZlYzNPbmUkMSIsIiR2ZWMzWmVybyQxIiwib3B0aW1pemVyIiwic2V0TG9jYWxTY2FsZSIsInNldExvY2FsRXVsZXJBbmdsZXMiLCJkaXJ0aWZ5TG9jYWwiLCJ0cmFuc2Zvcm1hYmxlIiwicGFyc2VkVHJhbnNmb3JtVG9NYXQ0IiwiX3RyYW5zZm9ybSRpIiwibXVsIiwic2V0TG9jYWxUcmFuc2Zvcm0iLCJyZXNldExvY2FsVHJhbnNmb3JtIiwiQ1NTUHJvcGVydHlUcmFuc2Zvcm0iLCJDU1NQcm9wZXJ0eVRyYW5zZm9ybU9yaWdpbiIsIkNTU1Byb3BlcnR5WkluZGV4IiwicGFyZW50RW50aXR5IiwicGFyZW50UmVuZGVyYWJsZSIsInBhcmVudFNvcnRhYmxlIiwic29ydGFibGUiLCJkaXJ0eVJlYXNvbiIsIlpfSU5ERVhfQ0hBTkdFRCIsIkNpcmNsZVVwZGF0ZXIiLCJfcGFyc2VkU3R5bGUkY3giLCJfcGFyc2VkU3R5bGUkY3kiLCJfcGFyc2VkU3R5bGUkciIsIkVsbGlwc2VVcGRhdGVyIiwiX3BhcnNlZFN0eWxlJHJ4IiwiX3BhcnNlZFN0eWxlJHJ5IiwiTGluZVVwZGF0ZXIiLCJQYXRoVXBkYXRlciIsIl9kJHJlY3QiLCJQb2x5bGluZVVwZGF0ZXIiLCJSZWN0VXBkYXRlciIsIl9wYXJzZWRTdHlsZSR3aWR0aCIsIl9wYXJzZWRTdHlsZSRoZWlnaHQiLCJjb250ZW50V2lkdGgiLCJjb250ZW50SGVpZ2h0IiwiVGV4dFVwZGF0ZXIiLCJnbG9iYWxSdW50aW1lIiwiaXNSZWFkeVRvTWVhc3VyZSIsIl9wYXJzZWRTdHlsZSR0ZXh0QWxpZyIsInRleHRBbGlnbiIsIl9wYXJzZWRTdHlsZSR0ZXh0QmFzZSIsInRleHRCYXNlbGluZSIsIl9wYXJzZWRTdHlsZSRkeCIsIl9wYXJzZWRTdHlsZSRkeSIsIm1ldHJpY3MiLCJmb250IiwibGluZXMiLCJsaW5lV2lkdGhzIiwibGluZUhlaWdodCIsIm1heExpbmVXaWR0aCIsImZvbnRQcm9wZXJ0aWVzIiwiYXNjZW50IiwiZGVzY2VudCIsImxpbmVNZXRyaWNzIiwib2Zmc2NyZWVuQ2FudmFzIiwidGV4dFNlcnZpY2UiLCJtZWFzdXJlVGV4dCIsImxpbmVYT2Zmc2V0IiwibGluZVlPZmZzZXQiLCJHcm91cFVwZGF0ZXIiLCJIVE1MVXBkYXRlciIsImlzRmVkZXJhdGVkRXZlbnQiLCJGZWRlcmF0ZWRFdmVudCIsIm1hbmFnZXIiLCJldmVudFBoYXNlIiwiTk9ORSIsImJ1YmJsZXMiLCJjYW5jZWxCdWJibGUiLCJjYW5jZWxhYmxlIiwiZGVmYXVsdFByZXZlbnRlZCIsInByb3BhZ2F0aW9uU3RvcHBlZCIsInByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkIiwibGF5ZXIiLCJwYWdlIiwidmlld3BvcnQiLCJjb21wb3NlZCIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwiY29tcG9zZWRQYXRoIiwicHJvcGFnYXRpb25QYXRoIiwicHJldmVudERlZmF1bHQiLCJuYXRpdmVFdmVudCIsIkV2ZW50Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwiaW5pdEV2ZW50IiwiaW5pdFVJRXZlbnQiLCJGZWRlcmF0ZWRNb3VzZUV2ZW50IiwiY2xpZW50IiwibW92ZW1lbnQiLCJzY3JlZW4iLCJnZXRNb2RpZmllclN0YXRlIiwiaW5pdE1vdXNlRXZlbnQiLCJGZWRlcmF0ZWRQb2ludGVyRXZlbnQiLCJfRmVkZXJhdGVkTW91c2VFdmVudCIsImlzUHJpbWFyeSIsImdldENvYWxlc2NlZEV2ZW50cyIsImdldFByZWRpY3RlZEV2ZW50cyIsImNsb25lUG9pbnRlckV2ZW50IiwiRmVkZXJhdGVkV2hlZWxFdmVudCIsImNsb25lV2hlZWxFdmVudCIsIkN1c3RvbUV2ZW50IiwiX0ZlZGVyYXRlZEV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ0FOVkFTX0NBQ0hFIiwiRXZlbnRUYXJnZXQiLCJlbWl0dGVyIiwib24iLCJsaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXB0dXJlIiwib25jZSIsIl9vcHRpb25zJGNhcHR1cmUiLCJfb3B0aW9ucyRvbmNlIiwiaGFuZGxlRXZlbnQiLCJvZmYiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMiLCJfdGhpcyRlbWl0dGVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2xpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsImUiLCJza2lwUHJvcGFnYXRlIiwiX293bmVyRG9jdW1lbnQiLCJnZXRFdmVudFNlcnZpY2UiLCJOb2RlIiwiX0V2ZW50VGFyZ2V0Iiwic2hhZG93IiwiaXNDb25uZWN0ZWQiLCJiYXNlVVJJIiwibm9kZVR5cGUiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImRvbmUiLCJfY2hpbGQiLCJ0ZXh0Q29udGVudCIsImVyciIsImNvbnRlbnQiLCJfdGhpczIiLCJyZW1vdmVDaGlsZCIsIm9wdHMiLCJob3N0IiwiaGFzQ2hpbGROb2RlcyIsImlzRGVmYXVsdE5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsImxvb2t1cE5hbWVzcGFjZVVSSSIsInByZWZpeCIsImxvb2t1cFByZWZpeCIsImlzRXF1YWxOb2RlIiwib3RoZXJOb2RlIiwiaXNTYW1lTm9kZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwibm9kZTFSb290Iiwibm9kZTJSb290Iiwibm9kZTFIaWVyYXJjaHkiLCJub2RlMkhpZXJhcmNoeSIsIl9ub2RlMVJvb3QkcGFyZW50Tm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRCIsIkRPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwibG9uZ2VySGllcmFyY2h5Iiwic2hvcnRlckhpZXJhcmNoeSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TIiwibG9uZ2VyU3RhcnQiLCJzaG9ydGVySGllcmFyY2h5Tm9kZSIsImxvbmdlckhpZXJhcmNoeU5vZGUiLCJjb250YWluIiwiZ2V0QW5jZXN0b3IiLCJQUk9QQUdBVElPTl9MSU1JVCIsIkV2ZW50U2VydmljZSIsIm5hdGl2ZUhUTUxNYXAiLCJjdXJzb3IiLCJtYXBwaW5nVGFibGUiLCJtYXBwaW5nU3RhdGUiLCJ0cmFja2luZ0RhdGEiLCJldmVudFBvb2wiLCJ0bXBNYXRyaXgiLCJ0bXBWZWMzIiwib25Qb2ludGVyRG93biIsImZyb20iLCJjcmVhdGVQb2ludGVyRXZlbnQiLCJwb2ludGVyVHlwZSIsImlzUmlnaHRCdXR0b24iLCJidXR0b24iLCJwb2ludGVySWQiLCJwcmVzc1RhcmdldHNCeUJ1dHRvbiIsImZyZWVFdmVudCIsIm9uUG9pbnRlclVwIiwiYWx3YXlzVHJpZ2dlclBvaW50ZXJFdmVudE9uQ2FudmFzIiwicm9vdFRhcmdldCIsInByZXNzVGFyZ2V0IiwiZmluZE1vdW50ZWRUYXJnZXQiLCJjbGlja1RhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJub3RpZnlUYXJnZXQiLCJfaXNSaWdodEJ1dHRvbiIsIl9lJGRldGFpbCIsImNsaWNrRXZlbnQiLCJjbGlja3NCeUJ1dHRvbiIsImNsaWNrQ291bnQiLCJ0aW1lU3RhbXAiLCJyZW5kZXJpbmdDb250ZXh0IiwiY2xpY2tIaXN0b3J5IiwiZGJsQ2xpY2tTcGVlZCIsInByZXZlbnRDbGljayIsInVzZU5hdGl2ZUNsaWNrRXZlbnQiLCJvblBvaW50ZXJNb3ZlIiwiaXNNb3VzZSIsIm91dFRhcmdldCIsIm92ZXJUYXJnZXRzIiwib3V0VHlwZSIsIm91dEV2ZW50IiwibGVhdmVFdmVudCIsIm92ZXJUeXBlIiwib3ZlckV2ZW50Iiwib3ZlclRhcmdldEFuY2VzdG9yIiwiZGlkUG9pbnRlckVudGVyIiwiZW50ZXJFdmVudCIsImdldEN1cnNvciIsIm9uUG9pbnRlck91dCIsIm9uUG9pbnRlck92ZXIiLCJvblBvaW50ZXJVcE91dHNpZGUiLCJvbldoZWVsIiwid2hlZWxFdmVudCIsImNyZWF0ZVdoZWVsRXZlbnQiLCJvbkNsaWNrIiwib25Qb2ludGVyQ2FuY2VsIiwiaW5pdCIsImFkZEV2ZW50TWFwcGluZyIsImdldFNjYWxlIiwiY29udGV4dFNlcnZpY2UiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXREb21FbGVtZW50IiwiY2xpZW50MlZpZXdwb3J0IiwiX3RoaXMkZ2V0U2NhbGUiLCJ2aWV3cG9ydDJDbGllbnQiLCJfdGhpcyRnZXRTY2FsZTIiLCJjYW1lcmEiLCJnZXRDYW1lcmEiLCJfdGhpcyRjb250ZXh0JGNvbmZpZyIsIndvcmxkTWF0cml4IiwiY2FudmFzMlZpZXdwb3J0IiwiY2FudmFzUCIsImNsaXAiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzIiLCJzZXRQaWNrSGFuZGxlciIsInBpY2tIYW5kbGVyIiwicHJpb3JpdHkiLCJtYXBFdmVudCIsIm1hcHBlcnMiLCJ3YXJuIiwicHJvcGFnYXRlIiwibm90aWZ5TGlzdGVuZXJzIiwidW5zaGlmdCIsImhpdFRlc3QiLCJ2aWV3cG9ydFgiLCJ2aWV3cG9ydFkiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzMiLCJkaXNhYmxlSGl0VGVzdGluZyIsImlzTmF0aXZlRXZlbnRGcm9tQ2FudmFzIiwiX3RhcmdldCIsInNoYWRvd1Jvb3QiLCJnZXRFeGlzdGVkSFRNTCIsImV2ZW50IiwiX2FyciIsImV2ZW50VGFyZ2V0IiwiZXhpc3RlZCIsInBpY2tUYXJnZXQiLCJjbGllbnRYIiwiY2xpZW50WSIsImNhbnZhc1giLCJjYW52YXNZIiwiZmFsbGJhY2tUYXJnZXQiLCJhbGxvY2F0ZUV2ZW50IiwiY29weVBvaW50ZXJEYXRhIiwiY29weU1vdXNlRGF0YSIsImNvcHlEYXRhIiwib3JpZ2luYWxFdmVudCIsImV4aXN0ZWRIVE1MIiwiY29weVdoZWVsRGF0YSIsIm92ZXJUYXJnZXQiLCJwcmVzc3VyZSIsInRhbmdlbnRpYWxQcmVzc3VyZSIsInRpbHRYIiwidGlsdFkiLCJ0d2lzdCIsImFsdEtleSIsImJ1dHRvbnMiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiZGVsdGFNb2RlIiwiZGVsdGFYIiwiZGVsdGFZIiwiZGVsdGFaIiwiaXNUcnVzdGVkIiwibGlzdGVuZXJzIiwiX2V2ZW50cyIsInJlbW92ZUxpc3RlbmVyIiwiT2Zmc2NyZWVuQ2FudmFzQ3JlYXRvciIsImdldE9yQ3JlYXRlQ2FudmFzIiwiY29udGV4dEF0dHJpYnV0ZXMiLCJnZXRDb250ZXh0Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImdldE9yQ3JlYXRlQ29udGV4dCIsImNyZWF0ZUNhbnZhcyIsIl91bnVzZWQyIiwiX3VudXNlZDMiLCJSZW5kZXJSZWFzb24iLCJSZW5kZXJpbmdTZXJ2aWNlIiwiaW5pdGVkIiwic3RhdHMiLCJ0b3RhbCIsInJlbmRlcmVkIiwiekluZGV4Q291bnRlciIsImhvb2tzIiwiaW5pdEFzeW5jIiwiZGlydHljaGVjayIsImN1bGwiLCJiZWdpbkZyYW1lIiwiYmVmb3JlUmVuZGVyIiwicmVuZGVyIiwiYWZ0ZXJSZW5kZXIiLCJlbmRGcmFtZSIsInBpY2siLCJwaWNrU3luYyIsInBvaW50ZXJEb3duIiwicG9pbnRlclVwIiwicG9pbnRlck1vdmUiLCJwb2ludGVyT3V0IiwicG9pbnRlck92ZXIiLCJwb2ludGVyV2hlZWwiLCJwb2ludGVyQ2FuY2VsIiwiY2xpY2siLCJ0aGVuIiwiZ2V0U3RhdHMiLCJkaXNhYmxlRGlydHlSZWN0YW5nbGVSZW5kZXJpbmciLCJyZW5kZXJlciIsIl9yZW5kZXJlciRnZXRDb25maWciLCJyZW5kZXJSZWFzb25zIiwiQ0FNRVJBX0NIQU5HRUQiLCJjYW52YXNDb25maWciLCJmcmFtZSIsInJlcmVuZGVyQ2FsbGJhY2siLCJzeW5jSGllcmFyY2h5IiwidHJpZ2dlclBlbmRpbmdFdmVudHMiLCJkaXJ0eVJlY3RhbmdsZVJlbmRlcmluZ0Rpc2FibGVkIiwib25seUNhbWVyYUNoYW5nZWQiLCJzaG91bGRUcmlnZ2VyUmVuZGVySG9va3MiLCJkaXNhYmxlUmVuZGVySG9va3MiLCJyZW5kZXJEaXNwbGF5T2JqZWN0IiwicmVuZGVyTGlzdEN1cnJlbnRGcmFtZSIsImRpc3BsYXlPYmplY3QiLCJfY2FudmFzQ29uZmlnJHJlbmRlcmUiLCJpbnRlcm5hbFJlbmRlclNpbmdsZURpc3BsYXlPYmplY3QiLCJvYmplY3RDaGFuZ2VkIiwib2JqZWN0VG9SZW5kZXIiLCJyZW5kZXJPcmRlciIsImRpcnR5Q2hpbGRyZW4iLCJjdXJyZW50T2JqZWN0Iiwib2JqZWN0cyIsInNvcnRlZCIsIl9pbmRleCIsIl9pbmRleDIiLCJjbGVhclBlbmRpbmdFdmVudHMiLCJkaXJ0aWZ5IiwiRElTUExBWV9PQkpFQ1RfQ0hBTkdFRCIsIkFUVFJJQlVURV9SRUdFWFAiLCJEZWZhdWx0U2NlbmVHcmFwaFNlbGVjdG9yIiwic2VsZWN0T25lIiwicXVlcnkiLCJzdGFydHNXaXRoIiwiY2xhc3NMaXN0IiwiZ2V0SWRPckNsYXNzbmFtZSIsIl90aGlzJGdldEF0dHJpYnV0ZSIsImF0dHJpYnV0ZVRvU3RyaW5nIiwic2VsZWN0QWxsIiwiZmluZEFsbCIsIl90aGlzJGdldEF0dHJpYnV0ZTIiLCJpcyIsImNsYXNzTmFtZSIsIl90aGlzJGdldEF0dHJpYnV0ZTMiLCJtYXRjaGVzIiwiRWxlbWVudEV2ZW50IiwiTXV0YXRpb25FdmVudCIsInR5cGVBcmciLCJyZWxhdGVkTm9kZSIsInByZXZWYWx1ZSIsImF0dHJOYW1lIiwiYXR0ckNoYW5nZSIsInByZXZQYXJzZWRWYWx1ZSIsIm5ld1BhcnNlZFZhbHVlIiwiQURESVRJT04iLCJNT0RJRklDQVRJT04iLCJSRU1PVkFMIiwibWFya1JlbmRlcmFibGVEaXJ0eSIsInJlcGFyZW50RXZlbnQiLCJSRVBBUkVOVCIsIiR2ZWMyWmVybyIsIiR2ZWMzWmVybyIsIiR2ZWMzT25lIiwiJG1hdDRJZGVudGl0eSIsIiR2ZWMyIiwiJHZlYzMkMSIsIiRtYXQ0IiwiJHF1YXQkMSIsIiRzZXRMb2NhbFRyYW5zZm9ybV8xIiwiJHNldExvY2FsVHJhbnNmb3JtXzIiLCIkc2V0TG9jYWxUcmFuc2Zvcm1fMyIsIiRzZXRMb2NhbFBvc2l0aW9uIiwiJHNldFBvc2l0aW9uXzEiLCIkc2V0UG9zaXRpb25fUGFyZW50SW52ZXJ0TWF0cml4IiwiJHNldEV1bGVyQW5nbGVzX0ludlBhcmVudFJvdCIsIiRyb3RhdGVMb2NhbCIsIiRyb3RhdGVfUGFyZW50SW52ZXJ0Um90YXRpb24iLCIkdHJpZ2dlclBlbmRpbmdFdmVudHNfZGV0YWlsIiwiYWZmZWN0Q2hpbGRyZW4iLCJEZWZhdWx0U2NlbmVHcmFwaFNlcnZpY2UiLCJwZW5kaW5nRXZlbnRzIiwiYm91bmRzQ2hhbmdlZEV2ZW50IiwiQk9VTkRTX0NIQU5HRUQiLCJkaXNwbGF5T2JqZWN0RGVwZW5kZW5jeU1hcCIsInNjZW5lR3JhcGhTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYXR0YWNoIiwiX3NvcnRhYmxlJHNvcnRlZCIsImRldGFjaGVkIiwiZGV0YWNoIiwiaXNDaGlsZEZyYWdtZW50IiwiaXNBdHRhY2hUb0ZyYWdtZW50Iiwibm9kZXMiLCJBRERFRCIsImRpcnRpZnlGcmFnbWVudCIsImRpcnRpZnlXb3JsZCIsIl9zb3J0YWJsZSRzb3J0ZWQyIiwiX3N0eWxlIiwiUkVNT1ZFRCIsImdldE9yaWdpbiIsImVsZW1lbnQiLCJvcmlnaW4iLCJvcmlnaW5WZWMiLCJkZWdyZWVzIiwicm90YXRlTG9jYWwiLCJmcm9tRXVsZXIiLCJyb3QiLCJnZXRSb3RhdGlvbiIsInBhcmVudFJvdCIsImxvY2FsUm90YXRpb24iLCJzZXRFdWxlckFuZ2xlcyIsInBhcmVudFJvdGF0aW9uIiwidHJhbnNsYXRlTG9jYWwiLCJ0cmFuc2Zvcm1RdWF0IiwibG9jYWxQb3NpdGlvbiIsIl9wb3NpdGlvbiQiLCJwYXJlbnRUcmFuc2Zvcm0iLCJ3b3JsZFRyYW5zZm9ybSIsIl9wb3NpdGlvbiQyIiwic2NhbGVMb2NhbCIsInNjYWxpbmciLCJfc2NhbGluZyQiLCJsb2NhbFNjYWxlIiwiX3NjYWxpbmckMiIsInNldFJvdGF0aW9uIiwic2V0TG9jYWxSb3RhdGlvbiIsInNldExvY2FsU2tldyIsImxvY2FsU2tldyIsImxvY2FsRGlydHlGbGFnIiwiZGlydHlGbGFnIiwidW5mcmVlemVQYXJlbnRUb1Jvb3QiLCJkaXJ0aWZ5V29ybGRJbnRlcm5hbCIsImZyb3plbiIsInRyaWdnZXJlZCIsInRyaWdnZXIiLCJpc011dGF0aW9uT2JzZXJ2ZWQiLCJpbmZvcm1EZXBlbmRlbnREaXNwbGF5T2JqZWN0cyIsIm9sZERlcGVuZGVuY3lNYXAiLCJuZXdEZXBlbmRlbmN5TWFwIiwiZGVwZW5kZW5jeU1hcCIsIkFUVFJfTU9ESUZJRUQiLCJpc0N1c3RvbUVsZW1lbnQiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJnZXRUcmFuc2xhdGlvbiIsInN5bmMiLCJnZXRMb2NhbFBvc2l0aW9uIiwiZ2V0TG9jYWxSb3RhdGlvbiIsImdldExvY2FsU2NhbGUiLCJnZXRMb2NhbFNrZXciLCJjYWxjTG9jYWxUcmFuc2Zvcm0iLCJoYXNTa2V3IiwibG9jYWxUcmFuc2Zvcm0iLCJoYXNQb3NpdGlvbiIsImhhc1JvdGF0aW9uIiwiaGFzU2NhbGUiLCJoYXNPcmlnaW4iLCJnZXRUcmFuc2Zvcm1lZEdlb21ldHJ5Qm91bmRzIiwiZXhpc3RlZEFBQkIiLCJzdHlsZVZhbHVlUmVnaXN0cnkiLCJnZXRCb3VuZHMiLCJfdGhpczMiLCJjaGlsZEJvdW5kcyIsImNsaXBwZWQiLCJjbGlwUGF0aEJvdW5kcyIsInBhcmVudEludmVydCIsImxvY2FsQm91bmRzIiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwiZ2V0Q29udGV4dFNlcnZpY2UiLCJfYWFiYiRnZXRNaW4iLCJfYWFiYiRnZXRNaW4yIiwiX2FhYmIkZ2V0TWF4IiwiX2FhYmIkZ2V0TWF4MiIsIl90aGlzNCIsImNoaWxkVHJhbnNmb3JtIiwiVEVYVF9NRVRSSUNTIiwiTWV0cmljc1N0cmluZyIsIkJhc2VsaW5lU3ltYm9sIiwiQmFzZWxpbmVNdWx0aXBsaWVyIiwiSGVpZ2h0TXVsdGlwbGllciIsIk5ld2xpbmVzIiwiQnJlYWtpbmdTcGFjZXMiLCJMQVRJTl9SRUdFWCIsInJlZ2V4Q2Fubm90U3RhcnRaaENuIiwicmVnZXhDYW5ub3RFbmRaaENuIiwicmVnZXhDYW5ub3RTdGFydFpoVHciLCJyZWdleENhbm5vdEVuZFpoVHciLCJyZWdleENhbm5vdFN0YXJ0SmFKcCIsInJlZ2V4Q2Fubm90RW5kSmFKcCIsInJlZ2V4Q2Fubm90U3RhcnRLb0tyIiwicmVnZXhDYW5ub3RFbmRLb0tyIiwicmVnZXhDYW5ub3RTdGFydCIsInJlZ2V4Q2Fubm90RW5kIiwiVGV4dFNlcnZpY2UiLCJmb250TWV0cmljc0NhY2hlIiwic2hvdWxkQnJlYWtCeUtpbnNva3VTaG9ydWkiLCJfY2hhciIsIm5leHRDaGFyIiwiaXNCcmVha2luZ1NwYWNlIiwidHJpbUJ5S2luc29rdVNob3J1aSIsInByZXZMaW5lIiwibGFzdENoYXIiLCJtZWFzdXJlRm9udCIsInByb3BlcnRpZXMiLCJvZmZzY3JlZW5DYW52YXNDcmVhdG9yIiwibWV0cmljc1N0cmluZyIsImJhc2VsaW5lIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJmaWxsVGV4dCIsImltYWdlZGF0YSIsImdldEltYWdlRGF0YSIsInBpeGVscyIsImxpbmUiLCJpZHgiLCJfcGFyc2VkU3R5bGUkZm9udFNpemUiLCJfcGFyc2VkU3R5bGUkd29yZFdyYXAiLCJ3b3JkV3JhcCIsInN0cm9rZUhlaWdodCIsIl9wYXJzZWRTdHlsZSRsZXR0ZXJTcCIsImxldHRlclNwYWNpbmciLCJ0ZXh0UGF0aCIsInRleHRQYXRoU2lkZSIsInRleHRQYXRoU3RhcnRPZmZzZXQiLCJfcGFyc2VkU3R5bGUkbGVhZGluZyIsImxlYWRpbmciLCJpc092ZXJmbG93aW5nIiwib3V0cHV0VGV4dCIsIl9saW5lV2lkdGgiLCJfd2lkdGgiLCJfcGFyc2VkU3R5bGUkd29yZFdyYXAyIiwid29yZFdyYXBXaWR0aCIsIl9wYXJzZWRTdHlsZSRsZXR0ZXJTcDIiLCJfcGFyc2VkU3R5bGUkbWF4TGluZXMiLCJtYXhMaW5lcyIsInRleHRPdmVyZmxvdyIsIm1heFdpZHRoIiwiZWxsaXBzaXMiLCJjaGFycyIsImN1cnJlbnRMaW5lSW5kZXgiLCJjdXJyZW50TGluZVdpZHRoIiwicHJldkxpbmVMYXN0Q2hhckluZGV4IiwiY2FsY1dpZHRoIiwidHh0IiwiZ2V0RnJvbUNhY2hlIiwiZWxsaXBzaXNXaWR0aCIsImZpbmRDaGFySW5kZXhDbG9zZXN0V2lkdGhUaHJlc2hvbGQiLCJsaW5lVHh0IiwidHh0TGFzdENoYXJJbmRleCIsInR4dFN0YXJ0Q2hhckluZGV4Iiwid2lkdGhUaHJlc2hvbGQiLCJpc05ld2xpbmUiLCJhcHBlbmRFbGxpcHNpcyIsImxpbmVJbmRleCIsInRleHRDaGFySW5kZXgiLCJfY2hhcjIiLCJwcmV2Q2hhciIsImNoYXJXaWR0aCIsImNhbkJyZWFrSW5MYXN0Q2hhciIsInRyaW1Ub0JyZWFrYWJsZSIsInN1bVRleHRXaWR0aEJ5Q2FjaGUiLCJfY2hhcjMiLCJjaGFyQ29kZUF0IiwiX2NoYXI0IiwiZmluZEJyZWFrYWJsZUluZGV4IiwidHJpbW1lZENoYXIiLCJpc1RyaW1tZWRXaXRoU3BhY2UiLCJ0cmltRnJvbSIsInRyaW1UbyIsIl9jaGFyNSIsImNhbGNXaWR0aFdpdGhDYWNoZSIsInN1bSIsInNwYWNpbmciLCJyZWN0VXBkYXRlciIsInBvbHlsaW5lVXBkYXRlciIsIklNQUdFIiwiSFRNTCIsIk1FU0giLCJQRVJDRU5UQUdFIiwiQU5HTEUiLCJnZXRHbG9iYWxUaGlzIiwiQ2FtZXJhQ29udHJpYnV0aW9uIiwiQW5pbWF0aW9uVGltZWxpbmUiLCJFYXNpbmdGdW5jdGlvbiIsImxheW91dFJlZ2lzdHJ5IiwiZW5hYmxlU3R5bGVTeW50YXgiLCJlbnRpdHlDb3VudGVyIiwicmVzZXRFbnRpdHlDb3VudGVyIiwiaW5zZXJ0ZWRFdmVudCIsIklOU0VSVEVEIiwicmVtb3ZlZEV2ZW50IiwiZGVzdHJveUV2ZW50IiwiREVTVFJPWSIsIkVsZW1lbnQiLCJfTm9kZSIsImVudGl0eSIsImRpcnR5UmVuZGVyQm91bmRzIiwiY3VsbGFibGUiLCJzdHJhdGVneSIsIlN0YW5kYXJkIiwidmlzaWJpbGl0eVBsYW5lTWFzayIsInZpc2libGUiLCJlbmFibGUiLCJyQnVzaE5vZGUiLCJuYW1lc3BhY2VVUkkiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImRlc3Ryb3llZCIsImNvbXB1dGVkU3R5bGUiLCJzZXRBdHRyaWJ1dGUiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiZGVlcCIsImFwcGVuZENoaWxkIiwiX3RoaXMkb3duZXJEb2N1bWVudCIsIm1vdW50RnJhZ21lbnQiLCJtb3VudENoaWxkcmVuIiwiaW5zZXJ0QmVmb3JlIiwibmV3Q2hpbGQiLCJyZWZDaGlsZCIsInJlcGxhY2VDaGlsZCIsIm9sZENoaWxkIiwiX2NoaWxkJG93bmVyRG9jdW1lbnQiLCJ1bm1vdW50Q2hpbGRyZW4iLCJyZW1vdmVDaGlsZHJlbiIsImRlc3Ryb3lDaGlsZHJlbiIsInNlbGVjdG9yIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJ0YWdOYW1lIiwic2VsZWN0b3JzIiwiY2xvc2VzdCIsImFmdGVyIiwiX2xlbjIiLCJfa2V5MiIsIl90aGlzNCRwYXJlbnROb2RlIiwiYmVmb3JlIiwiX2xlbjMiLCJfa2V5MyIsImZpcnN0IiwicmVzdCIsInJlcGxhY2VXaXRoIiwiYXBwZW5kIiwiX3RoaXM1IiwiX2xlbjQiLCJfa2V5NCIsInByZXBlbmQiLCJfdGhpczYiLCJfbGVuNSIsIl9rZXk1IiwicmVwbGFjZUNoaWxkcmVuIiwiZ2V0UmVuZGVyQm91bmRzIiwiZ2V0Q2xpZW50UmVjdHMiLCJjb21wdXRlZFN0eWxlTWFwIiwiZ2V0QXR0cmlidXRlTmFtZXMiLCJoYXNBdHRyaWJ1dGUiLCJxdWFsaWZpZWROYW1lIiwiaGFzQXR0cmlidXRlcyIsInJlbW92ZUF0dHJpYnV0ZSIsImF0dHJpYnV0ZU5hbWUiLCJmb3JjZSIsImdldEF0dHJpYnV0ZU5TIiwibG9jYWxOYW1lIiwiZ2V0QXR0cmlidXRlTm9kZSIsImdldEF0dHJpYnV0ZU5vZGVOUyIsImhhc0F0dHJpYnV0ZU5TIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGVOb2RlIiwiYXR0ciIsInNldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTm9kZSIsInNldEF0dHJpYnV0ZU5vZGVOUyIsInRvZ2dsZUF0dHJpYnV0ZSIsImlzRGlzcGxheU9iamVjdCIsIlByb3h5IiwiYXR0ck1vZGlmaWVkRXZlbnQiLCIkdmVjMyIsIiRxdWF0IiwiRGlzcGxheU9iamVjdCIsIl9FbGVtZW50IiwiYWN0aXZlQW5pbWF0aW9ucyIsImluaXRpYWxQYXJzZWRTdHlsZSIsImluaXRBdHRyaWJ1dGVzIiwic2V0UHJvcGVydHkiLCJwcm9wZXJ0eU5hbWUiLCJyZW1vdmVQcm9wZXJ0eSIsInByb3AiLCJnZXRBbmltYXRpb25zIiwiYW5pbWF0aW9uIiwiY2FuY2VsIiwiY3VzdG9tQ2xvbmVGdW5jIiwiY2xvbmVkU3R5bGUiLCJhdHRyaWJ1dGUiLCJjbG9uZWRDaGlsZCIsImludGVybmFsU2V0QXR0cmlidXRlIiwicGFyc2VPcHRpb25zIiwib2xkVmFsdWUiLCJvbGRQYXJzZWRWYWx1ZSIsIl9hdHRyaWJ1dGVDaGFuZ2VkQ2FsbCIsImdldEJCb3giLCJnZXRFdWxlckFuZ2xlcyIsIl9nZXRFdWxlciIsIl9nZXRFdWxlcjIiLCJleiIsImdldExvY2FsRXVsZXJBbmdsZXMiLCJfZ2V0RXVsZXIzIiwiX2dldEV1bGVyNCIsImFuaW1hdGUiLCJrZXlmcmFtZXMiLCJ0aW1lbGluZSIsInBsYXkiLCJpc1Zpc2libGUiLCJfdGhpcyRwYXJzZWRTdHlsZSIsInZpc2liaWxpdHkiLCJpc0ludGVyYWN0aXZlIiwiX3RoaXMkcGFyc2VkU3R5bGUyIiwiaXNDdWxsZWQiLCJ0b0Zyb250IiwidG9CYWNrIiwiZ2V0TWF0cml4IiwiX21hdDQkZ2V0VHJhbnNsYXRpb24iLCJfbWF0NCRnZXRUcmFuc2xhdGlvbjIiLCJfZ2V0RXVsZXI1IiwiX2dldEV1bGVyNiIsImV1eCIsImV1eiIsImdldExvY2FsTWF0cml4IiwiX2RlY29tcG9zZSIsIl9kZWNvbXBvc2UyIiwic2V0TG9jYWxNYXRyaXgiLCJfZGVjb21wb3NlMyIsIl9kZWNvbXBvc2U0Iiwic2hvdyIsImhpZGUiLCJnZXRDb3VudCIsImNoaWxkRWxlbWVudENvdW50IiwiZ2V0UGFyZW50IiwiZ2V0Q2hpbGRyZW4iLCJnZXRGaXJzdCIsImZpcnN0RWxlbWVudENoaWxkIiwiZ2V0TGFzdCIsImxhc3RFbGVtZW50Q2hpbGQiLCJnZXRDaGlsZEJ5SW5kZXgiLCJtb3ZlVG8iLCJtb3ZlIiwic2V0WkluZGV4IiwiQ2lyY2xlIiwiX0Rpc3BsYXlPYmplY3QiLCJfZXhjbHVkZWQkNiIsIkN1c3RvbUVsZW1lbnQiLCJFbGxpcHNlIiwiRnJhZ21lbnQiLCJHcm91cCIsIl9leGNsdWRlZCQ1IiwiSW1hZ2UiLCJfZXhjbHVkZWQkNCIsIkxpbmUiLCJ6MSIsIm1hcmtlclN0YXJ0QW5nbGUiLCJtYXJrZXJFbmRBbmdsZSIsInRyYW5zZm9ybU1hcmtlciIsImlzU3RhcnQiLCJtYXJrZXJTdGFydE9mZnNldCIsIm1hcmtlckVuZE9mZnNldCIsIm1hcmtlciIsIm9yaWdpbmFsQW5nbGUiLCJpbldvcmxkU3BhY2UiLCJfdGhpcyRwYXJzZWRTdHlsZTMiLCJfbGluZVBvaW50QXQiLCJ0cmFuc2Zvcm1lZCIsIl90aGlzJHBhcnNlZFN0eWxlNCIsIl9leGNsdWRlZCQzIiwiUGF0aCIsIm1pdGVyTGltaXQiLCJtYXJrZXJNaWRMaXN0IiwicGxhY2VNYXJrZXJNaWQiLCJfdGhpcyRnZXRTdGFydFRhbmdlbnQiLCJnZXRTdGFydFRhbmdlbnQiLCJfdGhpcyRnZXRTdGFydFRhbmdlbnQyIiwiX3RoaXMkZ2V0RW5kVGFuZ2VudCIsImdldEVuZFRhbmdlbnQiLCJfdGhpcyRnZXRFbmRUYW5nZW50MiIsIl9zZWdtZW50cyRpJGN1cnJlbnRQbyIsImdldFBvaW50QXRMZW5ndGgkMSIsIl9nZXRQb2ludEF0TGVuZ3RoMiIsImVuZFBvaW50IiwidGFuZ2VudCIsIl9leGNsdWRlZCQyIiwiUG9seWdvbiIsImlzQ2xvc2VkIiwiUCIsIl9leGNsdWRlZCQxIiwiUG9seWxpbmUiLCJfUG9seWdvbiIsInRlbXBMZW5ndGgiLCJzZWdtZW50VCIsInNlZ21lbnRMIiwic3VidCIsIlJlY3QiLCJfZXhjbHVkZWQiLCJUZXh0IiwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoIiwiX3RoaXMkcGFyc2VkU3R5bGUkbWV0IiwiZ2V0TGluZUJvdW5kaW5nUmVjdHMiLCJfdGhpcyRwYXJzZWRTdHlsZSRtZXQyIiwiQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJDU1MiLCJwZXJjZW50IiwiZW0iLCJyZW0iLCJncmFkIiwibXMiLCJyZWdpc3RlclByb3BlcnR5IiwiaW5oZXJpdHMiLCJpbnRlcnBvbGFibGUiLCJpbml0aWFsVmFsdWUiLCJyZWdpc3RlckxheW91dCIsImNsYXp6IiwiRG9jdW1lbnQiLCJpbml0aWFsU3R5bGUiLCJjdXN0b21FbGVtZW50cyIsInNoYXBlIiwiY3JlYXRlRWxlbWVudE5TIiwiZWxlbWVudHNGcm9tQkJveCIsInJCdXNoIiwickJ1c2hSb290IiwickJ1c2hOb2RlcyIsImhpdFRlc3RMaXN0IiwiX2Rpc3BsYXlPYmplY3QkcGFyc2VkIiwiaXNWaXNpYmlsaXR5QWZmZWN0ZWQiLCJlbGVtZW50RnJvbVBvaW50U3luYyIsIl90aGlzJGRlZmF1bHRWaWV3JGNhbiIsIl90aGlzJGRlZmF1bHRWaWV3JGdldCIsIl90aGlzJGRlZmF1bHRWaWV3JHZpZSIsIl90aGlzJGRlZmF1bHRWaWV3JGdldDIiLCJnZXRSZW5kZXJpbmdTZXJ2aWNlIiwidG9wbW9zdCIsInBpY2tlZCIsIl9lbGVtZW50RnJvbVBvaW50IiwiX3RoaXMkZGVmYXVsdFZpZXckY2FuMiIsIl90aGlzJGRlZmF1bHRWaWV3JGdldDMiLCJfdGhpcyRkZWZhdWx0VmlldyR2aWUyIiwiX3lpZWxkJHRoaXMkZGVmYXVsdFZpIiwiZWxlbWVudEZyb21Qb2ludCIsIl94IiwiX3gyIiwiZWxlbWVudHNGcm9tUG9pbnRTeW5jIiwiX3RoaXMkZGVmYXVsdFZpZXckY2FuMyIsIl90aGlzJGRlZmF1bHRWaWV3JGdldDQiLCJfdGhpcyRkZWZhdWx0VmlldyR2aWUzIiwiX3RoaXMkZGVmYXVsdFZpZXckZ2V0NSIsIl9lbGVtZW50c0Zyb21Qb2ludCIsIl9jYWxsZWUyIiwiX3RoaXMkZGVmYXVsdFZpZXckY2FuNCIsIl90aGlzJGRlZmF1bHRWaWV3JGdldDYiLCJfdGhpcyRkZWZhdWx0VmlldyR2aWU0IiwiX3lpZWxkJHRoaXMkZGVmYXVsdFZpMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImVsZW1lbnRzRnJvbVBvaW50IiwiX3gzIiwiX3g0IiwiQ3VsbGluZ1BsdWdpbiIsInN0cmF0ZWdpZXMiLCJyZW5kZXJpbmdTZXJ2aWNlIiwidGFnIiwidW5jdWxsZWRFbnRpdGllcyIsImV2ZXJ5IiwiQ1VMTEVEIiwiRXZlbnRQbHVnaW4iLCJhdXRvUHJldmVudERlZmF1bHQiLCJyb290UG9pbnRlckV2ZW50Iiwicm9vdFdoZWVsRXZlbnQiLCJfdGhpcyRjb250ZXh0JHJlbmRlcmkiLCJzdXBwb3J0c1RvdWNoRXZlbnRzIiwibm9ybWFsaXplZEV2ZW50cyIsIm5vcm1hbGl6ZVRvUG9pbnRlckV2ZW50Iiwibm9ybWFsaXplZEV2ZW50IiwiYm9vdHN0cmFwRXZlbnQiLCJldmVudFNlcnZpY2UiLCJzZXRDdXJzb3IiLCJfdGhpcyRjb250ZXh0JHJlbmRlcmkyIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsIl90aGlzMiRjb250ZXh0JHJlbmRlciIsIm5vcm1hbGl6ZVdoZWVsRXZlbnQiLCJldmVudHMiLCJpc05vcm1hbGl6ZWQiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiZmVkZXJhdGVkRXZlbnQiLCIkZWxlbWVudCIsIm91dHNpZGUiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiX2l0ZXJhdG9yNSIsIl9zdGVwNSIsInRyYW5zZmVyTW91c2VEYXRhIiwiX3RoaXMkY29udGV4dCRldmVudFNlIiwiX3RoaXMkY29udGV4dCRldmVudFNlMiIsIl90aGlzJGNvbnRleHQkZXZlbnRTZTMiLCJfdGhpcyRjb250ZXh0JGV2ZW50U2U0Iiwic3JjRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsInBhZ2VYIiwicGFnZVkiLCJzY3JlZW5YIiwic2NyZWVuWSIsInJlbGF0ZWRUYXJnZXQiLCJhcHBseUN1cnNvclN0eWxlIiwiaXNUb3VjaEV2ZW50IiwiY2hhbmdlZFRvdWNoZXMiLCJ0b3VjaCIsInRvdWNoZXMiLCJyYWRpdXNYIiwicmFkaXVzWSIsImlkZW50aWZpZXIiLCJpc01vdXNlRXZlbnQiLCJ0ZW1wRXZlbnQiLCJzaGFwZTJEIiwiRnJ1c3R1bUN1bGxpbmdTdHJhdGVneSIsIl9vYmplY3QkcGFyZW50Tm9kZSIsInBhcmVudFZpc2liaWxpdHlQbGFuZU1hc2siLCJjb21wdXRlVmlzaWJpbGl0eVdpdGhQbGFuZU1hc2siLCJJTkRFVEVSTUlOQVRFIiwiT1VUU0lERSIsInBhcmVudFBsYW5lTWFzayIsIklOU0lERSIsIm1hc2siLCJpc1NoYXBlMkQiLCJfcGxhbmVzJGsiLCJQcmVwYXJlUmVuZGVyZXJQbHVnaW4iLCJzeW5jVGFza3MiLCJpc0ZpcnN0VGltZVJlbmRlcmluZyIsInN5bmNpbmciLCJpc0ZpcnN0VGltZVJlbmRlcmluZ0ZpbmlzaGVkIiwiX3J1bnRpbWUkZ2xvYmFsVGhpcyRyIiwiaGFuZGxlQXR0cmlidXRlQ2hhbmdlZCIsImhhbmRsZUJvdW5kc0NoYW5nZWQiLCJoYW5kbGVNb3VudGVkIiwiaGFuZGxlVW5tb3VudGVkIiwiTU9VTlRFRCIsIlVOTU9VTlRFRCIsInJpYyIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJiaW5kIiwic3luY1JUcmVlIiwic3luY05vZGUiLCJfcmVuZGVyQm91bmRzJGdldE1pbiIsIl9yZW5kZXJCb3VuZHMkZ2V0TWluMiIsIl9yZW5kZXJCb3VuZHMkZ2V0TWF4IiwiX3JlbmRlckJvdW5kcyRnZXRNYXgyIiwiYnVsayIsInN5bmNlZCIsImlzQ2FudmFzIiwiQ2FudmFzRXZlbnQiLCJERUZBVUxUX0NBTUVSQV9aIiwiREVGQVVMVF9DQU1FUkFfTkVBUiIsIkRFRkFVTFRfQ0FNRVJBX0ZBUiIsIm1vdW50ZWRFdmVudCIsInVubW91bnRlZEV2ZW50IiwiYmVmb3JlUmVuZGVyRXZlbnQiLCJCRUZPUkVfUkVOREVSIiwicmVyZW5kZXJFdmVudCIsIlJFUkVOREVSIiwiYWZ0ZXJSZW5kZXJFdmVudCIsIkFGVEVSX1JFTkRFUiIsIkNhbnZhcyIsImJhY2tncm91bmQiLCJzdXBwb3J0c011dGlwbGVDYW52YXNlc0luT25lQ29udGFpbmVyIiwiX2NvbmZpZyRjbGVhblVwT25EZXN0IiwiY2xlYW5VcE9uRGVzdHJveSIsImRldmljZVBpeGVsUmF0aW8iLCJjcmVhdGVJbWFnZSIsInN1cHBvcnRzUG9pbnRlckV2ZW50cyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZHByIiwiUG9pbnRlckV2ZW50IiwiVG91Y2hFdmVudCIsIk1vdXNlRXZlbnQiLCJpbml0UmVuZGVyaW5nQ29udGV4dCIsImluaXREZWZhdWx0Q2FtZXJhIiwiaW5pdFJlbmRlcmVyIiwibWVyZ2VkQ29uZmlnIiwiZ2V0Um9vdCIsImdldFJlbmRlcmluZ0NvbnRleHQiLCJyZWFkeVByb21pc2UiLCJyZXNvbHZlIiwicmVzb2x2ZVJlYWR5UHJvbWlzZSIsInNraXBUcmlnZ2VyRXZlbnQiLCJCRUZPUkVfREVTVFJPWSIsImZyYW1lSWQiLCJBRlRFUl9ERVNUUk9ZIiwiY2xlYXJFdmVudFJldGFpbiIsImNoYW5nZVNpemUiLCJyZXNpemUiLCJSRVNJWkUiLCJydW4iLCJfdGljayIsInRpY2siLCJ0aW1lIiwiZmlyc3RDb250ZW50ZnVsbFBhaW50IiwibG9hZFJlbmRlcmVyQ29udGFpbmVyTW9kdWxlIiwiQ29udGV4dFNlcnZpY2UiLCJpbml0UmVuZGVyaW5nU2VydmljZSIsIl90aGlzNyIsImFzeW5jIiwiUkVBRFkiLCJSRU5ERVJFUl9DSEFOR0VEIiwiX3RoaXM4Iiwic2V0UmVuZGVyZXIiLCJvbGRSZW5kZXJlciIsInJldmVyc2UiLCJfdGhpczkiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsIl90aGlzMTAiLCJjb25uZWN0ZWRDYWxsYmFjayIsImdldFBvaW50QnlDbGllbnQiLCJnZXRDbGllbnRCeVBvaW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@antv+g-lite@2.2.16/node_modules/@antv/g-lite/dist/index.esm.js\n");

/***/ })

};
;