/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fmin@0.0.2";
exports.ids = ["vendor-chunks/fmin@0.0.2"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/fmin@0.0.2/node_modules/fmin/build/fmin.js":
/*!************************************************************************!*\
  !*** ../node_modules/.pnpm/fmin@0.0.2/node_modules/fmin/build/fmin.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */ function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100, tolerance = parameters.tolerance || 1e-10, fA = f(a), fB = f(b), delta = b - a;\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n        for(var i = 0; i < maxIterations; ++i){\n            delta /= 2;\n            var mid = a + delta, fMid = f(mid);\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n            if (Math.abs(delta) < tolerance || fMid === 0) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) {\n        var r = new Array(x);\n        for(var i = 0; i < x; ++i){\n            r[i] = 0;\n        }\n        return r;\n    }\n    function zerosM(x, y) {\n        return zeros(x).map(function() {\n            return zeros(y);\n        });\n    }\n    function dot(a, b) {\n        var ret = 0;\n        for(var i = 0; i < a.length; ++i){\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n    function norm2(a) {\n        return Math.sqrt(dot(a, a));\n    }\n    function scale(ret, value, c) {\n        for(var i = 0; i < value.length; ++i){\n            ret[i] = value[i] * c;\n        }\n    }\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for(var j = 0; j < ret.length; ++j){\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n    /** minimizes a function using the downhill simplex method */ function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 0.001, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== undefined ? parameters.rho : 1, chi = parameters.chi !== undefined ? parameters.chi : 2, psi = parameters.psi !== undefined ? parameters.psi : -0.5, sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5, maxDiff;\n        // initialize simplex.\n        var N = x0.length, simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for(var i = 0; i < N; ++i){\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i + 1] = point;\n            simplex[i + 1].fx = f(point);\n            simplex[i + 1].id = i + 1;\n        }\n        function updateSimplex(value) {\n            for(var i = 0; i < value.length; i++){\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n        var sortOrder = function(a, b) {\n            return a.fx - b.fx;\n        };\n        var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();\n        for(var iteration = 0; iteration < maxIterations; ++iteration){\n            simplex.sort(sortOrder);\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function(x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a, b) {\n                    return a.id - b.id;\n                });\n                parameters.history.push({\n                    x: simplex[0].slice(),\n                    fx: simplex[0].fx,\n                    simplex: sortedSimplex\n                });\n            }\n            maxDiff = 0;\n            for(i = 0; i < N; ++i){\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n                break;\n            }\n            // compute the centroid of all but the worst point in the simplex\n            for(i = 0; i < N; ++i){\n                centroid[i] = 0;\n                for(var j = 0; j < N; ++j){\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                } else {\n                    updateSimplex(reflected);\n                }\n            } else if (reflected.fx >= simplex[N - 1].fx) {\n                var shouldReduce = false;\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n                    // do a reduction\n                    for(i = 1; i < simplex.length; ++i){\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n        simplex.sort(sortOrder);\n        return {\n            fx: simplex[0].fx,\n            x: simplex[0]\n        };\n    }\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk), phi = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n        function zoom(a_lo, a_high, phi_lo) {\n            for(var iteration = 0; iteration < 16; ++iteration){\n                a = (a_lo + a_high) / 2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n                if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n                    a_high = a;\n                } else {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n                    if (phiPrime * (a_high - a_lo) >= 0) {\n                        a_high = a_lo;\n                    }\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n            return 0;\n        }\n        for(var iteration = 0; iteration < 10; ++iteration){\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n                return zoom(a0, a, phi_old);\n            }\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n            if (phiPrime >= 0) {\n                return zoom(a, a0, phi);\n            }\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n        return a;\n    }\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, next = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, yk = initial.slice(), pk, temp, a = 1, maxIterations;\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime, -1);\n        for(var i = 0; i < maxIterations; ++i){\n            a = wolfeLineSearch(f, pk, current, next, a);\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({\n                    x: current.x.slice(),\n                    fx: current.fx,\n                    fxprime: current.fxprime.slice(),\n                    alpha: a\n                });\n            }\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n            } else {\n                // update direction using Polakâ€“Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n                var delta_k = dot(current.fxprime, current.fxprime), beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n                temp = current;\n                current = next;\n                next = temp;\n            }\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n        if (params.history) {\n            params.history.push({\n                x: current.x.slice(),\n                fx: current.fx,\n                fxprime: current.fxprime.slice(),\n                alpha: a\n            });\n        }\n        return current;\n    }\n    function gradientDescent(f, initial, params) {\n        params = params || {};\n        var maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 0.001, current = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        };\n        for(var i = 0; i < maxIterations; ++i){\n            current.fx = f(current.x, current.fxprime);\n            if (params.history) {\n                params.history.push({\n                    x: current.x.slice(),\n                    fx: current.fx,\n                    fxprime: current.fxprime.slice()\n                });\n            }\n            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n        return current;\n    }\n    function gradientDescentLineSearch(f, initial, params) {\n        params = params || {};\n        var current = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, next = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 1, pk = initial.slice(), c1 = params.c1 || 1e-3, c2 = params.c2 || 0.1, temp, functionCalls = [];\n        if (params.history) {\n            // wrap the function call to track linesearch samples\n            var inner = f;\n            f = function(x, fxprime) {\n                functionCalls.push(x.slice());\n                return inner(x, fxprime);\n            };\n        }\n        current.fx = f(current.x, current.fxprime);\n        for(var i = 0; i < maxIterations; ++i){\n            scale(pk, current.fxprime, -1);\n            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n            if (params.history) {\n                params.history.push({\n                    x: current.x.slice(),\n                    fx: current.fx,\n                    fxprime: current.fxprime.slice(),\n                    functionCalls: functionCalls,\n                    learnRate: learnRate,\n                    alpha: learnRate\n                });\n                functionCalls = [];\n            }\n            temp = current;\n            current = next;\n            next = temp;\n            if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n        }\n        return current;\n    }\n    exports1.bisect = bisect;\n    exports1.nelderMead = nelderMead;\n    exports1.conjugateGradient = conjugateGradient;\n    exports1.gradientDescent = gradientDescent;\n    exports1.gradientDescentLineSearch = gradientDescentLineSearch;\n    exports1.zeros = zeros;\n    exports1.zerosM = zerosM;\n    exports1.norm2 = norm2;\n    exports1.weightedSum = weightedSum;\n    exports1.scale = scale;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZtaW5AMC4wLjIvbm9kZV9tb2R1bGVzL2ZtaW4vYnVpbGQvZm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDdEIsS0FBaUQsR0FBY0EsUUFBUUMsV0FDdkUsQ0FDMEM7QUFDOUMsR0FBRSxJQUFJLEVBQUUsU0FBVUEsUUFBTztJQUFJO0lBRXpCOzJCQUN1QixHQUN2QixTQUFTSyxPQUFPQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxVQUFVO1FBQy9CQSxhQUFhQSxjQUFjLENBQUM7UUFDNUIsSUFBSUMsZ0JBQWdCRCxXQUFXQyxhQUFhLElBQUksS0FDNUNDLFlBQVlGLFdBQVdFLFNBQVMsSUFBSSxPQUNwQ0MsS0FBS04sRUFBRUMsSUFDUE0sS0FBS1AsRUFBRUUsSUFDUE0sUUFBUU4sSUFBSUQ7UUFFaEIsSUFBSUssS0FBS0MsS0FBSyxHQUFHO1lBQ2IsTUFBTTtRQUNWO1FBRUEsSUFBSUQsT0FBTyxHQUFHLE9BQU9MO1FBQ3JCLElBQUlNLE9BQU8sR0FBRyxPQUFPTDtRQUVyQixJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUwsZUFBZSxFQUFFSyxFQUFHO1lBQ3BDRCxTQUFTO1lBQ1QsSUFBSUUsTUFBTVQsSUFBSU8sT0FDVkcsT0FBT1gsRUFBRVU7WUFFYixJQUFJQyxPQUFPTCxNQUFNLEdBQUc7Z0JBQ2hCTCxJQUFJUztZQUNSO1lBRUEsSUFBSSxLQUFNRyxHQUFHLENBQUNMLFNBQVNILGFBQWVNLFNBQVMsR0FBSTtnQkFDL0MsT0FBT0Q7WUFDWDtRQUNKO1FBQ0EsT0FBT1QsSUFBSU87SUFDZjtJQUVBLDBFQUEwRTtJQUMxRSxtQkFBbUI7SUFDbkIsU0FBU00sTUFBTUMsQ0FBQztRQUFJLElBQUlDLElBQUksSUFBSUMsTUFBTUY7UUFBSSxJQUFLLElBQUlOLElBQUksR0FBR0EsSUFBSU0sR0FBRyxFQUFFTixFQUFHO1lBQUVPLENBQUMsQ0FBQ1As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QUVLLEVBQUc7WUFDcENpQixNQUFNMkMsSUFBSUMsUUFBUU0sT0FBTyxFQUFFLENBQUM7WUFDNUJrQixZQUFZMUIsZ0JBQWdCcEUsR0FBR3FFLElBQUlDLFNBQVNDLE1BQU11QixXQUFXdEIsSUFBSUM7WUFFakUsSUFBSWMsT0FBTzFCLE9BQU8sRUFBRTtnQkFDaEIwQixPQUFPMUIsT0FBTyxDQUFDRyxJQUFJLENBQUM7b0JBQUNqRCxHQUFHdUQsUUFBUXZELENBQUMsQ0FBQ3FDLEtBQUs7b0JBQ2xCSCxJQUFJcUIsUUFBUXJCLEVBQUU7b0JBQ2QyQixTQUFTTixRQUFRTSxPQUFPLENBQUN4QixLQUFLO29CQUM5QjRDLGVBQWVBO29CQUNmRixXQUFXQTtvQkFDWEosT0FBT0k7Z0JBQVM7Z0JBQ3JDRSxnQkFBZ0IsRUFBRTtZQUN0QjtZQUdBUCxPQUFPbkI7WUFDUEEsVUFBVUM7WUFDVkEsT0FBT2tCO1lBRVAsSUFBSSxjQUFlLEtBQU9qRSxNQUFNOEMsUUFBUU0sT0FBTyxJQUFJLE1BQU87UUFDOUQ7UUFFQSxPQUFPTjtJQUNYO0lBRUE1RSxTQUFRSyxNQUFNLEdBQUdBO0lBQ2pCTCxTQUFReUMsVUFBVSxHQUFHQTtJQUNyQnpDLFNBQVEyRixpQkFBaUIsR0FBR0E7SUFDNUIzRixTQUFRbUcsZUFBZSxHQUFHQTtJQUMxQm5HLFNBQVFxRyx5QkFBeUIsR0FBR0E7SUFDcENyRyxTQUFRb0IsS0FBSyxHQUFHQTtJQUNoQnBCLFNBQVF3QixNQUFNLEdBQUdBO0lBQ2pCeEIsU0FBUThCLEtBQUssR0FBR0E7SUFDaEI5QixTQUFRbUMsV0FBVyxHQUFHQTtJQUN0Qm5DLFNBQVFnQyxLQUFLLEdBQUdBO0FBRXBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvY2Vzcy1hbmFseXNpcy1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvLnBucG0vZm1pbkAwLjAuMi9ub2RlX21vZHVsZXMvZm1pbi9idWlsZC9mbWluLmpzPzU3OTYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLmZtaW4gPSBnbG9iYWwuZm1pbiB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqIGZpbmRzIHRoZSB6ZXJvcyBvZiBhIGZ1bmN0aW9uLCBnaXZlbiB0d28gc3RhcnRpbmcgcG9pbnRzICh3aGljaCBtdXN0XG4gICAgICogaGF2ZSBvcHBvc2l0ZSBzaWducyAqL1xuICAgIGZ1bmN0aW9uIGJpc2VjdChmLCBhLCBiLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuICAgICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IHBhcmFtZXRlcnMubWF4SXRlcmF0aW9ucyB8fCAxMDAsXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSBwYXJhbWV0ZXJzLnRvbGVyYW5jZSB8fCAxZS0xMCxcbiAgICAgICAgICAgIGZBID0gZihhKSxcbiAgICAgICAgICAgIGZCID0gZihiKSxcbiAgICAgICAgICAgIGRlbHRhID0gYiAtIGE7XG5cbiAgICAgICAgaWYgKGZBICogZkIgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkluaXRpYWwgYmlzZWN0IHBvaW50cyBtdXN0IGhhdmUgb3Bwb3NpdGUgc2lnbnNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmQSA9PT0gMCkgcmV0dXJuIGE7XG4gICAgICAgIGlmIChmQiA9PT0gMCkgcmV0dXJuIGI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGRlbHRhIC89IDI7XG4gICAgICAgICAgICB2YXIgbWlkID0gYSArIGRlbHRhLFxuICAgICAgICAgICAgICAgIGZNaWQgPSBmKG1pZCk7XG5cbiAgICAgICAgICAgIGlmIChmTWlkICogZkEgPj0gMCkge1xuICAgICAgICAgICAgICAgIGEgPSBtaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnMoZGVsdGEpIDwgdG9sZXJhbmNlKSB8fCAoZk1pZCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICsgZGVsdGE7XG4gICAgfVxuXG4gICAgLy8gbmVlZCBzb21lIGJhc2ljIG9wZXJhdGlvbnMgb24gdmVjdG9ycywgcmF0aGVyIHRoYW4gYWRkaW5nIGEgZGVwZW5kZW5jeSxcbiAgICAvLyBqdXN0IGRlZmluZSBoZXJlXG4gICAgZnVuY3Rpb24gemVyb3MoeCkgeyB2YXIgciA9IG5ldyBBcnJheSh4KTsgZm9yICh2YXIgaSA9IDA7IGkgPCB4OyArK2kpIHsgcltpXSA9IDA7IH0gcmV0dXJuIHI7IH1cbiAgICBmdW5jdGlvbiB6ZXJvc00oeCx5KSB7IHJldHVybiB6ZXJvcyh4KS5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB6ZXJvcyh5KTsgfSk7IH1cblxuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIHZhciByZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldCArPSBhW2ldICogYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm0yKGEpICB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZG90KGEsIGEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZShyZXQsIHZhbHVlLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHZhbHVlW2ldICogYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlaWdodGVkU3VtKHJldCwgdzEsIHYxLCB3MiwgdjIpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHJldFtqXSA9IHcxICogdjFbal0gKyB3MiAqIHYyW2pdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIG1pbmltaXplcyBhIGZ1bmN0aW9uIHVzaW5nIHRoZSBkb3duaGlsbCBzaW1wbGV4IG1ldGhvZCAqL1xuICAgIGZ1bmN0aW9uIG5lbGRlck1lYWQoZiwgeDAsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBwYXJhbWV0ZXJzLm1heEl0ZXJhdGlvbnMgfHwgeDAubGVuZ3RoICogMjAwLFxuICAgICAgICAgICAgbm9uWmVyb0RlbHRhID0gcGFyYW1ldGVycy5ub25aZXJvRGVsdGEgfHwgMS4wNSxcbiAgICAgICAgICAgIHplcm9EZWx0YSA9IHBhcmFtZXRlcnMuemVyb0RlbHRhIHx8IDAuMDAxLFxuICAgICAgICAgICAgbWluRXJyb3JEZWx0YSA9IHBhcmFtZXRlcnMubWluRXJyb3JEZWx0YSB8fCAxZS02LFxuICAgICAgICAgICAgbWluVG9sZXJhbmNlID0gcGFyYW1ldGVycy5taW5FcnJvckRlbHRhIHx8IDFlLTUsXG4gICAgICAgICAgICByaG8gPSAocGFyYW1ldGVycy5yaG8gIT09IHVuZGVmaW5lZCkgPyBwYXJhbWV0ZXJzLnJobyA6IDEsXG4gICAgICAgICAgICBjaGkgPSAocGFyYW1ldGVycy5jaGkgIT09IHVuZGVmaW5lZCkgPyBwYXJhbWV0ZXJzLmNoaSA6IDIsXG4gICAgICAgICAgICBwc2kgPSAocGFyYW1ldGVycy5wc2kgIT09IHVuZGVmaW5lZCkgPyBwYXJhbWV0ZXJzLnBzaSA6IC0wLjUsXG4gICAgICAgICAgICBzaWdtYSA9IChwYXJhbWV0ZXJzLnNpZ21hICE9PSB1bmRlZmluZWQpID8gcGFyYW1ldGVycy5zaWdtYSA6IDAuNSxcbiAgICAgICAgICAgIG1heERpZmY7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzaW1wbGV4LlxuICAgICAgICB2YXIgTiA9IHgwLmxlbmd0aCxcbiAgICAgICAgICAgIHNpbXBsZXggPSBuZXcgQXJyYXkoTiArIDEpO1xuICAgICAgICBzaW1wbGV4WzBdID0geDA7XG4gICAgICAgIHNpbXBsZXhbMF0uZnggPSBmKHgwKTtcbiAgICAgICAgc2ltcGxleFswXS5pZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB4MC5zbGljZSgpO1xuICAgICAgICAgICAgcG9pbnRbaV0gPSBwb2ludFtpXSA/IHBvaW50W2ldICogbm9uWmVyb0RlbHRhIDogemVyb0RlbHRhO1xuICAgICAgICAgICAgc2ltcGxleFtpKzFdID0gcG9pbnQ7XG4gICAgICAgICAgICBzaW1wbGV4W2krMV0uZnggPSBmKHBvaW50KTtcbiAgICAgICAgICAgIHNpbXBsZXhbaSsxXS5pZCA9IGkrMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNpbXBsZXgodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaW1wbGV4W05dW2ldID0gdmFsdWVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaW1wbGV4W05dLmZ4ID0gdmFsdWUuZng7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc29ydE9yZGVyID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5meCAtIGIuZng7IH07XG5cbiAgICAgICAgdmFyIGNlbnRyb2lkID0geDAuc2xpY2UoKSxcbiAgICAgICAgICAgIHJlZmxlY3RlZCA9IHgwLnNsaWNlKCksXG4gICAgICAgICAgICBjb250cmFjdGVkID0geDAuc2xpY2UoKSxcbiAgICAgICAgICAgIGV4cGFuZGVkID0geDAuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyArK2l0ZXJhdGlvbikge1xuICAgICAgICAgICAgc2ltcGxleC5zb3J0KHNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBzaW1wbGV4IChzaW5jZSBsYXRlciBpdGVyYXRpb25zIHdpbGwgbXV0YXRlKSBhbmRcbiAgICAgICAgICAgICAgICAvLyBzb3J0IGl0IHRvIGhhdmUgYSBjb25zaXN0ZW50IG9yZGVyIGJldHdlZW4gaXRlcmF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRTaW1wbGV4ID0gc2ltcGxleC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0geC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5meCA9IHguZng7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlkID0geC5pZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNvcnRlZFNpbXBsZXguc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuaGlzdG9yeS5wdXNoKHt4OiBzaW1wbGV4WzBdLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ4OiBzaW1wbGV4WzBdLmZ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGV4OiBzb3J0ZWRTaW1wbGV4fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heERpZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBNYXRoLmFicyhzaW1wbGV4WzBdW2ldIC0gc2ltcGxleFsxXVtpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHNpbXBsZXhbMF0uZnggLSBzaW1wbGV4W05dLmZ4KSA8IG1pbkVycm9yRGVsdGEpICYmXG4gICAgICAgICAgICAgICAgKG1heERpZmYgPCBtaW5Ub2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIGNlbnRyb2lkIG9mIGFsbCBidXQgdGhlIHdvcnN0IHBvaW50IGluIHRoZSBzaW1wbGV4XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRbaV0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkW2ldICs9IHNpbXBsZXhbal1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbnRyb2lkW2ldIC89IE47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZmxlY3QgdGhlIHdvcnN0IHBvaW50IHBhc3QgdGhlIGNlbnRyb2lkICBhbmQgY29tcHV0ZSBsb3NzIGF0IHJlZmxlY3RlZFxuICAgICAgICAgICAgLy8gcG9pbnRcbiAgICAgICAgICAgIHZhciB3b3JzdCA9IHNpbXBsZXhbTl07XG4gICAgICAgICAgICB3ZWlnaHRlZFN1bShyZWZsZWN0ZWQsIDErcmhvLCBjZW50cm9pZCwgLXJobywgd29yc3QpO1xuICAgICAgICAgICAgcmVmbGVjdGVkLmZ4ID0gZihyZWZsZWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVmbGVjdGVkIHBvaW50IGlzIHRoZSBiZXN0IHNlZW4sIHRoZW4gcG9zc2libHkgZXhwYW5kXG4gICAgICAgICAgICBpZiAocmVmbGVjdGVkLmZ4IDwgc2ltcGxleFswXS5meCkge1xuICAgICAgICAgICAgICAgIHdlaWdodGVkU3VtKGV4cGFuZGVkLCAxK2NoaSwgY2VudHJvaWQsIC1jaGksIHdvcnN0KTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZC5meCA9IGYoZXhwYW5kZWQpO1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZC5meCA8IHJlZmxlY3RlZC5meCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTaW1wbGV4KGV4cGFuZGVkKTtcbiAgICAgICAgICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2ltcGxleChyZWZsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlZmxlY3RlZCBwb2ludCBpcyB3b3JzZSB0aGFuIHRoZSBzZWNvbmQgd29yc3QsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGNvbnRyYWN0XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZsZWN0ZWQuZnggPj0gc2ltcGxleFtOLTFdLmZ4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFJlZHVjZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZmxlY3RlZC5meCA+IHdvcnN0LmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIGFuIGluc2lkZSBjb250cmFjdGlvblxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZFN1bShjb250cmFjdGVkLCAxK3BzaSwgY2VudHJvaWQsIC1wc2ksIHdvcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RlZC5meCA9IGYoY29udHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdGVkLmZ4IDwgd29yc3QuZngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpbXBsZXgoY29udHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRSZWR1Y2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYW4gb3V0c2lkZSBjb250cmFjdGlvblxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZFN1bShjb250cmFjdGVkLCAxLXBzaSAqIHJobywgY2VudHJvaWQsIHBzaSpyaG8sIHdvcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RlZC5meCA9IGYoY29udHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdGVkLmZ4IDwgcmVmbGVjdGVkLmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTaW1wbGV4KGNvbnRyYWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVkdWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZWR1Y2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgY29udHJhY3QgaGVyZSwgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbWEgPj0gMSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYSByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNpbXBsZXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkU3VtKHNpbXBsZXhbaV0sIDEgLSBzaWdtYSwgc2ltcGxleFswXSwgc2lnbWEsIHNpbXBsZXhbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxleFtpXS5meCA9IGYoc2ltcGxleFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVNpbXBsZXgocmVmbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNpbXBsZXguc29ydChzb3J0T3JkZXIpO1xuICAgICAgICByZXR1cm4ge2Z4IDogc2ltcGxleFswXS5meCxcbiAgICAgICAgICAgICAgICB4IDogc2ltcGxleFswXX07XG4gICAgfVxuXG4gICAgLy8vIHNlYXJjaGVzIGFsb25nIGxpbmUgJ3BrJyBmb3IgYSBwb2ludCB0aGF0IHNhdGlmaWVzIHRoZSB3b2xmZSBjb25kaXRpb25zXG4gICAgLy8vIFNlZSAnTnVtZXJpY2FsIE9wdGltaXphdGlvbicgYnkgTm9jZWRhbCBhbmQgV3JpZ2h0IHA1OS02MFxuICAgIC8vLyBmIDogb2JqZWN0aXZlIGZ1bmN0aW9uXG4gICAgLy8vIHBrIDogc2VhcmNoIGRpcmVjdGlvblxuICAgIC8vLyBjdXJyZW50OiBvYmplY3QgY29udGFpbmluZyBjdXJyZW50IGdyYWRpZW50L2xvc3NcbiAgICAvLy8gbmV4dDogb3V0cHV0OiBjb250YWlucyBuZXh0IGdyYWRpZW50L2xvc3NcbiAgICAvLy8gcmV0dXJucyBhOiBzdGVwIHNpemUgdGFrZW5cbiAgICBmdW5jdGlvbiB3b2xmZUxpbmVTZWFyY2goZiwgcGssIGN1cnJlbnQsIG5leHQsIGEsIGMxLCBjMikge1xuICAgICAgICB2YXIgcGhpMCA9IGN1cnJlbnQuZngsIHBoaVByaW1lMCA9IGRvdChjdXJyZW50LmZ4cHJpbWUsIHBrKSxcbiAgICAgICAgICAgIHBoaSA9IHBoaTAsIHBoaV9vbGQgPSBwaGkwLFxuICAgICAgICAgICAgcGhpUHJpbWUgPSBwaGlQcmltZTAsXG4gICAgICAgICAgICBhMCA9IDA7XG5cbiAgICAgICAgYSA9IGEgfHwgMTtcbiAgICAgICAgYzEgPSBjMSB8fCAxZS02O1xuICAgICAgICBjMiA9IGMyIHx8IDAuMTtcblxuICAgICAgICBmdW5jdGlvbiB6b29tKGFfbG8sIGFfaGlnaCwgcGhpX2xvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCAxNjsgKytpdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhID0gKGFfbG8gKyBhX2hpZ2gpLzI7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRTdW0obmV4dC54LCAxLjAsIGN1cnJlbnQueCwgYSwgcGspO1xuICAgICAgICAgICAgICAgIHBoaSA9IG5leHQuZnggPSBmKG5leHQueCwgbmV4dC5meHByaW1lKTtcbiAgICAgICAgICAgICAgICBwaGlQcmltZSA9IGRvdChuZXh0LmZ4cHJpbWUsIHBrKTtcblxuICAgICAgICAgICAgICAgIGlmICgocGhpID4gKHBoaTAgKyBjMSAqIGEgKiBwaGlQcmltZTApKSB8fFxuICAgICAgICAgICAgICAgICAgICAocGhpID49IHBoaV9sbykpIHtcbiAgICAgICAgICAgICAgICAgICAgYV9oaWdoID0gYTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocGhpUHJpbWUpIDw9IC1jMiAqIHBoaVByaW1lMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGhpUHJpbWUgKiAoYV9oaWdoIC0gYV9sbykgPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhX2hpZ2ggPSBhX2xvO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYV9sbyA9IGE7XG4gICAgICAgICAgICAgICAgICAgIHBoaV9sbyA9IHBoaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgMTA7ICsraXRlcmF0aW9uKSB7XG4gICAgICAgICAgICB3ZWlnaHRlZFN1bShuZXh0LngsIDEuMCwgY3VycmVudC54LCBhLCBwayk7XG4gICAgICAgICAgICBwaGkgPSBuZXh0LmZ4ID0gZihuZXh0LngsIG5leHQuZnhwcmltZSk7XG4gICAgICAgICAgICBwaGlQcmltZSA9IGRvdChuZXh0LmZ4cHJpbWUsIHBrKTtcbiAgICAgICAgICAgIGlmICgocGhpID4gKHBoaTAgKyBjMSAqIGEgKiBwaGlQcmltZTApKSB8fFxuICAgICAgICAgICAgICAgIChpdGVyYXRpb24gJiYgKHBoaSA+PSBwaGlfb2xkKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gem9vbShhMCwgYSwgcGhpX29sZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwaGlQcmltZSkgPD0gLWMyICogcGhpUHJpbWUwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwaGlQcmltZSA+PSAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6b29tKGEsIGEwLCBwaGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaGlfb2xkID0gcGhpO1xuICAgICAgICAgICAgYTAgPSBhO1xuICAgICAgICAgICAgYSAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uanVnYXRlR3JhZGllbnQoZiwgaW5pdGlhbCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIGFsbG9jYXRlIGFsbCBtZW1vcnkgdXAgZnJvbnQgaGVyZSwga2VlcCBvdXQgb2YgdGhlIGxvb3AgZm9yIHBlcmZvbWFuY2VcbiAgICAgICAgLy8gcmVhc29uc1xuICAgICAgICB2YXIgY3VycmVudCA9IHt4OiBpbml0aWFsLnNsaWNlKCksIGZ4OiAwLCBmeHByaW1lOiBpbml0aWFsLnNsaWNlKCl9LFxuICAgICAgICAgICAgbmV4dCA9IHt4OiBpbml0aWFsLnNsaWNlKCksIGZ4OiAwLCBmeHByaW1lOiBpbml0aWFsLnNsaWNlKCl9LFxuICAgICAgICAgICAgeWsgPSBpbml0aWFsLnNsaWNlKCksXG4gICAgICAgICAgICBwaywgdGVtcCxcbiAgICAgICAgICAgIGEgPSAxLFxuICAgICAgICAgICAgbWF4SXRlcmF0aW9ucztcblxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIG1heEl0ZXJhdGlvbnMgPSBwYXJhbXMubWF4SXRlcmF0aW9ucyB8fCBpbml0aWFsLmxlbmd0aCAqIDIwO1xuXG4gICAgICAgIGN1cnJlbnQuZnggPSBmKGN1cnJlbnQueCwgY3VycmVudC5meHByaW1lKTtcbiAgICAgICAgcGsgPSBjdXJyZW50LmZ4cHJpbWUuc2xpY2UoKTtcbiAgICAgICAgc2NhbGUocGssIGN1cnJlbnQuZnhwcmltZSwtMSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGEgPSB3b2xmZUxpbmVTZWFyY2goZiwgcGssIGN1cnJlbnQsIG5leHQsIGEpO1xuXG4gICAgICAgICAgICAvLyB0b2RvOiBoaXN0b3J5IGluIHdyb25nIHNwb3Q/XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuaGlzdG9yeS5wdXNoKHt4OiBjdXJyZW50Lnguc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeDogY3VycmVudC5meCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeHByaW1lOiBjdXJyZW50LmZ4cHJpbWUuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTogYX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWlpbGVkIHRvIGZpbmQgcG9pbnQgdGhhdCBzYXRpZmllcyB3b2xmZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGRpcmVjdGlvbiBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBzY2FsZShwaywgY3VycmVudC5meHByaW1lLCAtMSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRpcmVjdGlvbiB1c2luZyBQb2xha+KAk1JpYmllcmUgQ0cgbWV0aG9kXG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRTdW0oeWssIDEsIG5leHQuZnhwcmltZSwgLTEsIGN1cnJlbnQuZnhwcmltZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFfayA9IGRvdChjdXJyZW50LmZ4cHJpbWUsIGN1cnJlbnQuZnhwcmltZSksXG4gICAgICAgICAgICAgICAgICAgIGJldGFfayA9IE1hdGgubWF4KDAsIGRvdCh5aywgbmV4dC5meHByaW1lKSAvIGRlbHRhX2spO1xuXG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRTdW0ocGssIGJldGFfaywgcGssIC0xLCBuZXh0LmZ4cHJpbWUpO1xuXG4gICAgICAgICAgICAgICAgdGVtcCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub3JtMihjdXJyZW50LmZ4cHJpbWUpIDw9IDFlLTUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGlzdG9yeSkge1xuICAgICAgICAgICAgcGFyYW1zLmhpc3RvcnkucHVzaCh7eDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeDogY3VycmVudC5meCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ4cHJpbWU6IGN1cnJlbnQuZnhwcmltZS5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IGF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyYWRpZW50RGVzY2VudChmLCBpbml0aWFsLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IHBhcmFtcy5tYXhJdGVyYXRpb25zIHx8IGluaXRpYWwubGVuZ3RoICogMTAwLFxuICAgICAgICAgICAgbGVhcm5SYXRlID0gcGFyYW1zLmxlYXJuUmF0ZSB8fCAwLjAwMSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSB7eDogaW5pdGlhbC5zbGljZSgpLCBmeDogMCwgZnhwcmltZTogaW5pdGlhbC5zbGljZSgpfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgY3VycmVudC5meCA9IGYoY3VycmVudC54LCBjdXJyZW50LmZ4cHJpbWUpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhpc3RvcnkucHVzaCh7eDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZng6IGN1cnJlbnQuZngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnhwcmltZTogY3VycmVudC5meHByaW1lLnNsaWNlKCl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2VpZ2h0ZWRTdW0oY3VycmVudC54LCAxLCBjdXJyZW50LngsIC1sZWFyblJhdGUsIGN1cnJlbnQuZnhwcmltZSk7XG4gICAgICAgICAgICBpZiAobm9ybTIoY3VycmVudC5meHByaW1lKSA8PSAxZS01KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncmFkaWVudERlc2NlbnRMaW5lU2VhcmNoKGYsIGluaXRpYWwsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHZhciBjdXJyZW50ID0ge3g6IGluaXRpYWwuc2xpY2UoKSwgZng6IDAsIGZ4cHJpbWU6IGluaXRpYWwuc2xpY2UoKX0sXG4gICAgICAgICAgICBuZXh0ID0ge3g6IGluaXRpYWwuc2xpY2UoKSwgZng6IDAsIGZ4cHJpbWU6IGluaXRpYWwuc2xpY2UoKX0sXG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gcGFyYW1zLm1heEl0ZXJhdGlvbnMgfHwgaW5pdGlhbC5sZW5ndGggKiAxMDAsXG4gICAgICAgICAgICBsZWFyblJhdGUgPSBwYXJhbXMubGVhcm5SYXRlIHx8IDEsXG4gICAgICAgICAgICBwayA9IGluaXRpYWwuc2xpY2UoKSxcbiAgICAgICAgICAgIGMxID0gcGFyYW1zLmMxIHx8IDFlLTMsXG4gICAgICAgICAgICBjMiA9IHBhcmFtcy5jMiB8fCAwLjEsXG4gICAgICAgICAgICB0ZW1wLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxscyA9IFtdO1xuXG4gICAgICAgIGlmIChwYXJhbXMuaGlzdG9yeSkge1xuICAgICAgICAgICAgLy8gd3JhcCB0aGUgZnVuY3Rpb24gY2FsbCB0byB0cmFjayBsaW5lc2VhcmNoIHNhbXBsZXNcbiAgICAgICAgICAgIHZhciBpbm5lciA9IGY7XG4gICAgICAgICAgICBmID0gZnVuY3Rpb24oeCwgZnhwcmltZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbHMucHVzaCh4LnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcih4LCBmeHByaW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LmZ4ID0gZihjdXJyZW50LngsIGN1cnJlbnQuZnhwcmltZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICBzY2FsZShwaywgY3VycmVudC5meHByaW1lLCAtMSk7XG4gICAgICAgICAgICBsZWFyblJhdGUgPSB3b2xmZUxpbmVTZWFyY2goZiwgcGssIGN1cnJlbnQsIG5leHQsIGxlYXJuUmF0ZSwgYzEsIGMyKTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhpc3RvcnkucHVzaCh7eDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZng6IGN1cnJlbnQuZngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnhwcmltZTogY3VycmVudC5meHByaW1lLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsczogZnVuY3Rpb25DYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFyblJhdGU6IGxlYXJuUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTogbGVhcm5SYXRlfSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxscyA9IFtdO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRlbXAgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gdGVtcDtcblxuICAgICAgICAgICAgaWYgKChsZWFyblJhdGUgPT09IDApIHx8IChub3JtMihjdXJyZW50LmZ4cHJpbWUpIDwgMWUtNSkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5iaXNlY3QgPSBiaXNlY3Q7XG4gICAgZXhwb3J0cy5uZWxkZXJNZWFkID0gbmVsZGVyTWVhZDtcbiAgICBleHBvcnRzLmNvbmp1Z2F0ZUdyYWRpZW50ID0gY29uanVnYXRlR3JhZGllbnQ7XG4gICAgZXhwb3J0cy5ncmFkaWVudERlc2NlbnQgPSBncmFkaWVudERlc2NlbnQ7XG4gICAgZXhwb3J0cy5ncmFkaWVudERlc2NlbnRMaW5lU2VhcmNoID0gZ3JhZGllbnREZXNjZW50TGluZVNlYXJjaDtcbiAgICBleHBvcnRzLnplcm9zID0gemVyb3M7XG4gICAgZXhwb3J0cy56ZXJvc00gPSB6ZXJvc007XG4gICAgZXhwb3J0cy5ub3JtMiA9IG5vcm0yO1xuICAgIGV4cG9ydHMud2VpZ2h0ZWRTdW0gPSB3ZWlnaHRlZFN1bTtcbiAgICBleHBvcnRzLnNjYWxlID0gc2NhbGU7XG5cbn0pKTsiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJmbWluIiwiYmlzZWN0IiwiZiIsImEiLCJiIiwicGFyYW1ldGVycyIsIm1heEl0ZXJhdGlvbnMiLCJ0b2xlcmFuY2UiLCJmQSIsImZCIiwiZGVsdGEiLCJpIiwibWlkIiwiZk1pZCIsIk1hdGgiLCJhYnMiLCJ6ZXJvcyIsIngiLCJyIiwiQXJyYXkiLCJ6ZXJvc00iLCJ5IiwibWFwIiwiZG90IiwicmV0IiwibGVuZ3RoIiwibm9ybTIiLCJzcXJ0Iiwic2NhbGUiLCJ2YWx1ZSIsImMiLCJ3ZWlnaHRlZFN1bSIsIncxIiwidjEiLCJ3MiIsInYyIiwiaiIsIm5lbGRlck1lYWQiLCJ4MCIsIm5vblplcm9EZWx0YSIsInplcm9EZWx0YSIsIm1pbkVycm9yRGVsdGEiLCJtaW5Ub2xlcmFuY2UiLCJyaG8iLCJ1bmRlZmluZWQiLCJjaGkiLCJwc2kiLCJzaWdtYSIsIm1heERpZmYiLCJOIiwic2ltcGxleCIsImZ4IiwiaWQiLCJwb2ludCIsInNsaWNlIiwidXBkYXRlU2ltcGxleCIsInNvcnRPcmRlciIsImNlbnRyb2lkIiwicmVmbGVjdGVkIiwiY29udHJhY3RlZCIsImV4cGFuZGVkIiwiaXRlcmF0aW9uIiwic29ydCIsImhpc3RvcnkiLCJzb3J0ZWRTaW1wbGV4Iiwic3RhdGUiLCJwdXNoIiwibWF4Iiwid29yc3QiLCJzaG91bGRSZWR1Y2UiLCJ3b2xmZUxpbmVTZWFyY2giLCJwayIsImN1cnJlbnQiLCJuZXh0IiwiYzEiLCJjMiIsInBoaTAiLCJwaGlQcmltZTAiLCJmeHByaW1lIiwicGhpIiwicGhpX29sZCIsInBoaVByaW1lIiwiYTAiLCJ6b29tIiwiYV9sbyIsImFfaGlnaCIsInBoaV9sbyIsImNvbmp1Z2F0ZUdyYWRpZW50IiwiaW5pdGlhbCIsInBhcmFtcyIsInlrIiwidGVtcCIsImFscGhhIiwiZGVsdGFfayIsImJldGFfayIsImdyYWRpZW50RGVzY2VudCIsImxlYXJuUmF0ZSIsImdyYWRpZW50RGVzY2VudExpbmVTZWFyY2giLCJmdW5jdGlvbkNhbGxzIiwiaW5uZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fmin@0.0.2/node_modules/fmin/build/fmin.js\n");

/***/ })

};
;